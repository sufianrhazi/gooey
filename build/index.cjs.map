{
  "version": 3,
  "sources": ["../src/index.ts", "../src/common/types.ts", "../src/common/log.ts", "../src/viewcontroller/jsx.ts", "../src/common/arrayevent.ts", "../src/common/slotsizes.ts", "../src/common/util.ts", "../src/viewcontroller/commit.ts", "../src/model/tarjan.ts", "../src/model/graph.ts", "../src/model/engine.ts", "../src/viewcontroller/rendernode/rendernode.ts", "../src/viewcontroller/rendernode/arrayrendernode.ts", "../src/viewcontroller/rendernode/dynamicrendernode.ts", "../src/viewcontroller/rendernode/foreignrendernode.ts", "../src/viewcontroller/rendernode/textrendernode.ts", "../src/viewcontroller/renderjsx.ts", "../src/viewcontroller/rendernode/componentrendernode.ts", "../src/common/sentinel.ts", "../src/model/calc.ts", "../src/common/dyn.ts", "../src/viewcontroller/webcomponents.ts", "../src/viewcontroller/xmlnamespace.ts", "../src/viewcontroller/ref.ts", "../src/viewcontroller/rendernode/portalrendernode.ts", "../src/viewcontroller/rendernode/intrinsicrendernode.ts", "../src/viewcontroller/createelement.ts", "../src/components/fragment.ts", "../src/viewcontroller/rendernode/intrinsicobserverrendernode.ts", "../src/components/intrinsicobserver.ts", "../src/modelview/collectionrendernode.ts", "../src/model/field.ts", "../src/model/fieldmap.ts", "../src/model/subscriptionconsumer.ts", "../src/model/subscriptionemitter.ts", "../src/model/trackeddata.ts", "../src/model/collection.ts", "../src/model/dict.ts", "../src/model/model.ts", "../src/viewcontroller/rendernode/webcomponentrendernode.ts", "../src/viewcontroller/definecustomelement.ts", "../src/viewcontroller/mount.ts"],
  "sourcesContent": ["import { createElement } from './viewcontroller/createelement';\n\nexport type { ArrayEvent } from './common/arrayevent';\nexport { ArrayEventType, applyArrayEvent } from './common/arrayevent';\nexport type {\n    Dyn,\n    DynMut,\n    Dynamic,\n    DynamicMut,\n    DynamicSubscriptionHandler,\n    DynamicNonErrorSubscriptionHandler,\n} from './common/dyn';\nexport {\n    dynGet,\n    dynSet,\n    dynSubscribe,\n    isDynamic,\n    isDynamicMut,\n} from './common/dyn';\nexport type { LogLevel } from './common/log';\nexport { getLogLevel, setLogLevel } from './common/log';\nexport { InvariantError } from './common/types';\n\nexport { Fragment } from './components/fragment';\nexport { IntrinsicObserver } from './components/intrinsicobserver';\n\nexport { calc, CycleError } from './model/calc';\nexport type { Calculation } from './model/calc';\nexport type { Collection, View } from './model/collection';\nexport { collection } from './model/collection';\nexport type { DictEvent } from './model/dict';\nexport { dict, Dict, DictEventType } from './model/dict';\nexport type { Field } from './model/field';\nexport { field } from './model/field';\nexport {\n    reset,\n    subscribe,\n    flush,\n    debug,\n    debugSubscribe,\n    debugGetGraph,\n} from './model/engine';\nexport type { Model, ModelEvent } from './model/model';\nexport { model, ModelEventType } from './model/model';\n\nexport { createElement } from './viewcontroller/createelement';\nexport { defineCustomElement } from './viewcontroller/definecustomelement';\nexport type { CustomElements } from './viewcontroller/jsx';\nexport { mount } from './viewcontroller/mount';\nexport type {\n    RefObjectOrCallback,\n    Ref,\n    RefCallback,\n} from './viewcontroller/ref';\nexport { ref } from './viewcontroller/ref';\nexport type {\n    Component,\n    EmptyProps,\n    ComponentLifecycle,\n} from './viewcontroller/rendernode/componentrendernode';\nexport { ClassComponent } from './viewcontroller/rendernode/componentrendernode';\nexport type {\n    WebComponent,\n    WebComponentLifecycle,\n} from './viewcontroller/rendernode/webcomponentrendernode';\nexport type {\n    IntrinsicObserverNodeCallback,\n    IntrinsicObserverElementCallback,\n} from './viewcontroller/rendernode/intrinsicobserverrendernode';\nexport { IntrinsicObserverEventType } from './viewcontroller/rendernode/intrinsicobserverrendernode';\n\nexport default createElement;\n\nexport const VERSION =\n    typeof LIB_VERSION === 'string' ? LIB_VERSION : 'development';\n", "export class InvariantError extends Error {\n    detail?: any;\n    constructor(msg: string, detail?: any) {\n        super(msg);\n        this.detail = detail;\n    }\n}\n", "import { InvariantError } from './types';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function getLogLevel(): LogLevel {\n    if (currentLevel >= levels.info) return 'info';\n    if (currentLevel >= levels.warn) return 'warn';\n    if (currentLevel >= levels.debug) return 'debug';\n    return 'error';\n}\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function group(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.group(...items);\n    }\n}\n\nexport function groupEnd() {\n    if (currentLevel >= levels.debug) {\n        console.groupEnd();\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function fail(msg: string, ...items: any[]): never {\n    error('Invariant error', msg, ...items);\n    throw new InvariantError(`Invariant error: ${msg}`, items);\n}\n\nexport function assert(\n    check: any,\n    msg: string,\n    ...items: any[]\n): asserts check {\n    if (!check) {\n        error(\n            'Assertion failure',\n            check === undefined\n                ? 'undefined'\n                : check === null\n                  ? 'null'\n                  : check.toString(),\n            'is not truthy',\n            msg,\n            ...items\n        );\n        throw new InvariantError(`Assertion failure: ${msg}`, items);\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new InvariantError('Assertion failure', { context, items });\n}\n", "import type { Dyn, Dynamic } from '../common/dyn';\nimport type { RefObjectOrCallback } from './ref';\nimport type { ClassComponentInterface } from './rendernode/componentrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\n\nexport interface JSXRenderable {\n    __renderNode<T>(\n        this: T,\n        renderJsxNode: (jsxNode: JSXNode) => RenderNode\n    ): RenderNode;\n}\n\nexport function isCustomJSXNode(node: JSXNode): node is JSXRenderable {\n    return !!(\n        node &&\n        typeof node === 'object' &&\n        '__renderNode' in node &&\n        typeof node.__renderNode === 'function'\n    );\n}\n\n/**\n * The core type that can be used as a child or root of a JSX expression\n */\nexport type JSXNode =\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    | bigint\n    | symbol\n    | Function\n    | Node\n    | RenderNode\n    | JSXNodeArray\n    | Dynamic<JSXNode>\n    | JSXRenderable;\n\n// The following interfaces are to allow for a recursive type alias: JSXNode\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSXNodeArray extends Array<JSXNode> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CustomElements {}\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        /**\n         * The core type produced by a JSX expression\n         */\n        type Element = RenderNode;\n\n        /**\n         * The core type allowable as a child node in a JSX expression\n         *\n         * Note: this is not used by TypeScript internally and exported for convenience so you may type a component like:\n         *\n         *   const TakesExactlyOneChild: Component<{ children: JSX.Node }> = ({ children }) => (<div>{children}</div>);\n         *\n         */\n        type Node = JSXNode;\n\n        /**\n         * The mapping of element name to intrinsic element path\n         */\n        type IntrinsicElements = KnownElements &\n            CustomElements &\n            Record<string, any>;\n\n        /**\n         * The object property of children\n         */\n        interface ElementChildrenAttribute {\n            children: {};\n        }\n\n        /**\n         * The class property of props\n         */\n        interface ElementAttributesProperty {\n            props: {};\n        }\n\n        /**\n         * The class component interface\n         */\n        type ElementClass = ClassComponentInterface;\n    }\n}\n\nfunction attrBooleanToEmptyString(\n    val: boolean | undefined\n): string | undefined {\n    if (!val) return undefined;\n    return '';\n}\n\nfunction attrStringOrNumberToNumber(\n    val: string | number | undefined\n): number | undefined {\n    if (val === undefined) return undefined;\n    return typeof val === 'number' ? val : parseInt(val);\n}\n\nfunction attrYesNo(val: '' | 'yes' | 'no' | undefined): boolean | undefined {\n    if (val === undefined) return undefined;\n    return val === 'no' ? false : true;\n}\n\n// All attributes (except for value) share similar behavior. This map holds:\n// - Mapping of html attribute name to idl property name\n// - Formatter of jsx property value to idl property value\n// - A flag to omit setting an html attribute (only used for indeterminate)\nconst attrBehavior: Record<\n    string,\n    {\n        // idl name\n        idn?: string | null;\n        // idl value formatter\n        idv?: (jsxAttr: any) => any;\n        // no attribute (do not call setAttribute)\n        noa?: true;\n    }\n> = {\n    'accept-charset': { idn: 'acceptCharset' },\n    'aria-atomic': { idn: 'ariaAtomic' },\n    'aria-autocomplete': { idn: 'ariaAutoComplete' },\n    'aria-busy': { idn: 'ariaBusy' },\n    'aria-checked': { idn: 'ariaChecked' },\n    'aria-colcount': { idn: 'ariaColCount' },\n    'aria-colindex': { idn: 'ariaColIndex' },\n    'aria-colindextext': { idn: 'ariaColIndexText' },\n    'aria-colspan': { idn: 'ariaColSpan' },\n    'aria-current': { idn: 'ariaCurrent' },\n    'aria-disabled': { idn: 'ariaDisabled' },\n    'aria-expanded': { idn: 'ariaExpanded' },\n    'aria-haspopup': { idn: 'ariaHasPopup' },\n    'aria-hidden': { idn: 'ariaHidden' },\n    'aria-invalid': { idn: 'ariaInvalid' },\n    'aria-keyshortcuts': { idn: 'ariaKeyShortcuts' },\n    'aria-label': { idn: 'ariaLabel' },\n    'aria-level': { idn: 'ariaLevel' },\n    'aria-live': { idn: 'ariaLive' },\n    'aria-modal': { idn: 'ariaModal' },\n    'aria-multiline': { idn: 'ariaMultiLine' },\n    'aria-multiselectable': { idn: 'ariaMultiSelectable' },\n    'aria-orientation': { idn: 'ariaOrientation' },\n    'aria-placeholder': { idn: 'ariaPlaceholder' },\n    'aria-posinset': { idn: 'ariaPosInSet' },\n    'aria-pressed': { idn: 'ariaPressed' },\n    'aria-readonly': { idn: 'ariaReadOnly' },\n    'aria-required': { idn: 'ariaRequired' },\n    'aria-roledescription': { idn: 'ariaRoleDescription' },\n    'aria-rowcount': { idn: 'ariaRowCount' },\n    'aria-rowindex': { idn: 'ariaRowIndex' },\n    'aria-rowindextext': { idn: 'ariaRowIndexText' },\n    'aria-rowspan': { idn: 'ariaRowSpan' },\n    'aria-selected': { idn: 'ariaSelected' },\n    'aria-setsize': { idn: 'ariaSetSize' },\n    'aria-sort': { idn: 'ariaSort' },\n    'aria-valuemax': { idn: 'ariaValueMax' },\n    'aria-valuemin': { idn: 'ariaValueMin' },\n    'aria-valuenow': { idn: 'ariaValueNow' },\n    'aria-valuetext': { idn: 'ariaValueText' },\n    'http-equiv': { idn: 'httpEquiv' },\n    abbr: {},\n    accept: {},\n    accesskey: { idn: 'accessKey' },\n    action: {},\n    allow: {},\n    allowfullscreen: { idn: 'allowFullscreen' },\n    alt: {},\n    as: {},\n    async: {},\n    autocapitalize: {},\n    autocomplete: {},\n    autofocus: {},\n    autoplay: {},\n    charset: { idn: null },\n    checked: {},\n    cite: {},\n    class: { idn: 'className' },\n    color: { idn: null },\n    cols: { idv: attrStringOrNumberToNumber },\n    colspan: { idn: 'colSpan', idv: attrStringOrNumberToNumber },\n    content: {},\n    contenteditable: { idn: 'contentEditable' },\n    controls: {},\n    coords: {},\n    crossorigin: { idn: 'crossOrigin' },\n    data: {},\n    datetime: { idn: 'dateTime' },\n    decoding: {},\n    default: {},\n    defer: {},\n    dir: {},\n    dirname: { idn: 'dirName' },\n    disabled: {},\n    download: {},\n    draggable: {},\n    enctype: {},\n    enterkeyhint: { idn: 'enterKeyHint' },\n    for: { idn: 'htmlFor' },\n    form: { idn: null },\n    formaction: { idn: 'formAction' },\n    formenctype: { idn: 'formEnctype' },\n    formmethod: { idn: 'formMethod' },\n    formnovalidate: { idn: 'formNoValidate' },\n    formtarget: { idn: 'formTarget' },\n    headers: {},\n    height: { idv: attrStringOrNumberToNumber },\n    hidden: {},\n    high: { idv: attrStringOrNumberToNumber },\n    href: {},\n    hreflang: {},\n    id: {},\n    imagesizes: { idn: 'imageSizes' },\n    imagesrcset: { idn: 'imageSrcset' },\n    indeterminate: { noa: true },\n    inputmode: { idn: 'inputMode' },\n    integrity: {},\n    is: { idn: null },\n    ismap: { idn: 'isMap' },\n    itemid: { idn: null },\n    itemprop: { idn: null },\n    itemref: { idn: null },\n    itemscope: { idn: null },\n    itemtype: { idn: null },\n    kind: {},\n    label: {},\n    lang: {},\n    list: {},\n    loading: {},\n    loop: { idv: attrBooleanToEmptyString },\n    low: { idv: attrStringOrNumberToNumber },\n    max: { idv: attrStringOrNumberToNumber },\n    maxlength: {\n        idn: 'maxLength',\n        idv: attrStringOrNumberToNumber,\n    },\n    media: {},\n    method: {},\n    min: { idv: attrStringOrNumberToNumber },\n    minlength: {\n        idn: 'minLength',\n        idv: attrStringOrNumberToNumber,\n    },\n    multiple: {},\n    muted: {},\n    name: {},\n    nomodule: { idn: 'noModule' },\n    nonce: {},\n    novalidate: { idn: 'noValidate' },\n    open: {},\n    optimum: { idv: attrStringOrNumberToNumber },\n    pattern: {},\n    ping: {},\n    placeholder: {},\n    playsinline: { idn: 'playsInline' },\n    popover: {\n        idv: (val) => {\n            if (val === true) return 'auto';\n            if (val === false) return undefined;\n            return val;\n        },\n    },\n    poster: {},\n    preload: {},\n    readonly: { idn: 'readOnly' },\n    referrerpolicy: { idn: 'referrerPolicy' },\n    rel: {},\n    required: {},\n    reversed: {},\n    role: {},\n    rows: { idv: attrStringOrNumberToNumber },\n    rowspan: { idn: 'rowSpan', idv: attrStringOrNumberToNumber },\n    sandbox: {},\n    scope: {},\n    selected: {},\n    shape: {},\n    size: { idv: attrStringOrNumberToNumber },\n    sizes: {},\n    slot: {},\n    span: { idv: attrStringOrNumberToNumber },\n    spellcheck: {},\n    src: {},\n    srcdoc: {},\n    srclang: {},\n    srcset: {},\n    start: { idv: attrStringOrNumberToNumber },\n    step: { idv: attrStringOrNumberToNumber },\n    style: {},\n    tabindex: { idn: 'tabIndex', idv: attrStringOrNumberToNumber },\n    target: {},\n    title: {},\n    translate: { idv: attrYesNo },\n    type: {},\n    usemap: { idn: 'useMap' },\n    // value: {}, // NOTE: value is special and depends on the element\n    width: { idv: attrStringOrNumberToNumber },\n    wrap: {},\n};\n\nexport function setAttribute(\n    element: Element,\n    attributeName: string,\n    val: unknown\n) {\n    if (val === undefined || val === null || val === false) {\n        element.removeAttribute(attributeName);\n    } else if (val === true) {\n        element.setAttribute(attributeName, '');\n    } else if (typeof val === 'string') {\n        element.setAttribute(attributeName, val);\n    } else if (typeof val === 'number' || typeof val === 'bigint') {\n        element.setAttribute(attributeName, val.toString());\n    }\n}\n\nexport function assignProp(element: Element, attribute: string, value: any) {\n    // Note: SVG elements (and probably other kinds) do not have the same\n    // shared IDL behaviors. For example, it's an error to set the .width\n    // property of an SVGSVGElement\n    if (!(element instanceof HTMLElement)) {\n        setAttribute(element, attribute, value);\n        return;\n    }\n    if (attribute === 'value') {\n        // Note: value is special and treated differently, depending on the element\n        switch (element.tagName) {\n            case 'PROGRESS':\n            case 'METER':\n                // Passthru attribue\n                // Numeric idl value\n                setAttribute(element, attribute, value);\n                (element as any).value = attrStringOrNumberToNumber(value);\n                break;\n\n            case 'SELECT':\n                // No attribue\n                // Passthru idl value; provided for convenience as writing to select.value assigns the corresponding option as the selected value\n                (element as any).value = value;\n                break;\n\n            case 'BUTTON':\n            case 'DATA':\n            case 'INPUT':\n            case 'LI':\n            case 'OPTION':\n            case 'PARAM':\n            case 'TEXTAREA':\n                // Passthru attribute\n                // Passthru idl\n                setAttribute(element, attribute, value);\n                (element as any).value = value;\n                break;\n            default:\n                // Passthru attribute\n                setAttribute(element, attribute, value);\n        }\n        return;\n    }\n    const behavior = attrBehavior[attribute];\n    if (behavior) {\n        if (!behavior.noa) {\n            const attributeValue = value;\n            setAttribute(element, attribute, attributeValue);\n        }\n        if (behavior.idn !== null) {\n            const idlValue = behavior.idv ? behavior.idv(value) : value;\n            (element as any)[behavior.idn ?? attribute] = idlValue;\n        }\n        return;\n    }\n    setAttribute(element, attribute, value);\n}\n\n/*\n * Interfaces adopted from HTML Living Standard Last Updated 30 November 2021: https://html.spec.whatwg.org/\n */\n\n// Note: abstract roles are **not** in this list, as \"Authors MUST NOT use abstract roles in content\"\ntype AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'associationlist'\n    | 'associationlistitemkey'\n    | 'associationlistitemvalue'\n    | 'banner'\n    | 'blockquote'\n    | 'button'\n    | 'caption'\n    | 'cell'\n    | 'checkbox'\n    | 'code'\n    | 'columnheader'\n    | 'combobox'\n    | 'comment'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'deletion'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'emphasis'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'generic'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'insertion'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'mark'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'meter'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'paragraph'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'strong'\n    | 'subscript'\n    | 'suggestion'\n    | 'superscript'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'time'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | string;\n\ntype DirValue = 'ltr' | 'rtl' | 'auto' | string;\n\ntype BrowsingContextValue = '_blank' | '_self' | '_parent' | '_top' | string;\n\ntype ReferrerPolicyValue =\n    | ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'same-origin'\n    | 'origin'\n    | 'strict-origin'\n    | 'origin-when-cross-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url'\n    | string;\n\ntype CrossOriginValue = 'anonymous' | '' | 'use-credentials';\n\ntype LazyLoadingValue = 'lazy' | 'eager' | string;\n\ntype ImageDecodingHintValue = 'sync' | 'async' | 'auto' | string;\n\ntype SandboxValue =\n    | 'allow-forms'\n    | 'allow-modals'\n    | 'allow-orientation-lock'\n    | 'allow-pointer-lock'\n    | 'allow-popups'\n    | 'allow-popups-to-escape-sandbox'\n    | 'allow-presentation'\n    | 'allow-same-origin'\n    | 'allow-scripts'\n    | 'allow-top-navigation'\n    | 'allow-top-navigation-by-user-activation'\n    | 'allow-downloads'\n    | string;\n\ntype EncTypeValue =\n    | 'application/x-www-form-urlencoded'\n    | 'multipart/form-data'\n    | 'text/plain'\n    | string;\n\ntype FormMethodValue = 'get' | 'post' | 'dialog' | string;\n\ntype AutocompleteValue = 'on' | 'off' | string;\n\ninterface JSXElementInterface {\n    /** a guide for creating a keyboard shortcut that activates or focuses the element */\n    accesskey?: string | undefined;\n    'aria-atomic'?: string | undefined; //  ariaAtomic\n    'aria-autocomplete'?: string | undefined; //  ariaAutoComplete\n    'aria-busy'?: string | undefined; //  ariaBusy\n    'aria-checked'?: string | undefined; //  ariaChecked\n    'aria-colcount'?: string | undefined; //  ariaColCount\n    'aria-colindex'?: string | undefined; //  ariaColIndex\n    'aria-colindextext'?: string | undefined; //  ariaColIndexText\n    'aria-colspan'?: string | undefined; //  ariaColSpan\n    'aria-current'?: string | undefined; //  ariaCurrent\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description'?: string | undefined; //  ariaDescription\n    */\n    'aria-disabled'?: string | undefined; //  ariaDisabled\n    'aria-expanded'?: string | undefined; //  ariaExpanded\n    'aria-haspopup'?: string | undefined; //  ariaHasPopup\n    'aria-hidden'?: string | undefined; //  ariaHidden\n    'aria-invalid'?: string | undefined; //  ariaInvalid\n    'aria-keyshortcuts'?: string | undefined; //  ariaKeyShortcuts\n    'aria-label'?: string | undefined; //  ariaLabel\n    'aria-level'?: string | undefined; //  ariaLevel\n    'aria-live'?: string | undefined; //  ariaLive\n    'aria-modal'?: string | undefined; //  ariaModal\n    'aria-multiline'?: string | undefined; //  ariaMultiLine\n    'aria-multiselectable'?: string | undefined; //  ariaMultiSelectable\n    'aria-orientation'?: string | undefined; //  ariaOrientation\n    'aria-placeholder'?: string | undefined; //  ariaPlaceholder\n    'aria-posinset'?: string | undefined; //  ariaPosInSet\n    'aria-pressed'?: string | undefined; //  ariaPressed\n    'aria-readonly'?: string | undefined; //  ariaReadOnly\n    'aria-required'?: string | undefined; //  ariaRequired\n    'aria-roledescription'?: string | undefined; //  ariaRoleDescription\n    'aria-rowcount'?: string | undefined; //  ariaRowCount\n    'aria-rowindex'?: string | undefined; //  ariaRowIndex\n    'aria-rowindextext'?: string | undefined; //  ariaRowIndexText\n    'aria-rowspan'?: string | undefined; //  ariaRowSpan\n    'aria-selected'?: string | undefined; //  ariaSelected\n    'aria-setsize'?: string | undefined; //  ariaSetSize\n    'aria-sort'?: string | undefined; //  ariaSort\n    'aria-valuemax'?: string | undefined; //  ariaValueMax\n    'aria-valuemin'?: string | undefined; //  ariaValueMin\n    'aria-valuenow'?: string | undefined; //  ariaValueNow\n    'aria-valuetext'?: string | undefined; //  ariaValueText\n    /** autocapitalization hint */\n    autocapitalize?:\n        | 'off'\n        | 'none'\n        | 'on'\n        | 'sentences'\n        | 'words'\n        | 'characters'\n        | string\n        | undefined;\n    /** focus as soon as the page is loaded or as soon as the dialog within which it finds itself is shown */\n    autofocus?: boolean | undefined;\n    /** the various classes that the element belongs to */\n    class?: string | undefined;\n    /** indicates if the element is editable */\n    contenteditable?: '' | 'true' | 'false' | string | undefined;\n    /** specifies the element's text directionality */\n    dir?: DirValue | undefined;\n    /** specifies the element's drag behavior */\n    draggable?: boolean | undefined;\n    /** specifies what action label (or icon) to present for the enter key on virtual keyboards */\n    enterkeyhint?:\n        | 'enter'\n        | 'done'\n        | 'go'\n        | 'next'\n        | 'previous'\n        | 'search'\n        | 'send'\n        | string\n        | undefined;\n    /** indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user */\n    hidden?: boolean | undefined;\n    /** the unique id of the element */\n    id?: string | undefined;\n    inputmode?:\n        | 'none'\n        | 'text'\n        | 'tel'\n        | 'url'\n        | 'email'\n        | 'numeric'\n        | 'decimal'\n        | 'search'\n        | string\n        | undefined;\n    is?: string | undefined;\n    itemid?: string | undefined;\n    itemprop?: string | undefined;\n    itemref?: string | undefined;\n    itemscope?: boolean | undefined;\n    itemtype?: string | undefined;\n    lang?: string | undefined;\n    nonce?: string | undefined;\n    // Convenience: true => 'auto'; false => undefined\n    popover?: 'auto' | 'manual' | true | false | undefined;\n    role?: AriaRole | undefined;\n    slot?: string | undefined;\n    spellcheck?: boolean | undefined;\n    style?: string | undefined;\n    tabindex?: -1 | 0 | '-1' | '0' | string | number | undefined; // \"-1\" and \"0\" used as convenience\n    title?: string | undefined;\n    translate?: '' | 'yes' | 'no' | undefined;\n}\n\ninterface JSXAnchorElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** Browsing context for hyperlink navigation */\n    target?: BrowsingContextValue | undefined;\n    /** Whether to download the resource instead of navigating to it, and its filename if so */\n    download?: string | undefined;\n    /** URLs to ping */\n    ping?: string | undefined;\n    /** Relationship between the location in the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXAreaElementInterface extends JSXElementInterface {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    shape?:\n        | 'circle'\n        | 'circ'\n        | 'default'\n        | 'poly'\n        | 'polygon'\n        | 'rect'\n        | 'rectangle'\n        | string\n        | undefined;\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n    download?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXMediaElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Hints how much buffering the media resource will likely need */\n    preload?: 'none' | 'metadata' | 'auto' | undefined;\n    /** Hint that the media resource can be started automatically when the page is loaded */\n    autoplay?: boolean | undefined;\n    /** Whether to loop the media resource */\n    loop?: boolean | undefined;\n    /** Whether to mute the media resource by default */\n    muted?: boolean | undefined;\n    /** Show user agent controls */\n    controls?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXAudioElementInterface extends JSXMediaElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBRElementInterface extends JSXElementInterface {}\n\ninterface JSXBaseElementInterface extends JSXElementInterface {\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBodyElementInterface extends JSXElementInterface {}\n\ninterface JSXButtonElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formaction?: string | undefined;\n    formenctype?: EncTypeValue | undefined;\n    formmethod?: FormMethodValue | undefined;\n    formnovalidate?: boolean | undefined;\n    formtarget?: BrowsingContextValue | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | string | undefined;\n    value?: string | undefined;\n}\n\ninterface JSXCanvasElementInterface extends JSXElementInterface {\n    width?: string | number | undefined;\n    height?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDListElementInterface extends JSXElementInterface {}\n\ninterface JSXDataElementInterface extends JSXElementInterface {\n    value?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDataListElementInterface extends JSXElementInterface {}\n\ninterface JSXDetailsElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\ninterface JSXDialogElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDivElementInterface extends JSXElementInterface {}\n\ninterface JSXEmbedElementInterface extends JSXElementInterface {\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: string | number | undefined;\n    height?: string | number | undefined;\n}\n\ninterface JSXFieldSetElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\ninterface JSXFormElementInterface extends JSXElementInterface {\n    'accept-charset'?: 'UTF-8' | string | undefined;\n    action?: string | undefined;\n    autocomplete?: AutocompleteValue | undefined;\n    enctype?: EncTypeValue | undefined;\n    method?: FormMethodValue | undefined;\n    name?: string | undefined;\n    novalidate?: boolean | undefined;\n    target?: BrowsingContextValue | undefined;\n    rel?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadingElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHRElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHtmlElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXIFrameElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** A document to render in the iframe */\n    srcdoc?: string | undefined;\n    /** Name of nested browsing context */\n    name?: string | undefined;\n    /** Security rules for nested content */\n    sandbox?: SandboxValue | undefined; // TODO: This _could_ be a SandboxValue[], but feels awkward\n    /** Permissions policy to be applied to the iframe's contents */\n    allow?: string | undefined;\n    /** Whether to allow the iframe's contents to use requestFullscreen() */\n    allowfullscreen?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\ninterface JSXImageElementInterface extends JSXElementInterface {\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Name of image map to use */\n    usemap?: string | undefined;\n    /** Whether the image is a server-side image map */\n    ismap?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Decoding hint to use when processing this image for presentation */\n    decoding?: ImageDecodingHintValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\ntype FormInputTypeValues =\n    | 'button'\n    | 'checkbox'\n    | 'color'\n    | 'date'\n    | 'datetime-local'\n    | 'email'\n    | 'file'\n    | 'hidden'\n    | 'image'\n    | 'month'\n    | 'number'\n    | 'password'\n    | 'radio'\n    | 'range'\n    | 'reset'\n    | 'search'\n    | 'submit'\n    | 'tel'\n    | 'text'\n    | 'time'\n    | 'url'\n    | 'week'\n    | string;\n\ninterface JSXInputElementInterface extends JSXElementInterface {\n    /** Hint for expected file type in file upload controls */\n    accept?: string | undefined;\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the control is checked */\n    checked?: boolean | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: string | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** URL to use for form submission */\n    formaction?: string | undefined;\n    /** Entry list encoding type to use for form submission */\n    formenctype?: EncTypeValue | undefined;\n    /** Variant to use for form submission */\n    formmethod?: FormMethodValue | undefined;\n    /** Bypass form control validation for form submission */\n    formnovalidate?: boolean | undefined;\n    /** Browsing context for form submission */\n    formtarget?: BrowsingContextValue | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Third, indeterminate state for checkboxes */\n    indeterminate?: boolean | undefined;\n    /** List of autocomplete options */\n    list?: string | undefined;\n    /** Maximum value */\n    max?: string | number | undefined;\n    /** Maximum length of value */\n    maxlength?: string | number | undefined;\n    /** Minimum value */\n    min?: string | number | undefined;\n    /** Minimum length of value */\n    minlength?: string | number | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Pattern to be matched by the form control's value */\n    pattern?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: string | number | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Granularity to be matched by the form control's value */\n    step?: string | number | undefined;\n    /** Type of form control */\n    type?: FormInputTypeValues | undefined;\n    /** Value of the form control */\n    value?: string | number | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n}\n\ninterface JSXModElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n    /** Date and (optionally) time of the change */\n    datetime?: string | undefined;\n}\n\ninterface JSXLabelElementInterface extends JSXElementInterface {\n    /** Associate the label with form control */\n    for?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLegendElementInterface extends JSXElementInterface {}\n\ninterface JSXLIElementInterface extends JSXElementInterface {\n    /** Ordinal value of the list item */\n    value?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLinkElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Relationship between the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Sizes of the icons (for rel=\"icon\") */\n    sizes?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel=\"preload\") */\n    imagesrcset?: string | undefined;\n    /** Image sizes for different page layouts (for rel=\"preload\") */\n    imagesizes?: string | undefined;\n    /** Potential destination for a preload request (for rel=\"preload\" and rel=\"modulepreload\") */\n    as?: string | undefined;\n    /** Color to use when customizing a site's icon (for rel=\"mask-icon\") */\n    color?: string | undefined;\n    /** Whether the link is disabled */\n    disabled?: boolean | undefined;\n}\n\ninterface JSXMapElementInterface extends JSXElementInterface {\n    /** Name of image map to reference from the usemap attribute */\n    name?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXMenuElementInterface extends JSXElementInterface {}\n\ninterface JSXMetaElementInterface extends JSXElementInterface {\n    /** Metadata name */\n    name?:\n        | 'application-name'\n        | 'author'\n        | 'description'\n        | 'generator'\n        | 'keywords'\n        | 'referrer'\n        | 'theme-color'\n        | 'color-scheme'\n        | string\n        | undefined;\n    /** Pragma directive */\n    'http-equiv'?: string | undefined;\n    /** Value of the element */\n    content?: string | undefined;\n    /** Character encoding declaration */\n    charset?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n}\n\ninterface JSXMeterElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: string | number | undefined;\n    /** Lower bound of range */\n    min?: string | number | undefined;\n    /** Upper bound of range */\n    max?: string | number | undefined;\n    /** High limit of low range */\n    low?: string | number | undefined;\n    /** Low limit of high range */\n    high?: string | number | undefined;\n    /** Optimum value in gauge */\n    optimum?: string | number | undefined;\n}\n\ninterface JSXObjectElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    data?: string | undefined;\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** Name of nested browsing context */\n    name?: BrowsingContextValue | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | undefined;\n    /** Vertical dimension */\n    height?: string | undefined;\n}\n\ninterface JSXOListElementInterface extends JSXElementInterface {\n    /** Number the list backwards */\n    reversed?: boolean | undefined;\n    /** Starting value of the list */\n    start?: string | number | undefined;\n    /** Kind of list marker */\n    type?:\n        | 'decimal'\n        | 'lower-alpha'\n        | 'upper-alpha'\n        | 'lower-roman'\n        | 'upper-roman'\n        | string\n        | undefined;\n}\n\ninterface JSXOptGroupElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n}\n\ninterface JSXOptionElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Whether the option is selected by default */\n    selected?: boolean | undefined;\n    /** Value to be used for form submission */\n    value?: string | undefined;\n}\n\ninterface JSXOutputElementInterface extends JSXElementInterface {\n    /** Specifies controls from which the output was calculated */\n    for?: string | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Name of the element to use in the form.elements API. */\n    name?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXParagraphElementInterface extends JSXElementInterface {}\n\ninterface JSXParamElementInterface extends JSXElementInterface {\n    /** Name of parameter */\n    name?: string | undefined;\n    /** Value of parameter */\n    value?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPictureElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPreElementInterface extends JSXElementInterface {}\n\ninterface JSXProgressElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: string | number | undefined;\n    /** Upper bound of range */\n    max?: string | number | undefined;\n}\n\ninterface JSXQuoteElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n}\n\ninterface JSXScriptElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Type of script */\n    type?: 'application/json' | 'text/json' | 'module' | string | undefined;\n    /** Prevents execution in user agents that support module scripts */\n    nomodule?: boolean | undefined;\n    /** Execute script when available, without blocking while fetching */\n    async?: boolean | undefined;\n    /** Defer script execution */\n    defer?: boolean | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXSelectElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: string | number | undefined;\n    /** Value of the element */\n    value?: string | undefined;\n}\n\ninterface JSXSlotElementInterface extends JSXElementInterface {\n    /** Name of shadow tree slot */\n    name?: string | undefined;\n}\n\ninterface JSXSourceElementInterface extends JSXElementInterface {\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** (in video or audio) \u2014 Address of the resource */\n    src?: string | undefined;\n    /** (in picture) \u2014 Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** (in picture) \u2014 Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** (in picture) \u2014 Applicable media */\n    media?: string | undefined;\n    /** (in picture) \u2014 Horizontal dimension */\n    width?: string | number | undefined;\n    /** (in picture) \u2014 Vertical dimension */\n    height?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXSpanElementInterface extends JSXElementInterface {}\n\ninterface JSXStyleElementInterface extends JSXElementInterface {\n    /** Applicable media */\n    media?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableCaptionElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableSectionElementInterface extends JSXElementInterface {}\n\ninterface JSXTableCellElementInterface extends JSXElementInterface {\n    /** Number of columns that the cell is to span */\n    colspan?: string | number | undefined;\n    /** Number of rows that the cell is to span */\n    rowspan?: string | number | undefined;\n    /** The header cells for this cell */\n    headers?: string | undefined;\n}\n\ninterface JSXTableHeaderElementInterface extends JSXTableCellElementInterface {\n    /** Specifies which cells the header cell applies to */\n    scope?: string | undefined;\n\n    /** Alternative label to use for the header cell when referencing the cell in other contexts */\n    abbr?: string | undefined;\n}\n\ninterface JSXTableColElementInterface extends JSXElementInterface {\n    /** Number of columns spanned by the element */\n    span?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTemplateElementInterface extends JSXElementInterface {}\n\ninterface JSXTextAreaElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Maximum number of characters per line */\n    cols?: string | number | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: DirValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Maximum length of value */\n    maxlength?: string | number | undefined;\n    /** Minimum length of value */\n    minlength?: string | number | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Number of lines to show */\n    rows?: string | number | undefined;\n    /** How the value of the form control is to be wrapped for form submission */\n    wrap?: 'soft' | 'hard' | string | undefined;\n    /** The value of the textarea element */\n    value?: string | undefined;\n}\n\ninterface JSXTimeElementInterface extends JSXElementInterface {\n    /** Machine-readable value */\n    datetime?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTitleElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableRowElementInterface extends JSXElementInterface {}\n\ninterface JSXTrackElementInterface extends JSXElementInterface {\n    /** The type of text track */\n    kind?:\n        | 'subtitles'\n        | 'captions'\n        | 'descriptions'\n        | 'chapters'\n        | 'metadata'\n        | string\n        | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Language of the text track */\n    srclang?: string | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Enable the track if no other text track is more suitable */\n    default?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXUListElementInterface extends JSXElementInterface {}\n\ninterface JSXVideoElementInterface extends JSXMediaElementInterface {\n    /** Poster frame to show prior to video playback */\n    poster?: string | undefined;\n    /** Encourage the user agent to display video content within the element's playback area */\n    playsinline?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n}\n\n/**\n * Good old bivarianceHack to allow assignability of specific event handlers to more generic event handlers :facepalm:\n */\ntype EventHandler<TEvent extends Event, TElement extends Element> =\n    | undefined\n    | {\n          bivarianceHack(event: TEvent, target: TElement): void;\n      }['bivarianceHack'];\n\ninterface JSXRefProps<TElement extends Element> {\n    ref?: undefined | RefObjectOrCallback<TElement | undefined>;\n}\n\ntype DynamicPropValue<T> = Dyn<T>;\n\ninterface JSXAttrProps {\n    [key: `attr:${string}`]: DynamicPropValue<\n        string | number | boolean | undefined\n    >;\n    [key: `prop:${string}`]: DynamicPropValue<\n        string | number | boolean | undefined\n    >;\n}\n\ntype JSXEventPrefix = 'on' | 'onpassive' | 'oncapture';\ntype JSXEventTypes = {\n    // Element events\n    animationcancel: AnimationEvent;\n    animationend: AnimationEvent;\n    animationiteration: AnimationEvent;\n    animationstart: AnimationEvent;\n    auxclick: PointerEvent;\n    beforeinput: InputEvent;\n    blur: FocusEvent;\n    click: PointerEvent;\n    compositionend: CompositionEvent;\n    compositionstart: CompositionEvent;\n    compositionupdate: CompositionEvent;\n    contextmenu: PointerEvent;\n    copy: ClipboardEvent;\n    cut: ClipboardEvent;\n    dblclick: MouseEvent;\n    focus: FocusEvent;\n    focusin: FocusEvent;\n    focusout: FocusEvent;\n    fullscreenchange: Event;\n    fullscreenerror: Event;\n    gotpointercapture: PointerEvent;\n    input: InputEvent;\n    keydown: KeyboardEvent;\n    keyup: KeyboardEvent;\n    lostpointercapture: PointerEvent;\n    mousedown: MouseEvent;\n    mouseenter: MouseEvent;\n    mouseleave: MouseEvent;\n    mousemove: MouseEvent;\n    mouseout: MouseEvent;\n    mouseover: MouseEvent;\n    mouseup: MouseEvent;\n    paste: ClipboardEvent;\n    pointercancel: PointerEvent;\n    pointerdown: PointerEvent;\n    pointerenter: PointerEvent;\n    pointerleave: PointerEvent;\n    pointermove: PointerEvent;\n    pointerout: PointerEvent;\n    pointerover: PointerEvent;\n    pointerup: PointerEvent;\n    scroll: Event;\n    scrollend: Event;\n    securitypolicyviolation: SecurityPolicyViolationEvent;\n    touchcancel: TouchEvent;\n    touchend: TouchEvent;\n    touchmove: TouchEvent;\n    touchstart: TouchEvent;\n    transitioncancel: TransitionEvent;\n    transitionend: TransitionEvent;\n    transitionrun: TransitionEvent;\n    transitionstart: TransitionEvent;\n    wheel: WheelEvent;\n\n    // Specific element events\n    beforetoggle: Event; // Incorrect: should be ToggleEvent\n    change: Event;\n    close: Event;\n    drag: DragEvent;\n    dragend: DragEvent;\n    dragenter: DragEvent;\n    dragleave: DragEvent;\n    dragover: DragEvent;\n    dragstart: DragEvent;\n    drop: DragEvent;\n    error: Event;\n    load: Event;\n    toggle: Event; // Incorrect: should be ToggleEvent\n\n    // Media elements: probably should be limited to HTMLMediaElement? (most/all don't bubble)\n    abort: Event;\n    canplay: Event;\n    canplaythrough: Event;\n    durationchange: Event;\n    emptied: Event;\n    encrypted: MediaEncryptedEvent;\n    ended: Event;\n    loadeddata: Event;\n    loadedmetadata: Event;\n    loadstart: Event;\n    pause: Event;\n    play: Event;\n    playing: Event;\n    progress: Event;\n    ratechange: Event;\n    seeked: Event;\n    seeking: Event;\n    stalled: Event;\n    suspend: Event;\n    timeupdate: Event;\n    volumechange: Event;\n    waiting: Event;\n    waitingforkey: Event;\n\n    // Dialog & Input events\n    cancel: Event;\n\n    // Canvas events\n    contextlost: Event;\n    contextrestored: Event;\n    webglcontextcreationerror: WebGLContextEvent;\n    webglcontextlost: WebGLContextEvent;\n    webglcontextrestored: WebGLContextEvent;\n\n    // Form events\n    formdata: FormDataEvent;\n    reset: Event;\n    submit: SubmitEvent;\n\n    // Input events\n    invalid: Event;\n    select: Event;\n\n    // Slot events\n    slotchange: Event;\n\n    // Window events... these probably should not be here?\n    hashchange: HashChangeEvent;\n    languagechange: Event;\n    message: MessageEvent;\n    messageerror: MessageEvent;\n    offline: Event;\n    online: Event;\n    pagehide: PageTransitionEvent;\n    pageshow: PageTransitionEvent;\n    popstate: PopStateEvent;\n    rejectionhandled: PromiseRejectionEvent;\n    storage: StorageEvent;\n    unhandledrejection: PromiseRejectionEvent;\n\n    // Document events... these probably should not be here?\n    readystatechange: Event;\n    visibilitychange: Event;\n\n    // Unknown... where did these come from?\n    connect: MessageEvent;\n    open: Event;\n};\n\ntype JSXEventPropsNamed<TElement extends Element> = {\n    [TKey in `${JSXEventPrefix}:${keyof JSXEventTypes}`]?: TKey extends `${JSXEventPrefix}:${infer TValue}`\n        ? TValue extends keyof JSXEventTypes\n            ? EventHandler<JSXEventTypes[TValue], TElement>\n            : never\n        : never;\n};\n\ninterface JSXEventProps<TElement extends Element>\n    extends JSXEventPropsNamed<TElement> {\n    [key: `on:${string}`]: EventHandler<Event, TElement>;\n    [key: `onpassive:${string}`]: EventHandler<Event, TElement>;\n    [key: `oncapture:${string}`]: EventHandler<Event, TElement>;\n}\n\ninterface CSSProps {\n    [key: `style:${string}`]: DynamicPropValue<string | number | undefined>;\n    [key: `cssprop:${string}`]: DynamicPropValue<string | number | undefined>;\n}\n\ninterface JSXDataProps {\n    [key: `data-${string}`]: DynamicPropValue<\n        string | number | boolean | undefined\n    >;\n}\n\ntype JSXElementInterfaceProps<TJSXType extends JSXElementInterface> = {\n    [Key in keyof TJSXType]: Key extends 'is'\n        ? string | undefined\n        : DynamicPropValue<TJSXType[Key]>;\n};\n\ntype JSXChildrenProps<HasChildren extends boolean> = HasChildren extends true\n    ? { children?: JSX.Node | JSX.Node[] }\n    : { children?: never };\n\ntype WithCalculationsAndRef<\n    TJSXType extends JSXElementInterface,\n    TElement extends Element,\n    HasChildren extends boolean,\n> = JSXRefProps<TElement> &\n    JSXAttrProps &\n    JSXEventProps<TElement> &\n    JSXDataProps &\n    CSSProps &\n    JSXElementInterfaceProps<TJSXType> &\n    JSXChildrenProps<HasChildren>;\n\nexport interface KnownElements {\n    a: WithCalculationsAndRef<\n        JSXAnchorElementInterface,\n        HTMLAnchorElement,\n        true\n    >;\n    abbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    address: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    area: WithCalculationsAndRef<\n        JSXAreaElementInterface,\n        HTMLAreaElement,\n        false\n    >;\n    article: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    aside: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    audio: WithCalculationsAndRef<\n        JSXAudioElementInterface,\n        HTMLAudioElement,\n        true\n    >;\n    b: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    base: WithCalculationsAndRef<\n        JSXBaseElementInterface,\n        HTMLBaseElement,\n        false\n    >;\n    bdi: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    bdo: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    blockquote: WithCalculationsAndRef<\n        JSXQuoteElementInterface,\n        HTMLQuoteElement,\n        true\n    >;\n    body: WithCalculationsAndRef<\n        JSXBodyElementInterface,\n        HTMLBodyElement,\n        true\n    >;\n    br: WithCalculationsAndRef<JSXBRElementInterface, HTMLBRElement, false>;\n    button: WithCalculationsAndRef<\n        JSXButtonElementInterface,\n        HTMLButtonElement,\n        true\n    >;\n    canvas: WithCalculationsAndRef<\n        JSXCanvasElementInterface,\n        HTMLCanvasElement,\n        true\n    >;\n    caption: WithCalculationsAndRef<\n        JSXTableCaptionElementInterface,\n        HTMLTableCaptionElement,\n        true\n    >;\n    cite: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    code: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    col: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        false\n    >;\n    colgroup: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        true\n    >;\n    data: WithCalculationsAndRef<\n        JSXDataElementInterface,\n        HTMLDataElement,\n        true\n    >;\n    datalist: WithCalculationsAndRef<\n        JSXDataListElementInterface,\n        HTMLDataListElement,\n        true\n    >;\n    dd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    del: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    details: WithCalculationsAndRef<\n        JSXDetailsElementInterface,\n        HTMLDetailsElement,\n        true\n    >;\n    dfn: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    dialog: WithCalculationsAndRef<\n        JSXDialogElementInterface,\n        HTMLDialogElement,\n        true\n    >;\n    div: WithCalculationsAndRef<JSXDivElementInterface, HTMLDivElement, true>;\n    dl: WithCalculationsAndRef<\n        JSXDListElementInterface,\n        HTMLDListElement,\n        true\n    >;\n    dt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    em: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    embed: WithCalculationsAndRef<\n        JSXEmbedElementInterface,\n        HTMLEmbedElement,\n        false\n    >;\n    fieldset: WithCalculationsAndRef<\n        JSXFieldSetElementInterface,\n        HTMLFieldSetElement,\n        true\n    >;\n    figcaption: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    figure: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    footer: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    form: WithCalculationsAndRef<\n        JSXFormElementInterface,\n        HTMLFormElement,\n        true\n    >;\n    h1: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h2: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h3: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h4: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h5: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h6: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    head: WithCalculationsAndRef<\n        JSXHeadElementInterface,\n        HTMLHeadElement,\n        true\n    >;\n    header: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hgroup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hr: WithCalculationsAndRef<JSXHRElementInterface, HTMLHRElement, false>;\n    html: WithCalculationsAndRef<\n        JSXHtmlElementInterface,\n        HTMLHtmlElement,\n        true\n    >;\n    i: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    iframe: WithCalculationsAndRef<\n        JSXIFrameElementInterface,\n        HTMLIFrameElement,\n        true\n    >;\n    img: WithCalculationsAndRef<\n        JSXImageElementInterface,\n        HTMLImageElement,\n        false\n    >;\n    input: WithCalculationsAndRef<\n        JSXInputElementInterface,\n        HTMLInputElement,\n        false\n    >;\n    ins: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    kbd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    label: WithCalculationsAndRef<\n        JSXLabelElementInterface,\n        HTMLLabelElement,\n        true\n    >;\n    legend: WithCalculationsAndRef<\n        JSXLegendElementInterface,\n        HTMLLegendElement,\n        true\n    >;\n    li: WithCalculationsAndRef<JSXLIElementInterface, HTMLLIElement, true>;\n    link: WithCalculationsAndRef<\n        JSXLinkElementInterface,\n        HTMLLinkElement,\n        false\n    >;\n    main: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    map: WithCalculationsAndRef<JSXMapElementInterface, HTMLMapElement, true>;\n    mark: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    menu: WithCalculationsAndRef<\n        JSXMenuElementInterface,\n        HTMLMenuElement,\n        true\n    >;\n    meta: WithCalculationsAndRef<\n        JSXMetaElementInterface,\n        HTMLMetaElement,\n        false\n    >;\n    meter: WithCalculationsAndRef<\n        JSXMeterElementInterface,\n        HTMLMeterElement,\n        true\n    >;\n    nav: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    noscript: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    object: WithCalculationsAndRef<\n        JSXObjectElementInterface,\n        HTMLObjectElement,\n        true\n    >;\n    ol: WithCalculationsAndRef<\n        JSXOListElementInterface,\n        HTMLOListElement,\n        true\n    >;\n    optgroup: WithCalculationsAndRef<\n        JSXOptGroupElementInterface,\n        HTMLOptGroupElement,\n        true\n    >;\n    option: WithCalculationsAndRef<\n        JSXOptionElementInterface,\n        HTMLOptionElement,\n        true\n    >;\n    output: WithCalculationsAndRef<\n        JSXOutputElementInterface,\n        HTMLOutputElement,\n        true\n    >;\n    p: WithCalculationsAndRef<\n        JSXParagraphElementInterface,\n        HTMLParagraphElement,\n        true\n    >;\n    param: WithCalculationsAndRef<\n        JSXParamElementInterface,\n        HTMLParamElement,\n        false\n    >;\n    picture: WithCalculationsAndRef<\n        JSXPictureElementInterface,\n        HTMLPictureElement,\n        true\n    >;\n    pre: WithCalculationsAndRef<JSXPreElementInterface, HTMLPreElement, true>;\n    progress: WithCalculationsAndRef<\n        JSXProgressElementInterface,\n        HTMLProgressElement,\n        true\n    >;\n    q: WithCalculationsAndRef<JSXQuoteElementInterface, HTMLQuoteElement, true>;\n    rp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    rt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ruby: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    s: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    samp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    script: WithCalculationsAndRef<\n        JSXScriptElementInterface,\n        HTMLScriptElement,\n        true\n    >;\n    section: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    select: WithCalculationsAndRef<\n        JSXSelectElementInterface,\n        HTMLSelectElement,\n        true\n    >;\n    slot: WithCalculationsAndRef<\n        JSXSlotElementInterface,\n        HTMLSlotElement,\n        true\n    >;\n    small: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    source: WithCalculationsAndRef<\n        JSXSourceElementInterface,\n        HTMLSourceElement,\n        false\n    >;\n    span: WithCalculationsAndRef<\n        JSXSpanElementInterface,\n        HTMLSpanElement,\n        true\n    >;\n    strong: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    style: WithCalculationsAndRef<\n        JSXStyleElementInterface,\n        HTMLStyleElement,\n        true\n    >;\n    sub: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    summary: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    sup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    table: WithCalculationsAndRef<\n        JSXTableElementInterface,\n        HTMLTableElement,\n        true\n    >;\n    tbody: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    td: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    template: WithCalculationsAndRef<\n        JSXTemplateElementInterface,\n        HTMLTemplateElement,\n        true\n    >;\n    textarea: WithCalculationsAndRef<\n        JSXTextAreaElementInterface,\n        HTMLTextAreaElement,\n        true\n    >;\n    tfoot: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    th: WithCalculationsAndRef<\n        JSXTableHeaderElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    thead: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    time: WithCalculationsAndRef<\n        JSXTimeElementInterface,\n        HTMLTimeElement,\n        true\n    >;\n    title: WithCalculationsAndRef<\n        JSXTitleElementInterface,\n        HTMLTitleElement,\n        true\n    >;\n    tr: WithCalculationsAndRef<\n        JSXTableRowElementInterface,\n        HTMLTableRowElement,\n        true\n    >;\n    track: WithCalculationsAndRef<\n        JSXTrackElementInterface,\n        HTMLTrackElement,\n        false\n    >;\n    u: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ul: WithCalculationsAndRef<\n        JSXUListElementInterface,\n        HTMLUListElement,\n        true\n    >;\n    var: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    video: WithCalculationsAndRef<\n        JSXVideoElementInterface,\n        HTMLVideoElement,\n        true\n    >;\n    wbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, false>;\n}\n", "import * as log from './log';\n\nexport enum ArrayEventType {\n    SPLICE = 'splice',\n    MOVE = 'move',\n    SORT = 'sort',\n}\n\nexport interface ArrayEventSplice<T> {\n    type: ArrayEventType.SPLICE;\n    index: number;\n    count: number;\n    items?: T[] | undefined;\n}\nexport interface ArrayEventMove {\n    type: ArrayEventType.MOVE;\n    from: number;\n    count: number;\n    to: number;\n}\nexport interface ArrayEventSort {\n    type: ArrayEventType.SORT;\n    from: number;\n    indexes: number[];\n}\n\nexport type ArrayEvent<T> =\n    | ArrayEventSplice<T>\n    | ArrayEventMove\n    | ArrayEventSort;\n\nexport function shiftEventBy<T>(shiftAmount: number, event: ArrayEvent<T>) {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            event.index += shiftAmount;\n            break;\n        }\n        case ArrayEventType.SORT: {\n            event.from += shiftAmount;\n            for (let i = 0; i < event.indexes.length; ++i) {\n                event.indexes[i] += shiftAmount;\n            }\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            event.from += shiftAmount;\n            event.to += shiftAmount;\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n}\nexport function shiftEvent<T>(\n    slotSizes: number[],\n    slotIndex: number,\n    event: ArrayEvent<T>\n) {\n    let shiftAmount = 0;\n    for (let i = 0; i < slotIndex; ++i) {\n        shiftAmount += slotSizes[i];\n    }\n    if (shiftAmount > 0) {\n        shiftEventBy(shiftAmount, event);\n    }\n    if (event.type === ArrayEventType.SPLICE) {\n        slotSizes[slotIndex] += (event.items?.length ?? 0) - event.count;\n    }\n}\n\nconst EMPTY_ARRAY: readonly [] = [];\n\nexport function applySort<T>(target: T[], from: number, indexes: number[]) {\n    const duped = target.slice(from, from + indexes.length);\n    for (let i = 0; i < indexes.length; ++i) {\n        target[i + from] = duped[indexes[i] - from];\n    }\n}\n\nexport function applyMove<T>(\n    target: T[],\n    from: number,\n    count: number,\n    to: number\n) {\n    const slice = target.splice(from, count);\n    target.splice(to, 0, ...slice);\n}\n\nexport function applyArrayEvent<T>(\n    target: T[],\n    event: ArrayEvent<T>\n): readonly T[] {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            if (event.items) {\n                return target.splice(event.index, event.count, ...event.items);\n            } else {\n                return target.splice(event.index, event.count);\n            }\n        }\n        case ArrayEventType.SORT: {\n            applySort(target, event.from, event.indexes);\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            applyMove(target, event.from, event.count, event.to);\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n    return EMPTY_ARRAY;\n}\n\nexport function* arrayEventFlatMap<T, V>(\n    slotSizes: number[],\n    flatMap: (item: T) => readonly V[],\n    target: V[],\n    event: ArrayEvent<T>\n): IterableIterator<ArrayEvent<V>> {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            let fromIndex = 0;\n            let count = 0;\n            for (let i = 0; i < event.index; ++i) {\n                fromIndex += i < slotSizes.length ? slotSizes[i] : 0;\n            }\n            for (let i = 0; i < event.count; ++i) {\n                const slotIndex = event.index + i;\n                count +=\n                    slotIndex < slotSizes.length ? slotSizes[slotIndex] : 0;\n            }\n            const slotItems: number[] = [];\n            const items: V[] = [];\n            if (event.items) {\n                for (const item of event.items) {\n                    const slot = flatMap(item);\n                    slotItems.push(slot.length);\n                    items.push(...slot);\n                }\n            }\n            target.splice(fromIndex, count, ...items);\n            slotSizes.splice(event.index, event.count, ...slotItems);\n            yield {\n                type: ArrayEventType.SPLICE,\n                index: fromIndex,\n                count,\n                items,\n            };\n            break;\n        }\n        case ArrayEventType.SORT: {\n            const slotStartIndex: number[] = [];\n            let realIndex = 0;\n            for (const slotSize of slotSizes) {\n                slotStartIndex.push(realIndex);\n                realIndex += slotSize;\n            }\n            const copiedSlotSizes = slotSizes.slice();\n            const copiedSource = target.slice();\n\n            const newIndexes: number[] = [];\n            let destSlotIndex = 0;\n            let destIndex = 0;\n            for (const sourceIndex of event.indexes) {\n                const realCount = copiedSlotSizes[sourceIndex];\n                const realIndex = slotStartIndex[sourceIndex];\n                for (let i = 0; i < realCount; ++i) {\n                    newIndexes.push(realIndex + i);\n                    target[destIndex] = copiedSource[realIndex + i];\n                    destIndex += 1;\n                }\n                slotSizes[destSlotIndex] = copiedSlotSizes[sourceIndex];\n                destSlotIndex += 1;\n            }\n            yield {\n                type: ArrayEventType.SORT,\n                from: slotStartIndex[event.from],\n                indexes: newIndexes,\n            };\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            let fromIndex = 0;\n            let toIndex = 0;\n            let count = 0;\n            for (let i = 0; i < event.from; ++i) {\n                fromIndex += slotSizes[i];\n            }\n            for (let i = 0; i < event.count; ++i) {\n                count += slotSizes[event.from + i];\n            }\n            const movedSlots = slotSizes.splice(event.from, event.count);\n            const movedItems = target.splice(fromIndex, count);\n            for (let i = 0; i < event.to; ++i) {\n                toIndex += slotSizes[i];\n            }\n            slotSizes.splice(event.to, 0, ...movedSlots);\n            target.splice(toIndex, 0, ...movedItems);\n            yield {\n                type: ArrayEventType.MOVE,\n                from: fromIndex,\n                count,\n                to: toIndex,\n            };\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n}\n\nexport function addArrayEvent<T>(\n    events: ArrayEvent<T>[],\n    event: ArrayEvent<T>\n) {\n    const lastEvent = events.length > 0 ? events[events.length - 1] : null;\n    if (\n        lastEvent &&\n        event.type === ArrayEventType.SPLICE &&\n        lastEvent.type === ArrayEventType.SPLICE\n    ) {\n        // Case 1: The insertion point of the next event is at the splice end of the last event\n        // - In this case, we add to the event's count and append items\n        const lastEventSpliceEnd =\n            lastEvent.index + (lastEvent.items?.length ?? 0);\n        if (lastEventSpliceEnd === event.index) {\n            lastEvent.count += event.count;\n            if (lastEvent.items && event.items) {\n                lastEvent.items.push(...event.items);\n            } else if (event.items) {\n                lastEvent.items = event.items;\n            }\n            return;\n        }\n        // TODO: add additional merge cases\n    }\n    events.push(event);\n}\n", "import { applyMove, applySort, ArrayEventType } from './arrayevent';\nimport type {\n    ArrayEvent,\n    ArrayEventMove,\n    ArrayEventSort,\n    ArrayEventSplice,\n} from './arrayevent';\nimport * as log from './log';\n\nexport class SlotSizes<TEventSource> {\n    items: TEventSource[];\n    private slots: number[];\n    private indexes: Map<TEventSource, number>;\n\n    constructor(items: TEventSource[]) {\n        this.slots = items.map(() => 0);\n        this.items = items;\n        this.indexes = new Map();\n        this.updateIndexes(0, items.length);\n    }\n\n    clearSlots() {\n        this.slots = this.items.map(() => 0);\n    }\n\n    updateIndexes(lo: number, hi: number) {\n        for (let i = lo; i < hi; ++i) {\n            this.indexes.set(this.items[i], i);\n        }\n    }\n\n    index(item: TEventSource): number | undefined {\n        return this.indexes.get(item);\n    }\n\n    get(index: number): TEventSource | undefined {\n        return this.items[index];\n    }\n\n    move(from: number, count: number, to: number): ArrayEventMove {\n        let fromShift = 0;\n        let countShift = 0;\n        let toShift = 0;\n        for (let i = 0; i < from; ++i) {\n            fromShift += this.slots[i];\n        }\n        for (let i = from; i < from + count; ++i) {\n            countShift += this.slots[i];\n        }\n\n        applyMove(this.slots, from, count, to);\n        applyMove(this.items, from, count, to);\n\n        for (let i = 0; i < to; ++i) {\n            toShift += this.slots[i];\n        }\n\n        this.updateIndexes(from, from + count);\n        this.updateIndexes(to, to + count);\n\n        return {\n            type: ArrayEventType.MOVE,\n            from: fromShift,\n            count: countShift,\n            to: toShift,\n        };\n    }\n\n    sort(from: number, indexes: number[]): ArrayEventSort {\n        // We need to both apply a sort operation and return a projected sort\n        // event that is formed from the full array.\n        //\n        // Imagine slots:\n        // - [0, 3, 1, 0, 2]\n        // - [[], [a,b,c], [d], [], [e,f]]\n        //\n        // Where we sort from index 1 so that it goes: 0, 1, 3:\n        // - [[], [], [d], [a,b,c], [e,f]]\n        //\n        // Original event: from: 1, indexes: [3,2,1]\n        //\n        // Shifted event: from: 0, indexes: [3,0,1,2]\n        //\n        // We get here by building nested indexes:\n        // - [[], [0,1,2], [3], [], [4,5]]\n        //\n        // Applying the array event:\n        // - [[], [], [3], [0,1,2], [4,5]]\n        //\n        // And slicing/flattening the result with a shifted from:\n        // - [3,0,1,2]\n\n        let fromShift = 0;\n        let totalIndex = 0;\n        const indexedSlots: number[][] = [];\n        for (let i = 0; i < from + indexes.length; ++i) {\n            const slotSize = this.slots[i];\n            const indexedSlot: number[] = [];\n            for (let j = 0; j < slotSize; ++j) {\n                indexedSlot.push(totalIndex++);\n            }\n            indexedSlots.push(indexedSlot);\n            if (i < from) {\n                fromShift += this.slots[i];\n            }\n        }\n        applySort(indexedSlots, from, indexes);\n        const newIndexes = indexedSlots.slice(from).flat();\n        applySort(this.slots, from, indexes);\n        applySort(this.items, from, indexes);\n        this.updateIndexes(from, from + indexes.length);\n        return {\n            type: ArrayEventType.SORT,\n            from: fromShift,\n            indexes: newIndexes,\n        };\n    }\n\n    splice<T>(\n        index: number,\n        count: number,\n        items: TEventSource[]\n    ): { removed: TEventSource[]; event: ArrayEventSplice<T> } {\n        let shiftIndex = 0;\n        for (let i = 0; i < index; ++i) {\n            shiftIndex += this.slots[i];\n        }\n        let shiftCount = 0;\n        for (let i = index; i < index + count; ++i) {\n            shiftCount += this.slots[i];\n        }\n        this.slots.splice(index, count, ...items.map(() => 0));\n        const removedItems = this.items.splice(index, count, ...items);\n        for (const removedItem of removedItems) {\n            this.indexes.delete(removedItem);\n        }\n        if (this.items.length === count) {\n            this.updateIndexes(index, index + count);\n        } else {\n            this.updateIndexes(index, this.items.length);\n        }\n        return {\n            removed: removedItems,\n            event: {\n                type: ArrayEventType.SPLICE,\n                index: shiftIndex,\n                count: shiftCount,\n                items: [], // Note: added items are _always_ treated as if they are empty\n            },\n        };\n    }\n\n    applyEvent<TEvent>(\n        source: TEventSource,\n        event: ArrayEvent<TEvent>\n    ): ArrayEvent<TEvent> {\n        const sourceIndex = this.indexes.get(source);\n        log.assert(\n            sourceIndex !== undefined,\n            'event from unknown SlotSizes source',\n            source\n        );\n        let shift = 0;\n        for (let i = 0; i < sourceIndex; ++i) {\n            shift += this.slots[i];\n        }\n        switch (event.type) {\n            case ArrayEventType.SPLICE: {\n                this.slots[sourceIndex] +=\n                    event.items?.length ?? 0 - event.count;\n                return {\n                    type: ArrayEventType.SPLICE,\n                    index: event.index + shift,\n                    count: event.count,\n                    items: event.items,\n                };\n            }\n            case ArrayEventType.SORT: {\n                return {\n                    type: ArrayEventType.SORT,\n                    from: event.from + shift,\n                    indexes: event.indexes.map((index) => index + shift),\n                };\n            }\n            case ArrayEventType.MOVE: {\n                return {\n                    type: ArrayEventType.MOVE,\n                    from: event.from + shift,\n                    count: event.count,\n                    to: event.to + shift,\n                };\n            }\n            default:\n                log.assertExhausted(event, 'unknown ArrayEvent type');\n        }\n    }\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function* noopGenerator() {}\n\nexport const dead = (): any => {\n    throw new Error('Cannot call dead function');\n};\n\nexport const uniqueid = (() => {\n    let id = 1;\n    return () => id++;\n})();\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy<TItem, TKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TKey, TVal]\n): Map<TKey, TVal[]> {\n    const grouped: Map<TKey, TVal[]> = new Map();\n    items.forEach((item) => {\n        const [key, val] = grouper(item);\n        let inner = grouped.get(key);\n        if (!inner) {\n            inner = [];\n            grouped.set(key, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function alwaysFalse(): false {\n    return false;\n}\n\nexport function strictEqual<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low)) + low;\n}\n\nexport function median(numbers: number[]): number {\n    const sorted = numbers.slice().sort((a, b) => a - b);\n    return (\n        (sorted[Math.floor((numbers.length - 1) / 2)] +\n            sorted[Math.ceil((numbers.length - 1) / 2)]) /\n        2\n    );\n}\n\nexport function wrapError(e: unknown, msg?: string): Error {\n    if (e instanceof Error) return e;\n    // @ts-ignore -- 2nd error cause param harmless to add\n    const err = new Error(msg ?? 'Unknown error', { cause: e });\n    return err;\n}\n", "import { noop } from '../common/util';\nimport { RenderNodeCommitPhase } from './rendernode/constants';\nimport type { RenderNode } from './rendernode/rendernode';\n\n/**\n * Global state\n */\nconst COMMIT_SEQUENCE = [\n    RenderNodeCommitPhase.COMMIT_UNMOUNT,\n    RenderNodeCommitPhase.COMMIT_DELETE,\n    RenderNodeCommitPhase.COMMIT_RENDER,\n    RenderNodeCommitPhase.COMMIT_INSERT,\n    RenderNodeCommitPhase.COMMIT_MOUNT,\n];\nlet commitPhases = {\n    [RenderNodeCommitPhase.COMMIT_UNMOUNT]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_DELETE]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_RENDER]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_INSERT]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_MOUNT]: new Set<RenderNode>(),\n};\nlet commitHandle: undefined | (() => void);\nlet commitScheduler = defaultScheduler;\n\nfunction defaultScheduler(callback: () => void) {\n    if ((window as any).queueMicrotask) {\n        let cancelled = false;\n        queueMicrotask(() => {\n            if (cancelled) return;\n            callback();\n        });\n        return () => {\n            cancelled = true;\n        };\n    }\n    const handle = setTimeout(callback, 0);\n    return () => clearTimeout(handle);\n}\n\nfunction noopScheduler(callback: () => void) {\n    return noop;\n}\n\nexport function reset() {\n    commitPhases = {\n        [RenderNodeCommitPhase.COMMIT_UNMOUNT]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_DELETE]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_RENDER]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_INSERT]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_MOUNT]: new Set<RenderNode>(),\n    };\n    commitHandle = undefined;\n    commitScheduler = defaultScheduler;\n}\n\nexport function commit() {\n    while (commitHandle !== undefined) {\n        commitHandle = undefined;\n        performCommit();\n    }\n}\n\nexport function subscribe(scheduler?: (callback: () => void) => () => void) {\n    commitScheduler = scheduler ?? noopScheduler;\n}\n\n// Committing has a few phases:\n// - 1: notify \"onUnmount\"\n// - 1.5: record document.activeElement\n// - 2: commit DOM deletions (notify \"raw\" DOM deletions)\n// - 3: commit DOM insertions (notify \"raw\" DOM insertions)\n// - 3.5: restore document.activeElement if it was moved\n// - 4: notify \"onMount\"\nfunction performCommit() {\n    let activeElement: Element | null = null;\n    for (const phase of COMMIT_SEQUENCE) {\n        if (phase === RenderNodeCommitPhase.COMMIT_DELETE) {\n            activeElement = document.activeElement;\n        }\n        const toCommit = Array.from(commitPhases[phase]).sort(\n            (a, b) => b.getDepth() - a.getDepth()\n        );\n        commitPhases[phase] = new Set();\n        for (const renderNode of toCommit) {\n            renderNode.commit(phase);\n        }\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_INSERT &&\n            activeElement &&\n            document.documentElement.contains(activeElement)\n        ) {\n            (activeElement as HTMLElement).focus();\n        }\n    }\n}\n\nexport function requestCommit(\n    target: RenderNode,\n    phase: RenderNodeCommitPhase\n) {\n    commitPhases[phase].add(target);\n    if (!commitHandle) {\n        commitHandle = commitScheduler(commit);\n    }\n}\n", "type Vertex = {\n    nodeId: number;\n    index?: number;\n    lowlink?: number;\n    onStack?: boolean;\n};\n\nexport function tarjanStronglyConnected(\n    reverseAdjacency: readonly (readonly number[])[],\n    topologicalIndexById: readonly (number | undefined)[],\n    lowerBound: number,\n    upperBound: number,\n    fromNodes: Iterable<number>\n): number[][] {\n    let index = 0;\n    const nodeVertex: Record<number, Vertex> = {};\n    const stack: Vertex[] = [];\n    const reverseTopoSort: number[][] = [];\n\n    function* getDepenencies(nodeId: number) {\n        for (const toId of reverseAdjacency[nodeId]) {\n            const toIndex = topologicalIndexById[toId];\n            if (\n                toIndex !== undefined &&\n                lowerBound <= toIndex &&\n                toIndex <= upperBound\n            ) {\n                yield toId;\n            }\n        }\n    }\n\n    const strongconnect = (vertex: Vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index = index + 1;\n        stack.push(vertex);\n        vertex.onStack = true;\n\n        // Consider successors of v\n        for (const toId of getDepenencies(vertex.nodeId)) {\n            if (!nodeVertex[toId]) {\n                nodeVertex[toId] = {\n                    nodeId: toId,\n                };\n            }\n            const toVertex = nodeVertex[toId];\n            if (toVertex.index === undefined) {\n                // Successor toVertex has not yet been visited; recurse on it\n                strongconnect(toVertex);\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    toVertex.lowlink!\n                );\n            } else if (toVertex.onStack) {\n                // Successor toVertex is in stack S and hence in the current SCC\n                // If toVertex is not on stack, then (vertex, toVertex) is an edge pointing to an SCC already found and must be ignored\n                // Note: The next line may look odd - but is correct.\n                // It says toVertex.index not toVertex.lowlink; that is deliberate and from the original paper\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    toVertex.index\n                );\n            }\n        }\n\n        // If vertex is a root node, pop the stack and generate an SCC\n        if (vertex.lowlink === vertex.index) {\n            // start a new strongly connected component\n            const component: number[] = [];\n            for (;;) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const toVertex = stack.pop()!;\n                toVertex.onStack = false;\n                // add toVertex to current strongly connected component\n                component.push(toVertex.nodeId);\n                if (toVertex === vertex) {\n                    break;\n                }\n            }\n            // output the current strongly connected component\n            reverseTopoSort.push(component);\n        }\n    };\n\n    for (const nodeId of fromNodes) {\n        if (!nodeVertex[nodeId]) {\n            nodeVertex[nodeId] = {\n                nodeId,\n            };\n            strongconnect(nodeVertex[nodeId]);\n        }\n    }\n\n    return reverseTopoSort;\n}\n", "/*\n * The Directed Graph\n * ==================\n *\n * The directed graph is a fully dynamic directed graph: vertices and edges may be added and removed at any time.\n *\n * Main challenge: maintain the topological ordering after each batch of vertex/edge additions/removals.\n *\n * Each vertex has a set of flags which may be set/cleared:\n * - \"dirty\": which is set when the vertex\u2019s underlying data is modified/invalidated.\n * - \"cycle\": set when the vertex is part of a cycle (more correctly: a strongly connected component with >1 vertex)\n * - \"self cycle\": set when the vertex has an edge pointing to itself (completely separate from \"cycle\")\n * - \"cycle informed\": set when the vertex has been processed as a cycle\n *\n * Edges in the graph have two colors:\n * - \u201Chard\u201D: represent data dependencies that propagate\n * - \u201Csoft\u201D: exist solely to maintain topological ordering\n *\n * When a dirty vertex is processed, its dirtiness is cleared. Depending on the result of processing the vertex,\n * dirtiness may be propagated to destination vertices, which have their dirty bit set.\n *\n *\n * Topological Ordering\n * --------------------\n *\n * Our primary goal is to process the dirty vertices in this graph in topological order. One hitch is that during the\n * processing of dirty vertices, edges may be added and vertices may be marked as dirty.\n *\n * Since a topological ordering means arrows go from left to right, the only thing that could possibly break a\n * topological ordering is the addition of an edge that goes in the opposite direction.\n *\n * When we add an edge that goes in the opposite direction, we add the vertices to a set that need to be reordered.\n *\n * It's important to note that if topological order is maintained, a cycle can only occur if an edge is added in the\n * incorrect order (or to itself).\n *\n * This graph uses a variation on the Pearce Kelly algorithm to maintain the topological ordering in this case\n * (https://whileydave.com/publications/pk07_jea/) while supporting cycles.\n *\n * The general structure of this variation is:\n * - Get the lower and upper index bounds of the set of out of order vertices\n * - Instead of using DFS to determine the correct order of the subgraph within the upper/lower bounds, use Tarjan's\n *   strongly connected component algorithm to both determine the order and obtain strongly connected components\n *\n *\n * Handling Cycles\n * ---------------\n *\n * One edge case not explicitly handled by the Pearce Kelly algorithm is how to handle cycles/strongly connected\n * components. This directed graph allows for cycles in the directed graph to exist.\n *\n * Note: The term cycle to mean a set of vertices that can all reach each other. This set may have a size of one.\n *\n * In this case, for the purposes of the graph, all nodes in a cycle are treated as a single unit:\n * - If any of the cycle vertices are marked as \u201Cdirty\u201D they all are marked as \u201Cdirty\u201D\n * - If any of the cycle vertices are processed, they are all processed (in arbitrary order) and dirtiness is propagated\n *   only to vertices that are not members of the cycle.\n *\n * When an edge is added that introduces a cycle, that edge will go from right to left. We will identify these cycles\n * when reordering. In every cycle there is at least one edge that goes in the wrong direction.\n *\n * If an edge that connects two vertices in a cycle is removed there are two cases to consider:\n *\n * Case 1) If the removed edge goes in the correct direction, the cycle may be broken. If broken, there exists at least\n * one edge in the cycle that goes in the wrong direction. In this case, the topological order of the subgraph\n * reachable/that reaches the vertices needs to be reordered. Tarjan\u2019s strongly connected components algorithm is used\n * to reorder the reachable subgraph in this case: identify the subgraph via a DFS traversal forward and backward, then\n * perform the algorithm on the subgraph.\n *\n * Case 2) If the edge goes in the wrong direction, no adjustments to the topological ordering need to be performed.\n * (This is a bold statement. Can a proof be demonstrated? Does this apply if edges are added to vertices in the middle\n * of a cycle?)\n *\n * **Open question**: when sorting and assigning vertices in a cycle, do we ever put anything in the middle of a cycle? We\n * should not.\n *\n * Given:\n * - a b c d e\n * - a->b->d->e->a\n * - And an addition: c->d\n * - We should place c before a as in: c a b d e\n * - This is since the component really \u201Clives\u201D at the first index of a cycle.\n *\n *\n * Graph Processing\n * ----------------\n *\n * The goal of graph processing is to visit all of the vertices marked as dirty and get them marked as not dirty.\n * Processing the graph is a coroutine operation, where a set of actions is produced and in response a Boolean is returned,\n * which indicates whether or not dirtiness should be propagated.\n *\n * When visiting a dirty node, one of three things happens:\n * - If the vertex is part of a cycle, it emits a cycle action.\n * - Otherwise, a recalculate action is emitted.\n *\n * While the graph doesn't concern itself with what these actions perform, in practice:\n * - Invalidation events clear cached data associated with the vertex. These always propagate dirtiness.\n * - Cycle events raise an error. These propagate dirtiness if the error is caught and the value produced is equal to the\n *   prior value.\n * - Recalculation events cause the calculation associated with the vertex to be re-executed. Propagation occurs if the\n *   value produced is equal to the prior value.\n *\n * The naive procedure of processing the graph is to iterate through the dirty vertices in topological order of the graph.\n * Upon discovering a dirty vertex:\n * - If it is part of a cycle, and is not cycle informed, emit a cycle, mark as informed, and conditionally propagate dirtiness\n * - If it ((is not part of a cycle) or (is part of a cycle and is cycle informed)), emit a recalculation and conditionally propagate dirtiness\n *\n * After processing a dirty vertex, perform any pending vertex/edge additions and removals caused by processing while\n * maintaining topological order. Proceed to the dirty vertex with lowest priority order. This ordering of dirty vertices\n * can be maintained with a priority queue that supports reassigning weights.\n *\n * Once all dirty vertices are processed, the operation is complete.\n *\n * It is possible for this algorithm to loop indefinitely. To avoid this, a process limit can be imposed (either per-vertex\n * or globally).\n *\n */\nimport * as log from '../common/log';\nimport { dead } from '../common/util';\nimport { tarjanStronglyConnected } from './tarjan';\n\nexport enum EdgeColor {\n    EDGE_SOFT = 0b01,\n    EDGE_HARD = 0b10,\n}\n\ninterface CycleInfo {\n    lowerBound: number;\n    upperBound: number;\n    vertexIds: Set<number>;\n}\n\nexport enum ProcessAction {\n    INVALIDATE,\n    RECALCULATE,\n    CYCLE,\n}\n\nconst VERTEX_BIT_DIRTY /* ********** */ = 0b0001;\nconst VERTEX_BIT_CYCLE /* ********** */ = 0b0010;\nconst VERTEX_BIT_SELF_CYCLE /* ***** */ = 0b0100;\nconst VERTEX_BIT_CYCLE_INFORMED /* * */ = 0b1000;\n\ninterface DebugAttributes {\n    isActive: boolean;\n    name: string;\n}\n\ntype DebugFormatter<TVertex> = (vertex: TVertex) => DebugAttributes;\ntype DebugSubscription = (graphviz: string, label: string) => void;\n\nexport class Graph<TVertex> {\n    static EDGE_SOFT = EdgeColor.EDGE_SOFT;\n    static EDGE_HARD = EdgeColor.EDGE_HARD;\n\n    /** identifiers available for reuse */\n    protected declare availableIds: number[];\n    protected declare availableIndices: number[];\n    protected declare nextId: number;\n\n    /** Mapping of id -> vertex */\n    protected declare vertexToId: Map<TVertex, number>;\n    protected declare vertexById: (TVertex | undefined)[];\n\n    /** Mapping of id -> bits */\n    protected declare vertexBitsById: number[];\n\n    /** Mapping of id -> CycleInfo */\n    protected declare cycleInfoById: Record<number, CycleInfo | undefined>;\n\n    /** Mapping of id -> hard edges in the forward direction */\n    protected declare forwardAdjacencyHard: number[][];\n\n    /** Mapping of id -> hard|soft edges in the forward direction */\n    protected declare forwardAdjacencyEither: number[][];\n\n    /** Mapping of id -> hard|soft edges in the reverse direction */\n    protected declare reverseAdjacencyEither: number[][];\n\n    /** Mapping of id -> index into topologicalOrdering */\n    protected declare topologicalIndexById: (number | undefined)[];\n\n    /** Ordered list of vertex ids */\n    protected declare topologicalOrdering: (number | undefined)[];\n\n    /** The start index of process(), moves forward in each step, may move back as a result of dirty vertices being added / reordered */\n    protected declare startVertexIndex: number;\n\n    /** Set of vertex ids that need reordering */\n    protected declare toReorderIds: Set<number>;\n\n    private declare debugSubscriptions: Set<{\n        formatter: DebugFormatter<TVertex>;\n        subscription: DebugSubscription;\n    }>;\n\n    private declare postActions: (() => void)[];\n\n    private declare _processHandler: (\n        vertex: TVertex,\n        action: ProcessAction,\n        addPostAction: (postAction: () => void) => void\n    ) => boolean;\n\n    constructor(\n        processHandler: (\n            vertex: TVertex,\n            action: ProcessAction,\n            addPostAction: (postAction: () => void) => void\n        ) => boolean\n    ) {\n        this._processHandler = processHandler;\n\n        this.nextId = 1;\n        this.availableIds = [];\n        this.availableIndices = [];\n\n        this.vertexById = [];\n        this.vertexToId = new Map();\n\n        this.vertexBitsById = [];\n        this.cycleInfoById = {};\n        this.topologicalIndexById = [];\n        this.topologicalOrdering = [];\n\n        this.forwardAdjacencyHard = [];\n        this.forwardAdjacencyEither = [];\n        this.reverseAdjacencyEither = [];\n\n        this.postActions = [];\n\n        this.startVertexIndex = 0;\n        this.toReorderIds = new Set();\n\n        this.debugSubscriptions = new Set();\n    }\n\n    /**\n     * Vertex ids can be reused.\n     *\n     * If a vertex is added, it gets a new id\n     * If a vertex is deleted, its id is removed\n     * If a\n     */\n    addVertex(vertex: TVertex) {\n        log.assert(!this.vertexToId.has(vertex), 'double vertex addition');\n\n        let id: number;\n        if (this.availableIds.length > 0) {\n            id = this.availableIds.pop() as number;\n        } else {\n            id = this.nextId++;\n        }\n\n        this.vertexToId.set(vertex, id);\n        this.vertexById[id] = vertex;\n        this.vertexBitsById[id] = 0;\n\n        let index: number;\n        if (this.availableIndices.length > 0) {\n            index = this.availableIndices.pop() as number;\n        } else {\n            index = this.topologicalOrdering.length;\n            this.topologicalOrdering.length += 1;\n        }\n\n        this.topologicalIndexById[id] = index;\n        this.topologicalOrdering[index] = id;\n\n        this.forwardAdjacencyHard[id] = [];\n        this.forwardAdjacencyEither[id] = [];\n        this.reverseAdjacencyEither[id] = [];\n    }\n\n    removeVertex(vertex: TVertex) {\n        const id = this.vertexToId.get(vertex);\n        log.assert(id, 'double vertex removal');\n        const index = this.topologicalIndexById[id];\n        log.assert(index !== undefined, 'malformed graph');\n\n        // Note: no need to clear edges as you can only remove vertices with no edges\n        log.assert(\n            this.forwardAdjacencyEither[id].length === 0,\n            'cannot remove vertex with forward edges'\n        );\n        log.assert(\n            this.reverseAdjacencyEither[id].length === 0,\n            'cannot remove vertex with reverse edges'\n        );\n\n        this.topologicalIndexById[id] = undefined;\n        this.topologicalOrdering[index] = undefined;\n\n        this.clearVertexDirtyInner(id);\n        this.vertexBitsById[id] = 0;\n        delete this.cycleInfoById[id];\n        this.vertexToId.delete(vertex);\n        this.vertexById[id] = undefined;\n        this.toReorderIds.delete(id);\n\n        // Mark vertices as available for reuse\n        this.availableIds.push(id);\n        this.availableIndices.push(index);\n    }\n\n    hasVertex(vertex: TVertex) {\n        return this.vertexToId.has(vertex);\n    }\n\n    markVertexDirty(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexDirty on nonexistent vertex');\n        this.markVertexDirtyInner(vertexId);\n    }\n\n    private markVertexDirtyInner(vertexId: number) {\n        const vertex = this.vertexById[vertexId];\n        if (vertex && !(this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY)) {\n            this.vertexBitsById[vertexId] |= VERTEX_BIT_DIRTY;\n            this.processHandler(vertex, ProcessAction.INVALIDATE);\n\n            const index = this.topologicalIndexById[vertexId];\n            if (index !== undefined && index < this.startVertexIndex) {\n                this.startVertexIndex = index;\n            }\n        }\n    }\n\n    clearVertexDirty(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexDirty on nonexistent vertex');\n        this.clearVertexDirtyInner(vertexId);\n    }\n\n    private clearVertexDirtyInner(vertexId: number) {\n        if (this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY) {\n            this.vertexBitsById[vertexId] &= ~VERTEX_BIT_DIRTY;\n        }\n    }\n\n    markVertexCycleInformed(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexCycleInformed on nonexistent vertex');\n        this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE_INFORMED;\n    }\n\n    private *cycleAwareAdjacency(\n        vertexId: number,\n        cycleInfo: CycleInfo | undefined,\n        adjacencyList: number[][]\n    ) {\n        if (cycleInfo) {\n            const yielded = new Set<number>();\n            for (const cycleId of cycleInfo.vertexIds) {\n                for (const toId of adjacencyList[cycleId]) {\n                    if (!cycleInfo.vertexIds.has(toId) && !yielded.has(toId)) {\n                        yielded.add(toId);\n                        yield toId;\n                    }\n                }\n            }\n            return;\n        }\n        for (const toId of adjacencyList[vertexId]) {\n            if (toId !== vertexId) yield toId;\n        }\n    }\n\n    addEdge(fromVertex: TVertex, toVertex: TVertex, kind: EdgeColor) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'addEdge from vertex not found');\n        log.assert(toId, 'addEdge to vertex not found');\n\n        DEBUG &&\n            log.assert(\n                !this.forwardAdjacencyEither[fromId].includes(toId),\n                'addEdge duplicate'\n            );\n        this.forwardAdjacencyEither[fromId].push(toId);\n        this.reverseAdjacencyEither[toId].push(fromId);\n        if (kind === EdgeColor.EDGE_HARD) {\n            this.forwardAdjacencyHard[fromId].push(toId);\n        }\n\n        if (\n            fromId === toId &&\n            (this.vertexBitsById[fromId] & VERTEX_BIT_SELF_CYCLE) === 0\n        ) {\n            const isInformed =\n                this.vertexBitsById[fromId] & VERTEX_BIT_CYCLE_INFORMED;\n            if (!isInformed) {\n                const vertex = this.vertexById[fromId];\n                log.assert(vertex, 'missing vertex in self-cycle');\n                this.processHandler(vertex, ProcessAction.CYCLE);\n                this.vertexBitsById[fromId] |=\n                    VERTEX_BIT_CYCLE_INFORMED | VERTEX_BIT_SELF_CYCLE;\n            } else {\n                this.vertexBitsById[fromId] |= VERTEX_BIT_SELF_CYCLE;\n            }\n        }\n\n        const fromIndex = this.topologicalIndexById[fromId];\n        const toIndex = this.topologicalIndexById[toId];\n        log.assert(toIndex !== undefined, 'malformed graph');\n        log.assert(fromIndex !== undefined, 'malformed graph');\n\n        // Check for out-of-order edge insertion and add to resort batch\n        const badOrder = fromIndex > toIndex; // Note: equal is ok: you can't reorder a self-edge\n        if (badOrder) {\n            this.toReorderIds.add(fromId);\n            this.toReorderIds.add(toId);\n        }\n    }\n\n    hasEdge(fromVertex: TVertex, toVertex: TVertex, kind: EdgeColor) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'addEdge from vertex not found');\n        log.assert(toId, 'addEdge to vertex not found');\n\n        return this.forwardAdjacencyEither[fromId].includes(toId);\n    }\n\n    removeEdge(fromVertex: TVertex, toVertex: TVertex, kind: EdgeColor) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'removeEdge from vertex not found');\n        log.assert(toId, 'removeEdge to vertex not found');\n\n        DEBUG &&\n            log.assert(\n                this.forwardAdjacencyEither[fromId].includes(toId),\n                'removeEdge on edge that does not exist'\n            );\n\n        removeUnordered(this.forwardAdjacencyEither[fromId], toId);\n        removeUnordered(this.reverseAdjacencyEither[toId], fromId);\n        if (kind === EdgeColor.EDGE_HARD) {\n            removeUnordered(this.forwardAdjacencyHard[fromId], toId);\n        }\n\n        // If we are removing a self-cycle, clear the self cycle bit\n        if (fromId === toId) {\n            this.vertexBitsById[fromId] =\n                this.vertexBitsById[fromId] & ~VERTEX_BIT_SELF_CYCLE;\n        }\n\n        // If the removed edge is between two nodes in a cycle, it _may_ break the cycle\n        const fromCycleInfo = this.cycleInfoById[fromId];\n        const toCycleInfo = this.cycleInfoById[toId];\n        if (fromCycleInfo && toCycleInfo && fromCycleInfo === toCycleInfo) {\n            this.toReorderIds.add(fromId);\n            this.toReorderIds.add(toId);\n        }\n    }\n\n    private visitDfsForwardRecurse(\n        vertexId: number,\n        lowerBound: number,\n        upperBound: number,\n        visited: Set<number>\n    ) {\n        if (visited.has(vertexId)) return;\n        visited.add(vertexId);\n        for (const toId of this.forwardAdjacencyEither[vertexId]) {\n            const toIndex = this.topologicalIndexById[toId];\n            log.assert(toIndex !== undefined, 'malformed graph');\n            if (lowerBound <= toIndex && toIndex <= upperBound) {\n                this.visitDfsForwardRecurse(\n                    toId,\n                    lowerBound,\n                    upperBound,\n                    visited\n                );\n            }\n        }\n    }\n\n    private visitDfsForward(\n        startVertices: Iterable<number>,\n        lowerBound: number,\n        upperBound: number\n    ) {\n        const visited = new Set<number>();\n        for (const vertexId of startVertices) {\n            this.visitDfsForwardRecurse(\n                vertexId,\n                lowerBound,\n                upperBound,\n                visited\n            );\n        }\n        return visited;\n    }\n\n    private resort(toReorder: Set<number>) {\n        // Determine the bounds of the subgraph to reorder\n        let lowerBound = Infinity;\n        let upperBound = -Infinity;\n        for (const vertexId of toReorder) {\n            const cycleInfo = this.cycleInfoById[vertexId];\n            if (cycleInfo) {\n                if (cycleInfo.lowerBound < lowerBound)\n                    lowerBound = cycleInfo.lowerBound;\n                if (cycleInfo.upperBound > upperBound)\n                    upperBound = cycleInfo.upperBound;\n            } else {\n                const index = this.topologicalIndexById[vertexId];\n                log.assert(index !== undefined, 'malformed graph');\n                if (index < lowerBound) lowerBound = index;\n                if (index > upperBound) upperBound = index;\n            }\n        }\n\n        // Determine \"seed\" vertices for Tarjan's algorithm (those that are reachable in reverse from the ones that need reordering, within bounds)\n        const seedVertices = this.visitDfsForward(\n            toReorder,\n            lowerBound,\n            upperBound\n        );\n\n        // Use Tarjan's strongly connected algorithm (limited by the bound subgraph, sourced solely from the nodes we\n        // want to reorder) to get topological order & strongly connected components\n        const components = tarjanStronglyConnected(\n            this.reverseAdjacencyEither,\n            this.topologicalIndexById,\n            lowerBound,\n            upperBound,\n            seedVertices\n        );\n\n        // Mark cycles and grab the list of current indexes that will be overwritten\n        const allocatedIndexes: number[] = [];\n        for (const component of components) {\n            let cycle: CycleInfo | undefined;\n            if (component.length > 1) {\n                cycle = {\n                    upperBound: -Infinity,\n                    lowerBound: Infinity,\n                    vertexIds: new Set(component),\n                };\n            }\n\n            for (const vertexId of component) {\n                const index = this.topologicalIndexById[vertexId];\n                log.assert(index !== undefined, 'malformed graph');\n                if (cycle) {\n                    if (index < cycle.lowerBound) cycle.lowerBound = index;\n                    if (index > cycle.upperBound) cycle.upperBound = index;\n\n                    if (!(this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE)) {\n                        this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE;\n                    }\n                    if (\n                        !(\n                            this.vertexBitsById[vertexId] &\n                            VERTEX_BIT_CYCLE_INFORMED\n                        )\n                    ) {\n                        // A vertex is discovered to be part of a cycle, inform it\n                        const vertex = this.vertexById[vertexId];\n                        log.assert(vertex, 'uninformed vertex missing');\n                        this.processHandler(vertex, ProcessAction.CYCLE);\n                        this.vertexBitsById[vertexId] |=\n                            VERTEX_BIT_CYCLE_INFORMED;\n                    }\n\n                    this.cycleInfoById[vertexId] = cycle;\n                } else if (this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE) {\n                    // Vertex no longer part of a cycle, clear the cycle bits and mark as dirty\n                    this.vertexBitsById[vertexId] =\n                        this.vertexBitsById[vertexId] &\n                        ~(VERTEX_BIT_CYCLE | VERTEX_BIT_CYCLE_INFORMED);\n                    delete this.cycleInfoById[vertexId];\n                    this.markVertexDirtyInner(vertexId);\n                }\n                allocatedIndexes.push(index);\n            }\n        }\n\n        // Sort the allocated indexes so we can incrementally assign vertices to these indexes\n        allocatedIndexes.sort((a, b) => a - b);\n        let i = 0;\n        for (const component of components) {\n            for (const vertexId of component) {\n                const index = allocatedIndexes[i];\n                this.topologicalOrdering[index] = vertexId;\n                this.topologicalIndexById[vertexId] = index;\n                i += 1;\n            }\n        }\n\n        return lowerBound;\n    }\n\n    private addPostAction = (action: () => void) => {\n        this.postActions.push(action);\n    };\n\n    private processHandler(vertex: TVertex, action: ProcessAction) {\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const name = formatter(vertex).name;\n                const label = `${ProcessAction[action]}: ${name}`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                            isActive: v === vertex,\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n        return this._processHandler(vertex, action, this.addPostAction);\n    }\n\n    private processVertex(vertexId: number) {\n        const vertex = this.vertexById[vertexId];\n        log.assert(vertex, 'nonexistent vertex dirtied');\n        return this.processHandler(vertex, ProcessAction.RECALCULATE);\n    }\n\n    process() {\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const label = `Process start`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n        if (this.toReorderIds.size > 0) {\n            this.resort(this.toReorderIds);\n            this.toReorderIds.clear();\n        }\n\n        for (;;) {\n            const vertexIndex = this.startVertexIndex;\n            if (vertexIndex >= this.vertexById.length) {\n                const postActions = this.postActions;\n                this.postActions = [];\n                for (const postAction of postActions) {\n                    postAction();\n                }\n                if (vertexIndex !== this.startVertexIndex) {\n                    // The result of processing postActions has dirtied the graph,\n                    // so we jump back and re-process\n                    continue;\n                }\n\n                this.startVertexIndex = 0;\n                break;\n            }\n            this.startVertexIndex++;\n\n            const vertexId = this.topologicalOrdering[vertexIndex];\n            if (vertexId === undefined) {\n                continue;\n            }\n\n            const isDirty = this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY;\n            if (!isDirty) {\n                continue;\n            }\n\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'nonexistent vertex dirtied');\n\n            const cycleInfo = this.cycleInfoById[vertexId];\n\n            let shouldPropagate = false;\n            const recheckIds: null | number[] =\n                cycleInfo ||\n                this.vertexBitsById[vertexId] & VERTEX_BIT_SELF_CYCLE\n                    ? []\n                    : null;\n            if (cycleInfo) {\n                for (const cycleId of cycleInfo.vertexIds) {\n                    if (!this.vertexById[cycleId]) continue; // broken cycles may release vertices in cycle\n                    const isInformed =\n                        this.vertexBitsById[cycleId] &\n                        VERTEX_BIT_CYCLE_INFORMED;\n                    if (isInformed) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        recheckIds!.push(cycleId);\n                    }\n                    shouldPropagate =\n                        this.processVertex(cycleId) || shouldPropagate;\n                }\n            } else {\n                const isInformed =\n                    this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE_INFORMED;\n                if (isInformed && recheckIds) {\n                    recheckIds.push(vertexId);\n                }\n                shouldPropagate =\n                    this.processVertex(vertexId) || shouldPropagate;\n            }\n\n            if (this.toReorderIds.size > 0) {\n                const lowerBound = this.resort(this.toReorderIds);\n                if (lowerBound < this.startVertexIndex) {\n                    this.startVertexIndex = lowerBound;\n                }\n                this.toReorderIds.clear();\n            }\n\n            // If cycles remain after recalculating an informed cycle, the recalculation failed to break the cycle, so\n            // we need to call the process handler with CYCLE actions to correctly set their error state\n            if (recheckIds) {\n                for (const cycleId of recheckIds) {\n                    const isStillCycle =\n                        this.vertexBitsById[cycleId] &\n                        (VERTEX_BIT_CYCLE | VERTEX_BIT_SELF_CYCLE);\n                    if (isStillCycle) {\n                        const cycleVertex = this.vertexById[cycleId];\n                        log.assert(cycleVertex, 'nonexistent vertex in cycle');\n                        shouldPropagate =\n                            this.processHandler(\n                                cycleVertex,\n                                ProcessAction.CYCLE\n                            ) || shouldPropagate;\n                    }\n                }\n            }\n\n            // Check if we gained or lost new cycle nodes which need to be propagated\n            const newCycleInfo = this.cycleInfoById[vertexId];\n            if (!cycleInfo && newCycleInfo) {\n                shouldPropagate = true;\n            }\n            if (cycleInfo && !newCycleInfo) {\n                shouldPropagate = true;\n            }\n            if (\n                cycleInfo &&\n                newCycleInfo &&\n                newCycleInfo.vertexIds !== cycleInfo.vertexIds\n            ) {\n                shouldPropagate = true;\n            }\n\n            if (shouldPropagate) {\n                // 3 sets of vertices to union + propagate:\n                // - the vertexId we are processing\n                // - the vertexIds that were part of the cycle prior to recalculating\n                // - the vertexIds that were part of the cycle after to recalculating\n                const toPropagate: Set<number> = new Set();\n                toPropagate.add(vertexId);\n                if (cycleInfo) {\n                    for (const oldVertexId of cycleInfo.vertexIds) {\n                        toPropagate.add(oldVertexId);\n                    }\n                }\n                if (newCycleInfo) {\n                    for (const newVertexId of newCycleInfo.vertexIds) {\n                        toPropagate.add(newVertexId);\n                    }\n                }\n\n                for (const cycleId of toPropagate) {\n                    if (!this.vertexById[cycleId]) continue; // broken cycles may release vertices in cycle\n                    this.propagateDirty(cycleId, toPropagate);\n                }\n            } else {\n                this.clearVertexDirtyInner(vertexId);\n            }\n        }\n\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const label = `Process end`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n    }\n\n    getOrderedDirty() {\n        if (this.toReorderIds.size > 0) {\n            this.resort(this.toReorderIds);\n            this.toReorderIds.clear();\n        }\n\n        const vertices: TVertex[] = [];\n        for (\n            let vertexIndex = 0;\n            vertexIndex < this.topologicalOrdering.length;\n            ++vertexIndex\n        ) {\n            const vertexId = this.topologicalOrdering[vertexIndex];\n            if (vertexId === undefined) {\n                continue;\n            }\n\n            const isDirty = this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY;\n            if (!isDirty) {\n                continue;\n            }\n\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'nonexistent vertex dirtied');\n            vertices.push(vertex);\n        }\n        return vertices;\n    }\n\n    private propagateDirty(\n        vertexId: number,\n        cycleVertexIds: null | Set<number>\n    ) {\n        this.clearVertexDirtyInner(vertexId);\n        for (const toId of this.forwardAdjacencyHard[vertexId]) {\n            const toCycleInfo = this.cycleInfoById[toId];\n            if (toCycleInfo) {\n                for (const toCycleId of toCycleInfo.vertexIds) {\n                    if (!cycleVertexIds || !cycleVertexIds.has(toCycleId)) {\n                        this.markVertexDirtyInner(toCycleId);\n                    }\n                }\n            } else {\n                if (!cycleVertexIds || !cycleVertexIds.has(toId)) {\n                    this.markVertexDirtyInner(toId);\n                }\n            }\n        }\n    }\n\n    debug(getAttrs: DebugFormatter<TVertex>, label?: string) {\n        const lines = [];\n        lines.push('digraph dependencies {');\n        lines.push(`  graph [];`);\n        lines.push(`  edge [penwidth=2.0];`);\n        lines.push(`  node [penwidth=2.0];`);\n        if (label) {\n            lines.push(`  graph [label=${JSON.stringify(label)};]`);\n        }\n\n        const emitVertex = (id: number) => {\n            const vertex = this.vertexById[id];\n            if (!vertex) return;\n            const customAttrs = getAttrs(vertex);\n            const attrs: Record<string, string | number> = {\n                style: 'filled',\n                label: `${id}\\n${customAttrs.name}`,\n            };\n\n            // Shapes:\n            attrs.shape = 'ellipse';\n\n            // Fill colors:\n            // - dirty: black / #F9C784\n            // - clean: black / white\n            if (this.vertexBitsById[id] & VERTEX_BIT_DIRTY) {\n                attrs.style = 'filled';\n                attrs.fontcolor = '#FFFFFF';\n                attrs.fillcolor = '#FC7A1E';\n            } else {\n                attrs.style = 'filled';\n                attrs.fontcolor = '#000000';\n                attrs.fillcolor = '#FFFFFF';\n            }\n\n            // Border:\n            // - active: #485696\n            if (customAttrs.isActive) {\n                attrs.penwidth = 4.0;\n                attrs.pencolor = '#485696';\n            }\n\n            const labelItems: string[] = [];\n            for (const [attrName, attrVal] of Object.entries(attrs)) {\n                labelItems.push(`${attrName}=${JSON.stringify(attrVal)}`);\n            }\n\n            lines.push(`  v_${id} [${labelItems.join(',')}]`);\n        };\n\n        const cycles = new Set<CycleInfo>();\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const cycleInfo = this.cycleInfoById[id];\n            if (cycleInfo) {\n                cycles.add(cycleInfo);\n            }\n        }\n        for (const cycle of cycles) {\n            lines.push('  subgraph cluster_cycle {');\n            lines.push(`  graph [label=\"cycle\";]`);\n            for (const cycleId of cycle.vertexIds) {\n                emitVertex(cycleId);\n            }\n            lines.push('  }');\n        }\n\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const cycleInfo = this.cycleInfoById[id];\n            if (cycleInfo) continue;\n            emitVertex(id);\n        }\n\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const hard = new Set(this.forwardAdjacencyHard[id] || []);\n            if (this.forwardAdjacencyEither[id]) {\n                for (const toId of this.forwardAdjacencyEither[id]) {\n                    if (hard.has(toId)) {\n                        lines.push(`  v_${id} -> v_${toId};`);\n                    } else {\n                        lines.push(`  v_${id} -> v_${toId} [style=\"dotted\"];`);\n                    }\n                }\n            }\n        }\n        lines.push('}');\n        return lines.join('\\n');\n    }\n\n    debugSubscribe(\n        formatter: DebugFormatter<TVertex>,\n        subscription: (graphviz: string, label: string) => void\n    ) {\n        const entry = {\n            formatter,\n            subscription,\n        };\n        this.debugSubscriptions.add(entry);\n        return () => {\n            this.debugSubscriptions.delete(entry);\n        };\n    }\n\n    debugGetGraph() {\n        const vertices: TVertex[] = [];\n        for (let i = 0; i < this.vertexById.length; ++i) {\n            const vertex = this.vertexById[i];\n            if (vertex) {\n                vertices.push(vertex);\n            }\n        }\n        const edges: [TVertex, TVertex][] = [];\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            if (this.forwardAdjacencyEither[id]) {\n                for (const toId of this.forwardAdjacencyEither[id]) {\n                    const source = this.vertexById[id];\n                    const target = this.vertexById[toId];\n                    if (source && target) {\n                        edges.push([source, target]);\n                    }\n                }\n            }\n        }\n        return { vertices, edges };\n    }\n\n    /**\n     * Test-only interfaces; omitted in standard build\n     */\n    _test_getVertices(): TVertex[] {\n        return dead();\n    }\n    _test_getDependencies(vertex: TVertex): TVertex[] {\n        return dead();\n    }\n    _test_getVertexInfo(\n        vertex: TVertex\n    ): undefined | { id: number; index: number; bits: number } {\n        return dead();\n    }\n}\n\n/**\n * Inject test-only interfaces if we are in a test environment\n */\nif (TEST) {\n    Graph.prototype._test_getVertices = function _test_getVertices<TVertex>(\n        this: Graph<TVertex>\n    ) {\n        return this.vertexById.filter((vertex) => !!vertex);\n    };\n    Graph.prototype._test_getDependencies = function _test_getDependencies<\n        TVertex,\n    >(this: Graph<TVertex>, vertex: TVertex) {\n        const id = this.vertexToId.get(vertex);\n        log.assert(id, 'getDependencies on nonexistent vertex');\n        return this.forwardAdjacencyEither[id].map(\n            (toId) => this.vertexById[toId]\n        );\n    };\n\n    Graph.prototype._test_getVertexInfo = function _test_getVertexInfo<TVertex>(\n        this: Graph<TVertex>,\n        vertex: TVertex\n    ) {\n        const id = this.vertexToId.get(vertex);\n        if (id === undefined) return undefined;\n        const index = this.topologicalIndexById[id];\n        log.assert(index !== undefined, 'malformed graph');\n        const bits = this.vertexBitsById[id];\n        return {\n            id,\n            index,\n            bits,\n        };\n    };\n}\n\nfunction removeUnordered(array: number[], value: number) {\n    if (value === array[array.length - 1]) {\n        array.pop();\n        return;\n    }\n    const index = array.indexOf(value);\n    array[index] = array[array.length - 1];\n    array.pop();\n}\n", "import * as log from '../common/log';\nimport { noop } from '../common/util';\nimport { commit } from '../viewcontroller/commit';\nimport { Graph, ProcessAction } from './graph';\n\nexport interface Retainable {\n    __debugName: string;\n    __refcount: number;\n    __alive: () => void;\n    __dead: () => void;\n}\n\nexport interface Processable {\n    __processable: true;\n    __debugName: string;\n    __recalculate?: (\n        addPostAction: (postAction: () => void) => void\n    ) => boolean;\n    __cycle?: (addPostAction: (postAction: () => void) => void) => boolean;\n    __invalidate?: () => boolean;\n}\n\nexport function isProcessable(val: any): val is Processable {\n    return val && val.__processable === true;\n}\n\nlet globalDependencyGraph = new Graph<Processable>(processHandler);\nlet postProcessActions = new Set<() => void>();\nlet trackReadSets: (Set<Retainable> | null)[] = [];\nlet trackCreateSets: (Set<Retainable> | null)[] = [];\nlet isFlushing = false;\nlet needsFlush = false;\nlet flushHandle: (() => void) | null = null;\nlet flushScheduler = defaultScheduler;\n\nfunction noopScheduler(callback: () => void) {\n    return noop;\n}\n\nfunction defaultScheduler(callback: () => void) {\n    if ((window as any).queueMicrotask) {\n        let cancelled = false;\n        queueMicrotask(() => {\n            if (cancelled) return;\n            callback();\n        });\n        return () => {\n            cancelled = true;\n        };\n    }\n    const handle = setTimeout(callback, 0);\n    return () => clearTimeout(handle);\n}\n\nexport function reset() {\n    globalDependencyGraph = new Graph<Processable>(processHandler);\n    postProcessActions = new Set();\n    trackReadSets = [];\n    trackCreateSets = [];\n    isFlushing = false;\n    needsFlush = false;\n    if (flushHandle) flushHandle();\n    flushHandle = null;\n    flushScheduler = defaultScheduler;\n}\n\nfunction scheduleFlush() {\n    if (needsFlush) return;\n    needsFlush = true;\n    flushHandle = flushScheduler(() => {\n        needsFlush = false;\n        flushHandle = null;\n        flushInner();\n    });\n}\n\nexport function flush() {\n    if (isFlushing) {\n        return;\n    }\n    if (flushHandle) {\n        flushHandle();\n        flushHandle = null;\n    }\n    needsFlush = false;\n    flushInner();\n}\n\nexport function subscribe(scheduler?: (callback: () => void) => () => void) {\n    flushScheduler = scheduler ?? noopScheduler;\n}\n\nexport function retain(retainable: Retainable) {\n    DEBUG &&\n        log.debug(\n            'retain',\n            retainable.__debugName,\n            'was',\n            retainable.__refcount\n        );\n    retainable.__refcount += 1;\n    if (retainable.__refcount === 1) {\n        retainable.__alive();\n    }\n}\n\nexport function release(retainable: Retainable) {\n    DEBUG &&\n        log.debug(\n            'release',\n            retainable.__debugName,\n            'was',\n            retainable.__refcount\n        );\n    log.assert(retainable.__refcount > 0, 'double release');\n    if (retainable.__refcount === 1) {\n        retainable.__dead();\n    }\n    retainable.__refcount -= 1;\n}\n\nfunction processHandler(\n    vertex: Processable,\n    action: ProcessAction,\n    addPostAction: (postAction: () => void) => void\n) {\n    DEBUG &&\n        log.debug('process', ProcessAction[action], vertex.__debugName, vertex);\n    switch (action) {\n        case ProcessAction.INVALIDATE:\n            return vertex.__invalidate?.() ?? false;\n        case ProcessAction.RECALCULATE:\n            return vertex.__recalculate?.(addPostAction) ?? false;\n        case ProcessAction.CYCLE:\n            return vertex.__cycle?.(addPostAction) ?? false;\n        default:\n            log.assertExhausted(action, 'unknown action');\n    }\n}\n\nfunction flushInner() {\n    isFlushing = true;\n    globalDependencyGraph.process();\n    const toProcess = postProcessActions;\n    postProcessActions = new Set();\n    for (const postProcessAction of toProcess) {\n        postProcessAction();\n    }\n    commit();\n    isFlushing = false;\n    if (needsFlush) {\n        // This can happen when a flush or commit causes nodes in the dependency graph to be dirtied\n        // Ideally this shouldn't happen in a normal application, probably should measure if that's true in an idiomatic one\n        flush();\n    }\n}\n\nexport function addPostProcessAction(action: () => void) {\n    postProcessActions.add(action);\n    scheduleFlush();\n    return () => {\n        postProcessActions.delete(action);\n    };\n}\n\nexport function addVertex(vertex: Processable) {\n    DEBUG && log.debug('addVertex', vertex.__debugName);\n    globalDependencyGraph.addVertex(vertex);\n}\n\nexport function removeVertex(vertex: Processable) {\n    DEBUG && log.debug('removeVertex', vertex.__debugName);\n    globalDependencyGraph.removeVertex(vertex);\n}\n\nexport function addHardEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'add edge:hard',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.addEdge(fromVertex, toVertex, Graph.EDGE_HARD);\n}\n\nexport function addSoftEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'add edge:soft',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.addEdge(fromVertex, toVertex, Graph.EDGE_SOFT);\n}\n\nexport function removeHardEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'del edge:hard',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.removeEdge(fromVertex, toVertex, Graph.EDGE_HARD);\n}\n\nexport function removeSoftEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'del edge:soft',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.removeEdge(fromVertex, toVertex, Graph.EDGE_SOFT);\n}\n\nexport function markDirty(vertex: Processable) {\n    DEBUG && log.debug('dirty', vertex.__debugName);\n    globalDependencyGraph.markVertexDirty(vertex);\n    scheduleFlush();\n}\n\nexport function unmarkDirty(vertex: Processable) {\n    DEBUG && log.debug('clean', vertex.__debugName);\n    globalDependencyGraph.clearVertexDirty(vertex);\n}\n\nexport function markCycleInformed(vertex: Processable) {\n    DEBUG && log.debug('cycle informed', vertex.__debugName);\n    globalDependencyGraph.markVertexCycleInformed(vertex);\n}\n\nexport function trackReads<T>(\n    set: Set<Retainable>,\n    fn: () => T,\n    debugName?: string\n): T {\n    DEBUG && log.group('trackReads', debugName ?? 'call');\n    trackReadSets.push(set);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            set === trackReadSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function untrackReads<T>(fn: () => T, debugName?: string): T {\n    DEBUG && log.group('untrackReads', debugName ?? 'call');\n    trackReadSets.push(null);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            null === trackReadSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function trackCreates<T>(\n    set: Set<Retainable | (Retainable & Processable)>,\n    fn: () => T,\n    debugName?: string\n): T {\n    DEBUG && log.group('trackCreates', debugName ?? 'call');\n    trackCreateSets.push(set);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            set === trackCreateSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function untrackCreates<T>(fn: () => T, debugName?: string): T {\n    DEBUG && log.group('untrackCreates', debugName ?? 'call');\n    trackCreateSets.push(null);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            null === trackCreateSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function notifyCreate(retainable: Retainable) {\n    if (trackCreateSets.length === 0) return;\n    const createSet = trackCreateSets[trackCreateSets.length - 1];\n    if (createSet) {\n        DEBUG &&\n            log.debug(\n                'notifying dependency',\n                retainable.__debugName,\n                'to was created'\n            );\n        if (!createSet.has(retainable)) {\n            createSet.add(retainable);\n        }\n    }\n}\n\nexport function notifyRead(dependency: Retainable) {\n    if (trackReadSets.length === 0) return;\n    const calculationReads = trackReadSets[trackReadSets.length - 1];\n    if (calculationReads) {\n        DEBUG &&\n            log.debug(\n                'adding dependency',\n                dependency.__debugName,\n                'to active calculation'\n            );\n        if (!calculationReads.has(dependency)) {\n            retain(dependency);\n            calculationReads.add(dependency);\n        }\n    }\n}\n\nexport function debug(activeVertex?: Processable, label?: string) {\n    return globalDependencyGraph.debug((vertex) => {\n        return {\n            isActive: vertex === activeVertex,\n            name: `${vertex.__debugName} (rc=${(vertex as any).__refcount})`,\n        };\n    }, label);\n}\n\nexport function debugSubscribe(fn: (label: string, graphviz: string) => void) {\n    return globalDependencyGraph.debugSubscribe((vertex) => {\n        return {\n            isActive: false,\n            name: vertex.__debugName,\n        };\n    }, fn);\n}\n\nexport function debugGetGraph() {\n    const { vertices, edges } = globalDependencyGraph.debugGetGraph();\n    const labels = new Map<Processable, string>();\n    vertices.forEach((vertex) => {\n        labels.set(vertex, vertex.__debugName);\n    });\n    return { vertices, edges, labels };\n}\n", "import type { ArrayEvent } from '../../common/arrayevent';\nimport { ArrayEventType } from '../../common/arrayevent';\nimport * as log from '../../common/log';\nimport { SlotSizes } from '../../common/slotsizes';\nimport type { Retainable } from '../../model/engine';\nimport { release, retain } from '../../model/engine';\nimport { requestCommit } from '../commit';\nimport type { RenderNodeCommitPhase } from './constants';\n\nexport type NodeEmitter = (event: ArrayEvent<Node>) => void;\n\nexport type ErrorEmitter = (error: Error) => void;\n\nexport interface ParentContext {\n    /**\n     * RenderNode instances send a stream of ArrayEvent<Node> to their parents,\n     * which take responsibility for placing them into the DOM.\n     */\n    nodeEmitter: NodeEmitter;\n    /**\n     * RenderNode instances may emit Error events to their parents in case of\n     * an unrecoverable error in the RenderNode. The parents take\n     * responsibility for handling those Errors.\n     */\n    errorEmitter: ErrorEmitter;\n    xmlNamespace: string;\n}\n\nexport interface RenderNode extends Retainable {\n    clone(\n        props?: {} | undefined,\n        children?: JSX.Node[] | undefined\n    ): RenderNode;\n\n    onMount(): void;\n\n    onUnmount(): void;\n\n    attach(parentContext: ParentContext): void;\n\n    commit(phase: RenderNodeCommitPhase): void;\n\n    detach(): void;\n\n    retain(): void;\n\n    release(): void;\n\n    getDepth(): number;\n\n    setDepth(depth: number): void;\n}\n\ninterface RenderNodeHandlers {\n    /**\n     * Called when the RenderNode is created, before it is attached and mounted\n     */\n    onAlive?: () => void;\n    /**\n     * Called before the RenderNode is destroyed; it may still be attached\n     */\n    onDestroy?: () => void;\n    /**\n     * Called just after the RenderNode is attached to a parent RenderNode -- it may start emitting ArrayEvent<Node> | Error events\n     */\n    onAttach?: (parentContext: ParentContext) => void;\n    /**\n     * Called after the RenderNode has been detached from a parent RenderNode. Any nodes it has emitted have been already removed.\n     */\n    onDetach?: () => void;\n    /**\n     * Called just after the RenderNode is mounted to the DOM (specifically has been attached transitively to a mount() point)\n     */\n    onMount?: () => void;\n    /**\n     * Called just before the RenderNode is mounted to the DOM (specifically has been attached transitively to a mount() point)\n     */\n    onUnmount?: () => void;\n    /**\n     * Called when the RenderNode has received an error event from any child; return true to not pass the event to its parent\n     */\n    onError?: (error: Error) => boolean | void;\n    /**\n     * Called when the RenderNode has received an ArrayEvent<Node> event from any child; return true to not pass the event to its parent\n     */\n    onEvent?: (event: ArrayEvent<Node>) => boolean | void;\n    /**\n     * Called when the RenderNode is committed (all children have already been committed)\n     */\n    onCommit?: (phase: RenderNodeCommitPhase) => void;\n    /**\n     * Called when the RenderNode has received an ArrayEvent<Node> event from a specific child; return true to not pass the event to its parent\n     */\n    onChildEvent?: (\n        child: RenderNode,\n        event: ArrayEvent<Node>\n    ) => boolean | void;\n    /**\n     * Called when the RenderNode is cloned; callers should clone the provided children (if passed to the cloned node) and return a new RenderNode\n     *\n     * If omitted, an exception is thrown if the RenderNode is attempted to be cloned.\n     */\n    clone?: (props?: {}, children?: RenderNode[]) => RenderNode;\n}\n\n/**\n * SingleChildRenderNode: a virtual node in the tree that has exactly one child\n */\nexport class SingleChildRenderNode implements RenderNode, Retainable {\n    private declare handlers: RenderNodeHandlers;\n    private declare parentContext: ParentContext | undefined;\n    private declare _isMounted: boolean;\n    private declare child: RenderNode;\n    private declare liveNodes: number;\n    private declare depth: number;\n\n    constructor(\n        handlers: RenderNodeHandlers,\n        child: RenderNode,\n        debugName?: string\n    ) {\n        this.handlers = handlers;\n        this.child = child;\n        this._isMounted = false;\n        this.parentContext = undefined;\n        this.liveNodes = 0;\n        this.depth = 0;\n\n        this.__debugName = debugName ?? `custom`;\n        this.__refcount = 0;\n    }\n\n    isAttached() {\n        return !!this.parentContext;\n    }\n\n    isMounted() {\n        return this._isMounted;\n    }\n\n    emitEvent(event: ArrayEvent<Node>) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit event when detached'\n        );\n        this.parentContext.nodeEmitter(event);\n    }\n\n    emitError(error: Error) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit error when detached'\n        );\n        this.parentContext.errorEmitter(error);\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        this.handlers.onCommit?.(phase);\n    }\n\n    requestCommit(phase: RenderNodeCommitPhase) {\n        requestCommit(this, phase);\n    }\n\n    clone(props?: {}, children?: RenderNode[]): RenderNode {\n        if (this.handlers.clone) {\n            return this.handlers.clone(props, children);\n        }\n        const clonedChild = this.child.clone();\n        return new SingleChildRenderNode(this.handlers, clonedChild);\n    }\n\n    setChild(child: RenderNode) {\n        const toRemove = this.child;\n        this.child = child;\n        if (this._isMounted) {\n            toRemove.onUnmount();\n        }\n        if (this.parentContext) {\n            if (this.liveNodes > 0) {\n                this.parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: this.liveNodes,\n                });\n            }\n            toRemove.detach();\n        }\n        this.liveNodes = 0;\n        this.disown(toRemove);\n        this.own(this.child);\n        if (this.parentContext) {\n            this.child.attach({\n                nodeEmitter: this.handleEvent,\n                errorEmitter: this.handleError,\n                xmlNamespace: this.parentContext.xmlNamespace,\n            });\n        }\n        if (this._isMounted) {\n            this.child.onMount();\n        }\n    }\n\n    private handleEvent = (event: ArrayEvent<Node>) => {\n        if (event.type === ArrayEventType.SPLICE) {\n            this.liveNodes += (event.items?.length ?? 0) - event.count;\n        }\n        if (!this.handlers.onEvent?.(event)) {\n            log.assert(\n                this.parentContext,\n                'Unexpected event on detached RenderNode'\n            );\n            this.parentContext.nodeEmitter(event);\n        }\n    };\n\n    private handleError = (event: Error) => {\n        if (!this.handlers.onError?.(event)) {\n            if (this.parentContext) {\n                this.parentContext.errorEmitter(event);\n            } else {\n                log.warn('Unhandled error on detached RenderNode', event);\n            }\n        }\n    };\n\n    detach() {\n        log.assert(this.parentContext, 'double detached');\n        this.child.detach();\n        this.parentContext = undefined;\n        this.handlers.onDetach?.();\n    }\n\n    attach(parentContext: ParentContext) {\n        log.assert(!this.parentContext, 'Invariant: double attached');\n        this.parentContext = parentContext;\n        this.child.attach({\n            nodeEmitter: this.handleEvent,\n            errorEmitter: this.handleError,\n            xmlNamespace: this.parentContext.xmlNamespace,\n        });\n        this.handlers.onAttach?.(parentContext);\n    }\n\n    onMount() {\n        this._isMounted = true;\n        this.child.onMount();\n        this.handlers.onMount?.();\n    }\n\n    onUnmount() {\n        this._isMounted = false;\n        this.child.onUnmount();\n        this.handlers.onUnmount?.();\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        this.own(this.child);\n        this.handlers.onAlive?.();\n    }\n    __dead() {\n        this.handlers.onDestroy?.();\n        this.disown(this.child);\n        this.parentContext = undefined;\n    }\n\n    own(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.setDepth(this.depth + 1);\n        child.retain();\n    }\n\n    disown(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.release();\n        child.setDepth(0);\n    }\n\n    getDepth() {\n        return this.depth;\n    }\n\n    setDepth(depth: number) {\n        this.depth = depth;\n    }\n}\n\n/**\n * MultiChildRenderNode: a virtual node in the tree that can have a variable number of children\n */\nexport class MultiChildRenderNode implements RenderNode, Retainable {\n    private declare handlers: RenderNodeHandlers;\n    private declare parentContext: ParentContext | undefined;\n    private declare _isMounted: boolean;\n    private declare slotSizes: SlotSizes<RenderNode>;\n    private declare depth: number;\n    private declare pendingCommit: undefined | Map<RenderNode, number>;\n\n    constructor(\n        handlers: RenderNodeHandlers,\n        children: RenderNode[],\n        debugName?: string\n    ) {\n        this.depth = 0;\n        this.handlers = handlers;\n        this._isMounted = false;\n        this.slotSizes = new SlotSizes(children);\n        this.parentContext = undefined;\n        this.pendingCommit = undefined;\n\n        this.__debugName = debugName ?? `custom`;\n        this.__refcount = 0;\n    }\n\n    isAttached() {\n        return !!this.parentContext;\n    }\n\n    isMounted() {\n        return this._isMounted;\n    }\n\n    emitEvent(event: ArrayEvent<Node>) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit event when detached'\n        );\n        this.parentContext.nodeEmitter(event);\n    }\n\n    emitError(error: Error) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit error when detached'\n        );\n        this.parentContext.errorEmitter(error);\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        this.handlers.onCommit?.(phase);\n    }\n\n    requestCommit(phase: RenderNodeCommitPhase) {\n        requestCommit(this, phase);\n    }\n\n    clone(props?: {}, children?: RenderNode[]): RenderNode {\n        if (this.handlers.clone) {\n            return this.handlers.clone(props, children);\n        }\n        const clonedChildren = this.slotSizes.items.map((child) =>\n            child.clone()\n        );\n        return new MultiChildRenderNode(this.handlers, clonedChildren);\n    }\n\n    sortChildren(from: number, indexes: number[]) {\n        const event = this.slotSizes.sort(from, indexes);\n        this.parentContext?.nodeEmitter(event);\n    }\n\n    moveChildren(from: number, count: number, to: number) {\n        const event = this.slotSizes.move(from, count, to);\n        this.parentContext?.nodeEmitter(event);\n    }\n\n    spliceChildren(index: number, count: number, children: RenderNode[]) {\n        // unmount & detach children before removing from slots (so they may emit their cleanup events)\n        for (let i = index; i < index + count; ++i) {\n            const child = this.slotSizes.items[i];\n            if (this._isMounted) {\n                child.onUnmount();\n            }\n        }\n        const { removed, event } = this.slotSizes.splice(\n            index,\n            count,\n            children\n        );\n        if (this.parentContext && event.count > 0) {\n            this.parentContext.nodeEmitter({\n                type: ArrayEventType.SPLICE,\n                index: event.index,\n                count: event.count,\n                // Note: we do *not* take the responsibility of emitting the new nodes -- the children do that on attach\n            });\n        }\n        for (const child of removed) {\n            if (this.parentContext) {\n                child.detach();\n            }\n            this.disown(child);\n        }\n        for (const child of children) {\n            this.own(child);\n            if (this.parentContext) {\n                child.attach({\n                    nodeEmitter: (event: ArrayEvent<Node>) =>\n                        this.handleChildEvent(child, event),\n                    errorEmitter: this.handleError,\n                    xmlNamespace: this.parentContext.xmlNamespace,\n                });\n            }\n            if (this._isMounted) {\n                child.onMount();\n            }\n        }\n    }\n\n    private handleChildEvent(child: RenderNode, event: ArrayEvent<Node>) {\n        if (!this.handlers.onChildEvent?.(child, event)) {\n            const shifted = this.slotSizes.applyEvent(child, event);\n            this.handleEvent(shifted);\n        }\n    }\n\n    private handleEvent(event: ArrayEvent<Node>) {\n        if (!this.handlers.onEvent?.(event)) {\n            log.assert(\n                this.parentContext,\n                'Unexpected event on detached RenderNode'\n            );\n            this.parentContext.nodeEmitter(event);\n        }\n    }\n\n    private handleError = (event: Error) => {\n        if (!this.handlers.onError?.(event)) {\n            if (this.parentContext) {\n                this.parentContext.errorEmitter(event);\n            } else {\n                log.warn('Unhandled error on detached RenderNode', event);\n            }\n        }\n    };\n\n    detach() {\n        log.assert(this.parentContext, 'double detached');\n        this.slotSizes.clearSlots();\n        for (const child of this.slotSizes.items) {\n            child.detach();\n        }\n        this.parentContext = undefined;\n        this.handlers.onDetach?.();\n    }\n\n    attach(parentContext: ParentContext) {\n        log.assert(!this.parentContext, 'Invariant: double attached');\n        this.parentContext = parentContext;\n        for (const child of this.slotSizes.items) {\n            child.attach({\n                nodeEmitter: (event) => {\n                    this.handleChildEvent(child, event);\n                },\n                errorEmitter: this.handleError,\n                xmlNamespace: this.parentContext.xmlNamespace,\n            });\n        }\n        this.handlers.onAttach?.(parentContext);\n    }\n\n    onMount() {\n        this._isMounted = true;\n        for (const child of this.slotSizes.items) {\n            child.onMount();\n        }\n        this.handlers.onMount?.();\n    }\n\n    onUnmount() {\n        this._isMounted = false;\n        for (const child of this.slotSizes.items) {\n            child.onUnmount();\n        }\n        this.handlers.onUnmount?.();\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        for (const child of this.slotSizes.items) {\n            this.own(child);\n        }\n        this.handlers.onAlive?.();\n    }\n    __dead() {\n        this.handlers.onDestroy?.();\n        for (const child of this.slotSizes.items) {\n            this.disown(child);\n        }\n        this.parentContext = undefined;\n    }\n\n    own(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.setDepth(this.depth + 1);\n        child.retain();\n    }\n\n    disown(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.release();\n        child.setDepth(0);\n    }\n\n    getDepth() {\n        return this.depth;\n    }\n\n    setDepth(depth: number) {\n        this.depth = depth;\n    }\n}\n\n/**\n * Renders nothing\n */\nexport class EmptyRenderNode implements RenderNode {\n    __debugName: string;\n    __refcount: number;\n    constructor() {\n        this.__debugName = '<empty>';\n        this.__refcount = 1; // Intentional: always alive, never dead\n    }\n\n    detach() {}\n    attach() {}\n    onMount() {}\n    onUnmount() {}\n    retain() {}\n    release() {}\n    commit() {}\n    getDepth() {\n        return 0;\n    }\n    setDepth() {}\n    clone(): RenderNode {\n        return emptyRenderNode;\n    }\n    __alive() {}\n    __dead() {}\n}\n\n/**\n * Only need one of nothing\n */\nexport const emptyRenderNode = new EmptyRenderNode();\n\nexport function isRenderNode(obj: any): obj is RenderNode {\n    return (\n        obj &&\n        (obj instanceof SingleChildRenderNode ||\n            obj instanceof MultiChildRenderNode ||\n            obj instanceof EmptyRenderNode)\n    );\n}\n", "import type { RenderNode } from './rendernode';\nimport { emptyRenderNode, MultiChildRenderNode } from './rendernode';\n\n/**\n * Renders an array of render nodes\n */\nexport function ArrayRenderNode(\n    children: RenderNode[],\n    debugName?: string\n): RenderNode {\n    if (children.length === 0) {\n        return emptyRenderNode;\n    }\n    if (children.length === 1) {\n        return children[0];\n    }\n    return new MultiChildRenderNode({}, children, debugName);\n}\n", "import type { Dynamic, DynamicSubscriptionHandler } from '../../common/dyn';\nimport * as log from '../../common/log';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\n/**\n * Renders the result of a dynamic value\n */\nexport function DynamicRenderNode(\n    renderJSXNode: (jsxNode: JSX.Node) => RenderNode,\n    dynamic: Dynamic<any>,\n    debugName?: string\n): RenderNode {\n    let dynamicError: Error | undefined;\n    let dynamicSubscription: (() => void) | undefined;\n    let renderValue: JSX.Node | undefined;\n    let syncSubscription = false;\n\n    const subscribe: DynamicSubscriptionHandler<JSX.Node> = (error, val) => {\n        if (error) {\n            renderNode.setChild(emptyRenderNode);\n            dynamicError = error;\n            if (renderNode.isAttached()) {\n                renderNode.emitError(error);\n            } else {\n                log.warn('Unhandled error on detached DynamicRenderNode', val);\n            }\n        } else if (syncSubscription) {\n            renderNode.setChild(renderJSXNode(val));\n        } else {\n            renderNode.setChild(emptyRenderNode);\n            renderValue = val;\n            renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_RENDER);\n        }\n    };\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                if (dynamicError) {\n                    parentContext.errorEmitter(dynamicError);\n                }\n            },\n            onCommit: (phase) => {\n                if (phase === RenderNodeCommitPhase.COMMIT_RENDER) {\n                    renderNode.setChild(renderJSXNode(renderValue));\n                }\n            },\n            clone: () => {\n                return DynamicRenderNode(renderJSXNode, dynamic, debugName);\n            },\n            onAlive: () => {\n                syncSubscription = true;\n                dynamicSubscription = dynamic.subscribe(subscribe);\n                syncSubscription = false;\n            },\n            onDestroy: () => {\n                dynamicError = undefined;\n                dynamicSubscription?.();\n                dynamicSubscription = undefined;\n            },\n        },\n        emptyRenderNode,\n        debugName ? `DynamicRenderNode(${debugName})` : `DynamicRenderNode`\n    );\n    return renderNode;\n}\n", "import { ArrayEventType } from '../../common/arrayevent';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\n/**\n * Renders a foreign managed DOM node\n */\nexport function ForeignRenderNode(node: Node, debugName?: string): RenderNode {\n    return new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: 0,\n                    items: [node],\n                });\n            },\n            clone: () => {\n                return ForeignRenderNode(node, debugName);\n            },\n        },\n        emptyRenderNode,\n        debugName ?? 'foreign'\n    );\n}\n", "import { ArrayEventType } from '../../common/arrayevent';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\n/**\n * Renders a Text DOM node\n */\nexport function TextRenderNode(str: string, debugName?: string): RenderNode {\n    const textNode = document.createTextNode(str);\n    return new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: 0,\n                    items: [textNode],\n                });\n            },\n            clone: () => {\n                return TextRenderNode(str, debugName);\n            },\n        },\n        emptyRenderNode,\n        DEBUG\n            ? debugName ?? `text(${JSON.stringify(str)})`\n            : debugName ?? 'text'\n    );\n}\n", "import * as log from '../common/log';\nimport { isCustomJSXNode } from './jsx';\nimport { ArrayRenderNode } from './rendernode/arrayrendernode';\nimport { DynamicRenderNode } from './rendernode/dynamicrendernode';\nimport { ForeignRenderNode } from './rendernode/foreignrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\nimport { emptyRenderNode, isRenderNode } from './rendernode/rendernode';\nimport { TextRenderNode } from './rendernode/textrendernode';\n\nexport function renderJSXNode(jsxNode: JSX.Node): RenderNode {\n    if (isRenderNode(jsxNode)) {\n        return jsxNode;\n    }\n    if (isCustomJSXNode(jsxNode)) {\n        return jsxNode.__renderNode(renderJSXNode);\n    }\n    if (jsxNode instanceof Node) {\n        return ForeignRenderNode(jsxNode);\n    }\n    if (Array.isArray(jsxNode)) {\n        return ArrayRenderNode(jsxNode.map((item) => renderJSXNode(item)));\n    }\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        typeof jsxNode === 'boolean'\n    ) {\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'function') {\n        log.warn('Rendering a function as JSX renders to nothing');\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'symbol') {\n        log.warn('Rendering a symbol as JSX renders to nothing');\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'string') {\n        return TextRenderNode(jsxNode);\n    }\n    if (typeof jsxNode === 'number' || typeof jsxNode === 'bigint') {\n        return TextRenderNode(jsxNode.toString());\n    }\n    if (\n        typeof jsxNode === 'object' &&\n        typeof jsxNode.get === 'function' &&\n        typeof jsxNode.subscribe === 'function'\n    ) {\n        return DynamicRenderNode(renderJSXNode, jsxNode);\n    }\n    log.warn('Unexpected JSX node type, rendering nothing', jsxNode);\n    return emptyRenderNode;\n}\n\nexport function renderJSXChildren(\n    children?: JSX.Node | JSX.Node[]\n): RenderNode[] {\n    const childRenderNodes: RenderNode[] = [];\n    if (children) {\n        if (Array.isArray(children) && !isCustomJSXNode(children)) {\n            for (const child of children) {\n                childRenderNodes.push(renderJSXNode(child));\n            }\n        } else {\n            childRenderNodes.push(renderJSXNode(children));\n        }\n    }\n    return childRenderNodes;\n}\n", "import * as log from '../../common/log';\nimport { wrapError } from '../../common/util';\nimport type { Retainable } from '../../model/engine';\nimport { release, retain, trackCreates } from '../../model/engine';\nimport { renderJSXNode } from '../renderjsx';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\nexport interface ComponentLifecycle {\n    onMount: (callback: () => void) => (() => void) | void;\n    onUnmount: (callback: () => void) => void;\n    onDestroy: (callback: () => void) => void;\n    onError: (handler: (e: Error) => JSX.Element | null) => void;\n}\n\nexport type Component<TProps = {}> =\n    | FunctionComponent<TProps>\n    | ClassComponentConstructor<TProps>;\n\n// NOTE: UnusedSymbolForChildrenOmission is present solely for the typechecker to not allow assignment of { children?: JSXNode | JSXNode[] } to TProps if TProps is {}\n// Which allows components to flag type errors when they do not specify a `children` prop, but children are given\ndeclare const UnusedSymbolForChildrenOmission: unique symbol;\nexport type EmptyProps = { [UnusedSymbolForChildrenOmission]?: boolean };\n\nexport type FunctionComponent<TProps = {}> = (\n    props: TProps & EmptyProps,\n    lifecycle: ComponentLifecycle\n) => JSX.Element | null;\n\nexport interface ClassComponentConstructor<TProps> {\n    new (props: TProps): ClassComponent<TProps>;\n}\n\nexport interface ClassComponentInterface {\n    render?(): JSX.Element | null;\n    onMount?(): (() => void) | void;\n    onUnmount?(): void;\n    onDestroy?(): void;\n    onError?(e: Error): JSX.Element | null;\n}\n\nexport class ClassComponent<TProps = EmptyProps>\n    implements ClassComponentInterface\n{\n    declare props: TProps;\n    constructor(props: TProps) {\n        this.props = props;\n    }\n\n    render?(): JSX.Element | null;\n    onMount?(): (() => void) | void;\n    onUnmount?(): void;\n    onDestroy?(): void;\n    onError?(e: Error): JSX.Element | null;\n}\n\nexport function ComponentRenderNode<TProps>(\n    Component: FunctionComponent<TProps>,\n    props: TProps | null | undefined,\n    children: JSX.Node[],\n    debugName?: string\n): RenderNode {\n    let result: undefined | Error | RenderNode;\n    let onMountCallbacks: undefined | (() => (() => void) | void)[];\n    let onUnmountCallbacks: undefined | (() => void)[];\n    let onDestroyCallbacks: undefined | (() => void)[];\n    let owned: Set<Retainable> = new Set();\n    let errorHandler: undefined | ((e: Error) => RenderNode | null);\n\n    function ensureResult() {\n        if (!result) {\n            let callbacksAllowed = true;\n            const lifecycle: ComponentLifecycle = {\n                onMount: (handler: () => (() => void) | void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onMount must be called in component body'\n                    );\n                    if (!onMountCallbacks) onMountCallbacks = [];\n                    onMountCallbacks.push(handler);\n                },\n                onUnmount: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onUnmount must be called in component body'\n                    );\n                    if (!onUnmountCallbacks) onUnmountCallbacks = [];\n                    onUnmountCallbacks.push(handler);\n                },\n                onDestroy: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onDestroy must be called in component body'\n                    );\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(handler);\n                },\n                onError: (handler: (e: Error) => RenderNode | null) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onError must be called in component body'\n                    );\n                    log.assert(!errorHandler, 'onError called multiple times');\n                    errorHandler = handler;\n                },\n            };\n\n            let componentProps: any;\n            if (children.length === 0) {\n                componentProps = props || {};\n            } else if (children.length === 1) {\n                componentProps = props\n                    ? { ...props, children: children[0] }\n                    : { children: children[0] };\n            } else {\n                componentProps = props ? { ...props, children } : { children };\n            }\n            let jsxResult: RenderNode | Error;\n            try {\n                // TODO: I don't think this trackCreates is needed... state should only be alive while used.\n                jsxResult = trackCreates(\n                    owned,\n                    () =>\n                        Component(componentProps, lifecycle) || emptyRenderNode\n                );\n            } catch (e) {\n                const error = wrapError(e, 'Unknown error rendering component');\n                if (errorHandler) {\n                    jsxResult = errorHandler(error) ?? emptyRenderNode;\n                } else {\n                    jsxResult = error;\n                }\n            }\n            callbacksAllowed = false;\n            for (const item of owned) {\n                retain(item);\n            }\n            if (!(jsxResult instanceof Error)) {\n                result = renderJSXNode(jsxResult);\n            } else {\n                result = jsxResult;\n            }\n        }\n        return result;\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAlive: () => {\n                const componentResult = ensureResult();\n                if (componentResult instanceof Error) {\n                    log.warn('Unhandled exception on detached component', {\n                        error: componentResult,\n                        renderNode: renderNode,\n                    });\n                } else {\n                    renderNode.own(componentResult);\n                }\n            },\n            onDestroy: () => {\n                if (result && !(result instanceof Error)) {\n                    renderNode.disown(result);\n                }\n                if (onDestroyCallbacks) {\n                    for (const callback of onDestroyCallbacks) {\n                        callback();\n                    }\n                }\n\n                for (const item of owned) {\n                    release(item);\n                }\n\n                owned = new Set();\n                onMountCallbacks = undefined;\n                onUnmountCallbacks = undefined;\n                onDestroyCallbacks = undefined;\n                result = undefined;\n                errorHandler = undefined;\n            },\n            onAttach: (parentContext) => {\n                if (result instanceof Error) {\n                    parentContext.errorEmitter(result);\n                } else if (result) {\n                    renderNode.setChild(result);\n                }\n            },\n            onDetach: () => {\n                renderNode.setChild(emptyRenderNode);\n            },\n            onError: (error: Error) => {\n                if (errorHandler) {\n                    const handledResult = errorHandler(error);\n                    result = handledResult\n                        ? renderJSXNode(handledResult)\n                        : emptyRenderNode;\n                    renderNode.setChild(result);\n                    return true;\n                }\n            },\n            onMount: () => {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_MOUNT);\n            },\n            onUnmount: () => {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                if (onUnmountCallbacks) {\n                    for (const callback of onUnmountCallbacks) {\n                        callback();\n                    }\n                }\n            },\n            onCommit: (phase) => {\n                if (\n                    phase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n                    onMountCallbacks\n                ) {\n                    for (const callback of onMountCallbacks) {\n                        const maybeOnUnmount = callback();\n                        if (typeof maybeOnUnmount === 'function') {\n                            if (!onUnmountCallbacks) {\n                                onUnmountCallbacks = [];\n                            }\n                            const onUnmount = () => {\n                                maybeOnUnmount();\n                                if (onUnmountCallbacks) {\n                                    const index =\n                                        onUnmountCallbacks.indexOf(onUnmount);\n                                    if (index >= 0) {\n                                        onUnmountCallbacks.splice(index, 1);\n                                    }\n                                }\n                            };\n                            onUnmountCallbacks.push(onUnmount);\n                        }\n                    }\n                }\n            },\n            clone(newProps, newChildren) {\n                return ComponentRenderNode(\n                    Component,\n                    props && newProps\n                        ? { ...props, ...newProps }\n                        : ((newProps || props) as TProps),\n                    newChildren ?? children\n                );\n            },\n        },\n        emptyRenderNode,\n        debugName ?? `component(${Component.name})`\n    );\n    return renderNode;\n}\n", "/**\n * An unchanging, internal sentinel value, used to identify a lack of assignment\n */\nexport const Sentinel = Symbol('sentinel');\nexport type Sentinel = typeof Sentinel;\n", "/*\n * ### Calculations\n *\n * A calculation exists on the directed graph as a single vertex. They only get dirtied via propagation.\n *\n * The calculation abstraction represents a \u201Cpure\u201D function which takes no arguments and should produce the same value\n * if the data it reads is unchanged. Calculations have the following state:\n * - An optional error handler, which provides an alternative value in case of a cycle/error in calculation/processing\n * - An optional equality function, which determines whether or not subsequent results are the same value\n * - The cached value of its result\n * - The items it owns with respect to retaining\n *\n * A calculation may be in an error state, in which any calls to it raise an exception.\n *\n *\n * #### Calculation Caching\n *\n * All calculations have their results cached. A calculation may be invalidated, which discards the cached result if it\n * exists.\n *\n * Additionally, calculations have an equality comparator. By default this comparator is strict reference equality.\n *\n * If a cached calculation is recalculated, if the recalculated result compares equal to the cached result, the newly\n * produced result is discarded and the cached result is kept.\n *\n * When a calculation is called, the calculation is treated as an access with respect to tracking, even if the\n * calculation is in an error state or its result is cached. If the calculation is cached, the cached value is returned.\n * If the calculation is uncached, the underlying function is executed, its result cached, and that value is returned.\n *\n *\n * #### Calculation Error Handling\n *\n * Calculations have an error state, which is initially clear, and an optional error handler which is not set.\n *\n * The optional error handler is a function that takes one parameter, a value which indicates the error was due to a cycle\n * or due to an exception.\n *\n * The error handler is always executed in an \u201Cuntracked\u201D context.\n *\n * When a calculation\u2019s function is executed, all exceptions are caught. If an error handler is present, it is called\n * with a value that indicates the error was due to an exception and the return value of the error handler is used as if\n * it was the return value of the function (including equality comparison of the cached value). On completion of an\n * error handler, the calculation is popped off the global tracking stack, and inbound edge replacement proceeds as\n * normal. This means that only accesses that occur during the execution of the function (not during the execution of\n * the error handler) are tracked in the directed graph.\n *\n * If an exception is caught and there is no error handler present, the error state is set on the calculation so that\n * further calls raise an exception, the calculation is popped off the global tracking stack, inbound edge replacement\n * proceeds as normal, and the caught exception is re-thrown. This means that access that occur during the execution of the\n * function prior to the exception are tracked in the directed graph.\n *\n * The error state is cleared when the calculation is recalculated or when the calculation is invalidated.\n *\n * A calculation in a non-error state may be informed that it participates in a cycle. In this case if there is no error\n * handler the calculation\u2019s cache is cleared and is set to an error state. If there is an error handler, it is called with\n * a value that indicates the error is due to a cycle and the returned value is set to the cache if unequal to the value in\n * cache.\n *\n *\n * #### Calculation Execution\n *\n * When a calculation\u2019s function is being executed, all calls to other calculations (cached or uncached) or fields are\n * tracked. These tracked accesses are added to the directed graph as inbound, \u201Chard\u201D edges: from the item being\n * accessed (either a calculation or a field) and to the calculation performing the access. Each execution replaces all\n * inbound \u201Chard\u201D edges.\n *\n * This tracking of access is shallow. That is to say:\n * * There is a stack of active calculations\n * * When a calculation starts execution it is added pushed on the top of the stack\n * * When a calculation finishes execution (either naturally or via exception) it is popped off the top of the stack\n * * Tracking only impacts the calculation on the top of the stack\n *\n * For example, if a calculation\u2019s function (A) is called, which calls another calculation\u2019s function (B), which accesses a\n * field (C), the resulting hard edges added are:\n * * C -> B\n * * B -> A\n *\n * Sometimes it is desirable to avoid this tracking. In this case a sentinel untracked value can be pushed to the stack of\n * calculations, call a function, and then pop the sentinel off the stack. When accesses occur while this sentinel value is\n * on top of the stack, no tracking is necessary. This is called executing a function in an \u201Cuntracked\u201D context.\n *\n *\n * #### Calculation Behavior\n *\n * This strict set of behaviors around caching, data tracking, and error handling are specifically chosen so that the\n * maintained topological ordering of the directed graph holds the quality that data accesses are placed before all things\n * doing the access. This allows us to intelligently recalculate functions only when their data dependencies have changed.\n * In other words, caching should be \u201Cperfect\u201D with no need to choose specific cache keys that need to be invalidated for\n * classes of calculations, or no need to manually invalidate cached calculations.\n *\n * For example, let\u2019s look at the following function that we\u2019ll call X:\n *\n * ```\n * calc(() => {\n *   if (A()) return B();\n *   if (C()) return D();\n *   return E();\n * })\n * ```\n *\n * There are three possible variations of the directed graph when calling X:\n * 1. If `A()` returns true, then `X` depends on `A` and `B`.\n * 2. If `A()` returns false and `C()` returns true, then `X` depends on `A` and `C` and `D`.\n * 3. If `A()` returns false and `C()` returns false, then `X` depends on `A` and `C` and `E`.\n *\n * This is to say that in case 2, we know for a fact that the return value does not and cannot depend on `B`, so we do not\n * need to recalculate/invalidate `X` if `B` were to change.\n *\n * Similarly in case 2, if `C` were to throw an exception, the effect of this exception depends on the fact that `A` was\n * called and returned a value that was true. If `A` were to change, even though the calculation is in an error state, it\n * could be that `A` now returns a value such that `C` is never called\u2014so we should recalculate `X` if `A` were to change\n * even if `X` is in the error state.\n *\n * In other words, we always know what values depend on the result of calculating `X`, so we know exactly when to\n * recalculate/invalidate `X`.\n *\n * If you are familiar with React hooks, you may recognize that the list of dependencies that React hooks forces you to\n * list explicitly when using `useMemo()` is the set of all possible data accesses, not the set of data accesses that\n * matter for each invocation. This is strikingly different than gooey, which performs the work of automatically tracking\n * only the values that the function uses.\n *\n *\n * #### Calculation Processing\n *\n * While the directed graph is processing, it emits one of three actions: invalidation, recalculation, and cycle.\n * * On an invalidation event, the calculation\u2019s cache is discarded and the error state is cleared. Propagation occurs if\n *   the calculation was cached.\n * * On a recalculation event, the calculation\u2019s underlying function is executed. Propagation occurs if the calculation is\n *   uncached.\n * * On a cycle event\n *     * If there is no error handler for the calculation, the calculation is invalidated and placed in an error state.\n *       Propagation occurs if the calculation was not in an error state.\n *     * If there is an error handler, it is called and the result is handled in the same manner as if it was the result of\n *       a recalculation event. Propagation occurs if the calculation was not cached or the error handler\u2019s return value\n *       does not equal the prior cached value.\n */\n\nimport type { Dynamic, DynamicSubscriptionHandler } from '../common/dyn';\nimport * as log from '../common/log';\nimport { Sentinel } from '../common/sentinel';\nimport { wrapError } from '../common/util';\nimport type { Processable, Retainable } from './engine';\nimport {\n    addHardEdge,\n    addVertex,\n    isProcessable,\n    markCycleInformed,\n    notifyCreate,\n    notifyRead,\n    release,\n    removeHardEdge,\n    removeVertex,\n    retain,\n    trackReads,\n    unmarkDirty,\n    untrackReads,\n} from './engine';\n\nenum CalculationState {\n    READY,\n    CALLING,\n    CACHED,\n    ERROR,\n    DEAD,\n}\n\nconst CalculationSymbol = Symbol('calculation');\n\ntype CalcUnsubscribe = () => void;\n\ntype CalcErrorHandler<T> = (error: Error) => T;\n\nexport class Calculation<T> implements Retainable, Processable, Dynamic<T> {\n    private declare _subscriptions?: Set<DynamicSubscriptionHandler<T>>;\n    private declare _type: typeof CalculationSymbol;\n    private declare _errorHandler?: CalcErrorHandler<T>;\n    private declare _state: CalculationState;\n    private declare _retained?: Set<Retainable | (Processable & Retainable)>;\n    private declare _val?: T;\n    private declare _error?: any;\n    private declare _fn: () => T;\n\n    declare __processable: true;\n    declare __debugName: string;\n    declare __refcount: number;\n\n    get(): T {\n        notifyRead(this);\n\n        const state = this._state;\n        switch (state) {\n            case CalculationState.DEAD:\n                // Note: dead calculations are just plain old functions\n                return this._fn();\n            case CalculationState.CACHED:\n                return this._val as T;\n            case CalculationState.CALLING:\n                this._state = CalculationState.ERROR;\n                this._error = new CycleError(\n                    'Cycle reached: calculation reached itself',\n                    this\n                );\n                throw this._error;\n            case CalculationState.ERROR:\n                if (this._error === Sentinel) {\n                    throw new Error(\n                        'Cycle reached: calculation reached itself'\n                    );\n                } else {\n                    throw new Error(\n                        'Calculation in error state: ' + this._error.message\n                    );\n                }\n                break;\n            case CalculationState.READY: {\n                const calculationReads: Set<Retainable> = new Set();\n                let result: T | Sentinel = Sentinel;\n                let exception: any;\n                this._state = CalculationState.CALLING;\n                try {\n                    result = trackReads(\n                        calculationReads,\n                        () => this._fn(),\n                        this.__debugName\n                    );\n                } catch (e) {\n                    exception = e;\n                }\n\n                if (\n                    (this._state as CalculationState) === CalculationState.DEAD\n                ) {\n                    // It's possible that a cycle which is recalculated releases itself entirely\n                    // In this case we release all of the things retained (automatically, see note XXX:AUTO_RETAIN)\n                    for (const retained of calculationReads) {\n                        release(retained);\n                    }\n                    if (result === Sentinel) throw exception;\n                    return result;\n                }\n\n                // If A calls B, which calls A, and B has an error handler:\n                // B will catch and return the self-cycle error.\n                // In this case, A will mark itself in the ERROR state.\n                if (\n                    // Cast due to TypeScript limitation\n                    (this._state as CalculationState) === CalculationState.ERROR\n                ) {\n                    exception = this._error;\n                }\n\n                let isActiveCycle = false;\n                let isActiveCycleRoot = false;\n                if (exception) {\n                    if (exception instanceof CycleError) {\n                        isActiveCycle = true;\n                        isActiveCycleRoot =\n                            exception.sourceCalculation === this;\n                    }\n                    const errorHandler = this._errorHandler;\n                    if (errorHandler) {\n                        result = untrackReads(\n                            () => errorHandler(exception),\n                            this.__debugName\n                        );\n                    }\n\n                    if (isActiveCycle) {\n                        markCycleInformed(this);\n                    }\n                }\n\n                if (result === Sentinel) {\n                    if ('_val' in this) {\n                        delete this._val;\n                    }\n                    this._error = exception;\n                    this._state = CalculationState.ERROR;\n                } else {\n                    this._val = result;\n                    if ('_error' in this) {\n                        delete this._error;\n                    }\n                    this._state = CalculationState.CACHED;\n                    unmarkDirty(this);\n                }\n\n                if (this._retained) {\n                    for (const priorDependency of this._retained) {\n                        if (\n                            isProcessable(priorDependency) &&\n                            !calculationReads.has(priorDependency)\n                        ) {\n                            removeHardEdge(priorDependency, this);\n                        }\n                        // XXX:AUTO_RETAIN: THIS IS SURPRISING\n                        // We retain all dependencies read when they are first added to a tracked calculation\n                        // So we need to release prior dependencies to keep the refcount stable\n                        // This is a bit gross...\n                        release(priorDependency);\n                    }\n                }\n                for (const dependency of calculationReads) {\n                    if (isProcessable(dependency)) {\n                        if (\n                            !this._retained ||\n                            !this._retained.has(dependency)\n                        ) {\n                            addHardEdge(dependency, this);\n                        }\n                    }\n                }\n                this._retained = calculationReads;\n\n                if (result === Sentinel) {\n                    throw exception;\n                } else if (isActiveCycle && !isActiveCycleRoot) {\n                    throw exception;\n                } else {\n                    return result;\n                }\n            }\n            default:\n                log.assertExhausted(state, 'Calculation in unknown state');\n        }\n    }\n\n    constructor(fn: () => T, debugName?: string) {\n        this.__debugName = debugName ?? 'calc';\n        this.__refcount = 0;\n        this.__processable = true;\n\n        this._type = CalculationSymbol;\n        this._state = CalculationState.DEAD;\n        this._fn = fn;\n    }\n\n    onError(handler: CalcErrorHandler<T>): this {\n        this._errorHandler = handler;\n        return this;\n    }\n\n    _eq(a: T, b: T): boolean {\n        return a === b;\n    }\n\n    setCmp(eq: (a: T, b: T) => boolean): this {\n        this._eq = eq;\n        return this;\n    }\n\n    subscribe(handler: DynamicSubscriptionHandler<T>): CalcUnsubscribe {\n        retain(this);\n        let args: [Error, undefined] | [undefined, T];\n        try {\n            args = [undefined, this.get()];\n        } catch (e) {\n            args = [wrapError(e), undefined];\n        }\n        if (!this._subscriptions) {\n            this._subscriptions = new Set();\n        }\n        this._subscriptions.add(handler);\n        const unsubscribe = () => {\n            this._subscriptions?.delete(handler);\n            release(this);\n        };\n        handler(...args);\n        return unsubscribe;\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        addVertex(this);\n        this._state = CalculationState.READY;\n    }\n\n    __dead() {\n        if (this._retained) {\n            for (const retained of this._retained) {\n                if (isProcessable(retained)) {\n                    removeHardEdge(retained, this);\n                }\n                release(retained);\n            }\n        }\n        delete this._retained;\n        removeVertex(this);\n        this._state = CalculationState.DEAD;\n        delete this._val;\n    }\n\n    __recalculate() {\n        switch (this._state) {\n            case CalculationState.DEAD:\n                log.fail('cannot recalculate dead calculation');\n                break;\n            case CalculationState.CALLING:\n                log.fail('cannot recalculate calculation being tracked');\n                break;\n            case CalculationState.READY:\n            case CalculationState.ERROR:\n            case CalculationState.CACHED: {\n                const priorResult =\n                    '_val' in this ? (this._val as T) : Sentinel;\n                this._state = CalculationState.READY;\n                let newResult: T;\n                try {\n                    newResult = this.get();\n                } catch (e) {\n                    this._state = CalculationState.ERROR;\n                    this._error = e;\n                    if (this._subscriptions) {\n                        const error = wrapError(\n                            e,\n                            'Unknown error in calculation'\n                        );\n                        for (const subscription of this._subscriptions) {\n                            subscription(error, undefined);\n                        }\n                    }\n                    return true; // Errors always propagate\n                }\n                if (\n                    priorResult !== Sentinel &&\n                    this._eq(priorResult, newResult)\n                ) {\n                    this._val = priorResult;\n                    return false;\n                }\n                if (this._subscriptions) {\n                    for (const subscription of this._subscriptions) {\n                        subscription(undefined, newResult);\n                    }\n                }\n                return true;\n            }\n            default:\n                log.assertExhausted(\n                    this._state,\n                    'Calculation in unknown state'\n                );\n        }\n    }\n\n    __invalidate() {\n        switch (this._state) {\n            case CalculationState.DEAD:\n                log.fail('cannot invalidate dead calculation');\n                break;\n            case CalculationState.CALLING:\n                log.fail('cannot invalidate calculation being tracked');\n                break;\n            case CalculationState.READY:\n                return false;\n            case CalculationState.ERROR:\n                this._state = CalculationState.READY;\n                return false;\n            case CalculationState.CACHED:\n                this._state = CalculationState.READY;\n                return true;\n            default:\n                log.assertExhausted(\n                    this._state,\n                    'Calculation in unknown state'\n                );\n        }\n    }\n\n    __cycle() {\n        switch (this._state) {\n            case CalculationState.DEAD:\n                log.fail('cannot trigger cycle on dead calculation');\n                break;\n            case CalculationState.CALLING:\n                log.fail('cannot trigger cycle on calculation being tracked');\n                break;\n            case CalculationState.ERROR:\n            case CalculationState.CACHED:\n            case CalculationState.READY: {\n                const priorResult =\n                    '_val' in this ? (this._val as T) : Sentinel;\n                this._state = CalculationState.READY;\n                const errorHandler = this._errorHandler;\n                if (errorHandler) {\n                    this._val = untrackReads(\n                        () =>\n                            errorHandler(\n                                new CycleError(\n                                    'Calculation is part of a cycle',\n                                    this\n                                )\n                            ),\n                        this.__debugName\n                    );\n                    this._state = CalculationState.CACHED;\n                    unmarkDirty(this);\n                } else {\n                    this._state = CalculationState.ERROR;\n                    this._error = Sentinel;\n                    if (this._subscriptions) {\n                        for (const subscription of this._subscriptions) {\n                            subscription(\n                                new CycleError(\n                                    'Calculation is part of a cycle',\n                                    this\n                                ),\n                                undefined\n                            );\n                        }\n                    }\n                    return true; // Errors always propagate\n                }\n                if (\n                    priorResult !== Sentinel &&\n                    this._eq(priorResult, this._val)\n                ) {\n                    this._val = priorResult;\n                    return false;\n                }\n                if (this._subscriptions) {\n                    for (const subscription of this._subscriptions) {\n                        subscription(undefined, this._val);\n                    }\n                }\n                return true;\n            }\n            default:\n                log.assertExhausted(\n                    this._state,\n                    'Calculation in unknown state'\n                );\n        }\n    }\n\n    map<V>(fn: (val: T) => V): Calculation<V> {\n        return calc(() => fn(this.get()));\n    }\n}\n\nexport class CycleError extends Error {\n    declare sourceCalculation: Calculation<any>;\n\n    constructor(msg: string, sourceCalculation: Calculation<any>) {\n        super(msg);\n        this.sourceCalculation = sourceCalculation;\n    }\n}\n\nexport function calc<T>(fn: () => T, debugName?: string) {\n    const calculation = new Calculation(fn, debugName);\n    notifyCreate(calculation);\n    return calculation;\n}\n", "import { calc } from '../model/calc';\nimport type { Calculation } from '../model/calc';\nimport { noop } from './util';\n\nexport interface DynamicNonErrorSubscriptionHandler<T> {\n    (error: undefined, val: T): void;\n}\nexport interface DynamicSubscriptionHandler<T> {\n    (\n        ...args: [error: Error, val: undefined] | [error: undefined, val: T]\n    ): void;\n}\n\nexport interface Dynamic<out T> {\n    get: () => T;\n    subscribe: (fn: DynamicSubscriptionHandler<T>) => () => void;\n}\n\nexport interface DynamicMut<in out T> extends Dynamic<T> {\n    set: (val: T) => void;\n}\n\nexport type Dyn<T> = T | Dynamic<T>;\n\nexport type DynMut<T> = T | DynamicMut<T>;\n\nexport function dynGet<TVal>(wrapper: Dyn<TVal>): TVal {\n    if (isDynamic(wrapper)) {\n        return wrapper.get();\n    }\n    return wrapper;\n}\n\nexport function dynSet<TVal>(\n    wrapper: Dyn<TVal> | DynMut<TVal>,\n    value: TVal\n): boolean {\n    if (isDynamicMut(wrapper)) {\n        wrapper.set(value);\n        return true;\n    }\n    return false;\n}\n\nexport function dynSubscribe<TVal>(\n    wrapper: Dyn<TVal>,\n    callback: DynamicSubscriptionHandler<TVal>\n): () => void {\n    if (isDynamic(wrapper)) {\n        return wrapper.subscribe(callback);\n    }\n    callback(undefined, wrapper);\n    return noop;\n}\n\nexport function isDynamic<TVal>(val: Dyn<TVal>): val is Dynamic<TVal> {\n    return !!(\n        val &&\n        typeof val === 'object' &&\n        'get' in val &&\n        'subscribe' in val &&\n        typeof val.get === 'function' &&\n        typeof val.subscribe === 'function'\n    );\n}\n\nexport function isDynamicMut<TVal>(val: DynMut<TVal>): val is DynamicMut<TVal> {\n    return isDynamic(val) && 'set' in val && typeof val.set === 'function';\n}\n\nexport function dynMap<T, V>(val: Dyn<T>, fn: (val: T) => V): Calculation<V> {\n    return calc(() => fn(dynGet(val)));\n}\n", "export const getWebComponentTagConstructors = () =>\n    ({\n        a: HTMLAnchorElement,\n        abbr: HTMLElement,\n        address: HTMLElement,\n        area: HTMLAreaElement,\n        article: HTMLElement,\n        aside: HTMLElement,\n        audio: HTMLAudioElement,\n        b: HTMLElement,\n        base: HTMLBaseElement,\n        bdi: HTMLElement,\n        bdo: HTMLElement,\n        blockquote: HTMLQuoteElement,\n        body: HTMLBodyElement,\n        br: HTMLBRElement,\n        button: HTMLButtonElement,\n        canvas: HTMLCanvasElement,\n        caption: HTMLTableCaptionElement,\n        cite: HTMLElement,\n        code: HTMLElement,\n        col: HTMLTableColElement,\n        colgroup: HTMLTableColElement,\n        data: HTMLDataElement,\n        datalist: HTMLDataListElement,\n        dd: HTMLElement,\n        del: HTMLModElement,\n        details: HTMLDetailsElement,\n        dfn: HTMLElement,\n        dialog: HTMLDialogElement,\n        div: HTMLDivElement,\n        dl: HTMLDListElement,\n        dt: HTMLElement,\n        em: HTMLElement,\n        embed: HTMLEmbedElement,\n        fieldset: HTMLFieldSetElement,\n        figcaption: HTMLElement,\n        figure: HTMLElement,\n        footer: HTMLElement,\n        form: HTMLFormElement,\n        h1: HTMLHeadingElement,\n        h2: HTMLHeadingElement,\n        h3: HTMLHeadingElement,\n        h4: HTMLHeadingElement,\n        h5: HTMLHeadingElement,\n        h6: HTMLHeadingElement,\n        head: HTMLHeadElement,\n        header: HTMLElement,\n        hgroup: HTMLElement,\n        hr: HTMLHRElement,\n        html: HTMLHtmlElement,\n        i: HTMLElement,\n        iframe: HTMLIFrameElement,\n        img: HTMLImageElement,\n        input: HTMLInputElement,\n        ins: HTMLModElement,\n        kbd: HTMLElement,\n        label: HTMLLabelElement,\n        legend: HTMLLegendElement,\n        li: HTMLLIElement,\n        link: HTMLLinkElement,\n        main: HTMLElement,\n        map: HTMLMapElement,\n        mark: HTMLElement,\n        menu: HTMLMenuElement,\n        meta: HTMLMetaElement,\n        meter: HTMLMeterElement,\n        nav: HTMLElement,\n        noscript: HTMLElement,\n        object: HTMLObjectElement,\n        ol: HTMLOListElement,\n        optgroup: HTMLOptGroupElement,\n        option: HTMLOptionElement,\n        output: HTMLOutputElement,\n        p: HTMLParagraphElement,\n        picture: HTMLPictureElement,\n        pre: HTMLPreElement,\n        progress: HTMLProgressElement,\n        q: HTMLQuoteElement,\n        rp: HTMLElement,\n        rt: HTMLElement,\n        ruby: HTMLElement,\n        s: HTMLElement,\n        samp: HTMLElement,\n        script: HTMLScriptElement,\n        section: HTMLElement,\n        select: HTMLSelectElement,\n        slot: HTMLSlotElement,\n        small: HTMLElement,\n        source: HTMLSourceElement,\n        span: HTMLSpanElement,\n        strong: HTMLElement,\n        style: HTMLStyleElement,\n        sub: HTMLElement,\n        summary: HTMLElement,\n        sup: HTMLElement,\n        table: HTMLTableElement,\n        tbody: HTMLTableSectionElement,\n        td: HTMLTableCellElement,\n        template: HTMLTemplateElement,\n        textarea: HTMLTextAreaElement,\n        tfoot: HTMLTableSectionElement,\n        th: HTMLTableCellElement,\n        thead: HTMLTableSectionElement,\n        time: HTMLTimeElement,\n        title: HTMLTitleElement,\n        tr: HTMLTableRowElement,\n        track: HTMLTrackElement,\n        u: HTMLElement,\n        ul: HTMLUListElement,\n        var: HTMLElement,\n        video: HTMLVideoElement,\n        wbr: HTMLElement,\n    }) as const;\n\nexport type WebComponentShadowSupportedExtends =\n    | undefined\n    | 'article'\n    | 'aside'\n    | 'blockquote'\n    | 'body'\n    | 'div'\n    | 'footer'\n    | 'h1'\n    | 'h2'\n    | 'h3'\n    | 'h4'\n    | 'h5'\n    | 'h6'\n    | 'header'\n    | 'main'\n    | 'nav'\n    | 'p'\n    | 'section'\n    | 'span';\n\n// List per https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals\nexport type WebComponentInternalsKey =\n    | 'ariaAtomic'\n    | 'ariaAutoComplete'\n    | 'ariaBusy'\n    | 'ariaChecked'\n    | 'ariaColCount'\n    | 'ariaColIndex'\n    | 'ariaColSpan'\n    | 'ariaCurrent'\n    | 'ariaDescription'\n    | 'ariaDisabled'\n    | 'ariaExpanded'\n    | 'ariaHasPopup'\n    | 'ariaHidden'\n    | 'ariaKeyShortcuts'\n    | 'ariaLabel'\n    | 'ariaLevel'\n    | 'ariaLive'\n    | 'ariaModal'\n    | 'ariaMultiLine'\n    | 'ariaMultiSelectable'\n    | 'ariaOrientation'\n    | 'ariaPlaceholder'\n    | 'ariaPosInSet'\n    | 'ariaPressed'\n    | 'ariaReadOnly'\n    | 'ariaRequired'\n    | 'ariaRoleDescription'\n    | 'ariaRowCount'\n    | 'ariaRowIndex'\n    | 'ariaRowSpan'\n    | 'ariaSelected'\n    | 'ariaSetSize'\n    | 'ariaSort'\n    | 'ariaValueMax'\n    | 'ariaValueMin'\n    | 'ariaValueNow'\n    | 'ariaValueText'\n    | 'role'\n    // Non-standard properties\n    | 'ariaRelevant'\n    // Experimental properties\n    | 'ariaRowIndexText'\n    | 'ariaColIndexText';\n", "export const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const ELEMENT_NAMESPACE_GUESS: Record<string, string | undefined> = {\n    // SVG Elements per https://developer.mozilla.org/en-US/docs/Web/SVG/Element\n    //'a': SVG_NAMESPACE,\n    animate: SVG_NAMESPACE,\n    animateMotion: SVG_NAMESPACE,\n    animateTransform: SVG_NAMESPACE,\n    circle: SVG_NAMESPACE,\n    clipPath: SVG_NAMESPACE,\n    defs: SVG_NAMESPACE,\n    desc: SVG_NAMESPACE,\n    discard: SVG_NAMESPACE,\n    ellipse: SVG_NAMESPACE,\n    feBlend: SVG_NAMESPACE,\n    feColorMatrix: SVG_NAMESPACE,\n    feComponentTransfer: SVG_NAMESPACE,\n    feComposite: SVG_NAMESPACE,\n    feConvolveMatrix: SVG_NAMESPACE,\n    feDiffuseLighting: SVG_NAMESPACE,\n    feDisplacementMap: SVG_NAMESPACE,\n    feDistantLight: SVG_NAMESPACE,\n    feDropShadow: SVG_NAMESPACE,\n    feFlood: SVG_NAMESPACE,\n    feFuncA: SVG_NAMESPACE,\n    feFuncB: SVG_NAMESPACE,\n    feFuncG: SVG_NAMESPACE,\n    feFuncR: SVG_NAMESPACE,\n    feGaussianBlur: SVG_NAMESPACE,\n    feImage: SVG_NAMESPACE,\n    feMerge: SVG_NAMESPACE,\n    feMergeNode: SVG_NAMESPACE,\n    feMorphology: SVG_NAMESPACE,\n    feOffset: SVG_NAMESPACE,\n    fePointLight: SVG_NAMESPACE,\n    feSpecularLighting: SVG_NAMESPACE,\n    feSpotLight: SVG_NAMESPACE,\n    feTile: SVG_NAMESPACE,\n    feTurbulence: SVG_NAMESPACE,\n    filter: SVG_NAMESPACE,\n    foreignObject: SVG_NAMESPACE,\n    g: SVG_NAMESPACE,\n    hatch: SVG_NAMESPACE,\n    hatchpath: SVG_NAMESPACE,\n    image: SVG_NAMESPACE,\n    line: SVG_NAMESPACE,\n    linearGradient: SVG_NAMESPACE,\n    marker: SVG_NAMESPACE,\n    mask: SVG_NAMESPACE,\n    metadata: SVG_NAMESPACE,\n    mpath: SVG_NAMESPACE,\n    path: SVG_NAMESPACE,\n    pattern: SVG_NAMESPACE,\n    polygon: SVG_NAMESPACE,\n    polyline: SVG_NAMESPACE,\n    radialGradient: SVG_NAMESPACE,\n    rect: SVG_NAMESPACE,\n    //'script': SVG_NAMESPACE,\n    set: SVG_NAMESPACE,\n    stop: SVG_NAMESPACE,\n    //'style': SVG_NAMESPACE,\n    svg: SVG_NAMESPACE,\n    switch: SVG_NAMESPACE,\n    symbol: SVG_NAMESPACE,\n    text: SVG_NAMESPACE,\n    textPath: SVG_NAMESPACE,\n    //'title': SVG_NAMESPACE,\n    tspan: SVG_NAMESPACE,\n    use: SVG_NAMESPACE,\n    view: SVG_NAMESPACE,\n\n    // MATHML Elements per https://developer.mozilla.org/en-US/docs/Web/MathML/Element\n    math: MATHML_NAMESPACE,\n    maction: MATHML_NAMESPACE,\n    annotation: MATHML_NAMESPACE,\n    'annotation-xml': MATHML_NAMESPACE,\n    menclose: MATHML_NAMESPACE,\n    merror: MATHML_NAMESPACE,\n    mfenced: MATHML_NAMESPACE,\n    mfrac: MATHML_NAMESPACE,\n    mi: MATHML_NAMESPACE,\n    mmultiscripts: MATHML_NAMESPACE,\n    mn: MATHML_NAMESPACE,\n    none: MATHML_NAMESPACE,\n    mo: MATHML_NAMESPACE,\n    mover: MATHML_NAMESPACE,\n    mpadded: MATHML_NAMESPACE,\n    mphantom: MATHML_NAMESPACE,\n    mprescripts: MATHML_NAMESPACE,\n    mroot: MATHML_NAMESPACE,\n    mrow: MATHML_NAMESPACE,\n    ms: MATHML_NAMESPACE,\n    semantics: MATHML_NAMESPACE,\n    mspace: MATHML_NAMESPACE,\n    msqrt: MATHML_NAMESPACE,\n    mstyle: MATHML_NAMESPACE,\n    msub: MATHML_NAMESPACE,\n    msup: MATHML_NAMESPACE,\n    msubsup: MATHML_NAMESPACE,\n    mtable: MATHML_NAMESPACE,\n    mtd: MATHML_NAMESPACE,\n    mtext: MATHML_NAMESPACE,\n    mtr: MATHML_NAMESPACE,\n    munder: MATHML_NAMESPACE,\n    munderover: MATHML_NAMESPACE,\n};\n\nexport const elementNamespaceTransitionMap: Record<\n    string,\n    Record<string, { node: string; children: string } | undefined> | undefined\n> = {\n    [HTML_NAMESPACE]: {\n        svg: {\n            node: SVG_NAMESPACE,\n            children: SVG_NAMESPACE,\n        },\n        math: {\n            node: MATHML_NAMESPACE,\n            children: MATHML_NAMESPACE,\n        },\n    },\n    [SVG_NAMESPACE]: {\n        foreignObject: {\n            node: SVG_NAMESPACE,\n            children: HTML_NAMESPACE,\n        },\n    },\n} as const;\n", "/**\n * A ref object that can be passed to native elements.\n */\nexport class Ref<in out T> {\n    declare current: T;\n    constructor(current: T) {\n        this.current = current;\n    }\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val: T): Ref<T>;\nexport function ref<T>(val?: T): Ref<T | undefined>;\nexport function ref<T>(val?: T): Ref<T | undefined> {\n    return new Ref(val);\n}\n\n/**\n * A standard ref callback\n */\nexport type RefCallback<T> = (val: T | undefined) => void;\n\n/**\n * Ref types may be passed as the ref prop to intrinsic elements to obtain a\n * reference to the underlying Element\n */\nexport type RefObjectOrCallback<T> = Ref<T> | RefCallback<T>;\n", "import type { ArrayEvent } from '../../common/arrayevent';\nimport { applyArrayEvent, ArrayEventType } from '../../common/arrayevent';\nimport * as log from '../../common/log';\nimport type { RefObjectOrCallback } from '../ref';\nimport { Ref } from '../ref';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { SingleChildRenderNode } from './rendernode';\n\n// A shared document fragment; NOTE: always clear after use\nlet sharedFragment: DocumentFragment | undefined;\nfunction getFragment() {\n    if (!sharedFragment) {\n        sharedFragment = document.createDocumentFragment();\n    }\n    return sharedFragment;\n}\n\nexport function PortalRenderNode(\n    element: Element | ShadowRoot,\n    childrenRenderNode: RenderNode,\n    refProp:\n        | RefObjectOrCallback<Element | ShadowRoot | undefined>\n        | null\n        | undefined,\n    debugName?: string\n) {\n    let committedNodes: Node[] = [];\n    let liveNodes: Node[] = [];\n    let liveNodeSet: Set<Node> = new Set();\n    let deadNodeSet: Set<Node> = new Set();\n\n    function insertBefore(nodes: Node[], targetIndex: number) {\n        let toInsert: Node | undefined;\n        if (nodes.length === 1) {\n            toInsert = nodes[0];\n            liveNodeSet.add(nodes[0]);\n            committedNodes.splice(targetIndex, 0, toInsert);\n        } else if (nodes.length > 1) {\n            const fragment = getFragment();\n            for (const node of nodes) {\n                liveNodeSet.add(node);\n                fragment.appendChild(node);\n            }\n            committedNodes.splice(targetIndex, 0, ...nodes);\n            toInsert = fragment;\n        }\n        if (toInsert) {\n            element.insertBefore(\n                toInsert,\n                element.childNodes[targetIndex] || null\n            );\n        }\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onEvent: (event: ArrayEvent<Node>) => {\n                const removed = applyArrayEvent(liveNodes, event);\n                for (const toRemove of removed) {\n                    if (liveNodeSet.has(toRemove)) {\n                        deadNodeSet.add(toRemove);\n                    }\n                }\n                const isDelete =\n                    event.type !== ArrayEventType.SPLICE || event.count > 0;\n                const isInsert =\n                    event.type !== ArrayEventType.SPLICE || event.items?.length;\n                if (isDelete) {\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_DELETE\n                    );\n                }\n                if (isInsert) {\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_INSERT\n                    );\n                }\n                return true;\n            },\n            onMount: () => {\n                if (refProp) {\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                }\n            },\n            onUnmount: () => {\n                if (refProp) {\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            onCommit: (phase: RenderNodeCommitPhase) => {\n                if (phase === RenderNodeCommitPhase.COMMIT_UNMOUNT && refProp) {\n                    if (refProp instanceof Ref) {\n                        refProp.current = undefined;\n                    } else if (typeof refProp === 'function') {\n                        refProp(undefined);\n                    }\n                }\n                if (\n                    phase === RenderNodeCommitPhase.COMMIT_DELETE &&\n                    deadNodeSet.size > 0\n                ) {\n                    if (deadNodeSet.size === liveNodeSet.size) {\n                        element.replaceChildren();\n                        liveNodeSet.clear();\n                        committedNodes = [];\n                    } else {\n                        for (const toRemove of deadNodeSet) {\n                            liveNodeSet.delete(toRemove);\n                            element.removeChild(toRemove);\n                        }\n                        committedNodes = committedNodes.filter(\n                            (node) => !deadNodeSet.has(node)\n                        );\n                    }\n                    deadNodeSet.clear();\n                }\n                if (\n                    phase === RenderNodeCommitPhase.COMMIT_INSERT &&\n                    liveNodes.length > 0\n                ) {\n                    // At this point, we've removed all the nodes from element and committedNodes\n                    // And need to insert nodes in liveNodes in order to committedNodes\n                    //\n                    // Scan through liveNodes, if we hit the end corresponding missing node  and liveNodes\n                    let liveIndex = 0;\n                    while (liveIndex < liveNodes.length) {\n                        if (liveIndex >= committedNodes.length) {\n                            // We're at the end of the committed set, insert the remaining liveNodes at the end\n                            insertBefore(liveNodes.slice(liveIndex), liveIndex);\n                            break;\n                        }\n                        if (\n                            liveNodes[liveIndex] !== committedNodes[liveIndex]\n                        ) {\n                            let checkIndex = liveIndex + 1;\n                            while (\n                                checkIndex < liveNodes.length &&\n                                checkIndex < committedNodes.length &&\n                                liveNodes[checkIndex] !==\n                                    committedNodes[liveIndex]\n                            ) {\n                                checkIndex++;\n                            }\n                            // [liveIndex...checkIndex] need to be inserted before committedNodes[liveIndex]\n                            insertBefore(\n                                liveNodes.slice(liveIndex, checkIndex),\n                                liveIndex\n                            );\n                            liveIndex = checkIndex;\n                            continue;\n                        }\n                        liveIndex++;\n                    }\n                }\n                if (phase === RenderNodeCommitPhase.COMMIT_MOUNT && refProp) {\n                    if (refProp instanceof Ref) {\n                        refProp.current = element;\n                    } else if (typeof refProp === 'function') {\n                        refProp(element);\n                    }\n                }\n            },\n            clone(): RenderNode {\n                log.assert(\n                    false,\n                    \"Attempted to clone a PortalRenderNode -- this operation doesn't make sense\"\n                );\n            },\n            onDestroy: () => {\n                committedNodes = [];\n                liveNodes = [];\n                liveNodeSet = new Set();\n                deadNodeSet = new Set();\n            },\n        },\n        childrenRenderNode,\n        `mount(${\n            element instanceof Element\n                ? element.tagName\n                : `shadow(${element.host.tagName})`\n        })`\n    );\n    return renderNode;\n}\n", "import type { ArrayEvent } from '../../common/arrayevent';\nimport { ArrayEventType } from '../../common/arrayevent';\nimport type { Dyn } from '../../common/dyn';\nimport { dynGet, dynSubscribe, isDynamic } from '../../common/dyn';\nimport * as log from '../../common/log';\nimport { flush } from '../../model/engine';\nimport { assignProp, setAttribute } from '../jsx';\nimport { getWebComponentTagConstructors } from '../webcomponents';\nimport {\n    ELEMENT_NAMESPACE_GUESS,\n    elementNamespaceTransitionMap,\n    HTML_NAMESPACE,\n} from '../xmlnamespace';\nimport { ArrayRenderNode } from './arrayrendernode';\nimport { PortalRenderNode } from './portalrendernode';\nimport type { ParentContext, RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\nconst EventProps = [\n    { prefix: 'on:', param: false },\n    { prefix: 'oncapture:', param: true },\n    { prefix: 'onpassive:', param: { passive: true } },\n] as const;\n\n/**\n * Renders an intrinsic DOM node\n */\nexport function IntrinsicRenderNode(\n    tagName: string,\n    props: Record<string, any> | undefined,\n    childRenderNode: RenderNode,\n    debugName?: string\n): RenderNode {\n    let boundAttributes: undefined | Map<string, Dyn<unknown>>;\n    let subscriptions: undefined | Set<() => void>;\n    let element: undefined | Element;\n    let elementXmlNamespace: undefined | string;\n    let portalRenderNode: undefined | RenderNode;\n    let detachedError: undefined | Error;\n\n    function handleEvent(event: ArrayEvent<Node>) {\n        log.assert(\n            false,\n            'unexpected event in IntrinsicRenderNode from PortalRenderNode'\n        );\n    }\n\n    function handleError(error: Error) {\n        if (renderNode.isAttached()) {\n            // Pass up errors while attached\n            renderNode.emitError(error);\n        } else {\n            // We are capable of handling errors while detached\n            log.warn(\n                'Unhandled error on detached IntrinsicRenderNode',\n                debugName,\n                error\n            );\n            detachedError = error;\n            return true;\n        }\n    }\n\n    function ensureElement(\n        parentContext: ParentContext,\n        xmlNamespace: string,\n        childXmlNamespace: string\n    ) {\n        if (!element || xmlNamespace !== elementXmlNamespace) {\n            elementXmlNamespace = xmlNamespace;\n            element = createElement(xmlNamespace);\n\n            if (portalRenderNode) {\n                if (renderNode.isMounted()) {\n                    portalRenderNode.onUnmount();\n                }\n                portalRenderNode.detach();\n                renderNode.disown(portalRenderNode);\n            }\n            portalRenderNode = PortalRenderNode(\n                element,\n                childRenderNode,\n                props?.ref\n            );\n            renderNode.own(portalRenderNode);\n            portalRenderNode.attach({\n                nodeEmitter: handleEvent,\n                errorEmitter: handleError,\n                xmlNamespace: childXmlNamespace,\n            });\n            if (renderNode.isMounted()) {\n                portalRenderNode.onMount();\n            }\n        }\n        return element;\n    }\n\n    function createElement(xmlNamespace: string) {\n        let element: Element;\n        if (\n            typeof props?.is === 'string' &&\n            tagName in getWebComponentTagConstructors()\n        ) {\n            element = document.createElement(tagName, {\n                is: props.is,\n            });\n        } else {\n            element = document.createElementNS(xmlNamespace, tagName);\n        }\n        if (props) {\n            for (const [prop, val] of Object.entries(props)) {\n                if (prop === 'ref') continue; // specially handled by PortalRenderNode\n                if (prop === 'is') continue; // specially handled above\n                if (\n                    EventProps.some(({ prefix, param }) => {\n                        if (prop.startsWith(prefix)) {\n                            if (val) {\n                                element.addEventListener(\n                                    prop.slice(prefix.length),\n                                    (e) => {\n                                        val(e, element);\n                                        flush(); // TODO: this is probably not necessary, and may even lead to surprising behavior (read calc A, trigger event, read calc B -> both reads differ!). Consider not flushing after events are triggered.\n                                    },\n                                    param\n                                );\n                            }\n                            return true;\n                        }\n                        return false;\n                    })\n                ) {\n                    continue;\n                }\n                if (isDynamic(val)) {\n                    if (!boundAttributes) {\n                        boundAttributes = new Map();\n                    }\n                    boundAttributes.set(prop, val);\n                } else {\n                    setProp(element, prop, dynGet(val));\n                }\n            }\n            if (boundAttributes) {\n                if (!subscriptions) {\n                    subscriptions = new Set();\n                }\n                for (const [prop, boundAttr] of boundAttributes.entries()) {\n                    subscriptions.add(\n                        dynSubscribe(boundAttr, (error, updatedVal) => {\n                            if (error) {\n                                log.error('Unhandled error in bound prop', {\n                                    prop,\n                                    element,\n                                    error: updatedVal,\n                                });\n                            } else {\n                                setProp(element, prop, updatedVal);\n                            }\n                        })\n                    );\n                    const currentVal = dynGet(boundAttr);\n                    setProp(element, prop, currentVal);\n                }\n            }\n        }\n        return element;\n    }\n\n    function setProp(element: Element, prop: string, val: unknown) {\n        if (prop.startsWith('prop:')) {\n            const propName = prop.slice(5);\n            (element as any)[propName] = val;\n            return;\n        }\n\n        if (prop.startsWith('attr:')) {\n            const attrName = prop.slice(5);\n            setAttribute(element, attrName, val);\n            return;\n        }\n\n        if (\n            (element instanceof HTMLElement || element instanceof SVGElement) &&\n            (prop.startsWith('cssprop:') || prop.startsWith('style:'))\n        ) {\n            const attrName = prop.startsWith('cssprop:')\n                ? '--' + prop.slice(8)\n                : prop.slice(6);\n            if (val === undefined || val === null || val === false) {\n                element.style.removeProperty(attrName);\n            } else if (typeof val === 'string') {\n                element.style.setProperty(attrName, val);\n            } else if (typeof val === 'number' || typeof val === 'bigint') {\n                element.style.setProperty(attrName, val.toString());\n            }\n            return;\n        }\n\n        if (prop.startsWith('style:')) {\n            const attrName = prop.slice(6);\n            setAttribute(element, attrName, val);\n            return;\n        }\n\n        assignProp(element, prop, val);\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                if (detachedError) {\n                    parentContext.errorEmitter(detachedError);\n                    return;\n                }\n                const namespaceTransition =\n                    elementNamespaceTransitionMap[parentContext.xmlNamespace]?.[\n                        tagName\n                    ];\n                const xmlNamespace =\n                    namespaceTransition?.node ?? parentContext.xmlNamespace;\n                const childXmlNamespace =\n                    namespaceTransition?.children ?? parentContext.xmlNamespace;\n\n                element = ensureElement(\n                    parentContext,\n                    xmlNamespace,\n                    childXmlNamespace\n                );\n\n                parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: 0,\n                    items: [element],\n                });\n            },\n            onDetach: () => {},\n            onMount: () => {\n                portalRenderNode?.onMount();\n            },\n            onUnmount: () => {\n                portalRenderNode?.onUnmount();\n            },\n            clone: (adjustedProps?: {}, newChildren?: RenderNode[]) => {\n                return IntrinsicRenderNode(\n                    tagName,\n                    adjustedProps ? { ...props, ...adjustedProps } : props,\n                    newChildren\n                        ? ArrayRenderNode(newChildren ?? [])\n                        : childRenderNode.clone()\n                );\n            },\n            onAlive: () => {\n                const xmlNamespaceGuess =\n                    ELEMENT_NAMESPACE_GUESS[tagName] ?? HTML_NAMESPACE;\n                const childXmlNamespaceGuess =\n                    elementNamespaceTransitionMap[xmlNamespaceGuess]?.[tagName]\n                        ?.children ?? xmlNamespaceGuess;\n                element = ensureElement(\n                    {\n                        nodeEmitter: (nodeEvent) => {\n                            log.fail(\n                                'IntrinsicRenderNode got unexpected node event',\n                                nodeEvent\n                            );\n                        },\n                        errorEmitter: (err) => {\n                            log.fail(\n                                'IntrinsicRenderNode got unexpected error event',\n                                err\n                            );\n                        },\n                        xmlNamespace: xmlNamespaceGuess,\n                    },\n                    xmlNamespaceGuess,\n                    childXmlNamespaceGuess\n                );\n            },\n            onDestroy: () => {\n                boundAttributes = undefined;\n                if (subscriptions) {\n                    for (const unsubscribe of subscriptions) {\n                        unsubscribe();\n                    }\n                    subscriptions = undefined;\n                }\n\n                element = undefined;\n                elementXmlNamespace = undefined;\n                if (portalRenderNode) {\n                    renderNode.disown(portalRenderNode);\n                    portalRenderNode = undefined;\n                }\n\n                detachedError = undefined;\n            },\n        },\n        emptyRenderNode,\n        debugName ?? `intrinsic(${tagName})`\n    );\n    return renderNode;\n}\n", "import { renderJSXChildren } from './renderjsx';\nimport { ArrayRenderNode } from './rendernode/arrayrendernode';\nimport type {\n    Component,\n    FunctionComponent,\n} from './rendernode/componentrendernode';\nimport {\n    ClassComponent,\n    ComponentRenderNode,\n} from './rendernode/componentrendernode';\nimport { IntrinsicRenderNode } from './rendernode/intrinsicrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\n\nexport const Fragment: Component<{ children?: JSX.Node | JSX.Node[] }> = ({\n    children,\n}) => ArrayRenderNode(renderJSXChildren(children));\n\nexport interface ClassComponentConstructor<TProps> {\n    new (props: TProps): ClassComponent<TProps>;\n}\n\nexport function isClassComponent(\n    val: any\n): val is ClassComponentConstructor<unknown> {\n    return val && val.prototype instanceof ClassComponent;\n}\n\nexport function classComponentToFunctionComponentRenderNode<TProps>(\n    Component: ClassComponentConstructor<TProps>,\n    props: TProps,\n    children: JSX.Node[]\n) {\n    return ComponentRenderNode(\n        (props: TProps, lifecycle) => {\n            const instance = new Component(props);\n            if (!instance.render) return null;\n            if (instance.onDestroy)\n                lifecycle.onDestroy(instance.onDestroy.bind(instance));\n            if (instance.onMount)\n                lifecycle.onMount(instance.onMount.bind(instance));\n            if (instance.onError)\n                lifecycle.onError(instance.onError.bind(instance));\n            if (instance.onUnmount)\n                lifecycle.onUnmount(instance.onUnmount.bind(instance));\n            return instance.render();\n        },\n        props,\n        children\n    );\n}\n\nexport function createElement<TProps extends {} | undefined>(\n    type: string | Component<TProps>,\n    props: TProps,\n    ...children: JSX.Node[]\n): RenderNode {\n    if (typeof type === 'string') {\n        return IntrinsicRenderNode(\n            type,\n            props,\n            ArrayRenderNode(renderJSXChildren(children))\n        );\n    }\n    if (isClassComponent(type)) {\n        return classComponentToFunctionComponentRenderNode<TProps>(\n            type as ClassComponentConstructor<TProps>,\n            props,\n            children\n        );\n    }\n    return ComponentRenderNode<TProps>(\n        type as FunctionComponent<TProps>,\n        props,\n        children\n    );\n}\ncreateElement.Fragment = Fragment;\n", "import { renderJSXChildren } from '../viewcontroller/renderjsx';\nimport { ArrayRenderNode } from '../viewcontroller/rendernode/arrayrendernode';\nimport type { Component } from '../viewcontroller/rendernode/componentrendernode';\n\nexport const Fragment: Component<{ children?: JSX.Node | JSX.Node[] }> = ({\n    children,\n}) => ArrayRenderNode(renderJSXChildren(children));\n", "import { applyArrayEvent, ArrayEventType } from '../../common/arrayevent';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { SingleChildRenderNode } from './rendernode';\n\nexport enum IntrinsicObserverEventType {\n    MOUNT = 'mount',\n    UNMOUNT = 'unmount',\n}\n\nexport type IntrinsicObserverNodeCallback = (\n    node: Node,\n    event: IntrinsicObserverEventType\n) => void;\n\nexport type IntrinsicObserverElementCallback = (\n    element: Element,\n    event: IntrinsicObserverEventType\n) => void;\n\nexport function IntrinsicObserverRenderNode(\n    nodeCallback: IntrinsicObserverNodeCallback | undefined,\n    elementCallback: IntrinsicObserverElementCallback | undefined,\n    child: RenderNode,\n    debugName?: string\n): RenderNode {\n    const nodes: Node[] = [];\n    const pendingEvent = new Map<Node, IntrinsicObserverEventType>();\n\n    function notify(node: Node, eventType: IntrinsicObserverEventType) {\n        nodeCallback?.(node, eventType);\n        if (node instanceof Element) {\n            elementCallback?.(node, eventType);\n        }\n    }\n    const renderNode = new SingleChildRenderNode(\n        {\n            onEvent: (event) => {\n                for (const removedNode of applyArrayEvent(nodes, event)) {\n                    pendingEvent.set(\n                        removedNode,\n                        IntrinsicObserverEventType.UNMOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n                if (event.type === ArrayEventType.SPLICE && event.items) {\n                    for (const addedNode of event.items) {\n                        pendingEvent.set(\n                            addedNode,\n                            IntrinsicObserverEventType.MOUNT\n                        );\n                    }\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            clone: () => {\n                return IntrinsicObserverRenderNode(\n                    nodeCallback,\n                    elementCallback,\n                    child.clone(),\n                    debugName\n                );\n            },\n            onMount: () => {\n                for (const node of nodes) {\n                    pendingEvent.set(node, IntrinsicObserverEventType.MOUNT);\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            onUnmount: () => {\n                for (const node of nodes) {\n                    pendingEvent.set(node, IntrinsicObserverEventType.UNMOUNT);\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            onCommit: (phase) => {\n                switch (phase) {\n                    case RenderNodeCommitPhase.COMMIT_UNMOUNT:\n                        for (const [node, event] of pendingEvent.entries()) {\n                            if (event === IntrinsicObserverEventType.UNMOUNT) {\n                                notify(\n                                    node,\n                                    IntrinsicObserverEventType.UNMOUNT\n                                );\n                            }\n                        }\n                        break;\n                    case RenderNodeCommitPhase.COMMIT_MOUNT:\n                        for (const [node, event] of pendingEvent.entries()) {\n                            if (event === IntrinsicObserverEventType.MOUNT) {\n                                notify(node, IntrinsicObserverEventType.MOUNT);\n                            }\n                        }\n                        pendingEvent.clear();\n                        break;\n                }\n            },\n        },\n        child,\n        debugName ?? 'IntrinsicObserverRenderNode'\n    );\n    return renderNode;\n}\n", "import { renderJSXChildren } from '../viewcontroller/renderjsx';\nimport { ArrayRenderNode } from '../viewcontroller/rendernode/arrayrendernode';\nimport type { Component } from '../viewcontroller/rendernode/componentrendernode';\nimport type {\n    IntrinsicObserverElementCallback,\n    IntrinsicObserverNodeCallback,\n} from '../viewcontroller/rendernode/intrinsicobserverrendernode';\nimport { IntrinsicObserverRenderNode } from '../viewcontroller/rendernode/intrinsicobserverrendernode';\n\nexport const IntrinsicObserver: Component<{\n    nodeCallback?: IntrinsicObserverNodeCallback;\n    elementCallback?: IntrinsicObserverElementCallback;\n    children?: JSX.Node | JSX.Node[];\n}> = ({ nodeCallback, elementCallback, children }) => {\n    return IntrinsicObserverRenderNode(\n        nodeCallback,\n        elementCallback,\n        ArrayRenderNode(renderJSXChildren(children))\n    );\n};\n", "import type { ArrayEvent } from '../common/arrayevent';\nimport { ArrayEventType } from '../common/arrayevent';\nimport type { Collection, View } from '../model/collection';\nimport { untrackReads } from '../model/engine';\nimport type { RenderNode } from '../viewcontroller/rendernode/rendernode';\nimport { MultiChildRenderNode } from '../viewcontroller/rendernode/rendernode';\n\nexport function CollectionRenderNode(\n    renderJSXNode: (jsxNode: JSX.Node) => RenderNode,\n    collection: Collection<any> | View<any>,\n    debugName?: string\n): RenderNode {\n    let unsubscribe: undefined | (() => void);\n    function handleEvent(events: ArrayEvent<any>[]) {\n        for (const event of events) {\n            switch (event.type) {\n                case ArrayEventType.SPLICE:\n                    renderNode.spliceChildren(\n                        event.index,\n                        event.count,\n                        event.items?.map((item) => renderJSXNode(item)) ?? []\n                    );\n                    break;\n                case ArrayEventType.MOVE:\n                    renderNode.moveChildren(event.from, event.count, event.to);\n                    break;\n                case ArrayEventType.SORT:\n                    renderNode.sortChildren(event.from, event.indexes);\n                    break;\n            }\n        }\n    }\n    const renderNode = new MultiChildRenderNode(\n        {\n            onAlive: () => {\n                unsubscribe = collection.subscribe(handleEvent);\n                untrackReads(() => {\n                    renderNode.spliceChildren(\n                        0,\n                        0,\n                        collection.map((item) => renderJSXNode(item))\n                    );\n                });\n            },\n            onDestroy: () => {\n                unsubscribe?.();\n                untrackReads(() => {\n                    renderNode.spliceChildren(0, collection.length, []);\n                });\n            },\n        },\n        [],\n        debugName ?? `CollectionRenderNode(${collection.__debugName})`\n    );\n\n    return renderNode;\n}\n", "import type {\n    DynamicMut,\n    DynamicNonErrorSubscriptionHandler,\n} from '../common/dyn';\nimport * as log from '../common/log';\nimport type { Calculation } from './calc';\nimport { calc } from './calc';\nimport type { Processable, Retainable } from './engine';\nimport {\n    addVertex,\n    markDirty,\n    notifyRead,\n    release,\n    removeVertex,\n    retain,\n} from './engine';\n\nexport class Field<T> implements Processable, Retainable, DynamicMut<T> {\n    private declare _val: T;\n    // Map of subscriber to the clock time\n    private declare _subscribers?: Map<\n        DynamicNonErrorSubscriptionHandler<T>,\n        number\n    >;\n    private declare _changeClock: number;\n\n    declare __processable: true;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(val: T, debugName?: string) {\n        this._val = val;\n        this._changeClock = 0;\n\n        this.__processable = true;\n        this.__refcount = 0;\n\n        this.__debugName = debugName ?? 'field';\n    }\n\n    get(): T {\n        notifyRead(this);\n        return this._val;\n    }\n\n    set(newVal: T) {\n        if (newVal !== this._val) {\n            if (this._subscribers) {\n                this._changeClock += 1;\n            }\n            this._val = newVal;\n            if (this.__refcount > 0) {\n                markDirty(this);\n            }\n        }\n    }\n\n    subscribe(subscriber: DynamicNonErrorSubscriptionHandler<T>): () => void {\n        this.retain();\n        if (!this._subscribers) this._subscribers = new Map();\n        this._subscribers.set(subscriber, this._changeClock);\n        subscriber(undefined, this._val);\n        return () => {\n            if (this._subscribers?.has(subscriber)) {\n                this._subscribers?.delete(subscriber);\n                this.release();\n            }\n        };\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        addVertex(this);\n    }\n\n    __dead() {\n        removeVertex(this);\n    }\n\n    __recalculate() {\n        log.assert(this.__refcount > 0, 'cannot flush dead field');\n        if (this._subscribers) {\n            for (const [subscriber, observeClock] of this._subscribers) {\n                if (observeClock < this._changeClock) {\n                    subscriber(undefined, this._val);\n                }\n                this._subscribers.set(subscriber, 0);\n            }\n            this._changeClock = 0;\n        }\n        return true;\n    }\n\n    map<V>(fn: (val: T) => V): Calculation<V> {\n        return calc(() => fn(this.get()));\n    }\n}\n\nexport function field<T>(val: T, debugName?: string): Field<T> {\n    return new Field(val, debugName);\n}\n", "import type { Processable, Retainable } from './engine';\nimport {\n    addSoftEdge,\n    notifyRead,\n    release,\n    removeSoftEdge,\n    retain,\n} from './engine';\nimport { Field } from './field';\n\nexport class FieldMap implements Retainable {\n    private declare keysField: Field<number>;\n    private declare fieldMap: Map<any, Field<any>>;\n    private declare consumer: (Retainable & Processable) | null;\n    private declare emitter: (Retainable & Processable) | null;\n\n    declare __debugName: string;\n    declare __refcount: number;\n\n    constructor(\n        keysField: Field<number>,\n        consumer: (Retainable & Processable) | null,\n        emitter: (Retainable & Processable) | null,\n        debugName?: string\n    ) {\n        this.__refcount = 0;\n        this.__debugName = debugName ?? 'fieldmap';\n        this.keysField = keysField;\n        this.fieldMap = new Map();\n        this.consumer = consumer;\n        this.emitter = emitter;\n    }\n\n    getOrMake(key: any, val: any) {\n        let field = this.fieldMap.get(key);\n        if (!field) {\n            field = new Field(val, `${this.__debugName}:${key}`);\n            this.fieldMap.set(key, field);\n\n            if (this.__refcount > 0) {\n                retain(field);\n                if (this.consumer) addSoftEdge(this.consumer, field);\n                if (this.emitter) addSoftEdge(field, this.emitter);\n            }\n        }\n        return field;\n    }\n\n    set(key: any, val: any) {\n        const field = this.getOrMake(key, undefined);\n        field.set(val);\n    }\n\n    delete(key: any) {\n        const field = this.fieldMap.get(key);\n        if (field) {\n            field.set(undefined);\n            this.fieldMap.delete(key);\n\n            if (this.__refcount > 0) {\n                if (this.emitter) removeSoftEdge(field, this.emitter);\n                if (this.consumer) removeSoftEdge(this.consumer, field);\n                release(field);\n            }\n        }\n    }\n\n    keys() {\n        notifyRead(this.keysField);\n        return this.fieldMap.keys();\n    }\n\n    values() {\n        notifyRead(this.keysField);\n        return this.fieldMap.values();\n    }\n\n    entries() {\n        notifyRead(this.keysField);\n        return this.fieldMap.entries();\n    }\n\n    clear() {\n        const keys = [...this.fieldMap.keys()];\n        keys.forEach((key) => {\n            this.delete(key);\n        });\n    }\n\n    __dead() {\n        for (const field of this.fieldMap.values()) {\n            if (this.emitter) removeSoftEdge(field, this.emitter);\n            if (this.consumer) removeSoftEdge(this.consumer, field);\n            release(field);\n        }\n\n        if (this.emitter) removeSoftEdge(this.keysField, this.emitter);\n        if (this.consumer) removeSoftEdge(this.consumer, this.keysField);\n        release(this.keysField);\n\n        if (this.emitter) release(this.emitter);\n        if (this.consumer) release(this.consumer);\n    }\n\n    __alive() {\n        if (this.emitter) retain(this.emitter);\n        if (this.consumer) retain(this.consumer);\n\n        retain(this.keysField);\n        if (this.emitter) addSoftEdge(this.keysField, this.emitter);\n        if (this.consumer) addSoftEdge(this.consumer, this.keysField);\n\n        for (const field of this.fieldMap.values()) {\n            retain(field);\n            if (this.emitter) addSoftEdge(field, this.emitter);\n            if (this.consumer) addSoftEdge(this.consumer, field);\n        }\n    }\n}\n", "import type { Processable, Retainable } from './engine';\nimport {\n    addHardEdge,\n    addSoftEdge,\n    addVertex,\n    markDirty,\n    release,\n    removeHardEdge,\n    removeSoftEdge,\n    removeVertex,\n    retain,\n} from './engine';\nimport type { Field } from './field';\nimport type { SubscriptionEmitter } from './subscriptionemitter';\n\ntype SubscriptionConsumerHandler<TData, TConsumeEvent, TEmitEvent> = {\n    bivarianceHack(\n        target: TData,\n        events: TConsumeEvent[]\n    ): IterableIterator<TEmitEvent>;\n}['bivarianceHack'];\n\nexport class SubscriptionConsumer<TData, TConsumeEvent, TEmitEvent>\n    implements Processable, Retainable\n{\n    private declare target: TData;\n    private declare handler: SubscriptionConsumerHandler<\n        TData,\n        TConsumeEvent,\n        TEmitEvent\n    >;\n    private declare events: TConsumeEvent[];\n    private declare isActive: boolean;\n    private declare sourceEmitter: SubscriptionEmitter<TConsumeEvent>;\n    private declare transformEmitter: SubscriptionEmitter<TEmitEvent>;\n    private declare unsubscribe?: () => void;\n\n    // Note: for reasons I don't understand; this cannot be typed as:\n    //     private declare appendEvent: (events: TConsumeEvent[], event: TConsumeEvent) => void;\n    // without causing bizarre type errors across the application\n    private declare appendEvent: (events: any[], event: any) => void;\n\n    // Processable\n    declare __processable: true;\n    declare __debugName: string;\n\n    __recalculate() {\n        for (const emitEvent of this.handler(this.target, this.events)) {\n            this.transformEmitter.addEvent(emitEvent);\n        }\n        this.events.splice(0, this.events.length);\n        return false;\n    }\n\n    // Retainable\n    declare __refcount: number;\n\n    __alive() {\n        this.isActive = true;\n        addVertex(this);\n        retain(this.sourceEmitter);\n        addHardEdge(this.sourceEmitter, this);\n        this.unsubscribe = this.sourceEmitter.subscribe((events) => {\n            for (const event of events) {\n                this.addEvent(event);\n            }\n        });\n    }\n\n    __dead() {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n            removeHardEdge(this.sourceEmitter, this);\n            release(this.sourceEmitter);\n        }\n        this.events.splice(0, this.events.length);\n        removeVertex(this);\n        this.isActive = false;\n    }\n\n    constructor(\n        target: TData,\n        sourceEmitter: SubscriptionEmitter<TConsumeEvent>,\n        transformEmitter: SubscriptionEmitter<TEmitEvent>,\n        handler: SubscriptionConsumerHandler<TData, TConsumeEvent, TEmitEvent>,\n        appendEvent: (events: TConsumeEvent[], event: TConsumeEvent) => void,\n        debugName: string\n    ) {\n        this.target = target;\n        this.handler = handler;\n        this.events = [];\n        this.isActive = false;\n        this.sourceEmitter = sourceEmitter;\n        this.transformEmitter = transformEmitter;\n        this.appendEvent = appendEvent;\n        this.__refcount = 0;\n        this.__processable = true;\n        this.__debugName = `consumer:${debugName}`;\n    }\n\n    addEvent(event: TConsumeEvent) {\n        if (!this.isActive) return;\n        const firstEvent = this.events.length === 0;\n        this.appendEvent(this.events, event);\n        if (firstEvent) {\n            markDirty(this);\n        }\n    }\n\n    addField(field: Field<any>) {\n        if (this.isActive) {\n            retain(field);\n            addSoftEdge(this, field);\n        }\n    }\n\n    removeField(field: Field<any>) {\n        if (this.isActive) {\n            removeSoftEdge(this, field);\n            release(field);\n        }\n    }\n}\n", "import * as log from '../common/log';\nimport type { Processable, Retainable } from './engine';\nimport { addVertex, markDirty, removeVertex } from './engine';\n\ntype SubscriptionEmitterHandler<TEmitEvent> = {\n    bivarianceHack(events: TEmitEvent[]): void;\n}['bivarianceHack'];\n\nexport class SubscriptionEmitter<TEmitEvent>\n    implements Processable, Retainable\n{\n    /** Per-emitter function to add an event to the sequence of events for a subscriber */\n    // Note: for reasons I don't understand; this cannot be typed as:\n    //     private declare appendEvent: (events: TEmitEvent[], event: TEmitEvent) => void;\n    // without causing bizarre type errors across the application\n    private declare appendEvent: (events: any[], event: any) => void;\n    private declare subscribers: {\n        handler: SubscriptionEmitterHandler<TEmitEvent>;\n        events: TEmitEvent[];\n    }[];\n    private declare isActive: boolean;\n\n    // Processable\n    declare __processable: true;\n    declare __debugName: string;\n\n    __recalculate() {\n        for (const subscriber of this.subscribers) {\n            subscriber.handler(subscriber.events);\n            subscriber.events = [];\n        }\n        return true;\n    }\n\n    // Retainable\n    declare __refcount: number;\n\n    __alive() {\n        this.isActive = true;\n        addVertex(this);\n    }\n\n    __dead() {\n        log.assert(\n            this.subscribers.length === 0,\n            'released subscription emitter that had subscribers'\n        );\n        removeVertex(this);\n        this.isActive = false;\n    }\n\n    constructor(\n        appendEvent: (events: TEmitEvent[], event: TEmitEvent) => void,\n        debugName: string\n    ) {\n        this.appendEvent = appendEvent;\n        this.subscribers = [];\n        this.isActive = false;\n        this.__refcount = 0;\n        this.__processable = true;\n        this.__debugName = `emitter:${debugName}`;\n    }\n\n    addEvent(event: TEmitEvent) {\n        if (!this.isActive) return;\n        let firstAdded = false;\n        for (const subscriber of this.subscribers) {\n            if (subscriber.events.length === 0) firstAdded = true;\n            this.appendEvent(subscriber.events, event);\n        }\n        if (firstAdded) {\n            markDirty(this);\n        }\n    }\n\n    subscribe(handler: SubscriptionEmitterHandler<TEmitEvent>) {\n        this.subscribers.push({ handler, events: [] });\n        return () => {\n            const index = this.subscribers.findIndex(\n                (subscriber) => subscriber.handler === handler\n            );\n            if (index === -1) return;\n            this.subscribers.splice(index, 1);\n        };\n    }\n}\n", "import type { JSXRenderable } from '../viewcontroller/jsx';\nimport type { Retainable } from './engine';\nimport { notifyCreate, notifyRead } from './engine';\nimport { Field } from './field';\nimport { FieldMap } from './fieldmap';\nimport { SubscriptionConsumer } from './subscriptionconsumer';\nimport { SubscriptionEmitter } from './subscriptionemitter';\n\nexport class TrackedDataHandle<\n    TData extends object,\n    TMethods extends Retainable & JSXRenderable,\n    TEmitEvent,\n    TConsumeEvent,\n> {\n    declare target: TData;\n    declare methods: TMethods;\n\n    declare fieldMap: FieldMap;\n    declare keys: Set<string>;\n    declare keysField: Field<number>;\n    declare dataAccessor: DataAccessor;\n    declare emitter: SubscriptionEmitter<TEmitEvent>;\n    declare consumer: null | SubscriptionConsumer<\n        TData,\n        TConsumeEvent,\n        TEmitEvent\n    >;\n    declare revocable: {\n        proxy: TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>;\n        revoke: () => void;\n    };\n\n    constructor(\n        target: TData,\n        proxyHandler: ProxyHandler<TEmitEvent>,\n        methods: TMethods,\n        derivedEmitter: null | SubscriptionEmitter<TConsumeEvent>,\n        handleEvents:\n            | null\n            | ((\n                  target: TData,\n                  events: TConsumeEvent[]\n              ) => IterableIterator<TEmitEvent>),\n        appendEmitEvent: (events: TEmitEvent[], event: TEmitEvent) => void,\n        appendConsumeEvent: (\n            events: TConsumeEvent[],\n            event: TConsumeEvent\n        ) => void,\n        debugName = 'trackeddata'\n    ) {\n        this.target = target;\n        this.methods = methods;\n\n        this.emitter = new SubscriptionEmitter<TEmitEvent>(\n            appendEmitEvent,\n            debugName\n        );\n\n        if (derivedEmitter && handleEvents) {\n            this.consumer = new SubscriptionConsumer(\n                target,\n                derivedEmitter,\n                this.emitter,\n                handleEvents,\n                appendConsumeEvent,\n                debugName\n            );\n        } else {\n            this.consumer = null;\n        }\n\n        this.keys = new Set<string>(Object.keys(target));\n        this.keysField = new Field(this.keys.size, `${debugName}:@keys`);\n        this.fieldMap = new FieldMap(\n            this.keysField,\n            this.consumer,\n            this.emitter,\n            debugName\n        );\n\n        const emitEvent = (event: TEmitEvent) => {\n            this.emitter.addEvent(event);\n        };\n\n        this.dataAccessor = {\n            get: (prop, receiver) => {\n                if (prop === '__tdHandle') {\n                    return this;\n                }\n                if (prop === '__debugName') {\n                    return debugName;\n                }\n                if (prop === '__processable') {\n                    return false;\n                }\n                if (\n                    prop === '__refcount' ||\n                    prop === '__alive' ||\n                    prop === '__dead' ||\n                    prop === '__renderNode'\n                ) {\n                    return methods[prop];\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.get(this.target, prop, receiver);\n                }\n                if (prop in methods) {\n                    return (methods as any)[prop];\n                }\n                const value = Reflect.get(this.target, prop, receiver);\n                const field = this.fieldMap.getOrMake(prop, value);\n                notifyRead(this.revocable.proxy);\n                notifyRead(field);\n                return value;\n            },\n            peekHas: (prop) => {\n                return Reflect.has(target, prop);\n            },\n            has: (prop) => {\n                if (\n                    prop === '__refcount' ||\n                    prop === '__alive' ||\n                    prop === '__dead'\n                ) {\n                    return prop in methods;\n                }\n                if (prop === '__processable') {\n                    return true;\n                }\n                if (prop in methods) {\n                    return true;\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.has(this.target, prop);\n                }\n                const value = Reflect.has(target, prop);\n                const field = this.fieldMap.getOrMake(prop, value);\n                notifyRead(this.revocable.proxy);\n                notifyRead(field);\n                return value;\n            },\n            set: (prop, value, receiver) => {\n                if (prop === '__refcount') {\n                    methods[prop] = value;\n                    return true;\n                }\n                if (prop in methods) {\n                    return false; // Prevent writes to owned methods\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.set(this.target, prop, value, receiver);\n                }\n                const hadProp = Reflect.has(target, prop);\n                const field = this.fieldMap.getOrMake(prop, value);\n                field.set(value);\n                if (!hadProp) {\n                    this.keys.add(prop);\n                    this.keysField.set(this.keys.size);\n                }\n                return Reflect.set(target, prop, value, this.revocable.proxy);\n            },\n            delete: (prop) => {\n                if (\n                    prop === '__refcount' ||\n                    prop === '__alive' ||\n                    prop === '__dead' ||\n                    prop === '__processable'\n                ) {\n                    return false; // Prevent deletes of internal symbols\n                }\n                if (prop in methods) {\n                    return false; // Prevent deletes of owned methods\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.deleteProperty(this.target, prop);\n                }\n                const hadProp = Reflect.has(target, prop);\n                const result = Reflect.deleteProperty(target, prop);\n                if (hadProp) {\n                    this.keys.delete(prop);\n                    this.keysField.set(this.keys.size);\n                    this.fieldMap.delete(prop);\n                }\n                return result;\n            },\n        };\n\n        this.revocable = Proxy.revocable<\n            TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>\n        >(target as TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>, {\n            get: (target, prop, receiver) =>\n                proxyHandler.get(this.dataAccessor, emitEvent, prop, receiver),\n            has: (target, prop) =>\n                proxyHandler.has(this.dataAccessor, emitEvent, prop),\n            set: (target, prop, value, receiver) =>\n                proxyHandler.set(\n                    this.dataAccessor,\n                    emitEvent,\n                    prop,\n                    value,\n                    receiver\n                ),\n            deleteProperty: (target, prop) =>\n                proxyHandler.delete(this.dataAccessor, emitEvent, prop),\n            ownKeys: () => {\n                const keys = this.keys;\n                this.keysField.get(); // force a read to add a dependency on keys\n                return [...keys];\n            },\n        });\n\n        notifyCreate(this.revocable.proxy);\n    }\n}\n\nexport type TrackedData<\n    TData extends object,\n    TMethods extends Retainable & JSXRenderable,\n    TEmitEvent,\n    TConsumeEvent,\n> = TData &\n    TMethods & {\n        __tdHandle: TrackedDataHandle<\n            TData,\n            TMethods,\n            TEmitEvent,\n            TConsumeEvent\n        >;\n    };\n\nexport function getTrackedDataHandle<\n    TData extends object,\n    TMethods extends Retainable & JSXRenderable,\n    TEmitEvent,\n    TConsumeEvent,\n>(\n    trackedData: TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>\n): undefined | TrackedDataHandle<TData, TMethods, TEmitEvent, TConsumeEvent> {\n    return trackedData.__tdHandle;\n}\n\nexport interface DataAccessor {\n    get: (prop: string | symbol, receiver: any) => any;\n    has: (prop: string | symbol) => any;\n    peekHas: (prop: string | symbol) => any;\n    set: (prop: string | symbol, value: any, receiver: any) => any;\n    delete: (prop: string | symbol) => boolean;\n}\n\nexport interface ProxyHandler<TEmitEvent> {\n    get: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol,\n        receiver: any\n    ) => any;\n    has: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol\n    ) => any;\n    set: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol,\n        value: any,\n        receiver: any\n    ) => any;\n    delete: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol\n    ) => boolean;\n}\n", "import type { ArrayEvent } from '../common/arrayevent';\nimport {\n    addArrayEvent,\n    arrayEventFlatMap,\n    ArrayEventType,\n} from '../common/arrayevent';\nimport * as log from '../common/log';\nimport { CollectionRenderNode } from '../modelview/collectionrendernode';\nimport type { JSXNode, JSXRenderable } from '../viewcontroller/jsx';\nimport type { RenderNode } from '../viewcontroller/rendernode/rendernode';\nimport type { Retainable } from './engine';\nimport { release, retain, untrackReads } from './engine';\nimport type { ProxyHandler, TrackedData } from './trackeddata';\nimport { getTrackedDataHandle, TrackedDataHandle } from './trackeddata';\n\nexport interface CollectionImpl<T> extends Retainable, JSXRenderable {\n    _type: 'collection';\n    splice(start: number, deleteCount?: number | undefined): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    push(...items: T[]): number;\n    pop(): T | undefined;\n    shift(): T | undefined;\n    unshift(...items: T[]): number;\n    sort(cmp?: ((a: T, b: T) => number) | undefined): this;\n    reverse(): this;\n\n    reject: (pred: (val: T) => boolean) => T[];\n    moveSlice: (fromIndex: number, count: number, toIndex: number) => void;\n\n    mapView: <V>(\n        fn: (val: T) => V,\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n    filterView: (\n        fn: (val: T) => boolean,\n        debugName?: string | undefined\n    ) => View<T, ArrayEvent<T>>;\n    flatMapView: <V>(\n        fn: (val: T) => V[],\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n\n    subscribe: (handler: (event: ArrayEvent<T>[]) => void) => () => void;\n    __renderNode: (\n        renderJSXNode: (jsxNode: JSXNode) => RenderNode\n    ) => RenderNode;\n}\n\nexport function makeCollectionPrototype<T>(): CollectionImpl<T> {\n    return {\n        _type: 'collection',\n\n        // Array mutation values\n        splice: collectionSplice,\n        push: collectionPush,\n        pop: collectionPop,\n        shift: collectionShift,\n        unshift: collectionUnshift,\n        sort: collectionSort,\n        reverse: collectionReverse,\n\n        // Handy API values\n        reject: collectionReject,\n        moveSlice: collectionMoveSlice,\n\n        // View production\n        mapView,\n        filterView,\n        flatMapView,\n        subscribe: collectionSubscribe,\n\n        // Retainable\n        __refcount: 0,\n        __alive: collectionAlive,\n        __dead: collectionDead,\n        __debugName: 'collection',\n\n        // JSXRenderable\n        __renderNode: collectionRender,\n    };\n}\n\nexport interface ViewImpl<T> extends Retainable {\n    _type: 'view';\n    splice(start: number, deleteCount?: number | undefined): never;\n    splice(start: number, deleteCount: number, ...items: T[]): never;\n    push(...items: T[]): never;\n    pop(): never;\n    shift(): never;\n    unshift(...items: T[]): never;\n    sort(cmp?: ((a: T, b: T) => number) | undefined): never;\n    reverse(): never;\n\n    mapView: <V>(\n        fn: (val: T) => V,\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n    filterView: (\n        fn: (val: T) => boolean,\n        debugName?: string | undefined\n    ) => View<T, ArrayEvent<T>>;\n    flatMapView: <V>(\n        fn: (val: T) => V[],\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n\n    subscribe: (handler: (event: ArrayEvent<T>[]) => void) => () => void;\n    __renderNode: (\n        renderJSXNode: (jsxNode: JSXNode) => RenderNode\n    ) => RenderNode;\n}\n\nexport function makeViewPrototype<T>(\n    sourceCollection: TrackedData<any, any, unknown, unknown>\n): ViewImpl<T> {\n    return {\n        _type: 'view',\n\n        // Array mutation values\n        splice: viewSplice,\n        push: viewPush,\n        pop: viewPop,\n        shift: viewShift,\n        unshift: viewUnshift,\n        sort: viewSort,\n        reverse: viewReverse,\n\n        // View production\n        mapView,\n        filterView,\n        flatMapView,\n        subscribe: collectionSubscribe,\n\n        // Retainable\n        __refcount: 0,\n        __alive(this: View<T>) {\n            retain(sourceCollection);\n            const tdHandle = getTrackedDataHandle(this);\n            log.assert(tdHandle, 'missing tdHandle');\n            retain(tdHandle.fieldMap);\n        },\n        __dead(this: View<T>) {\n            const tdHandle = getTrackedDataHandle(this);\n            log.assert(tdHandle, 'missing tdHandle');\n            release(tdHandle.fieldMap);\n            release(sourceCollection);\n        },\n        __debugName: 'collection',\n\n        // JSXRenderable\n        __renderNode: collectionRender,\n    };\n}\n\nexport type Collection<T> = TrackedData<\n    T[],\n    CollectionImpl<T>,\n    ArrayEvent<T>,\n    ArrayEvent<T>\n>;\nexport type View<T, TConsumeEvent = any> = TrackedData<\n    readonly T[],\n    ViewImpl<T>,\n    ArrayEvent<T>,\n    TConsumeEvent\n>;\n\nexport function isCollection(val: any): val is Collection<any> {\n    return val && val._type === 'collection';\n}\n\nexport function isView(val: any): val is View<any> {\n    return val && val._type === 'view';\n}\n\nexport const CollectionHandler: ProxyHandler<ArrayEvent<any>> = {\n    get: (dataAccessor, emitter, prop, receiver) => {\n        return dataAccessor.get(prop, receiver);\n    },\n    has: (dataAccessor, emitter, prop) => {\n        return dataAccessor.has(prop);\n    },\n    set: (dataAccessor, emitter, prop, value, receiver) => {\n        if (typeof prop === 'string') {\n            const numericProp = parseInt(prop, 10);\n            if (!isNaN(numericProp)) {\n                emitter({\n                    type: ArrayEventType.SPLICE,\n                    index: numericProp,\n                    count: 1,\n                    items: [value],\n                });\n            }\n        }\n        return dataAccessor.set(prop, value, receiver);\n    },\n    delete: (dataAccessor, emitter, prop) => {\n        return dataAccessor.delete(prop);\n    },\n};\n\nexport const ViewHandler: ProxyHandler<ArrayEvent<any>> = {\n    get: (dataAccessor, emitter, prop, receiver) => {\n        return dataAccessor.get(prop, receiver);\n    },\n    has: (dataAccessor, emitter, prop) => {\n        return dataAccessor.has(prop);\n    },\n    set: (dataAccessor, emitter, prop, value, receiver) => {\n        if (prop === '__refcount') {\n            return dataAccessor.set(prop, value, receiver);\n        }\n        log.fail('Cannot mutate readonly view');\n    },\n    delete: (dataAccessor, emitter, prop) => {\n        log.fail('Cannot mutate readonly view');\n    },\n};\n\nexport function collection<T>(items: T[], debugName?: string): Collection<T> {\n    const handle = new TrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >(\n        items,\n        CollectionHandler,\n        makeCollectionPrototype(),\n        null,\n        null,\n        addArrayEvent,\n        addArrayEvent,\n        debugName\n    );\n    return handle.revocable.proxy;\n}\n\nfunction viewSplice<T>(\n    this: View<T>,\n    index: number,\n    count: number,\n    ...items: T[]\n): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction spliceInner<T>(\n    tdHandle: TrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >,\n    index: number,\n    count: number,\n    ...items: T[]\n) {\n    const startLength = tdHandle.target.length;\n    const removed = Array.prototype.splice.call(\n        tdHandle.target,\n        index,\n        count,\n        ...items\n    );\n    const endLength = tdHandle.target.length;\n    if (startLength === endLength) {\n        // invalidate fields affected by splice\n        for (let i = index; i < index + items.length; ++i) {\n            tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n        }\n    } else {\n        // invalidate fields affected by splice\n        for (let i = index; i < endLength; ++i) {\n            tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n        }\n        // destroy any dead fields\n        for (let i = endLength; i < startLength; ++i) {\n            tdHandle.fieldMap.delete(i.toString());\n        }\n        tdHandle.fieldMap.set('length', endLength);\n    }\n    tdHandle.emitter.addEvent({\n        type: ArrayEventType.SPLICE,\n        index,\n        count,\n        items,\n    });\n    return removed;\n}\n\nfunction collectionSplice<T>(\n    this: Collection<T>,\n    index: number,\n    count = 0,\n    ...items: T[]\n) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    return spliceInner(tdHandle, index, count, ...items);\n}\n\nfunction viewPush<T>(this: View<T>, ...items: T[]): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionPush<T>(this: Collection<T>, ...items: T[]) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    spliceInner(tdHandle, tdHandle.target.length, 0, ...items);\n    return tdHandle.target.length;\n}\n\nfunction viewPop<T>(this: View<T>): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionPop<T>(this: Collection<T>): T | undefined {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    return spliceInner(tdHandle, tdHandle.target.length - 1, 1)[0];\n}\n\nfunction viewShift<T>(this: View<T>): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionShift<T>(this: Collection<T>): T | undefined {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    return spliceInner(tdHandle, 0, 1)[0];\n}\n\nfunction viewUnshift<T>(this: View<T>, ...items: T[]): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionUnshift<T>(this: Collection<T>, ...items: T[]) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    spliceInner(tdHandle, 0, 0, ...items);\n    return tdHandle.target.length;\n}\n\nfunction collectionReject<T>(\n    this: Collection<T>,\n    pred: (val: T) => boolean\n): T[] {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n\n    let start: null | number = null;\n    let length = tdHandle.target.length;\n    let toRemove = false;\n    const removed: T[] = [];\n    for (let i = 0; i < length; ++i) {\n        toRemove = pred(tdHandle.target[i]);\n        if (toRemove && start === null) {\n            start = i;\n        }\n        if (!toRemove && start !== null) {\n            const count = i - start;\n            removed.push(...spliceInner(tdHandle, start, count));\n            length -= count;\n            i -= count;\n            start = null;\n        }\n    }\n    if (start !== null) {\n        const count = length - start;\n        removed.push(...spliceInner(tdHandle, start, count));\n    }\n    return removed;\n}\n\nfunction collectionMoveSlice<T>(\n    this: Collection<T>,\n    fromIndex: number,\n    count: number,\n    toIndex: number\n) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'moveSlice missing tdHandle');\n    const removed = tdHandle.target.splice(fromIndex, count);\n    tdHandle.target.splice(toIndex, 0, ...removed);\n    tdHandle.emitter.addEvent({\n        type: ArrayEventType.MOVE,\n        from: fromIndex,\n        count,\n        to: toIndex,\n    });\n}\n\nfunction collectionSubscribe<T>(\n    this: Collection<T> | View<T>,\n    handler: (event: ArrayEvent<T>[]) => void\n) {\n    const tdHandle = getTrackedDataHandle<\n        readonly T[],\n        CollectionImpl<T> | ViewImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<any>\n    >(this);\n    log.assert(tdHandle, 'subscribe missing tdHandle');\n    retain(this); // Yes, this is a bit odd -- a collection with a subscription should always be retained while the subscription is alive\n    retain(tdHandle.emitter);\n    const unsubscribe = tdHandle.emitter.subscribe((events) => {\n        handler(events);\n    });\n    return () => {\n        unsubscribe();\n        release(tdHandle.emitter);\n        release(this);\n    };\n}\n\nfunction collectionAlive<T>(this: Collection<T>) {\n    const tdHandle = getTrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    retain(tdHandle.fieldMap);\n}\n\nfunction collectionDead<T>(this: Collection<T>) {\n    const tdHandle = getTrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    release(tdHandle.fieldMap);\n}\n\nfunction viewSort<T>(\n    this: Collection<T>,\n    sortFn?: (a: T, b: T) => number\n): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction viewReverse<T>(this: Collection<T>): never {\n    log.fail('Cannot mutate readonly view');\n}\n\n// https://tc39.es/ecma262/multipage/indexed-collections.html#sec-sortcompare\nfunction defaultSort(x: any, y: any) {\n    if (x === undefined && y === undefined) return 0;\n    if (x === undefined) return 1;\n    if (y === undefined) return -1;\n    const xStr = '' + x;\n    const yStr = '' + y;\n    if (xStr < yStr) return -1;\n    if (xStr > yStr) return 1;\n    return 0;\n}\n\nfunction collectionSort<T>(\n    this: Collection<T>,\n    sortFn: (a: T, b: T) => number = defaultSort\n) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'collectionSort missing tdHandle');\n    let indexes: null | number[] = null;\n    if (tdHandle.emitter) {\n        indexes = (tdHandle.target as T[])\n            .map((_unused: T, index: number) => index)\n            .sort((a, b) => sortFn(tdHandle.target[a], tdHandle.target[b]));\n    }\n    tdHandle.target.sort(sortFn);\n    if (indexes) {\n        tdHandle.emitter.addEvent({\n            type: ArrayEventType.SORT,\n            from: 0,\n            indexes,\n        });\n    }\n\n    // Invalidate sorted fields\n    for (let i = 0; i < tdHandle.target.length; ++i) {\n        tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n    }\n    return this;\n}\n\nfunction collectionReverse<T>(this: Collection<T>) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'collectionReverse missing tdHandle');\n    tdHandle.target.reverse();\n    if (tdHandle.emitter) {\n        const indexes: number[] = [];\n        for (let i = tdHandle.target.length - 1; i >= 0; --i) {\n            indexes.push(i);\n        }\n        tdHandle.emitter.addEvent({\n            type: ArrayEventType.SORT,\n            from: 0,\n            indexes,\n        });\n    }\n\n    // Invalidate sorted fields\n    for (let i = 0; i < tdHandle.target.length; ++i) {\n        tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n    }\n    return this;\n}\n\nfunction mapView<T, V>(\n    this: Collection<T> | View<T>,\n    fn: (item: T) => V,\n    debugName?: string\n): View<V, ArrayEvent<T>> {\n    return makeFlatMapView(this, (item: T) => [fn(item)], debugName);\n}\nfunction filterView<T>(\n    this: Collection<T> | View<T>,\n    fn: (item: T) => boolean,\n    debugName?: string\n): View<T, ArrayEvent<T>> {\n    return makeFlatMapView(\n        this,\n        (item: T) => (fn(item) ? [item] : []),\n        debugName\n    );\n}\nfunction flatMapView<T, V>(\n    this: Collection<T> | View<T>,\n    fn: (item: T) => V[],\n    debugName?: string\n): View<V, ArrayEvent<T>> {\n    return makeFlatMapView(this, fn, debugName);\n}\n\nfunction makeFlatMapView<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    flatMap: (item: T) => readonly V[],\n    debugName?: string\n): View<V, ArrayEvent<T>> {\n    const sourceTDHandle = getTrackedDataHandle<\n        readonly T[],\n        CollectionImpl<T> | ViewImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<any>\n    >(sourceCollection);\n    log.assert(sourceTDHandle, 'missing tdHandle');\n    const slotSizes: number[] = [];\n    const initialTransform: V[] = [];\n\n    untrackReads(() => {\n        for (const item of sourceCollection) {\n            const slot = flatMap(item);\n            slotSizes.push(slot.length);\n            initialTransform.push(...slot);\n        }\n    });\n\n    const derivedCollection = new TrackedDataHandle<\n        readonly V[],\n        ViewImpl<V>,\n        ArrayEvent<V>,\n        ArrayEvent<T>\n    >(\n        initialTransform,\n        ViewHandler,\n        makeViewPrototype(sourceCollection),\n        sourceTDHandle.emitter,\n        function* (target, events: ArrayEvent<T>[]) {\n            for (const event of events) {\n                const lengthStart = initialTransform.length;\n                // Oops this is accidentally quadratic!\n                yield* arrayEventFlatMap(\n                    slotSizes,\n                    flatMap,\n                    initialTransform,\n                    event\n                );\n                // Invalidate affected ranges\n                switch (event.type) {\n                    case ArrayEventType.SPLICE: {\n                        const lengthEnd = initialTransform.length;\n                        if (lengthStart === lengthEnd) {\n                            for (\n                                let i = event.index;\n                                i < event.index + event.count;\n                                ++i\n                            ) {\n                                derivedCollection.fieldMap.set(\n                                    i.toString(),\n                                    initialTransform[i]\n                                );\n                            }\n                        } else {\n                            for (let i = event.index; i < lengthEnd; ++i) {\n                                derivedCollection.fieldMap.set(\n                                    i.toString(),\n                                    initialTransform[i]\n                                );\n                            }\n                            for (let i = lengthEnd; i < lengthStart; ++i) {\n                                derivedCollection.fieldMap.delete(i.toString());\n                            }\n                            derivedCollection.fieldMap.set('length', lengthEnd);\n                        }\n                        break;\n                    }\n                    case ArrayEventType.MOVE: {\n                        const lowerBound = Math.min(event.from, event.to);\n                        const upperBound = Math.max(\n                            event.from + event.count,\n                            event.to + event.count\n                        );\n                        for (let i = lowerBound; i < upperBound; ++i) {\n                            derivedCollection.fieldMap.set(\n                                i.toString(),\n                                initialTransform[i]\n                            );\n                        }\n                        break;\n                    }\n                    case ArrayEventType.SORT:\n                        for (\n                            let i = event.from;\n                            i < event.from + event.indexes.length;\n                            ++i\n                        ) {\n                            derivedCollection.fieldMap.set(\n                                i.toString(),\n                                initialTransform[i]\n                            );\n                        }\n                        break;\n                }\n            }\n        },\n        addArrayEvent,\n        addArrayEvent,\n        debugName ?? 'derived'\n    );\n\n    return derivedCollection.revocable.proxy;\n}\n\nfunction collectionRender<T>(\n    this: Collection<T>,\n    renderJSXNode: (jsxNode: JSXNode) => RenderNode\n): RenderNode {\n    return CollectionRenderNode(renderJSXNode, this, this.__debugName);\n}\n", "import type { ArrayEvent } from '../common/arrayevent';\nimport { addArrayEvent, ArrayEventType } from '../common/arrayevent';\nimport * as log from '../common/log';\nimport { Sentinel } from '../common/sentinel';\nimport type { View, ViewImpl } from './collection';\nimport { makeViewPrototype, ViewHandler } from './collection';\nimport type { Retainable } from './engine';\nimport { release, retain } from './engine';\nimport { Field } from './field';\nimport { FieldMap } from './fieldmap';\nimport { SubscriptionEmitter } from './subscriptionemitter';\nimport { TrackedDataHandle } from './trackeddata';\n\nexport enum DictEventType {\n    ADD = 'add',\n    SET = 'set',\n    DEL = 'del',\n}\nexport type DictEvent<K, V> =\n    | { type: DictEventType.ADD; prop: K; value: V }\n    | { type: DictEventType.SET; prop: K; value: V }\n    | { type: DictEventType.DEL; prop: K; value?: V };\n\nexport type Model<T extends {}> = T;\n\nfunction addDictEvent<K, V>(events: DictEvent<K, V>[], event: DictEvent<K, V>) {\n    // TODO: make smarter\n    events.push(event);\n}\n\nexport class Dict<K, V> implements Retainable {\n    private declare keysField: Field<number>;\n    private declare emitter: SubscriptionEmitter<DictEvent<K, V>>;\n    private declare fieldMap: FieldMap;\n    private declare ownKeys: Set<K>;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(entries: [K, V][] = [], debugName?: string) {\n        this.ownKeys = new Set();\n        this.keysField = new Field<number>(entries.length);\n        this.emitter = new SubscriptionEmitter<DictEvent<K, V>>(\n            addDictEvent,\n            debugName ?? 'map'\n        );\n        this.fieldMap = new FieldMap(\n            this.keysField,\n            null,\n            this.emitter,\n            debugName\n        );\n        for (const [key, value] of entries) {\n            this.ownKeys.add(key);\n            this.fieldMap.getOrMake(key, value);\n        }\n        this.__refcount = 0;\n        this.__debugName = debugName || 'map';\n    }\n\n    // Map interface\n    clear() {\n        this.fieldMap.clear();\n        this.ownKeys.forEach((key) => {\n            this.emitter.addEvent({\n                type: DictEventType.DEL,\n                prop: key,\n            });\n        });\n        this.ownKeys.clear();\n        this.keysField.set(this.ownKeys.size);\n    }\n\n    delete(key: K) {\n        this.fieldMap.delete(key);\n        if (this.ownKeys.has(key)) {\n            this.ownKeys.delete(key);\n            this.emitter.addEvent({\n                type: DictEventType.DEL,\n                prop: key,\n            });\n            this.keysField.set(this.ownKeys.size);\n        }\n    }\n\n    forEach(fn: (value: V, key: K) => void) {\n        for (const [key, value] of this.fieldMap.entries()) {\n            fn(value.get(), key);\n        }\n    }\n\n    get(key: K): V | undefined {\n        const field = this.fieldMap.getOrMake(key, Sentinel);\n        const value = field.get();\n        if (value === Sentinel) return undefined;\n        return value;\n    }\n\n    has(key: K) {\n        const field = this.fieldMap.getOrMake(key, Sentinel);\n        const value = field.get();\n        if (value === Sentinel) return false;\n        return true;\n    }\n\n    set(key: K, value: V): this {\n        this.fieldMap.set(key, value);\n        if (this.ownKeys.has(key)) {\n            this.emitter.addEvent({\n                type: DictEventType.SET,\n                prop: key,\n                value,\n            });\n        } else {\n            this.ownKeys.add(key);\n            this.emitter.addEvent({\n                type: DictEventType.ADD,\n                prop: key,\n                value,\n            });\n            this.keysField.set(this.ownKeys.size);\n        }\n        return this;\n    }\n\n    entries(debugName?: string): View<[K, V]> {\n        const initialEntries: [K, V][] = [...this.fieldMap.entries()] as any;\n        const derivedCollection = new TrackedDataHandle<\n            [K, V][],\n            ViewImpl<[K, V]>,\n            ArrayEvent<[K, V]>,\n            DictEvent<K, V>\n        >(\n            initialEntries,\n            ViewHandler,\n            makeViewPrototype(this),\n            this.emitter,\n            function* keysHandler(\n                target: [K, V][],\n                events: DictEvent<K, V>[]\n            ): IterableIterator<ArrayEvent<[K, V]>> {\n                const addEvent = (prop: K, value: V): ArrayEvent<[K, V]> => {\n                    const length = target.length;\n                    target.push([prop, value]);\n\n                    // Invalidate ranges\n                    derivedCollection.fieldMap.set(length.toString(), prop);\n                    derivedCollection.fieldMap.set('length', target.length);\n\n                    return {\n                        type: ArrayEventType.SPLICE,\n                        index: length,\n                        count: 0,\n                        items: [[prop, value]],\n                    };\n                };\n\n                for (const event of events) {\n                    switch (event.type) {\n                        case DictEventType.DEL: {\n                            const index = target.findIndex(\n                                (item) => item[0] === event.prop\n                            );\n                            if (index !== -1) {\n                                const prevLength = target.length;\n                                target.splice(index, 1);\n                                const newLength = target.length;\n\n                                // Invalidate ranges\n                                for (let i = index; i < target.length; ++i) {\n                                    derivedCollection.fieldMap.set(\n                                        i.toString(),\n                                        target[i]\n                                    );\n                                }\n                                for (let i = newLength; i < prevLength; ++i) {\n                                    derivedCollection.fieldMap.delete(\n                                        i.toString()\n                                    );\n                                }\n                                derivedCollection.fieldMap.set(\n                                    'length',\n                                    target.length\n                                );\n\n                                yield {\n                                    type: ArrayEventType.SPLICE,\n                                    index,\n                                    count: 1,\n                                    items: [],\n                                };\n                            }\n                            break;\n                        }\n                        case DictEventType.ADD: {\n                            yield addEvent(event.prop, event.value);\n                            break;\n                        }\n                        case DictEventType.SET: {\n                            const index = target.findIndex(\n                                (item) => item[0] === event.prop\n                            );\n                            if (index === -1) {\n                                yield addEvent(event.prop, event.value);\n                            } else {\n                                const entry: [K, V] = [event.prop, event.value];\n                                target.splice(index, 1, entry);\n                                yield {\n                                    type: ArrayEventType.SPLICE,\n                                    index,\n                                    count: 1,\n                                    items: [entry],\n                                };\n                            }\n                            break;\n                        }\n                        default:\n                            log.assertExhausted(event);\n                    }\n                }\n            },\n            addArrayEvent,\n            addDictEvent,\n            debugName\n        );\n        return derivedCollection.revocable.proxy;\n    }\n\n    keys(debugName?: string): View<K> {\n        return this.entries(debugName).mapView(([key, value]) => key);\n    }\n\n    values(debugName?: string): View<V> {\n        return this.entries(debugName).mapView(([key, value]) => value);\n    }\n\n    subscribe(handler: (events: DictEvent<K, V>[]) => void) {\n        retain(this.fieldMap);\n        const unsubscribe = this.emitter.subscribe((events) => {\n            handler(events);\n        });\n        return () => {\n            unsubscribe();\n            release(this.fieldMap);\n        };\n    }\n\n    field(key: K): Field<V | undefined> {\n        return this.fieldMap.getOrMake(key, undefined);\n    }\n\n    __alive() {\n        retain(this.fieldMap);\n    }\n    __dead() {\n        retain(this.emitter);\n    }\n}\n\nexport function dict<K, V>(entries: [K, V][] = [], debugName?: string) {\n    return new Dict<K, V>(entries, debugName);\n}\n", "import * as log from '../common/log';\nimport { release, retain } from './engine';\nimport { Field } from './field';\nimport { FieldMap } from './fieldmap';\nimport { SubscriptionEmitter } from './subscriptionemitter';\n\nexport enum ModelEventType {\n    SET = 'set',\n}\n\ninterface ModelHandle<T> {\n    target: T;\n    emitter: SubscriptionEmitter<ModelEvent>;\n    fieldMap: FieldMap;\n}\n\nexport type ModelEvent = { type: ModelEventType.SET; prop: string; value: any };\n\nexport type Model<T extends {}> = T;\n\nexport function addModelEvent(events: ModelEvent[], event: ModelEvent) {\n    // TODO: make smarter\n    events.push(event);\n}\n\nfunction getModelHandle<T extends {}>(model: Model<T>) {\n    return (model as any).__handle as ModelHandle<T> | undefined;\n}\n\nexport function model<T extends {}>(target: T, debugName?: string): Model<T> {\n    const keysField = new Field<number>(Object.keys(target).length);\n    const emitter = new SubscriptionEmitter<ModelEvent>(\n        addModelEvent,\n        debugName ?? 'model'\n    );\n    const fieldMap = new FieldMap(keysField, null, emitter, debugName);\n    const modelHandle: ModelHandle<T> = {\n        target,\n        emitter,\n        fieldMap,\n    };\n    const modelObj: Model<T> = { ...target };\n    Object.keys(target).forEach((key) => {\n        Object.defineProperty(modelObj, key, {\n            get: () => {\n                return fieldMap.getOrMake(key, target[key as keyof T]).get();\n            },\n            set: (newValue) => {\n                fieldMap.getOrMake(key, newValue).set(newValue);\n                emitter.addEvent({\n                    type: ModelEventType.SET,\n                    prop: key,\n                    value: newValue,\n                });\n            },\n        });\n    });\n    Object.defineProperty(modelObj, '__handle', { get: () => modelHandle });\n    return modelObj;\n}\n\nmodel.subscribe = function modelSubscribe<T extends {}>(\n    sourceModel: Model<T>,\n    handler: (event: ModelEvent[]) => void,\n    debugName?: string\n): () => void {\n    const modelHandle = getModelHandle(sourceModel);\n    log.assert(modelHandle, 'missing model __handle');\n    retain(modelHandle.emitter);\n    retain(modelHandle.fieldMap);\n    const unsubscribe = modelHandle.emitter.subscribe((events) => {\n        handler(events);\n    });\n    return () => {\n        unsubscribe();\n        release(modelHandle.emitter);\n        release(modelHandle.fieldMap);\n    };\n};\n\nmodel.field = function modelField<T extends {}, K extends keyof T>(\n    sourceModel: Model<T>,\n    field: K\n): Field<T[K]> {\n    const modelHandle = getModelHandle(sourceModel);\n    log.assert(modelHandle, 'missing model __handle');\n    return modelHandle.fieldMap.getOrMake(\n        field as string,\n        modelHandle.target[field]\n    );\n};\n", "import type { Dyn } from '../../common/dyn';\nimport { dynGet, dynSubscribe } from '../../common/dyn';\nimport * as log from '../../common/log';\nimport { wrapError } from '../../common/util';\nimport type { Retainable } from '../../model/engine';\nimport { release, retain, trackCreates } from '../../model/engine';\nimport type { Field } from '../../model/field';\nimport type { JSXNode } from '../jsx';\nimport { renderJSXNode } from '../renderjsx';\nimport type {\n    getWebComponentTagConstructors,\n    WebComponentInternalsKey,\n    WebComponentShadowSupportedExtends,\n} from '../webcomponents';\nimport type { ComponentLifecycle } from './componentrendernode';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\nexport type WebComponentProps<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n> = TShadowMode extends undefined\n    ? { [Key in TKeys]?: Dyn<string | undefined> } & { children: JSXNode }\n    : { [Key in TKeys]?: Dyn<string | undefined> };\n\nexport interface WebComponentLifecycle extends ComponentLifecycle {\n    host: HTMLElement;\n    shadowRoot: ShadowRoot | undefined;\n    elementInternals: ElementInternals | undefined;\n    addEventListener<K extends keyof HTMLElementEventMap>(\n        type: K,\n        listener: (\n            this: HTMLElement,\n            ev: HTMLElementEventMap[K],\n            el: HTMLElement // Added for convenience\n        ) => any,\n        options?: boolean | AddEventListenerOptions\n    ): () => void;\n    addEventListener(\n        type: string,\n        listener: (\n            this: HTMLElement,\n            ev: Event,\n            el: HTMLElement // Added for convenience\n        ) => any,\n        options?: boolean | AddEventListenerOptions\n    ): void;\n    bindElementInternalsAttribute: (\n        param: WebComponentInternalsKey,\n        value: Dyn<string | null>\n    ) => () => void;\n    bindFormValue: (formValue: Dyn<FormValue>) => () => void;\n    bindValidity: (validity: Dyn<Validity>) => () => void;\n    checkValidity: () => void;\n    reportValidity: () => void;\n}\n\nexport type WebFunctionComponent<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n> = (\n    props: WebComponentProps<TKeys, TShadowMode>,\n    lifecycle: WebComponentLifecycle\n) => JSX.Element | null;\n\nexport type WebComponent<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n> = WebFunctionComponent<TKeys, TShadowMode>;\n\nexport interface WebComponentOptions<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n    TExtends extends\n        | keyof ReturnType<typeof getWebComponentTagConstructors>\n        | undefined,\n> {\n    tagName: `${string}-${string}`;\n    Component: WebComponent<TKeys, TShadowMode>;\n    hydrateTemplateChild?: boolean | undefined;\n    observedAttributes?: TKeys[] | undefined;\n    formAssociated?: boolean | undefined;\n    shadowMode?: TExtends extends WebComponentShadowSupportedExtends\n        ? TShadowMode\n        : undefined;\n    delegatesFocus?: boolean | undefined;\n    extends?: TExtends;\n}\n\nexport interface Validity {\n    flags: {\n        valueMissing?: boolean;\n        typeMismatch?: boolean;\n        patternMismatch?: boolean;\n        tooLong?: boolean;\n        tooShort?: boolean;\n        rangeUnderflow?: boolean;\n        rangeOverflow?: boolean;\n        stepMismatch?: boolean;\n        badInput?: boolean;\n        customError?: boolean;\n    };\n    message?: string | undefined;\n    anchor?: HTMLElement | undefined;\n}\n\nexport type FormValue =\n    | string\n    | File\n    | FormData\n    | {\n          value: string | File | FormData;\n          state?: string | File | FormData | undefined;\n      };\n\nexport function WebComponentRenderNode<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n    TExtends extends\n        | keyof ReturnType<typeof getWebComponentTagConstructors>\n        | undefined,\n>(\n    host: HTMLElement,\n    shadowRoot: ShadowRoot | undefined,\n    elementInternals: ElementInternals | undefined,\n    options: WebComponentOptions<TKeys, TShadowMode, TExtends>,\n    childrenField: Field<Node[] | undefined>,\n    fields: Record<TKeys, Field<string | undefined>>,\n    debugName?: string\n): RenderNode {\n    let result: RenderNode | Error | undefined;\n    let onMountCallbacks: undefined | (() => (() => void) | void)[];\n    let onUnmountCallbacks: undefined | (() => void)[];\n    let onDestroyCallbacks: undefined | (() => void)[];\n    const owned: Set<Retainable> = new Set();\n    let errorHandler: ((e: Error) => RenderNode | null) | undefined;\n\n    function ensureResult() {\n        if (!result) {\n            let callbacksAllowed = true;\n            const lifecycle: WebComponentLifecycle = {\n                onMount: (handler: () => (() => void) | void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onMount must be called in component body'\n                    );\n                    if (!onMountCallbacks) onMountCallbacks = [];\n                    onMountCallbacks.push(handler);\n                },\n                onUnmount: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onUnmount must be called in component body'\n                    );\n                    if (!onUnmountCallbacks) onUnmountCallbacks = [];\n                    onUnmountCallbacks.push(handler);\n                },\n                onDestroy: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onDestroy must be called in component body'\n                    );\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(handler);\n                },\n                onError: (handler: (e: Error) => RenderNode | null) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onError must be called in component body'\n                    );\n                    log.assert(!errorHandler, 'onError called multiple times');\n                    errorHandler = handler;\n                },\n                host,\n                elementInternals,\n                shadowRoot,\n                addEventListener: (\n                    name: string,\n                    handler: (\n                        this: HTMLElement,\n                        event: Event,\n                        el: HTMLElement\n                    ) => void,\n                    options?: boolean | AddEventListenerOptions\n                ) => {\n                    const listener = (event: Event) => {\n                        handler.call(host, event, host);\n                    };\n                    host.addEventListener(name, listener, options);\n                    const unsubscribe = () => {\n                        host.removeEventListener(name, listener, options);\n                    };\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                bindElementInternalsAttribute: (param, value) => {\n                    // @ts-expect-error // for some reason, ariaDescription is missing from the ARIAMixin definition. Probably need to update type dependencies\n                    elementInternals[param] = dynGet(value);\n                    const unsubscribe = dynSubscribe(value, (err, newValue) => {\n                        if (err === undefined) {\n                            // @ts-expect-error // for some reason, ariaDescription is missing from the ARIAMixin definition. Probably need to update type dependencies\n                            elementInternals[param] = newValue;\n                        } else {\n                            // TODO: what to do on errors?\n                        }\n                    });\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                bindFormValue: (formValue) => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    const update = (formValue: FormValue) => {\n                        if (\n                            typeof formValue === 'string' ||\n                            formValue instanceof File ||\n                            formValue instanceof FormData\n                        ) {\n                            elementInternals?.setFormValue(formValue);\n                        } else {\n                            const { value, state } = formValue;\n                            if (state === undefined) {\n                                elementInternals?.setFormValue(value);\n                            } else {\n                                elementInternals?.setFormValue(value, state);\n                            }\n                        }\n                    };\n                    update(dynGet(formValue));\n                    const unsubscribe = dynSubscribe(\n                        formValue,\n                        (err, newVal) => {\n                            if (err === undefined) {\n                                update(newVal);\n                            } else {\n                                // TODO: what to do on error?\n                            }\n                        }\n                    );\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                bindValidity: (validity) => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    const update = (validity: Validity) => {\n                        const { flags, message, anchor } = validity;\n                        elementInternals?.setValidity(flags, message, anchor);\n                    };\n                    const val = dynGet(validity);\n                    update(val);\n                    const unsubscribe = dynSubscribe(validity, (err, val) => {\n                        if (err === undefined) {\n                            update(val);\n                        } else {\n                            // TODO: what to do on error?\n                        }\n                    });\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                checkValidity: () => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    elementInternals?.checkValidity();\n                },\n                reportValidity: () => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    elementInternals?.reportValidity();\n                },\n            };\n\n            const componentProps: any =\n                options.shadowMode === undefined\n                    ? {\n                          ...fields,\n                          children: renderJSXNode(childrenField),\n                      }\n                    : {\n                          ...fields,\n                      };\n            const Component = options.Component;\n            let jsxResult: RenderNode | Error;\n            try {\n                jsxResult = trackCreates(\n                    owned,\n                    () =>\n                        Component(componentProps, lifecycle) || emptyRenderNode\n                );\n            } catch (e) {\n                const error = wrapError(e, 'Unknown error rendering component');\n                if (errorHandler) {\n                    jsxResult = errorHandler(error) ?? emptyRenderNode;\n                } else {\n                    jsxResult = error;\n                }\n            }\n            callbacksAllowed = false;\n            for (const item of owned) {\n                retain(item);\n            }\n            if (!(jsxResult instanceof Error)) {\n                result = renderJSXNode(jsxResult);\n            } else {\n                result = jsxResult;\n            }\n        }\n        return result;\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAlive: () => {\n                const result = ensureResult();\n                if (result instanceof Error) {\n                    log.warn('Unhandled exception on detached component', {\n                        error: result,\n                        renderNode: renderNode,\n                    });\n                } else {\n                    renderNode.setChild(result);\n                }\n            },\n            onDestroy: () => {\n                if (onDestroyCallbacks) {\n                    for (const callback of onDestroyCallbacks) {\n                        callback();\n                    }\n                }\n\n                result = undefined;\n                onMountCallbacks = undefined;\n                onUnmountCallbacks = undefined;\n                onDestroyCallbacks = undefined;\n                errorHandler = undefined;\n\n                for (const item of owned) {\n                    release(item);\n                }\n                owned.clear();\n            },\n            onAttach: (parentContext) => {\n                if (result instanceof Error) {\n                    parentContext.errorEmitter(result);\n                }\n            },\n            onError: (error: Error) => {\n                if (errorHandler) {\n                    const handledResult = errorHandler(error);\n                    result = handledResult\n                        ? renderJSXNode(handledResult)\n                        : emptyRenderNode;\n                    renderNode.setChild(result);\n                    return true;\n                }\n            },\n            onMount() {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_MOUNT);\n            },\n            onUnmount() {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                if (onUnmountCallbacks) {\n                    for (const callback of onUnmountCallbacks) {\n                        callback();\n                    }\n                }\n            },\n            onCommit(phase: RenderNodeCommitPhase) {\n                if (\n                    phase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n                    onMountCallbacks\n                ) {\n                    for (const callback of onMountCallbacks) {\n                        const maybeOnUnmount = callback();\n                        if (typeof maybeOnUnmount === 'function') {\n                            if (!onUnmountCallbacks) {\n                                onUnmountCallbacks = [];\n                            }\n                            const onUnmount = () => {\n                                maybeOnUnmount();\n                                if (onUnmountCallbacks) {\n                                    const index =\n                                        onUnmountCallbacks.indexOf(onUnmount);\n                                    if (index >= 0) {\n                                        onUnmountCallbacks.splice(index, 1);\n                                    }\n                                }\n                            };\n                            onUnmountCallbacks.push(onUnmount);\n                        }\n                    }\n                }\n            },\n            clone() {\n                log.assert(\n                    false,\n                    \"Attempted to clone a WebComponentRenderNode -- this operation doesn't make sense\"\n                );\n            },\n        },\n        emptyRenderNode,\n        debugName ?? `web-component(${options.tagName})`\n    );\n    return renderNode;\n}\n", "import * as log from '../common/log';\nimport type { Retainable } from '../model/engine';\nimport { release, retain } from '../model/engine';\nimport type { Field } from '../model/field';\nimport { field } from '../model/field';\nimport { PortalRenderNode } from './rendernode/portalrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\nimport type { WebComponentOptions } from './rendernode/webcomponentrendernode';\nimport { WebComponentRenderNode } from './rendernode/webcomponentrendernode';\nimport { getWebComponentTagConstructors } from './webcomponents';\nimport { HTML_NAMESPACE } from './xmlnamespace';\n\nexport function defineCustomElement<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined = undefined,\n    TExtends extends\n        | keyof ReturnType<typeof getWebComponentTagConstructors>\n        | undefined = undefined,\n>(options: WebComponentOptions<TKeys, TShadowMode, TExtends>) {\n    const Superclass = options.extends\n        ? getWebComponentTagConstructors()[options.extends]\n        : HTMLElement;\n    class GooeyCustomElement extends Superclass implements Retainable {\n        __debugName: string;\n        __refcount: number;\n        _originalChildren: Node[] | null;\n        _unmount: (() => void) | undefined;\n        _portalRenderNode: RenderNode | null;\n        _renderNode: RenderNode | null;\n        _childrenField: Field<Node[] | undefined>;\n        _fields: Record<TKeys, Field<string | undefined>>;\n        static formAssociated = options.formAssociated || false;\n        static observedAttributes = options.observedAttributes ?? [];\n\n        constructor() {\n            super();\n            const shadowRoot = options.shadowMode\n                ? this.attachShadow({\n                      delegatesFocus: options.delegatesFocus,\n                      mode: options.shadowMode,\n                  })\n                : undefined;\n\n            const elementInternals = options.extends\n                ? undefined\n                : this.attachInternals();\n\n            this._childrenField = field<Node[] | undefined>(undefined);\n            this._fields = {} as Record<TKeys, Field<string | undefined>>;\n            options.observedAttributes?.forEach((attr) => {\n                this._fields[attr] = field<string | undefined>(undefined);\n            });\n\n            this._renderNode = WebComponentRenderNode(\n                this,\n                shadowRoot,\n                elementInternals,\n                options,\n                this._childrenField,\n                this._fields\n            );\n            this._portalRenderNode = PortalRenderNode(\n                shadowRoot || this,\n                this._renderNode,\n                undefined\n            );\n            this._originalChildren = null;\n            this.__debugName = `custom:${options.tagName}`;\n            this.__refcount = 0;\n        }\n\n        __dead() {\n            this._portalRenderNode?.release();\n            if (this._originalChildren) {\n                this.replaceChildren(...this._originalChildren);\n            }\n        }\n\n        __alive() {\n            if (\n                options.hydrateTemplateChild !== false &&\n                this.children.length === 1 &&\n                this.children[0] instanceof HTMLTemplateElement\n            ) {\n                this._originalChildren = Array.from(this.childNodes);\n                this.replaceChildren(\n                    ...this._originalChildren.map((node) =>\n                        node instanceof HTMLTemplateElement\n                            ? node.content\n                            : node\n                    )\n                );\n            }\n            let children: Node[] = [];\n            if (!options.shadowMode) {\n                children = Array.from(this.childNodes);\n                this.replaceChildren();\n                this._childrenField.set(children);\n            }\n            this._portalRenderNode?.retain();\n            this._portalRenderNode?.attach({\n                nodeEmitter: (event) => {\n                    log.assert(false, 'Unexpected event from Portal', event);\n                },\n                errorEmitter: (error) => {\n                    log.error('Unhandled web component mount error', error);\n                },\n                xmlNamespace: this.namespaceURI ?? HTML_NAMESPACE,\n            });\n        }\n\n        retain() {\n            retain(this);\n        }\n\n        release() {\n            release(this);\n        }\n\n        connectedCallback() {\n            this.retain();\n            this._portalRenderNode?.onMount();\n        }\n\n        disconnectedCallback() {\n            this._portalRenderNode?.onUnmount();\n            this.release();\n        }\n\n        adoptedCallback() {\n            // TODO: what should be done here?\n        }\n\n        attributeChangedCallback(\n            name: string,\n            oldValue: string,\n            newValue: string\n        ) {\n            this._fields[name as TKeys].set(newValue);\n        }\n    }\n    if (options.extends) {\n        customElements.define(options.tagName, GooeyCustomElement, {\n            extends: options.extends,\n        });\n    } else {\n        customElements.define(options.tagName, GooeyCustomElement);\n    }\n}\n", "import * as log from '../common/log';\nimport { flush } from '../model/engine';\nimport { ArrayRenderNode } from './rendernode/arrayrendernode';\nimport { ForeignRenderNode } from './rendernode/foreignrendernode';\nimport { PortalRenderNode } from './rendernode/portalrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\nimport { HTML_NAMESPACE } from './xmlnamespace';\n\nexport function mount(\n    target: Element | ShadowRoot,\n    node: RenderNode\n): () => void {\n    const skipNodes = target.childNodes.length;\n    const children: RenderNode[] = [];\n    for (let i = 0; i < target.childNodes.length; ++i) {\n        children.push(ForeignRenderNode(target.childNodes[i]));\n    }\n    children.push(node);\n    const root = PortalRenderNode(\n        target,\n        ArrayRenderNode(children),\n        null,\n        'root'\n    );\n    root.retain();\n    let syncError: undefined | Error;\n    root.attach({\n        nodeEmitter: (event) => {\n            log.assert(false, 'Unexpected event emitted by Portal', event);\n        },\n        errorEmitter: (error) => {\n            syncError = error;\n            log.error('Unhandled mount error', error);\n        },\n        xmlNamespace:\n            (target instanceof Element\n                ? target.namespaceURI\n                : target.host.namespaceURI) ?? HTML_NAMESPACE,\n    });\n    if (syncError) {\n        root.release();\n        throw syncError;\n    }\n    // WE HAVE A CONUNDRUM!\n    // - When onMount() is called _before_ flushing, IntrinsicObserver callbacks work as expected; but component onMount notifications fail\n    // - When onMount() is called _after_ flushing, IntrinsicObserver callbacks fail; but component onMount notifications work as expected\n    // This is probably because the interaction between mounting and commit is very awkward when dealing with DOM nodes\n    // - For onMount lifecycles to be able to observe nodes in the DOM, onMount needs to happen __after__ commit\n    // - ref={} callbacks should be equivalent to onMount\n    // - refRaw={} callbacks should be equivalent to retain() (NEEDS BETTER NAME)\n    // Overall, it really sucks that we have to flush at all here.\n    root.onMount();\n    flush();\n    return () => {\n        const nodesToKeep = Array.from(target.childNodes).slice(0, skipNodes);\n        root.onUnmount();\n        flush();\n        target.replaceChildren(...nodesToKeep);\n        root.detach();\n        root.release();\n    };\n}\n"],
  "mappings": "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",
  "names": ["Fragment", "debug", "ArrayEventType", "realIndex", "processHandler", "defaultScheduler", "debug", "error", "event", "renderJSXNode", "subscribe", "error", "error", "error", "error", "createElement", "element", "props", "Fragment", "IntrinsicObserverEventType", "renderJSXNode", "collection", "field", "field", "field", "target", "renderJSXNode", "DictEventType", "field", "ModelEventType", "model", "field", "options", "formValue", "validity", "val", "error", "result", "error", "error"]
}
