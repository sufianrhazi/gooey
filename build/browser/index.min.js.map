{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/types.ts", "../../src/log.ts", "../../src/util.ts", "../../src/graph.ts", "../../src/debug.ts", "../../src/calc.ts", "../../src/jsx.ts", "../../src/vnode.ts", "../../src/view.ts", "../../src/collection.ts", "../../src/trackeddata.ts", "../../src/model.ts"],
  "sourcesContent": ["export { getLogLevel, setLogLevel } from './log';\nexport type { LogLevel } from './log';\nimport { createElement } from './view';\nexport { Fragment, mount } from './view';\nexport type { Component } from './jsx';\nexport { model } from './model';\nexport { collection } from './collection';\nexport {\n    calc,\n    effect,\n    reset,\n    subscribe,\n    flush,\n    nextFlush,\n    retain,\n    release,\n    debug,\n    debugState,\n    debugSubscribe,\n} from './calc';\n\nexport type {\n    Ref,\n    Calculation,\n    Collection,\n    View,\n    Model,\n    Context,\n} from './types';\nexport { ref, createContext, InvariantError } from './types';\n\nexport default createElement;\n\nexport const VERSION =\n    typeof LIB_VERSION === 'string' ? LIB_VERSION : 'development';\n", "export class InvariantError extends Error {\n    detail?: any;\n    constructor(msg: string, detail?: any) {\n        super(msg);\n        this.detail = detail;\n    }\n}\n\nexport const TypeTag = Symbol('typeTag');\nexport const ContextGetterTag = Symbol('contextGetter');\nexport const DataTypeTag = Symbol('dataTypeTag');\nexport const CalculationTypeTag = Symbol('calculationType');\nexport const CalculationRecalculateTag = Symbol('calculationRecalculate');\nexport const CalculationInvalidateTag = Symbol('calculationInvalidate');\nexport const CalculationSetCycleTag = Symbol('calculationSetCycle');\n\nexport const ObserveKey = Symbol('observe');\nexport const GetSubscriptionNodeKey = Symbol('getSubscriptionNode');\nexport const MakeModelViewKey = Symbol('makeModelView');\nexport const DisposeKey = Symbol('dispose');\nexport const FlushKey = Symbol('flush');\nexport const AddDeferredWorkKey = Symbol('addDeferredWork');\nexport const NotifyKey = Symbol('notify');\n\nexport type ProcessAction = 'recalculate' | 'cycle' | 'invalidate';\n\n/**\n * A ref object that can be passed to native elements.\n */\nexport type Ref<T> = {\n    [TypeTag]: 'ref';\n    current: T | undefined;\n};\nexport function isRef(ref: any): ref is Ref<unknown> {\n    return ref && ref[TypeTag] === 'ref';\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val?: T): Ref<T> {\n    return {\n        [TypeTag]: 'ref',\n        current: val,\n    };\n}\n\nexport type ModelEvent =\n    | {\n          type: 'add';\n          key: string | number | symbol;\n      }\n    | {\n          type: 'set';\n          key: string | number | symbol;\n          value: any;\n      }\n    | {\n          type: 'delete';\n          key: string | number | symbol;\n      };\nexport type ModelObserver = (event: ModelEvent) => void;\n\nexport type EqualityFunc<T> = (a: T, b: T) => boolean;\nexport type MappingFunction<T, V> = (item: T) => V;\nexport type FilterFunction<T> = (item: T) => boolean;\nexport type FlatMapFunction<T, V> = (item: T) => V[];\n\nexport interface ViewSpec<TInitialize, TItem, TEvent> {\n    /**\n     * Return initial items\n     */\n    initialize: (items: TInitialize) => TItem[];\n\n    /**\n     * Process subscription events\n     */\n    processEvent: (\n        view: Collection<TItem>,\n        event: TEvent,\n        initialValue: TItem[]\n    ) => void;\n}\n\nexport type CollectionEvent<T> =\n    | {\n          type: 'splice';\n          index: number;\n          count: number;\n          items: readonly T[];\n          removed: readonly T[];\n      }\n    | {\n          type: 'move';\n          fromIndex: number;\n          fromCount: number;\n          toIndex: number;\n          moved: readonly T[];\n      }\n    | {\n          type: 'sort';\n          indexes: readonly number[];\n      };\n\nexport type TrackedData<TTypeTag, TEvent> = {\n    $__id: string;\n    [TypeTag]: 'data';\n    [DataTypeTag]: TTypeTag;\n    [FlushKey]: () => boolean;\n    [AddDeferredWorkKey]: (task: () => void) => void;\n    [ObserveKey]: (\n        listener: (events: TEvent[], subscriptionNode: Subscription) => void\n    ) => () => void;\n    [GetSubscriptionNodeKey]: () => Subscription;\n    [NotifyKey](event: TEvent): void; // Note: bivariance needed here!\n    [DisposeKey]: () => void;\n};\n\n/**\n * A mutable object to hold state\n */\ninterface ModelMethods<T extends {}> {\n    [MakeModelViewKey]: <V>(\n        modelViewSpec: ViewSpec<Readonly<T>, V, ModelEvent>,\n        debugName?: string\n    ) => View<V>;\n}\nexport type Model<T> = TrackedData<'model', ModelEvent> &\n    ModelMethods<T> & {\n        [Key in keyof T]: T[Key];\n    };\n\n/**\n * A mutable array to hold state, with some additional convenience methods\n */\ninterface CollectionMethods<T> {\n    makeView<V>(\n        viewSpec: ViewSpec<readonly T[], V, CollectionEvent<T>>,\n        debugName?: string\n    ): View<V>;\n    mapView<V>(mapFn: MappingFunction<T, V>, debugName?: string): View<V>;\n    filterView(filterFn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(\n        flatMapFn: MappingFunction<T, V[]>,\n        debugName?: string\n    ): View<V>;\n    reject(shouldReject: (item: T, index: number) => boolean): T[];\n    moveSlice(fromIndex: number, fromCount: number, toIndex: number): void;\n}\nexport interface Collection<T>\n    extends TrackedData<'collection', CollectionEvent<T>>,\n        CollectionMethods<T>,\n        Array<T> {}\n\n/**\n * A readonly array to hold projected state\n */\ninterface ViewMethods<T> {\n    makeView<V>(\n        viewSpec: ViewSpec<readonly T[], V, CollectionEvent<T>>,\n        debugName?: string\n    ): View<V>;\n    mapView<V>(mapFn: MappingFunction<T, V>, debugName?: string): View<V>;\n    filterView(filterFn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(\n        flatMapFn: MappingFunction<T, V[]>,\n        debugName?: string\n    ): View<V>;\n}\nexport interface View<T>\n    extends TrackedData<'collection', CollectionEvent<T>>,\n        ViewMethods<T>,\n        ReadonlyArray<T> {}\n\nexport interface Subscription {\n    $__id: string;\n    [TypeTag]: 'subscription';\n    item: any;\n    [FlushKey]: () => boolean;\n}\n\nexport interface NodeOrdering {\n    $__id: string;\n    [TypeTag]: 'nodeOrdering';\n}\n\n/**\n * A key-value pair that is active for a subtree\n */\nexport interface Context<TValue> {\n    (): never;\n    [ContextGetterTag]: () => TValue;\n    [TypeTag]: 'context';\n}\n\nexport function createContext<TValue>(val: TValue): Context<TValue> {\n    return Object.assign(\n        () => {\n            throw new Error('Do not call contexts as functions');\n        },\n        {\n            [ContextGetterTag]: () => val,\n            [TypeTag]: 'context' as const,\n        }\n    );\n}\n\nexport function getContext<TValue>(context: Context<TValue>): TValue {\n    return context[ContextGetterTag]();\n}\n\nexport function isContext(val: any): val is Context<any> {\n    return !!(val && val[TypeTag] === 'context');\n}\n\n/**\n * A calculation cell that recalculates when dependencies change\n */\nexport interface Calculation<Result> {\n    (): Result;\n    $__id: string;\n    [TypeTag]: 'calculation';\n    [CalculationTypeTag]: 'calculation' | 'effect';\n    dispose: () => void;\n    onError: (handler: (errorType: 'cycle' | 'error') => Result) => this;\n    [CalculationSetCycleTag]: () => boolean;\n    [CalculationRecalculateTag]: () => boolean;\n    [CalculationInvalidateTag]: () => void;\n}\n\nexport interface ModelField {\n    $__id: string;\n    model: {\n        [DataTypeTag]: any;\n    };\n    key: string | number | symbol;\n}\n\nexport function isModel(thing: any): thing is Model<unknown> {\n    return !!(\n        thing &&\n        thing[TypeTag] === 'data' &&\n        thing[DataTypeTag] === 'model'\n    );\n}\n\nexport function isModelField(thing: any): thing is ModelField {\n    return !!(\n        thing &&\n        !thing[TypeTag] &&\n        !!thing.model &&\n        !!thing.model[DataTypeTag]\n    );\n}\n\nexport function isCollection(thing: any): thing is Collection<any> | View<any> {\n    return !!(\n        thing &&\n        thing[TypeTag] === 'data' &&\n        thing[DataTypeTag] === 'collection'\n    );\n}\n\nexport function isCalculation(thing: any): thing is Calculation<any> {\n    return !!(thing && thing[TypeTag] === 'calculation');\n}\n\nexport function isEffect(thing: Calculation<unknown>): boolean {\n    return thing[CalculationTypeTag] === 'effect';\n}\n\nexport function isSubscription(thing: any): thing is Subscription {\n    return !!(thing && thing[TypeTag] === 'subscription');\n}\n\nexport function isNodeOrdering(thing: any): thing is NodeOrdering {\n    return !!(thing && thing[TypeTag] === 'nodeOrdering');\n}\n\nexport type GraphNode = { $__id: string };\n", "import { InvariantError } from './types';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function getLogLevel(): LogLevel {\n    if (currentLevel >= levels.info) return 'info';\n    if (currentLevel >= levels.warn) return 'warn';\n    if (currentLevel >= levels.debug) return 'debug';\n    return 'error';\n}\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function assert(check: any, msg: string): asserts check {\n    if (!check) {\n        error(\n            'Assertion failure',\n            check === undefined\n                ? 'undefined'\n                : check === null\n                ? 'null'\n                : check.toString(),\n            'is not truthy',\n            msg\n        );\n        throw new InvariantError(`Assertion failure: ${msg}`);\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new InvariantError('Assertion failure', { context, items });\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\nexport const uniqueid = (() => {\n    let id = 0;\n    return () => (id++).toString();\n})();\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy<TItem, TKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TKey, TVal]\n): Map<TKey, TVal[]> {\n    const grouped: Map<TKey, TVal[]> = new Map();\n    items.forEach((item) => {\n        const [key, val] = grouper(item);\n        let inner = grouped.get(key);\n        if (!inner) {\n            inner = [];\n            grouped.set(key, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function strictEqual<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low)) + low;\n}\n\nexport function median(numbers: number[]): number {\n    const sorted = numbers.slice().sort((a, b) => a - b);\n    return (\n        (sorted[Math.floor((numbers.length - 1) / 2)] +\n            sorted[Math.ceil((numbers.length - 1) / 2)]) /\n        2\n    );\n}\n", "import * as log from './log';\nimport type { ProcessAction } from './types';\nimport { groupBy } from './util';\n\n/**\n * A directed graph\n *\n * Edges may me marked as Graph.EDGE_SOFT (visualized as ->) or Graph.EDGE_HARD (visualized as =>):\n * - An EDGE_SOFT edge from A to B indicate an order dependency, but not a data dependency\n *   - If A and B are both dirty, A should be flushed **after** B is flushed\n *   - If A is not dirty and B is dirty and B is visited and B does not short-circuit, A does not get marked as dirty\n *   - Used to ensure that the DOM structure is updated in the correct order\n *     - onEffect() effects are executed after all of the calc() present in a component's DOM\n *     - \"parent\" calc() view nodes are executed after \"child\" calc() view nodes\n * - An EDGE_HARD edge from A to B indicates both order dependency and data dependency\n *   - If A and B are both dirty, A should be flushed **after** B is flushed\n *   - If A is not dirty and B is dirty and B is visited and B does not short-circuit, A gets marked as dirty and is visited\n */\nexport class Graph<Type extends object> {\n    private static EDGE_NONE = 0b00 as const;\n    static EDGE_SOFT = 0b01 as const;\n    static EDGE_HARD = 0b10 as const;\n    private static EDGE_ANY = 0b11 as const;\n\n    private nextId: number;\n    private nodesSet: Record<string, Type>;\n    private retained: Record<string, true>;\n    private dirtyNodes: Record<string, true>;\n    private knownCycles: Record<string, boolean>;\n\n    private graph: Record<string, Record<string, number>>;\n    private reverseGraph: Record<string, Record<string, number>>;\n\n    constructor() {\n        this.nextId = 1;\n        this.nodesSet = {};\n        this.retained = {};\n        this.graph = {};\n        this.reverseGraph = {};\n        this.dirtyNodes = {};\n        this.knownCycles = {};\n    }\n\n    private getId(node: Type): string {\n        return (node as any).$__id;\n    }\n\n    addNode(node: Type): boolean {\n        const nodeId = this.getId(node);\n        if (this.nodesSet[nodeId]) return false;\n        this.graph[nodeId] = {};\n        this.reverseGraph[nodeId] = {};\n        this.nodesSet[nodeId] = node;\n        return true;\n    }\n\n    hasNode(node: Type): boolean {\n        return !!this.nodesSet[this.getId(node)];\n    }\n\n    markNodeDirty(node: Type): void {\n        this.dirtyNodes[this.getId(node)] = true;\n    }\n\n    private getRecursiveDependenciesInner(nodeId: string): {\n        otherNodeIds: Record<string, 1 | 2 | undefined>;\n        otherNodes: Type[];\n        isCycle: boolean;\n    } {\n        const otherNodeIds: Record<string, 1 | 2 | undefined> = {};\n        const otherNodes: Type[] = [];\n        let foundCycle = false;\n        const visit = (visitId: string) => {\n            if (otherNodeIds[visitId] === 2) foundCycle = true;\n            if (otherNodeIds[visitId]) return;\n            if (visitId !== nodeId) otherNodes.push(this.nodesSet[visitId]);\n            otherNodeIds[visitId] = 2;\n            this.getDependenciesInner(visitId, Graph.EDGE_ANY).forEach(\n                (toId) => {\n                    visit(toId);\n                }\n            );\n            otherNodeIds[visitId] = 1;\n        };\n\n        visit(nodeId);\n        return { otherNodeIds, otherNodes, isCycle: foundCycle };\n    }\n\n    getRecursiveDependencies(node: Type): Type[] {\n        const nodeId = this.getId(node);\n        const { otherNodes, isCycle } =\n            this.getRecursiveDependenciesInner(nodeId);\n        log.assert(!isCycle, 'getRecursiveDependencies found a cycle');\n        return otherNodes;\n    }\n\n    hasDirtyNodes(): boolean {\n        return Object.keys(this.dirtyNodes).length > 0;\n    }\n\n    /**\n     * Indicate that toNode needs to be updated if fromNode has changed\n     */\n    addEdge(fromNode: Type, toNode: Type, kind: 0b01 | 0b10): void {\n        const fromId = this.getId(fromNode);\n        const toId = this.getId(toNode);\n        this.addEdgeInner(fromId, toId, kind);\n    }\n\n    private addEdgeInner(\n        fromId: string,\n        toId: string,\n        kind: 0b01 | 0b10\n    ): void {\n        log.assert(\n            !!this.nodesSet[fromId],\n            'cannot add edge from node that does not exist'\n        );\n        log.assert(\n            !!this.nodesSet[toId],\n            'cannot add edge to node that does not exist'\n        );\n        this.graph[fromId][toId] = (this.graph[fromId][toId] || 0) | kind;\n        this.reverseGraph[toId][fromId] =\n            (this.reverseGraph[toId][fromId] || 0) | kind;\n    }\n\n    /**\n     * Returns true if edge is removed\n     */\n    removeEdge(fromNode: Type, toNode: Type, kind: 0b01 | 0b10 | 0b11) {\n        const fromId = this.getId(fromNode);\n        const toId = this.getId(toNode);\n        this.removeEdgeInner(fromId, toId, kind);\n    }\n\n    private removeEdgeInner(\n        fromId: string,\n        toId: string,\n        kind: 0b01 | 0b10 | 0b11\n    ) {\n        log.assert(\n            !!this.nodesSet[fromId],\n            'cannot remove edge from node that does not exist'\n        );\n        log.assert(\n            !!this.nodesSet[toId],\n            'cannot remove edge to node that does not exist'\n        );\n        this.graph[fromId][toId] = (this.graph[fromId][toId] || 0) & ~kind;\n        this.reverseGraph[toId][fromId] =\n            (this.reverseGraph[toId][fromId] || 0) & ~kind;\n    }\n\n    removeNode(node: Type) {\n        const nodeId = this.getId(node);\n        this.removeNodeInner(nodeId);\n    }\n\n    private removeNodeInner(nodeId: string) {\n        log.assert(\n            !this.retained[nodeId],\n            'attempted to remove a retained node'\n        ); // Is this right?\n        const toIds = this.getDependenciesInner(nodeId);\n        const fromIds = this.getReverseDependenciesInner(nodeId);\n\n        // delete fromId -> nodeId for fromId in fromIds\n        fromIds.forEach((fromId) => {\n            this.graph[fromId][nodeId] = 0;\n            this.reverseGraph[nodeId][fromId] = 0;\n        });\n        // delete nodeId -> toId for toId in toIds\n        toIds.forEach((toId) => {\n            this.reverseGraph[toId][nodeId] = 0;\n            this.graph[nodeId][toId] = 0;\n        });\n        delete this.nodesSet[nodeId];\n        delete this.dirtyNodes[nodeId];\n        delete this.retained[nodeId];\n        delete this.knownCycles[nodeId];\n    }\n\n    retain(node: Type) {\n        const nodeId = this.getId(node);\n        log.assert(!this.retained[nodeId], 'double-retain');\n        this.retained[nodeId] = true;\n    }\n\n    release(node: Type) {\n        const nodeId = this.getId(node);\n        log.assert(this.retained[nodeId], 'double-release');\n        delete this.retained[nodeId];\n    }\n\n    replaceIncoming(node: Type, newIncomingNodes: Type[]) {\n        const toId = this.getId(node);\n\n        const beforeFromIds = this.getReverseDependenciesInner(\n            toId,\n            Graph.EDGE_HARD\n        );\n        const beforeFromSet = new Set(beforeFromIds);\n        const newFromIds = newIncomingNodes.map((fromNode) =>\n            this.getId(fromNode)\n        );\n        const newFromSet = new Set(newFromIds);\n        beforeFromIds.forEach((fromId) => {\n            if (!newFromSet.has(fromId)) {\n                this.removeEdgeInner(fromId, toId, Graph.EDGE_HARD);\n            }\n        });\n        newFromIds.forEach((fromId) => {\n            if (!beforeFromSet.has(fromId)) {\n                this.addEdgeInner(fromId, toId, Graph.EDGE_HARD);\n            }\n        });\n    }\n\n    removeIncoming(node: Type) {\n        const toId = this.getId(node);\n\n        const fromIds = this.getReverseDependenciesInner(toId);\n        fromIds.forEach((fromId) => {\n            this.removeEdgeInner(fromId, toId, Graph.EDGE_HARD);\n        });\n    }\n\n    /**\n     * Get dependencies (specify EDGE_SOFT, EDGE_HARD, or EDGE_ANY)\n     */\n    private getDependenciesInner(\n        nodeId: string,\n        edgeType: 0b01 | 0b10 | 0b11 = Graph.EDGE_ANY\n    ): string[] {\n        if (!this.graph[nodeId]) return [];\n        return Object.keys(this.graph[nodeId]).filter(\n            (toId) => (this.graph[nodeId][toId] || 0) & edgeType\n        );\n    }\n\n    /**\n     * Get reverse dependencies (either EDGE_SOFT or EDGE_HARD)\n     */\n    private getReverseDependenciesInner(\n        nodeId: string,\n        edgeType: 0b01 | 0b10 | 0b11 = Graph.EDGE_ANY\n    ): string[] {\n        if (!this.reverseGraph[nodeId]) return [];\n        return Object.keys(this.reverseGraph[nodeId]).filter(\n            (fromId) => (this.reverseGraph[nodeId][fromId] || 0) & edgeType\n        );\n    }\n\n    /**\n     * Get list of things need to be updated, when fromNode has changed?\n     */\n    getDependencies(\n        fromNode: Type,\n        edgeType: 0b01 | 0b10 | 0b11 = Graph.EDGE_ANY\n    ): Type[] {\n        const nodeId = this.getId(fromNode);\n        return this.getDependenciesInner(nodeId, edgeType).map(\n            (toId) => this.nodesSet[toId]\n        );\n    }\n\n    /**\n     * This uses Tarjan's strongly connected components algorithm to build the\n     * topological sort of the subgraph that contains all retained nodes.\n     *\n     * Note: Because we are starting at retained nodes, which should be \"end\"\n     * bestination nodes, we build a topological sort of the _reverse graph_.\n     * Due to the nature of Tarjan's algorithm, the sort we build is\n     * constructed in reverse order. It is also the case that the reverse of a\n     * topological sort of the reverse graph is a valid topological sort of the\n     * forward graph.\n     *\n     * This means that we do not need to reverse the topological sort produced\n     * by Tarjan's algorithm if we follow the reverse edges.\n     *\n     * Note: handling of dynamic additions/deletions of edges in this algorithm is incredibly inefficient!\n     * TODO: Implement the algorithm outlined in:\n     * - Title: Incremental Topological Sort and Cycle Detection in O(msqrt{n}) Expected Total Time\n     * - Authors: Aaron Bernstein and Shiri Chechik\n     * - Paper: https://aaronbernstein.cs.rutgers.edu/wp-content/uploads/sites/43/2018/12/Dynamic-Cycle-Detection.pdf\n     * - From: https://aaronbernstein.cs.rutgers.edu/publications/\n     */\n    private _toposortRetained() {\n        type Vertex = {\n            nodeId: string;\n            index?: number;\n            lowlink?: number;\n            onStack?: boolean;\n        };\n        let index = 0;\n        const nodeVertex: Record<string, Vertex> = {};\n        const stack: Vertex[] = [];\n        const reverseTopoSort: Vertex[][] = [];\n\n        const strongconnect = (vertex: Vertex) => {\n            vertex.index = index;\n            vertex.lowlink = index;\n            index = index + 1;\n            stack.push(vertex);\n            vertex.onStack = true;\n\n            // Consider successors of v\n            this.getReverseDependenciesInner(vertex.nodeId).forEach((toId) => {\n                if (!nodeVertex[toId]) {\n                    nodeVertex[toId] = {\n                        nodeId: toId,\n                    };\n                }\n                const toVertex = nodeVertex[toId];\n                if (toVertex.index === undefined) {\n                    // Successor toVertex has not yet been visited; recurse on it\n                    strongconnect(toVertex);\n                    vertex.lowlink = Math.min(\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        vertex.lowlink!,\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        toVertex.lowlink!\n                    );\n                } else if (toVertex.onStack) {\n                    // Successor toVertex is in stack S and hence in the current SCC\n                    // If toVertex is not on stack, then (vertex, toVertex) is an edge pointing to an SCC already found and must be ignored\n                    // Note: The next line may look odd - but is correct.\n                    // It says toVertex.index not toVertex.lowlink; that is deliberate and from the original paper\n                    vertex.lowlink = Math.min(\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        vertex.lowlink!,\n                        toVertex.index\n                    );\n                }\n            });\n\n            // If vertex is a root node, pop the stack and generate an SCC\n            if (vertex.lowlink === vertex.index) {\n                // start a new strongly connected component\n                const component: Vertex[] = [];\n                for (;;) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const toVertex = stack.pop()!;\n                    toVertex.onStack = false;\n                    // add toVertex to current strongly connected component\n                    component.push(toVertex);\n                    if (toVertex === vertex) {\n                        break;\n                    }\n                }\n                // output the current strongly connected component\n                reverseTopoSort.push(component);\n            }\n        };\n\n        Object.keys(this.retained).forEach((nodeId) => {\n            if (this.retained[nodeId] && !nodeVertex[nodeId]) {\n                nodeVertex[nodeId] = {\n                    nodeId,\n                };\n                strongconnect(nodeVertex[nodeId]);\n            }\n        });\n\n        // Note: Because we traversed the reverse graph, the reverse\n        // topological sort is a valid forward topological sort of the forward\n        // graph.\n        return reverseTopoSort;\n    }\n\n    private _toposort(fromNodeIds: string[]) {\n        type Vertex = {\n            nodeId: string;\n            index?: number;\n            lowlink?: number;\n            onStack?: boolean;\n            reachesRetained?: boolean;\n        };\n        let index = 0;\n        const nodeVertex: Record<string, Vertex> = {};\n        const stack: Vertex[] = [];\n        const reverseTopoSort: Vertex[][] = [];\n\n        const strongconnect = (vertex: Vertex) => {\n            vertex.index = index;\n            vertex.lowlink = index;\n            index = index + 1;\n            stack.push(vertex);\n            vertex.onStack = true;\n\n            // Consider successors of v\n            this.getDependenciesInner(vertex.nodeId).forEach((toId) => {\n                if (!nodeVertex[toId]) {\n                    nodeVertex[toId] = {\n                        nodeId: toId,\n                        reachesRetained: !!this.retained[toId],\n                    };\n                }\n                const toVertex = nodeVertex[toId];\n                if (toVertex.index === undefined) {\n                    // Successor toVertex has not yet been visited; recurse on it\n                    strongconnect(toVertex);\n                    vertex.lowlink = Math.min(\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        vertex.lowlink!,\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        toVertex.lowlink!\n                    );\n                } else if (toVertex.onStack) {\n                    // Successor toVertex is in stack S and hence in the current SCC\n                    // If toVertex is not on stack, then (vertex, toVertex) is an edge pointing to an SCC already found and must be ignored\n                    // Note: The next line may look odd - but is correct.\n                    // It says toVertex.index not toVertex.lowlink; that is deliberate and from the original paper\n                    vertex.lowlink = Math.min(\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        vertex.lowlink!,\n                        toVertex.index\n                    );\n                }\n                if (toVertex.reachesRetained) {\n                    vertex.reachesRetained = true;\n                }\n            });\n\n            // If vertex is a root node, pop the stack and generate an SCC\n            if (vertex.lowlink === vertex.index) {\n                // start a new strongly connected component\n                const component: Vertex[] = [];\n                for (;;) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const toVertex = stack.pop()!;\n                    toVertex.onStack = false;\n                    // add toVertex to current strongly connected component\n                    component.push(toVertex);\n                    if (toVertex === vertex) {\n                        break;\n                    }\n                }\n                // output the current strongly connected component\n                reverseTopoSort.push(component);\n            }\n        };\n\n        fromNodeIds.forEach((nodeId) => {\n            if (!nodeVertex[nodeId]) {\n                nodeVertex[nodeId] = {\n                    nodeId,\n                    reachesRetained: !!this.retained[nodeId],\n                };\n                strongconnect(nodeVertex[nodeId]);\n            }\n        });\n\n        return reverseTopoSort.reverse();\n    }\n\n    /**\n     * Process the graph, visiting strongly connected nodes topologically that have a data dependency on a retained\n     * node.\n     *\n     * This uses Tarjan's strongly connected component algorithm to both segment strongly connected nodes and\n     * topologically sort them.\n     */\n    /*\n     * Core Processing Algorithm\n     * =========================\n     *\n     * First, soft-flush all dirty nodes in case recalculating a node grows a dependency on a dirty node.\n     * This prevents basic forms of stale reads.\n     *\n     * Until we perform the rest of the algorithm without visiting a dirty node, repeat:\n     * - Visit all strongly connected components in topological order reachable from retained nodes.\n     * - For each component:\n     *   - If it is a cycle (length > 1), flush + mark dirty all nodes that are not known to already be in a cycle, and record the node is known to be in a cycle\n     *   - If it is not cycle (length = 1), flush + mark dirty all nodes that are not known to already be in a cycle, and clear the record that the node is not to be known to be in a cycle\n     *   - Process the node if it is dirty, propagating dirtiness (if specified) to all hard edges that is not in the component\n     *     - When a node becomes dirty, flush the node\n     *   - After visiting all nodes in the component, mark all nodes in the component as not dirty\n     *\n     * For all remaining dirty nodes:\n     * - Recursively flush the node and its hard dependencies, (keeping track of those visited so we only visit a node at most one time)\n     *\n     * This should handle all tricky edge cases, and in most cases flush the graph with either 2 or 3 topological sorts.\n     *\n     *\n     * ## Edge cases to handle:\n     *\n     * Edge case 1: It's possible that a dirty node grows a dependency on a cached node that has a dependency on a dirty node.\n     * In this case, when processing is complete, if we topologically order all nodes reachable from retained nodes, a dirty node will be discovered.\n     * To account for this, we loop until visiting all newly topologically ordered strongly connected components are not dirty.\n     *\n     * Edge case 2: It's possible that a cycle is detected (a strongly connected component with more than 1 node)\n     * We keep track of known cycle nodes. To handle cycles correctly, we need to: identify when a node newly becomes part of a cycle and identify when a node is no longer part of a cycle.\n     * The graph keeps track of known cycle nodes.\n     *\n     * In case of a component of length > 1 for each node, we (in this specific order):\n     * 1. for all of the nodes that are not known to be in a cycle:\n     *   a. flush the node\n     *   b. mark the node as dirty\n     *   c. set the node to be known to be in a cycle\n     * 2. process _all_ of the dirty nodes in the cycle, propagating dirtiness **only to nodes not in the cycle**\n     * This handles the case for identifying when a node becomes part of a cycle.\n     *\n     * In case of a component of length = 1 where the node is known to be in a cycle, we (in this specific order):\n     * 1. flush the node\n     * 2. mark the node as dirty\n     * 3. set the node to not be known to be in a cycle\n     * 4. process the node, propagating dirtiness if needed\n     * This handles the case for identifying when a node becomes part of a cycle.\n     *\n     *\n     * ## In pseudocode\n     *\n     * for node in dirty_nodes:\n     *   soft_flush(node)\n     * do:\n     *   visited_dirty := false\n     *   to_process := tarjan_connected(retained)\n     *   for component in to_process:\n     *     is_cycle := len(component) > 1\n     *     if is_cycle:\n     *       for node in component:\n     *         if not is_known_cycle(node):\n     *           soft_flush(node)\n     *           set_dirty(node)\n     *           set_known_cycle(node)\n     *     elif is_known_cycle(component[0]):\n     *       soft_flush(component[0])\n     *       set_dirty(component[0])\n     *       clear_known_cycle(component[0])\n     *     for node in component:\n     *       if is_dirty(node):\n     *         should_propagate := callback(node, is_cycle ? 'cycle' : 'recalculate')\n     *         if should_propagate:\n     *           for to_node in hard_edges(node):\n     *             if to_node not in component:\n     *               set_dirty(to_node)\n     *               soft_flush(to_node)\n     *         visited_dirty := true\n     *     for node in component:\n     *       clear_dirty(node)\n     * while visited_dirty\n     */\n    process(callback: (node: Type, action: ProcessAction) => boolean): void {\n        // Preemptively flush all of the dirty nodes to prevent direct stale accesses\n        Object.keys(this.dirtyNodes).forEach((nodeId) => {\n            if (this.dirtyNodes[nodeId]) {\n                callback(this.nodesSet[nodeId], 'invalidate');\n            }\n        });\n\n        let visitedAnyDirty = false;\n        do {\n            visitedAnyDirty = false;\n            this._toposortRetained().forEach((component) => {\n                const isCycle = component.length > 1;\n                const nodeIds = new Set(\n                    component.map((vertex) => vertex.nodeId)\n                );\n\n                // If the nodes in the component have either become part of a\n                // cycle or been removed from a cycle, flush and dirty the node\n                // so it is processed\n                nodeIds.forEach((nodeId) => {\n                    const wasCycle = !!this.knownCycles[nodeId];\n                    if (wasCycle !== isCycle) {\n                        callback(this.nodesSet[nodeId], 'invalidate');\n                        this.dirtyNodes[nodeId] = true;\n                        this.knownCycles[nodeId] = isCycle;\n                    }\n                });\n\n                // Process and propagate dirty nodes, omitting those in the\n                // current component\n                nodeIds.forEach((nodeId) => {\n                    if (this.dirtyNodes[nodeId]) {\n                        const shouldPropagate = callback(\n                            this.nodesSet[nodeId],\n                            isCycle ? 'cycle' : 'recalculate'\n                        );\n                        if (shouldPropagate) {\n                            this.getDependenciesInner(\n                                nodeId,\n                                Graph.EDGE_HARD\n                            ).forEach((toId) => {\n                                if (!nodeIds.has(toId)) {\n                                    this.dirtyNodes[toId] = true;\n                                    callback(this.nodesSet[toId], 'invalidate');\n                                }\n                            });\n                        }\n                        visitedAnyDirty = true;\n                        delete this.dirtyNodes[nodeId];\n                    }\n                });\n            });\n        } while (visitedAnyDirty);\n\n        // Flush all remaining stray dirty nodes (and unfortunately their transitive dependencies) --\n        // these do not reach retained nodes, but need to be flushed so future reads are not stale\n        const visited: Record<string, boolean> = {};\n        const flushTransitive = (nodeId: string) => {\n            if (visited[nodeId]) return;\n            visited[nodeId] = true;\n            callback(this.nodesSet[nodeId], 'invalidate');\n            this.getDependenciesInner(nodeId, Graph.EDGE_HARD).forEach(\n                (toId) => {\n                    flushTransitive(toId);\n                }\n            );\n        };\n        Object.keys(this.dirtyNodes).forEach((nodeId) => {\n            if (this.dirtyNodes[nodeId]) {\n                flushTransitive(nodeId);\n                delete this.dirtyNodes[nodeId];\n            }\n        });\n    }\n\n    /**\n     * Generate a dot file structure of the graph\n     */\n    graphviz(\n        getAttributes: (\n            label: string,\n            item: Type\n        ) => { label: string; subgraph: object | undefined; penwidth: string }\n    ) {\n        const lines = [\n            'digraph debug {',\n            //'graph [rankdir=\"LR\"];',\n            'node [style=\"filled\", fillcolor=\"#DDDDDD\"];',\n        ];\n\n        const nodeIds = Object.keys(this.nodesSet).filter(\n            (nodeId) => !!this.nodesSet[nodeId]\n        );\n        const nodeAttributes: Record<\n            string,\n            { label: string; subgraph: object | undefined; penwidth: string }\n        > = {};\n        nodeIds.forEach((nodeId) => {\n            nodeAttributes[nodeId] = getAttributes(\n                nodeId,\n                this.nodesSet[nodeId]\n            );\n        });\n        const groupedNodes = groupBy(nodeIds, (nodeId) => {\n            return [nodeAttributes[nodeId].subgraph, nodeId];\n        });\n\n        let clusterId = 0;\n        groupedNodes.forEach((nodeIds, group) => {\n            if (group)\n                lines.push(\n                    `subgraph cluster_${clusterId++} {`,\n                    'style=\"filled\";',\n                    'color=\"#AAAAAA\";'\n                );\n            nodeIds.forEach((nodeId) => {\n                const props: Record<string, string> = {\n                    shape: this.retained[nodeId] ? 'box' : 'ellipse',\n                    label: nodeAttributes[nodeId].label,\n                    penwidth: nodeAttributes[nodeId].penwidth,\n                    fillcolor: this.dirtyNodes[nodeId] ? '#FFDDDD' : '#DDDDDD',\n                };\n                lines.push(\n                    `  item_${nodeId} [${Object.entries(props)\n                        .map(\n                            ([key, value]) => `${key}=${JSON.stringify(value)}`\n                        )\n                        .join(',')}];`\n                );\n            });\n            if (group) lines.push('}');\n        });\n\n        nodeIds.forEach((fromId) => {\n            const allDestinations = Array.from(\n                new Set(Object.keys(this.graph[fromId]))\n            );\n            allDestinations.forEach((toId) => {\n                if (this.graph[fromId][toId] & Graph.EDGE_HARD) {\n                    lines.push(\n                        `  item_${fromId} -> item_${toId} [style=\"solid\"];`\n                    );\n                }\n                if (this.graph[fromId][toId] & Graph.EDGE_SOFT) {\n                    lines.push(\n                        `  item_${fromId} -> item_${toId} [style=\"dashed\"];`\n                    );\n                }\n            });\n        });\n\n        lines.push('}');\n\n        return lines.join('\\n');\n    }\n}\n", "import {\n    GraphNode,\n    isCalculation,\n    isCollection,\n    isEffect,\n    isModel,\n    isSubscription,\n    isNodeOrdering,\n    isModelField,\n} from './types';\n\nlet nameMap: WeakMap<any, string> = new WeakMap();\n\nexport function clearNames() {\n    nameMap = new WeakMap();\n}\n\nexport function debugNameFor(item: GraphNode): string {\n    if (!DEBUG) {\n        return '';\n    }\n    const id = (item as any).$__id;\n    if (isCollection(item)) {\n        return `${id}:collection:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isCalculation(item)) {\n        return `${id}:${isEffect(item) ? 'effect' : 'calc'}:${\n            nameMap.get(item) ?? '?'\n        }`;\n    }\n    if (isModel(item)) {\n        return `${id}:model:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isSubscription(item)) {\n        return `${id}:sub:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isNodeOrdering(item)) {\n        return `${id}:ord:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isModelField(item)) {\n        return `${id}:field:${nameMap.get(item.model) ?? '?'}:${String(\n            item.key\n        )}`;\n    }\n    return `${id}:unknown`;\n}\n\nexport function name<T>(item: T, name: string): T {\n    if (!DEBUG) return item;\n    nameMap.set(item, name);\n    return item;\n}\n", "import {\n    Calculation,\n    CalculationRecalculateTag,\n    CalculationInvalidateTag,\n    CalculationSetCycleTag,\n    CalculationTypeTag,\n    GraphNode,\n    EqualityFunc,\n    FlushKey,\n    InvariantError,\n    TypeTag,\n    isCalculation,\n    isCollection,\n    isModel,\n    isModelField,\n    isSubscription,\n} from './types';\nimport * as log from './log';\nimport { Graph } from './graph';\nimport { alwaysTrue, noop, strictEqual, uniqueid } from './util';\nimport { clearNames, debugNameFor, name } from './debug';\n\nlet activeCalculations: { calc: null | Calculation<any>; deps: GraphNode[] }[] =\n    [];\n\nlet globalDependencyGraph = new Graph<GraphNode>();\n\nlet refcountMap: Record<string, number> = {};\n\n/**\n * Reset all data to a clean slate.\n */\nexport function reset() {\n    activeCalculations = [];\n\n    globalDependencyGraph = new Graph();\n    refcountMap = {};\n    clearNames();\n}\n\nlet createdCalculations: Calculation<any>[] | undefined;\n/**\n * Collect all synchronously created calc() and effect() calls\n */\nexport function trackCreatedCalculations(fn: () => void): Calculation<any>[] {\n    const before = createdCalculations;\n    createdCalculations = [];\n    try {\n        fn();\n        const toReturn = createdCalculations;\n        return toReturn;\n    } finally {\n        createdCalculations = before;\n    }\n}\n\n/**\n * Create a calculation cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be recalculated when any of those dependencies are changed. The result of this function is\n * treated as a dependency, so if recalculations change the result, any dependent calculations are recalculated.\n */\nexport function calc<Ret>(func: () => Ret): Calculation<Ret>;\nexport function calc<Ret>(func: () => Ret, debugName: string): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual: EqualityFunc<Ret>\n): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual: EqualityFunc<Ret>,\n    debugName: string\n): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual?: string | EqualityFunc<Ret>,\n    debugName?: string\n): Calculation<Ret> {\n    if (typeof isEqual === 'string') debugName = isEqual;\n    if (typeof isEqual !== 'function') isEqual = strictEqual;\n    if (typeof debugName !== 'string') debugName = undefined;\n    const calculation = makeCalculation(func, isEqual, false);\n    if (debugName) name(calculation, debugName);\n    if (createdCalculations) createdCalculations.push(calculation);\n    return calculation;\n}\n\n/**\n * Create an effect cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be re-executed when any of those dependencies are changed.\n *\n * Effect cells are not be added as dependencies to the current computation.\n *\n * Note: Since nothing depends on created effects, they must be be manually retained and released if you want the effect\n * to re-run when its dependencies change. Failure to do so will not automatically re-run the effect (which may be\n * desired if you want to trigger behavior only once within a computation)\n */\nexport function effect(\n    func: () => void,\n    debugName?: string\n): Calculation<void> {\n    const calculation = makeCalculation(\n        func,\n        alwaysTrue /* effects always return true for equality */,\n        true\n    );\n    if (debugName) name(calculation, debugName);\n    if (createdCalculations) createdCalculations.push(calculation);\n    return calculation;\n}\n\nexport function untracked<TRet>(func: () => TRet): TRet {\n    activeCalculations.push({ calc: null, deps: [] });\n    try {\n        return func();\n    } finally {\n        activeCalculations.pop();\n    }\n}\n\nenum CalculationState {\n    STATE_FLUSHED,\n    STATE_TRACKING,\n    STATE_CACHED,\n    STATE_CYCLE,\n    STATE_ERROR,\n}\n\nclass CalculationError extends Error {\n    public originalError: unknown;\n    constructor(msg: string, originalError: unknown) {\n        super(msg);\n        this.originalError = originalError;\n    }\n}\n\nclass CycleAbortError extends Error {}\n\nfunction makeCalculation<Ret>(\n    calculationFunc: () => Ret,\n    isEqual: (a: Ret, b: Ret) => boolean,\n    isEffect: boolean\n): Calculation<Ret> {\n    if (typeof calculationFunc !== 'function') {\n        throw new InvariantError('calculation must be provided a function');\n    }\n\n    let result: { result: Ret } | undefined = undefined;\n    let state: CalculationState = CalculationState.STATE_FLUSHED;\n    let errorHandler: ((errorType: 'cycle' | 'error') => Ret) | undefined =\n        undefined;\n    let isDisposed = false;\n\n    const calculation: Calculation<Ret> = Object.assign(calculationBody, {\n        $__id: uniqueid(),\n        [TypeTag]: 'calculation' as const,\n        [CalculationTypeTag]: isEffect\n            ? ('effect' as const)\n            : ('calculation' as const),\n        [CalculationSetCycleTag]: calculationSetError,\n        [CalculationRecalculateTag]: calculationRecalculate,\n        [CalculationInvalidateTag]: calculationInvalidate,\n        onError: calculationOnError,\n        dispose: calculationDispose,\n    });\n\n    globalDependencyGraph.addNode(calculation);\n\n    function calculationBody() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        if (!isEffect) {\n            // effects return void, so they **cannot** have an effect on the current calculation\n            addDepToCurrentCalculation(calculation);\n        }\n\n        switch (state) {\n            case CalculationState.STATE_FLUSHED: {\n                state = CalculationState.STATE_TRACKING;\n                activeCalculations.push({ calc: calculation, deps: [] });\n                const prevResult = result;\n                try {\n                    result = { result: calculationFunc() };\n                } catch (e) {\n                    const calcRecord = activeCalculations.pop();\n                    log.assert(\n                        calcRecord?.calc === calculation,\n                        'calculation stack inconsistency'\n                    );\n                    globalDependencyGraph.replaceIncoming(\n                        calculation,\n                        calcRecord.deps\n                    );\n                    const isCycle = e instanceof CycleAbortError;\n                    state = isCycle\n                        ? CalculationState.STATE_CYCLE\n                        : CalculationState.STATE_ERROR;\n                    if (errorHandler) {\n                        result = {\n                            result: errorHandler(isCycle ? 'cycle' : 'error'),\n                        };\n                    } else {\n                        // If we don't have an error handler, but we hit an\n                        // error, we need to clear out the preexisting result\n                        // so we throw when called in an error state.\n                        result = undefined;\n                    }\n                    // Only return a value if we're the _outermost_ tracked call.\n                    // Otherwise, we need to propagate the error to catch the remaining ones.\n                    if (result && activeCalculations.length === 0) {\n                        return prevResult &&\n                            isEqual(prevResult.result, result.result)\n                            ? prevResult.result\n                            : result.result;\n                    }\n                    if (isCycle) {\n                        throw e;\n                    }\n                    throw new CalculationError(\n                        'Calculation error: calculation threw error while being called',\n                        e\n                    );\n                }\n                state = CalculationState.STATE_CACHED;\n                const calcRecord = activeCalculations.pop();\n                log.assert(\n                    calcRecord?.calc === calculation,\n                    'calculation stack inconsistency'\n                );\n                globalDependencyGraph.replaceIncoming(\n                    calculation,\n                    calcRecord.deps\n                );\n                return prevResult && isEqual(prevResult.result, result.result)\n                    ? prevResult.result\n                    : result.result;\n            }\n            case CalculationState.STATE_TRACKING:\n                state = CalculationState.STATE_ERROR;\n                if (errorHandler) {\n                    result = {\n                        result: errorHandler('cycle'),\n                    };\n                    // If we have an error handler and we call ourselves,\n                    // only return a value if we are the outermost tracked\n                    // call. Otherwise, we need to propagate the error to the\n                    // callers\n                    if (activeCalculations.length === 0) {\n                        return result.result;\n                    }\n                }\n                throw new CycleAbortError(\n                    'Cycle reached: calculation is part of a cycle'\n                );\n                break;\n            case CalculationState.STATE_CACHED:\n                if (result) {\n                    return result.result;\n                }\n                throw new InvariantError(\n                    'Calculation in cached state missing result value'\n                );\n            case CalculationState.STATE_CYCLE:\n                if (result) {\n                    return result.result;\n                }\n                throw new Error(\n                    'Cycle reached: calculation is part of a cycle'\n                );\n            case CalculationState.STATE_ERROR:\n                if (result) {\n                    return result.result;\n                }\n                throw new Error('Calculation in error state');\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationInvalidate() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot invalidate a calculation while being tracked'\n                );\n            case CalculationState.STATE_FLUSHED:\n                return;\n            case CalculationState.STATE_CYCLE:\n                DEBUG &&\n                    log.debug(\n                        'Invalidating node in a cycle',\n                        debugNameFor(calculation)\n                    );\n                globalDependencyGraph.removeIncoming(calculation);\n                state = CalculationState.STATE_FLUSHED;\n                break;\n            case CalculationState.STATE_CACHED:\n            case CalculationState.STATE_ERROR: {\n                DEBUG &&\n                    log.debug('Invalidating node', debugNameFor(calculation));\n                state = CalculationState.STATE_FLUSHED;\n                break;\n            }\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationSetError() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot mark calculation as being a cycle while it is being calculated'\n                );\n                break;\n            case CalculationState.STATE_FLUSHED:\n            case CalculationState.STATE_CACHED:\n            case CalculationState.STATE_CYCLE:\n            case CalculationState.STATE_ERROR: {\n                state = CalculationState.STATE_CYCLE;\n                if (errorHandler) {\n                    let isResultEqual = false;\n                    const newResult = errorHandler('cycle');\n                    if (result) {\n                        isResultEqual = isEqual(result.result, newResult);\n                    }\n                    if (!isResultEqual) {\n                        result = { result: newResult };\n                    }\n                    return !isResultEqual;\n                } else {\n                    if (result) {\n                        result = undefined;\n                        return true;\n                    }\n                    return false;\n                }\n            }\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationRecalculate() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot recalculate calculation while it is being calculated'\n                );\n                break;\n            case CalculationState.STATE_FLUSHED:\n            case CalculationState.STATE_ERROR:\n            case CalculationState.STATE_CACHED: {\n                const priorResult = result;\n                try {\n                    calculationBody();\n                } catch (e) {\n                    // Completely ignore, at this point `result` should hold the correct value\n                }\n                if (\n                    priorResult &&\n                    result &&\n                    isEqual(priorResult.result, result.result)\n                ) {\n                    result = priorResult;\n                    return false;\n                }\n                return true;\n            }\n            case CalculationState.STATE_CYCLE:\n                throw new InvariantError(\n                    'Cannot recalculate calculation in cycle state without flushing'\n                );\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationOnError(\n        handler: (errorType: 'cycle' | 'error') => Ret\n    ) {\n        log.assert(!isDisposed, 'calculation already disposed');\n        errorHandler = handler;\n        return calculation;\n    }\n\n    function calculationDispose() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        globalDependencyGraph.removeNode(calculation);\n\n        // Delete local state\n        result = undefined;\n        errorHandler = undefined;\n\n        isDisposed = true;\n    }\n\n    return calculation;\n}\n\nexport function addDepToCurrentCalculation(item: GraphNode) {\n    if (activeCalculations.length === 0) return;\n    const dependentCalculation =\n        activeCalculations[activeCalculations.length - 1];\n    dependentCalculation.deps.push(item);\n    DEBUG &&\n        log.debug(\n            'New global dependency',\n            debugNameFor(item),\n            '->',\n            dependentCalculation.calc\n                ? debugNameFor(dependentCalculation.calc)\n                : '<untracked>' // We probably could avoid adding to .deps if we were untracked, but it may be helpful to log these\n        );\n}\n\nexport function addManualDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.addNode(fromNode);\n    globalDependencyGraph.addNode(toNode);\n    globalDependencyGraph.addEdge(fromNode, toNode, Graph.EDGE_HARD);\n    DEBUG &&\n        log.debug(\n            'New manual dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function registerNode(node: GraphNode) {\n    globalDependencyGraph.addNode(node);\n}\n\nexport function disposeNode(node: GraphNode) {\n    globalDependencyGraph.removeNode(node);\n}\n\nexport function addOrderingDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.addEdge(fromNode, toNode, Graph.EDGE_SOFT);\n    DEBUG &&\n        log.debug(\n            'New manual ordering dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function removeManualDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.removeEdge(fromNode, toNode, Graph.EDGE_HARD);\n    DEBUG &&\n        log.debug(\n            'Removed manual dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function removeOrderingDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.removeEdge(fromNode, toNode, Graph.EDGE_SOFT);\n    DEBUG &&\n        log.debug(\n            'Removed manual ordering dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function markDirty(item: GraphNode) {\n    DEBUG && log.debug('Dirtying', debugNameFor(item));\n    globalDependencyGraph.addNode(item);\n    globalDependencyGraph.markNodeDirty(item);\n    scheduleFlush();\n}\n\ntype Listener = () => void;\nlet needsFlush = false;\nlet flushPromise: Promise<void> = Promise.resolve();\nlet resolveFlushPromise: () => void = noop;\nlet subscribeListener: Listener = () => setTimeout(() => flush(), 0);\n\nexport function nextFlush() {\n    if (!needsFlush) return Promise.resolve();\n    return flushPromise;\n}\n\n/**\n * Call provided callback when any pending calculations are created. Use to configure how/when the application flushes calculations.\n *\n * If any pending calculations are needed when this function is called, the provided callback is called synchronously.\n *\n * By default, the subscribe mechanism is to call flush() on setTimeout. Calling subscribe removes this default and\n * replaces it with whatever mechanism you'd like.\n *\n * Example: subscribe(() => requestAnimationFrame(() => flush()));\n */\nexport function subscribe(listener: Listener = noop): void {\n    subscribeListener = listener;\n    if (needsFlush) {\n        subscribeListener();\n    }\n}\n\nfunction scheduleFlush() {\n    if (!needsFlush) {\n        needsFlush = true;\n        notify();\n    }\n}\n\nfunction notify() {\n    try {\n        flushPromise = new Promise((resolve) => {\n            resolveFlushPromise = resolve;\n        });\n        subscribeListener();\n    } catch (e) {\n        log.exception(e, 'uncaught exception in notify');\n    }\n}\n\n/**\n * Hoo boy this is probably a mistake. Stream the graph while we flush\n */\nlet debugSubscription: ((graphViz: string, detail: string) => void) | null =\n    null;\n\n/**\n * Recalculate all pending calculations.\n */\nexport function flush() {\n    if (!needsFlush) {\n        return;\n    }\n    needsFlush = false;\n\n    DEBUG && debugSubscription && debugSubscription(debug(), '0: flush start');\n\n    // Then flush dependencies in topological order\n    globalDependencyGraph.process((item, action) => {\n        let shouldPropagate = true;\n\n        switch (action) {\n            case 'cycle':\n                if (isCalculation(item)) {\n                    shouldPropagate = item[CalculationSetCycleTag]();\n                } else {\n                    throw new Error('Unexpected dependency on cycle');\n                }\n                break;\n            case 'invalidate':\n                if (isCalculation(item)) {\n                    item[CalculationInvalidateTag]();\n                }\n                break;\n            case 'recalculate':\n                if (isCalculation(item)) {\n                    shouldPropagate = item[CalculationRecalculateTag]();\n                } else if (\n                    isCollection(item) ||\n                    isModel(item) ||\n                    isSubscription(item)\n                ) {\n                    shouldPropagate = item[FlushKey]();\n                }\n                break;\n            default:\n                log.assertExhausted(action);\n        }\n        if (DEBUG) {\n            log.debug(\n                `process:${action}`,\n                debugNameFor(item),\n                `shouldPropagate=${shouldPropagate}`\n            );\n            debugSubscription &&\n                debugSubscription(\n                    debug(item),\n                    `process:${action}:shouldPropagate=${shouldPropagate}`\n                );\n        }\n        return shouldPropagate;\n    });\n\n    if (globalDependencyGraph.hasDirtyNodes()) {\n        DEBUG && log.debug('Graph contained dirty nodes post-flush');\n        scheduleFlush();\n    }\n\n    DEBUG && debugSubscription && debugSubscription(debug(), `2: after visit`);\n\n    resolveFlushPromise();\n}\n\n/**\n * Retain a calculation (increase the refcount)\n */\nexport function retain(item: GraphNode) {\n    const refcount = refcountMap[item.$__id] ?? 0;\n    const newRefcount = refcount + 1;\n    if (refcount === 0) {\n        DEBUG &&\n            log.debug(\n                `retain ${debugNameFor(\n                    item\n                )} retained; refcount ${refcount} -> ${newRefcount}`\n            );\n        if (!globalDependencyGraph.hasNode(item)) {\n            globalDependencyGraph.addNode(item);\n        }\n        globalDependencyGraph.retain(item);\n    } else {\n        DEBUG &&\n            log.debug(\n                `retain ${debugNameFor(\n                    item\n                )} incremented; refcount ${refcount} -> ${newRefcount}`\n            );\n    }\n    refcountMap[item.$__id] = newRefcount;\n}\n\n/**\n * Release a calculation (decrease the refcount). If the refcount reaches zero, the calculation will be garbage\n * collected.\n */\nexport function release(item: GraphNode) {\n    const refcount = refcountMap[item.$__id] ?? 0;\n    const newRefcount = Math.min(refcount - 1, 0);\n    if (refcount < 1) {\n        log.error(\n            `release called on unretained item ${debugNameFor(item)}`,\n            item\n        );\n    }\n    if (newRefcount < 1) {\n        DEBUG &&\n            log.debug(\n                `release ${debugNameFor(\n                    item\n                )} released; refcount ${refcount} -> ${newRefcount}`\n            );\n        globalDependencyGraph.release(item);\n    } else {\n        DEBUG &&\n            log.debug(\n                `release ${debugNameFor(\n                    item\n                )} decremented; refcount ${refcount} -> ${newRefcount}`\n            );\n    }\n    refcountMap[item.$__id] = newRefcount;\n}\n\n/**\n * Return a graphviz formatted directed graph\n */\nexport function debug(activeItem?: any): string {\n    return globalDependencyGraph.graphviz((id, item) => {\n        let subgraph: object | undefined = undefined;\n        if (isModel(item)) {\n            subgraph = item;\n        }\n        if (isCollection(item)) {\n            subgraph = item;\n        }\n        if (isModelField(item)) {\n            subgraph = item.model;\n        }\n        if (isSubscription(item)) {\n            subgraph = item.item;\n        }\n        return {\n            label: `${id}\\n${debugNameFor(item)}`,\n            subgraph,\n            penwidth: activeItem === item ? '5.0' : '1.0',\n        };\n    });\n}\n\nexport function debugState() {\n    return {\n        globalDependencyGraph,\n        activeCalculations,\n        refcountMap,\n        needsFlush,\n        flushPromise,\n        resolveFlushPromise,\n        subscribeListener,\n    };\n}\n\nexport function debugSubscribe(\n    callback: ((graphviz: string, detail: string) => void) | null\n) {\n    debugSubscription = callback;\n}\n", "import { Ref, Calculation, Collection, View, Context } from './types';\n\nexport const NoChildren = Symbol('NoChildren');\nexport type NoChildren = typeof NoChildren;\n\n/**\n * The core type that can be used as a child or root of a JSX expression\n */\nexport type JSXNode =\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    | symbol\n    | Function\n    | RenderedElement<any, any, any>\n    | Calculation<JSXNode>\n    | Collection<JSXNode>\n    | View<JSXNode>;\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        /**\n         * The core type that can be used as a child or root of a JSX expression\n         */\n        type Element = JSXNode;\n\n        interface IntrinsicElements extends KnownElements {\n            [unknownElement: string]: any;\n        }\n\n        interface ElementChildrenAttribute {\n            children: {}; // specify children name to use\n        }\n    }\n}\n\ntype OnUnmountCallback = () => void;\ntype OnMountCallback = () => void;\ntype EffectCallback = () => void;\n\ntype ComponentListeners = {\n    onUnmount: (callback: OnUnmountCallback) => void;\n    onMount: (callback: OnMountCallback) => void;\n    onEffect: (callback: EffectCallback) => void;\n    getContext: <TVal>(context: Context<TVal>) => TVal;\n};\n/**\n * This is a big ol hack that allows components which don't declare any props (const MyComponent: Component<{}> = ...) to enforce that no children can be passed.\n * Why does this work? {} types as function properties accept _any_ props\n *\n * See:\n * - https://www.typescriptlang.org/play?jsx=1#code/C4TwDgpgBAShB2ATCAnCiDCB7AtmL8CwUAvFAN5QDGWWANgFxQBGtdEAhvFAL4DcAKGRU6HNNQIBnYgFd4MyegDKIHK0ZQ5ASwCOM6JNXrBoSFGx4CRADwAVAAoosYSQD5SUABRgnLpg99JKAAyCigAbTkFZSN6AF0AfiZWek5uHgBKUnc4JFR0C3xCeGBBIQgRMWh4DhwISTAOKmgAKSUADQoBKB6oU2gASRKULXhJLSoAUXY6kqCycm7e5Yg8UCZF5eWeJa2oAC9ULA3dvd6AfXOoxUQkvpR9ABpT7ZfeqxOzraoACy06RBoeBMNrtAB001WREEXx4zy+VgA8mBgJ8vr1fv9AQg7qCITNoW8ejsvjgZHRgFo0ejqH8AUCQR18VCSuE4jCznCiVAyRStMjUV0aT1MfScYzwZDZsA2Ry9lyEYRESgALLkynU9Gi7HAqB4qVEKAAHz1TINrPZ3IVZyRqvV-JRmq+2qBuLNBJKxtNko9MstsPhZ3CVAUwFw5sF0hG8AA5nEnUGQ9Jw76AILAYAjZgyYAQJhR0ZxphcEByrb8U47U6jXMoABmTWgEYwdJ16czWmzuaFZxdCA2Fdep36UAjHgLsa98jUqC9KXYXC9cmQddG6Cn5LoXtyyDQmFwRUJVYA9MeBKeoEMO2MJlAIL7JOez0-R2sQFAfM4gp49PVKQQmAAdx+d9ECweo+j+IJmAgH4OAAN2gYAoKgQCOBABIMgEaxVhRd9j1cQQcLfVxrAADygAjrGPXDQEI7DaJAUiKKoljSJokiygvAAtI5aSxIFsMOJxKPo6xhKwZjROoiSxNk8jpLYmSjnol9EUIO8yKaYhtWwqxRKI-SpKo48rDEsyFNY6TTMIVSL3U6BnH-Got106wkRRAy9KVTzjPYjzgHMnzAssvzqICuzjygNU+TAdhNO0-ixXgbDeUpLzrDSrQoDC48srE-LQqKvL7Ui6LyS0OLHJRLQCA4VzW0EzL7QFDKsta3L2pRAqWu6oqlJKvkBTKyYtKoYA6HffSsBQHkZugPsUvcpU7T5DLbRi9Lco20rDJWzatDCgadr5MqBVqlzJqgabZpweakp1LwSygacYJQLDlogZUDtagi9q+1bKQ64qTqB7r-u+3qQqU479qhyKX0KKxPXvFlgEfC8BAEGgxmISY3yYJHimAaxyB4dwyE8LISHcTxKBoegmEzfReAyQQcekKBeKcQmD2RkmyYprxqdp+m2CZh5oEydmpGIBzecsYnSYehlvWZaVeCFqnsi8MXGfuFnpex2WoAcgUFcPEplcWt0fTRzWPG1mndYkfXmaltnjdx8q+Qt-nrca-s1YjNkHcpkWXYZjR3dZmXvZ+x1zD5pX6cD+BbfVohQ-Jx2I7p13o8l2Ovc5s3AapJPFZsVOBKD-VfS9eu0ezrW871wvDc9jm5bhobE6J6uVfFYOG5NJvpRb3OdfzqOJc7riovxvCP0CLxf2kC6gJAqAwIg5CtGg2CEKQlC0Iwj6l9ADLL6Y4qb7E+-+us++F65vjFuw7msAyr-ct-ojf5PxMv-LG9kNIQDGjpVs2EHIZVgblByYlEFAPYog1+sCnIXXqg9GBwU4F4IQcFJBRCUHUTNuDUBUUDpVQSuNIeS0DoZUYblA6YlWGkOPKw1+MVKrxUwXVBqtcGFQyYSIlh8MiIJ2hopayUiRqQKujdOa4gP7WDLowv6uCAbMOKuo3aWjIanQ4Xo066CaoCMURpGayiFppyevAd8r1UAfRMWDYgmi1G9zcTlXRXiHSBSIq4-xR1rJBOGgvRGydDSo2lEEUYdZUB7hfFjbul4b6O3OJ+PwFBMjT3bnPD2cdOYDC-o7LJkgNhQEuNcdAdx5xpFZnkguBTi6pIGLAym5TKmLQlJnT0uTnYz3FgbQpJdiDtLwZTTJgRulpwzmOAZotmkjNaSbAYjCpldLCD0kezc4iNMGfklZRs2lSIyVsmuyV5m+mzm3ZZMcTlrKCecmZ2y069LHGPd0eyDlLNnscruTy-GtU2a8y5Oprn2y+XbCe+zFmR2GQ8z2L50nlLXvoDeAFULb13kEfeh84KIUggfVC6FMLYQGOkjxlKSLFRpXhMS9K6IcKZUxV+pTVElL4tSwBA0uVOEZbymRJl+WSXQeAyBODrATOgNS+BdK0EUuQTDayMqzpWPMS5KVMrfqMvIcQXKOqKHSv1SEkVpruH2hoRAxKnKNGMp0XyrhFL2EqpFc6l8PCaH8K1XakR1KzmGrkURdZ8MWXBsoaOBRU0rG3Xupy55cq-E+L5UEvVfizXsR1eXM6mr6qWMcnGlRdjPDPSce9JVwLPJJu0WIhVVaAmVtrX3aRVlzUNsIkAA\n */\nconst UnusedSymbol = Symbol('unused');\nexport type Component<TProps extends {}> = (\n    props: TProps & { [UnusedSymbol]?: boolean },\n    listeners: ComponentListeners\n) => JSXNode;\n\n/**\n * The type returned by createElement\n */\nexport type RenderedElement<TProps, TContext, TChildren extends JSXNode> =\n    | {\n          type: 'intrinsic';\n          element: string;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'context';\n          context: Context<TContext>;\n          props: { value: TContext };\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children: TChildren }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children?: TChildren }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children: TChildren[] }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children?: TChildren[] }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps>;\n          props: TProps;\n          children: TChildren[];\n      };\n\n/*\n * Interfaces adopted from HTML Living Standard Last Updated 30 November 2021: https://html.spec.whatwg.org/\n */\nfunction attrBooleanToEmptyString(\n    val: boolean | undefined\n): string | undefined {\n    if (!val) return undefined;\n    return '';\n}\nfunction attrStringOrNumberToNumber(\n    val: string | number | undefined\n): number | undefined {\n    if (val === undefined) return undefined;\n    return typeof val === 'number' ? val : parseInt(val);\n}\nfunction attrYesNo(val: '' | 'yes' | 'no' | undefined): boolean | undefined {\n    if (val === undefined) return undefined;\n    return val === 'no' ? false : true;\n}\n\n// Note: TypeScript has some notably missing IDL properties from its HTMLElement interface, this adds them in lieu of those properties:\ninterface MissingFromTypescriptHTMLElementProperties {\n    // https://w3c.github.io/aria/#idl-reflection-attribute-values\n    ariaColIndexText?: string | undefined;\n    ariaInvalid?: string | undefined;\n    ariaRowIndexText?: string | undefined;\n    role?: string | undefined;\n\n    // https://html.spec.whatwg.org/multipage/dom.html#htmlorsvgelement\n    autofocus?: boolean | undefined;\n\n    itemscope?: string | undefined;\n}\n\n// Note: TypeScript has some notably missing IDL properties from its HTMLDialog interface, this adds them in lieu of those properties:\ninterface MissingFromTypescriptHTMLDialogElementProperties {\n    // https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element\n    open?: boolean | undefined;\n}\n\ninterface MissingFromTypescriptHTMLIframeElementProperties {\n    // https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element\n    loading?: LazyLoadingValue | undefined;\n}\n\ninterface MissingFromTypescriptHTMLMetaElementProperties {\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-meta-media\n    media?: string | undefined;\n}\n\ninterface MissingFromTypescriptHTMLSourceElementProperties {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#the-source-element\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\ntype PropertyMapField<TJSXField, TElement, TIDLName extends keyof TElement> =\n    | {\n          makeAttrValue?:\n              | ((jsxAttr: Exclude<TJSXField, undefined>) => string | undefined)\n              | null;\n      }\n    | {\n          makeAttrValue?:\n              | ((jsxAttr: Exclude<TJSXField, undefined>) => string | undefined)\n              | null;\n          idlName?: TIDLName | null;\n          makeIdlValue?: (\n              jsxAttr: Exclude<TJSXField, undefined>\n          ) => TElement[TIDLName];\n      };\n\ntype PropertyMap<TJSXElementInterface, TElement> = {\n    [TJSXKey in keyof Required<TJSXElementInterface>]: PropertyMapField<\n        TJSXElementInterface[TJSXKey],\n        TElement,\n        keyof TElement\n    >;\n};\n\n// Note: abstract roles are **not** in this list, as \"Authors MUST NOT use abstract roles in content\"\ntype AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'associationlist'\n    | 'associationlistitemkey'\n    | 'associationlistitemvalue'\n    | 'banner'\n    | 'blockquote'\n    | 'button'\n    | 'caption'\n    | 'cell'\n    | 'checkbox'\n    | 'code'\n    | 'columnheader'\n    | 'combobox'\n    | 'comment'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'deletion'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'emphasis'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'generic'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'insertion'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'mark'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'meter'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'paragraph'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'strong'\n    | 'subscript'\n    | 'suggestion'\n    | 'superscript'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'time'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | string;\n\ntype DirValue = 'ltr' | 'rtl' | 'auto' | string;\n\ntype BrowsingContextValue = '_blank' | '_self' | '_parent' | '_top' | string;\n\ntype ReferrerPolicyValue =\n    | ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'same-origin'\n    | 'origin'\n    | 'strict-origin'\n    | 'origin-when-cross-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url'\n    | string;\n\ntype CrossOriginValue = 'anonymous' | '' | 'use-credentials';\n\ntype LazyLoadingValue = 'lazy' | 'eager' | string;\n\ntype ImageDecodingHintValue = 'sync' | 'async' | 'auto' | string;\n\ntype SandboxValue =\n    | 'allow-forms'\n    | 'allow-modals'\n    | 'allow-orientation-lock'\n    | 'allow-pointer-lock'\n    | 'allow-popups'\n    | 'allow-popups-to-escape-sandbox'\n    | 'allow-presentation'\n    | 'allow-same-origin'\n    | 'allow-scripts'\n    | 'allow-top-navigation'\n    | 'allow-top-navigation-by-user-activation'\n    | 'allow-downloads'\n    | string;\n\ntype EncTypeValue =\n    | 'application/x-www-form-urlencoded'\n    | 'multipart/form-data'\n    | 'text/plain'\n    | string;\n\ntype FormMethodValue = 'get' | 'post' | 'dialog' | string;\n\ntype AutocompleteValue = 'on' | 'off' | string;\n\ninterface JSXElementInterface {\n    /** a guide for creating a keyboard shortcut that activates or focuses the element */\n    accesskey?: string | undefined;\n    'aria-atomic'?: string | undefined; //  ariaAtomic\n    'aria-autocomplete'?: string | undefined; //  ariaAutoComplete\n    'aria-busy'?: string | undefined; //  ariaBusy\n    'aria-checked'?: string | undefined; //  ariaChecked\n    'aria-colcount'?: string | undefined; //  ariaColCount\n    'aria-colindex'?: string | undefined; //  ariaColIndex\n    'aria-colindextext'?: string | undefined; //  ariaColIndexText\n    'aria-colspan'?: string | undefined; //  ariaColSpan\n    'aria-current'?: string | undefined; //  ariaCurrent\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description'?: string | undefined; //  ariaDescription\n    */\n    'aria-disabled'?: string | undefined; //  ariaDisabled\n    'aria-expanded'?: string | undefined; //  ariaExpanded\n    'aria-haspopup'?: string | undefined; //  ariaHasPopup\n    'aria-hidden'?: string | undefined; //  ariaHidden\n    'aria-invalid'?: string | undefined; //  ariaInvalid\n    'aria-keyshortcuts'?: string | undefined; //  ariaKeyShortcuts\n    'aria-label'?: string | undefined; //  ariaLabel\n    'aria-level'?: string | undefined; //  ariaLevel\n    'aria-live'?: string | undefined; //  ariaLive\n    'aria-modal'?: string | undefined; //  ariaModal\n    'aria-multiline'?: string | undefined; //  ariaMultiLine\n    'aria-multiselectable'?: string | undefined; //  ariaMultiSelectable\n    'aria-orientation'?: string | undefined; //  ariaOrientation\n    'aria-placeholder'?: string | undefined; //  ariaPlaceholder\n    'aria-posinset'?: string | undefined; //  ariaPosInSet\n    'aria-pressed'?: string | undefined; //  ariaPressed\n    'aria-readonly'?: string | undefined; //  ariaReadOnly\n    'aria-required'?: string | undefined; //  ariaRequired\n    'aria-roledescription'?: string | undefined; //  ariaRoleDescription\n    'aria-rowcount'?: string | undefined; //  ariaRowCount\n    'aria-rowindex'?: string | undefined; //  ariaRowIndex\n    'aria-rowindextext'?: string | undefined; //  ariaRowIndexText\n    'aria-rowspan'?: string | undefined; //  ariaRowSpan\n    'aria-selected'?: string | undefined; //  ariaSelected\n    'aria-setsize'?: string | undefined; //  ariaSetSize\n    'aria-sort'?: string | undefined; //  ariaSort\n    'aria-valuemax'?: string | undefined; //  ariaValueMax\n    'aria-valuemin'?: string | undefined; //  ariaValueMin\n    'aria-valuenow'?: string | undefined; //  ariaValueNow\n    'aria-valuetext'?: string | undefined; //  ariaValueText\n    /** autocapitalization hint */\n    autocapitalize?:\n        | 'off'\n        | 'none'\n        | 'on'\n        | 'sentences'\n        | 'words'\n        | 'characters'\n        | string\n        | undefined;\n    /** focus as soon as the page is loaded or as soon as the dialog within which it finds itself is shown */\n    autofocus?: boolean | undefined;\n    /** the various classes that the element belongs to */\n    class?: string | undefined;\n    /** indicates if the element is editable */\n    contenteditable?: '' | 'true' | 'false' | string | undefined;\n    /** specifies the element's text directionality */\n    dir?: DirValue | undefined;\n    /** specifies the element's drag behavior */\n    draggable?: boolean | undefined;\n    /** specifies what action label (or icon) to present for the enter key on virtual keyboards */\n    enterkeyhint?:\n        | 'enter'\n        | 'done'\n        | 'go'\n        | 'next'\n        | 'previous'\n        | 'search'\n        | 'send'\n        | string\n        | undefined;\n    /** indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user */\n    hidden?: boolean | undefined;\n    /** the unique id of the element */\n    id?: string | undefined;\n    inputmode?:\n        | 'none'\n        | 'text'\n        | 'tel'\n        | 'url'\n        | 'email'\n        | 'numeric'\n        | 'decimal'\n        | 'search'\n        | string\n        | undefined;\n    is?: string | undefined;\n    itemid?: string | undefined;\n    itemprop?: string | undefined;\n    itemref?: string | undefined;\n    itemscope?: boolean | undefined;\n    itemtype?: string | undefined;\n    lang?: string | undefined;\n    nonce?: string | undefined;\n    role?: AriaRole | undefined;\n    slot?: string | undefined;\n    spellcheck?: boolean | undefined;\n    style?: string | undefined;\n    tabindex?: -1 | 0 | number | undefined; // \"-1\" and \"0\" used as convenience\n    title?: string | undefined;\n    translate?: '' | 'yes' | 'no' | undefined;\n}\n\nexport const HTMLElementMap: PropertyMap<\n    JSXElementInterface,\n    HTMLElement & MissingFromTypescriptHTMLElementProperties\n> = {\n    accesskey: {\n        idlName: 'accessKey',\n    },\n    'aria-atomic': {\n        idlName: 'ariaAtomic',\n    },\n    'aria-autocomplete': {\n        idlName: 'ariaAutoComplete',\n    },\n    'aria-busy': {\n        idlName: 'ariaBusy',\n    },\n    'aria-checked': {\n        idlName: 'ariaChecked',\n    },\n    'aria-colcount': {\n        idlName: 'ariaColCount',\n    },\n    'aria-colindex': {\n        idlName: 'ariaColIndex',\n    },\n    'aria-colindextext': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaColIndexText\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaColIndexText',\n    },\n    'aria-colspan': {\n        idlName: 'ariaColSpan',\n    },\n    'aria-current': {\n        idlName: 'ariaCurrent',\n    },\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description': {\n        idlName: 'ariaDescription',\n    },\n    */\n    'aria-disabled': {\n        idlName: 'ariaDisabled',\n    },\n    'aria-expanded': {\n        idlName: 'ariaExpanded',\n    },\n    'aria-haspopup': {\n        idlName: 'ariaHasPopup',\n    },\n    'aria-hidden': {\n        idlName: 'ariaHidden',\n    },\n    'aria-invalid': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaInvalid\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaInvalid',\n    },\n    'aria-keyshortcuts': {\n        idlName: 'ariaKeyShortcuts',\n    },\n    'aria-label': {\n        idlName: 'ariaLabel',\n    },\n    'aria-level': {\n        idlName: 'ariaLevel',\n    },\n    'aria-live': {\n        idlName: 'ariaLive',\n    },\n    'aria-modal': {\n        idlName: 'ariaModal',\n    },\n    'aria-multiline': {\n        idlName: 'ariaMultiLine',\n    },\n    'aria-multiselectable': {\n        idlName: 'ariaMultiSelectable',\n    },\n    'aria-orientation': {\n        idlName: 'ariaOrientation',\n    },\n    'aria-placeholder': {\n        idlName: 'ariaPlaceholder',\n    },\n    'aria-posinset': {\n        idlName: 'ariaPosInSet',\n    },\n    'aria-pressed': {\n        idlName: 'ariaPressed',\n    },\n    'aria-readonly': {\n        idlName: 'ariaReadOnly',\n    },\n    'aria-required': {\n        idlName: 'ariaRequired',\n    },\n    'aria-roledescription': {\n        idlName: 'ariaRoleDescription',\n    },\n    'aria-rowcount': {\n        idlName: 'ariaRowCount',\n    },\n    'aria-rowindex': {\n        idlName: 'ariaRowIndex',\n    },\n    'aria-rowindextext': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaColIndexText\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaRowIndexText',\n    },\n    'aria-rowspan': {\n        idlName: 'ariaRowSpan',\n    },\n    'aria-selected': {\n        idlName: 'ariaSelected',\n    },\n    'aria-setsize': {\n        idlName: 'ariaSetSize',\n    },\n    'aria-sort': {\n        idlName: 'ariaSort',\n    },\n    'aria-valuemax': {\n        idlName: 'ariaValueMax',\n    },\n    'aria-valuemin': {\n        idlName: 'ariaValueMin',\n    },\n    'aria-valuenow': {\n        idlName: 'ariaValueNow',\n    },\n    'aria-valuetext': {\n        idlName: 'ariaValueText',\n    },\n    autocapitalize: {},\n    autofocus: {\n        // Note: The \"autofocus\" property exists in HTMLElement interface: https://html.spec.whatwg.org/multipage/dom.html#htmlorsvgelement\n    },\n    class: {\n        idlName: 'className',\n    },\n    contenteditable: {\n        idlName: 'contentEditable',\n    },\n    dir: {},\n    draggable: {},\n    enterkeyhint: {\n        idlName: 'enterKeyHint',\n    },\n    hidden: {},\n    id: {},\n    inputmode: {\n        idlName: 'inputMode',\n    },\n    is: { idlName: null },\n    itemid: { idlName: null },\n    itemprop: { idlName: null },\n    itemref: { idlName: null },\n    itemscope: { idlName: null },\n    itemtype: { idlName: null },\n    lang: {},\n    nonce: {},\n    role: {},\n    slot: {},\n    spellcheck: {},\n    style: {},\n    tabindex: {\n        idlName: 'tabIndex',\n        makeIdlValue: attrStringOrNumberToNumber,\n    },\n    title: {},\n    translate: {\n        makeIdlValue: attrYesNo,\n    },\n};\n\ninterface JSXAnchorElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** Browsing context for hyperlink navigation */\n    target?: BrowsingContextValue | undefined;\n    /** Whether to download the resource instead of navigating to it, and its filename if so */\n    download?: string | undefined;\n    /** URLs to ping */\n    ping?: string | undefined;\n    /** Relationship between the location in the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLAnchorElementMap: PropertyMap<\n    JSXAnchorElementInterface,\n    HTMLAnchorElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    target: {},\n    download: {},\n    ping: {},\n    rel: {},\n    hreflang: {},\n    type: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXAreaElementInterface extends JSXElementInterface {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    shape?:\n        | 'circle'\n        | 'circ'\n        | 'default'\n        | 'poly'\n        | 'polygon'\n        | 'rect'\n        | 'rectangle'\n        | string\n        | undefined;\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n    download?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLAreaElementMap: PropertyMap<\n    JSXAreaElementInterface,\n    HTMLAreaElement\n> = {\n    ...HTMLElementMap,\n    alt: {},\n    coords: {},\n    shape: {},\n    href: {},\n    target: {},\n    download: {},\n    ping: {},\n    rel: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXMediaElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Hints how much buffering the media resource will likely need */\n    preload?: 'none' | 'metadata' | 'auto' | undefined;\n    /** Hint that the media resource can be started automatically when the page is loaded */\n    autoplay?: boolean | undefined;\n    /** Whether to loop the media resource */\n    loop?: boolean | undefined;\n    /** Whether to mute the media resource by default */\n    muted?: boolean | undefined;\n    /** Show user agent controls */\n    controls?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXAudioElementInterface extends JSXMediaElementInterface {}\n\nconst HTMLAudioElementMap: PropertyMap<\n    JSXAudioElementInterface,\n    HTMLAudioElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    preload: {},\n    autoplay: {},\n    loop: {\n        makeIdlValue: attrBooleanToEmptyString,\n    },\n    muted: {},\n    controls: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBRElementInterface extends JSXElementInterface {}\n\nconst HTMLBRElementMap: PropertyMap<JSXBRElementInterface, HTMLBRElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXBaseElementInterface extends JSXElementInterface {\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n}\n\nconst HTMLBaseElementMap: PropertyMap<\n    JSXBaseElementInterface,\n    HTMLBaseElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    target: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBodyElementInterface extends JSXElementInterface {}\n\nconst HTMLBodyElementMap: PropertyMap<\n    JSXBodyElementInterface,\n    HTMLBodyElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXButtonElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formaction?: string | undefined;\n    formenctype?: EncTypeValue | undefined;\n    formmethod?: FormMethodValue | undefined;\n    formnovalidate?: boolean | undefined;\n    formtarget?: BrowsingContextValue | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | string | undefined;\n    value?: string | undefined;\n}\n\nconst HTMLButtonElementMap: PropertyMap<\n    JSXButtonElementInterface,\n    HTMLButtonElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    form: { idlName: null }, // Note: form IDL not ever written\n    formaction: {\n        idlName: 'formAction',\n    },\n    formenctype: {\n        idlName: 'formEnctype',\n    },\n    formmethod: {\n        idlName: 'formMethod',\n    },\n    formnovalidate: {\n        idlName: 'formNoValidate',\n    },\n    formtarget: {\n        idlName: 'formTarget',\n    },\n    name: {},\n    type: {},\n    value: {},\n};\n\ninterface JSXCanvasElementInterface extends JSXElementInterface {\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\nconst HTMLCanvasElementMap: PropertyMap<\n    JSXCanvasElementInterface,\n    HTMLCanvasElement\n> = {\n    ...HTMLElementMap,\n    width: {},\n    height: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDListElementInterface extends JSXElementInterface {}\n\nconst HTMLDListElementMap: PropertyMap<\n    JSXDListElementInterface,\n    HTMLDListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXDataElementInterface extends JSXElementInterface {\n    value?: string | undefined;\n}\n\nconst HTMLDataElementMap: PropertyMap<\n    JSXDataElementInterface,\n    HTMLDataElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDataListElementInterface extends JSXElementInterface {}\n\nconst HTMLDataListElementMap: PropertyMap<\n    JSXDataListElementInterface,\n    HTMLDataListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXDetailsElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\nconst HTMLDetailsElementMap: PropertyMap<\n    JSXDetailsElementInterface,\n    HTMLDetailsElement\n> = {\n    ...HTMLElementMap,\n    open: {},\n};\n\ninterface JSXDialogElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\nconst HTMLDialogElementMap: PropertyMap<\n    JSXDialogElementInterface,\n    HTMLDialogElement & MissingFromTypescriptHTMLDialogElementProperties\n> = {\n    ...HTMLElementMap,\n    open: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDivElementInterface extends JSXElementInterface {}\n\nconst HTMLDivElementMap: PropertyMap<JSXDivElementInterface, HTMLDivElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXEmbedElementInterface extends JSXElementInterface {\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\nconst HTMLEmbedElementMap: PropertyMap<\n    JSXEmbedElementInterface,\n    HTMLEmbedElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    type: {},\n    width: {},\n    height: {},\n};\n\ninterface JSXFieldSetElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\nconst HTMLFieldSetElementMap: PropertyMap<\n    JSXFieldSetElementInterface,\n    HTMLFieldSetElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    form: { idlName: null }, // form IDL not ever written\n    name: {},\n};\n\ninterface JSXFormElementInterface extends JSXElementInterface {\n    'accept-charset'?: 'UTF-8' | string | undefined;\n    action?: string | undefined;\n    autocomplete?: AutocompleteValue | undefined;\n    enctype?: EncTypeValue | undefined;\n    method?: FormMethodValue | undefined;\n    name?: string | undefined;\n    novalidate?: boolean | undefined;\n    target?: BrowsingContextValue | undefined;\n    rel?: string | undefined;\n}\n\nconst HTMLFormElementMap: PropertyMap<\n    JSXFormElementInterface,\n    HTMLFormElement\n> = {\n    ...HTMLElementMap,\n    'accept-charset': {\n        idlName: 'acceptCharset',\n    },\n    action: {},\n    autocomplete: {},\n    enctype: {},\n    method: {},\n    name: {},\n    novalidate: {\n        idlName: 'noValidate',\n    },\n    target: {},\n    rel: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadingElementInterface extends JSXElementInterface {}\n\nconst HTMLHeadingElementMap: PropertyMap<\n    JSXHeadingElementInterface,\n    HTMLHeadingElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadElementInterface extends JSXElementInterface {}\n\nconst HTMLHeadElementMap: PropertyMap<\n    JSXHeadElementInterface,\n    HTMLHeadElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHRElementInterface extends JSXElementInterface {}\n\nconst HTMLHRElementMap: PropertyMap<JSXHRElementInterface, HTMLHRElement> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHtmlElementInterface extends JSXElementInterface {}\n\nconst HTMLHtmlElementMap: PropertyMap<\n    JSXHtmlElementInterface,\n    HTMLHtmlElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXIFrameElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** A document to render in the iframe */\n    srcdoc?: string | undefined;\n    /** Name of nested browsing context */\n    name?: string | undefined;\n    /** Security rules for nested content */\n    sandbox?: SandboxValue | undefined; // TODO: This _could_ be a SandboxValue[], but feels awkward\n    /** Permissions policy to be applied to the iframe's contents */\n    allow?: string | undefined;\n    /** Whether to allow the iframe's contents to use requestFullscreen() */\n    allowfullscreen?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\nconst HTMLIFrameElementMap: PropertyMap<\n    JSXIFrameElementInterface,\n    HTMLIFrameElement & MissingFromTypescriptHTMLIframeElementProperties\n> = {\n    ...HTMLElementMap,\n    src: {},\n    srcdoc: {},\n    name: {},\n    sandbox: {},\n    allow: {},\n    allowfullscreen: {\n        idlName: 'allowFullscreen',\n    },\n    width: {},\n    height: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    loading: {},\n};\n\ninterface JSXImageElementInterface extends JSXElementInterface {\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Name of image map to use */\n    usemap?: string | undefined;\n    /** Whether the image is a server-side image map */\n    ismap?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Decoding hint to use when processing this image for presentation */\n    decoding?: ImageDecodingHintValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\nconst HTMLImageElementMap: PropertyMap<\n    JSXImageElementInterface,\n    HTMLImageElement\n> = {\n    ...HTMLElementMap,\n    alt: {},\n    src: {},\n    srcset: {},\n    sizes: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    usemap: {\n        idlName: 'useMap',\n    },\n    ismap: {\n        idlName: 'isMap',\n    },\n    width: {},\n    height: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    decoding: {},\n    loading: {},\n};\n\ntype FormInputTypeValues =\n    | 'button'\n    | 'checkbox'\n    | 'color'\n    | 'date'\n    | 'datetime-local'\n    | 'email'\n    | 'file'\n    | 'hidden'\n    | 'image'\n    | 'month'\n    | 'number'\n    | 'password'\n    | 'radio'\n    | 'range'\n    | 'reset'\n    | 'search'\n    | 'submit'\n    | 'tel'\n    | 'text'\n    | 'time'\n    | 'url'\n    | 'week'\n    | string;\n\ninterface JSXInputElementInterface extends JSXElementInterface {\n    /** Hint for expected file type in file upload controls */\n    accept?: string | undefined;\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the control is checked */\n    checked?: boolean | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: string | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** URL to use for form submission */\n    formaction?: string | undefined;\n    /** Entry list encoding type to use for form submission */\n    formenctype?: EncTypeValue | undefined;\n    /** Variant to use for form submission */\n    formmethod?: FormMethodValue | undefined;\n    /** Bypass form control validation for form submission */\n    formnovalidate?: boolean | undefined;\n    /** Browsing context for form submission */\n    formtarget?: BrowsingContextValue | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Third, indeterminate state for checkboxes */\n    indeterminate?: boolean | undefined;\n    /** List of autocomplete options */\n    list?: string | undefined;\n    /** Maximum value */\n    max?: number | undefined;\n    /** Maximum length of value */\n    maxlength?: number | undefined;\n    /** Minimum value */\n    min?: number | undefined;\n    /** Minimum length of value */\n    minlength?: number | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Pattern to be matched by the form control's value */\n    pattern?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: number | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Granularity to be matched by the form control's value */\n    step?: number | undefined;\n    /** Type of form control */\n    type?: FormInputTypeValues | undefined;\n    /** Value of the form control */\n    value?: string | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n}\nconst HTMLInputElementMap: PropertyMap<\n    JSXInputElementInterface,\n    HTMLInputElement\n> = {\n    ...HTMLElementMap,\n    accept: {},\n    alt: {},\n    autocomplete: {},\n    checked: {},\n    dirname: {\n        idlName: 'dirName',\n    },\n    disabled: {},\n    form: {},\n    formaction: {\n        idlName: 'formAction',\n    },\n    formenctype: {\n        idlName: 'formEnctype',\n    },\n    formmethod: {\n        idlName: 'formMethod',\n    },\n    formnovalidate: {\n        idlName: 'formNoValidate',\n    },\n    formtarget: {\n        idlName: 'formTarget',\n    },\n    height: {},\n    indeterminate: {\n        makeAttrValue: null, // TODO: what other IDL attributes don't set html attributes?\n    },\n    list: {},\n    max: {},\n    maxlength: {},\n    min: {},\n    minlength: {\n        idlName: 'minLength',\n    },\n    multiple: {},\n    name: {},\n    pattern: {},\n    placeholder: {},\n    readonly: {\n        idlName: 'readOnly',\n    },\n    required: {},\n    size: {},\n    src: {},\n    step: {},\n    type: {},\n    value: {},\n    width: {},\n};\n\ninterface JSXModElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n    /** Date and (optionally) time of the change */\n    datetime?: string | undefined;\n}\n\nconst HTMLModElementMap: PropertyMap<JSXModElementInterface, HTMLModElement> = {\n    ...HTMLElementMap,\n    cite: {},\n    datetime: {\n        idlName: 'dateTime',\n    },\n};\n\ninterface JSXLabelElementInterface extends JSXElementInterface {\n    /** Associate the label with form control */\n    for?: string | undefined;\n}\n\nconst HTMLLabelElementMap: PropertyMap<\n    JSXLabelElementInterface,\n    HTMLLabelElement\n> = {\n    ...HTMLElementMap,\n    for: {\n        idlName: 'htmlFor',\n    },\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLegendElementInterface extends JSXElementInterface {}\n\nconst HTMLLegendElementMap: PropertyMap<\n    JSXLegendElementInterface,\n    HTMLLegendElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXLIElementInterface extends JSXElementInterface {\n    /** Ordinal value of the list item */\n    value?: string | undefined;\n}\n\nconst HTMLLIElementMap: PropertyMap<JSXLIElementInterface, HTMLLIElement> = {\n    ...HTMLElementMap,\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLinkElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Relationship between the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Sizes of the icons (for rel=\"icon\") */\n    sizes?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel=\"preload\") */\n    imagesrcset?: string | undefined;\n    /** Image sizes for different page layouts (for rel=\"preload\") */\n    imagesizes?: string | undefined;\n    /** Potential destination for a preload request (for rel=\"preload\" and rel=\"modulepreload\") */\n    as?: string | undefined;\n    /** Color to use when customizing a site's icon (for rel=\"mask-icon\") */\n    color?: string | undefined;\n    /** Whether the link is disabled */\n    disabled?: boolean | undefined;\n}\n\nconst HTMLLinkElementMap: PropertyMap<\n    JSXLinkElementInterface,\n    HTMLLinkElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    rel: {},\n    media: {},\n    integrity: {},\n    hreflang: {},\n    type: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    sizes: {},\n    imagesrcset: {\n        idlName: 'imageSrcset',\n    },\n    imagesizes: {\n        idlName: 'imageSizes',\n    },\n    as: {},\n    color: {\n        idlName: null, // TODO: confirm\n    },\n    disabled: {},\n};\n\ninterface JSXMapElementInterface extends JSXElementInterface {\n    /** Name of image map to reference from the usemap attribute */\n    name?: string | undefined;\n}\n\nconst HTMLMapElementMap: PropertyMap<JSXMapElementInterface, HTMLMapElement> = {\n    ...HTMLElementMap,\n    name: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXMenuElementInterface extends JSXElementInterface {}\n\nconst HTMLMenuElementMap: PropertyMap<\n    JSXMenuElementInterface,\n    HTMLMenuElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXMetaElementInterface extends JSXElementInterface {\n    /** Metadata name */\n    name?:\n        | 'application-name'\n        | 'author'\n        | 'description'\n        | 'generator'\n        | 'keywords'\n        | 'referrer'\n        | 'theme-color'\n        | 'color-scheme'\n        | string\n        | undefined;\n    /** Pragma directive */\n    'http-equiv'?: string | undefined;\n    /** Value of the element */\n    content?: string | undefined;\n    /** Character encoding declaration */\n    charset?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n}\n\nconst HTMLMetaElementMap: PropertyMap<\n    JSXMetaElementInterface,\n    HTMLMetaElement & MissingFromTypescriptHTMLMetaElementProperties\n> = {\n    ...HTMLElementMap,\n    name: {},\n    'http-equiv': {\n        idlName: 'httpEquiv',\n    },\n    content: {},\n    charset: {\n        idlName: null, // TODO: confirm\n    },\n    media: {},\n};\n\ninterface JSXMeterElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: number | undefined;\n    /** Lower bound of range */\n    min?: number | undefined;\n    /** Upper bound of range */\n    max?: number | undefined;\n    /** High limit of low range */\n    low?: number | undefined;\n    /** Low limit of high range */\n    high?: number | undefined;\n    /** Optimum value in gauge */\n    optimum?: number | undefined;\n}\n\nconst HTMLMeterElementMap: PropertyMap<\n    JSXMeterElementInterface,\n    HTMLMeterElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n    min: {},\n    max: {},\n    low: {},\n    high: {},\n    optimum: {},\n};\n\ninterface JSXObjectElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    data?: string | undefined;\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** Name of nested browsing context */\n    name?: BrowsingContextValue | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | undefined;\n    /** Vertical dimension */\n    height?: string | undefined;\n}\n\nconst HTMLObjectElementMap: PropertyMap<\n    JSXObjectElementInterface,\n    HTMLObjectElement\n> = {\n    ...HTMLElementMap,\n    data: {},\n    type: {},\n    name: {},\n    form: {\n        idlName: null,\n    },\n    width: {},\n    height: {},\n};\n\ninterface JSXOListElementInterface extends JSXElementInterface {\n    /** Number the list backwards */\n    reversed?: boolean | undefined;\n    /** Starting value of the list */\n    start?: number | undefined;\n    /** Kind of list marker */\n    type?:\n        | 'decimal'\n        | 'lower-alpha'\n        | 'upper-alpha'\n        | 'lower-roman'\n        | 'upper-roman'\n        | string\n        | undefined;\n}\n\nconst HTMLOListElementMap: PropertyMap<\n    JSXOListElementInterface,\n    HTMLOListElement\n> = {\n    ...HTMLElementMap,\n    reversed: {},\n    start: {},\n    type: {},\n};\n\ninterface JSXOptGroupElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n}\n\nconst HTMLOptGroupElementMap: PropertyMap<\n    JSXOptGroupElementInterface,\n    HTMLOptGroupElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    label: {},\n};\n\ninterface JSXOptionElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Whether the option is selected by default */\n    selected?: boolean | undefined;\n    /** Value to be used for form submission */\n    value?: string | undefined;\n}\n\nconst HTMLOptionElementMap: PropertyMap<\n    JSXOptionElementInterface,\n    HTMLOptionElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    label: {},\n    selected: {},\n    value: {},\n};\n\ninterface JSXOutputElementInterface extends JSXElementInterface {\n    /** Specifies controls from which the output was calculated */\n    for?: string | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Name of the element to use in the form.elements API. */\n    name?: string | undefined;\n}\n\nconst HTMLOutputElementMap: PropertyMap<\n    JSXOutputElementInterface,\n    HTMLOutputElement\n> = {\n    ...HTMLElementMap,\n    for: {\n        idlName: 'htmlFor',\n    },\n    form: { idlName: null },\n    name: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXParagraphElementInterface extends JSXElementInterface {}\n\nconst HTMLParagraphElementMap: PropertyMap<\n    JSXParagraphElementInterface,\n    HTMLParagraphElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXParamElementInterface extends JSXElementInterface {\n    /** Name of parameter */\n    name?: string | undefined;\n    /** Value of parameter */\n    value?: string | undefined;\n}\n\nconst HTMLParamElementMap: PropertyMap<\n    JSXParamElementInterface,\n    HTMLParamElement\n> = {\n    ...HTMLElementMap,\n    name: {},\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPictureElementInterface extends JSXElementInterface {}\n\nconst HTMLPictureElementMap: PropertyMap<\n    JSXPictureElementInterface,\n    HTMLPictureElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPreElementInterface extends JSXElementInterface {}\n\nconst HTMLPreElementMap: PropertyMap<JSXPreElementInterface, HTMLPreElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXProgressElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: number | undefined;\n    /** Upper bound of range */\n    max?: number | undefined;\n}\n\nconst HTMLProgressElementMap: PropertyMap<\n    JSXProgressElementInterface,\n    HTMLProgressElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n    max: {},\n};\n\ninterface JSXQuoteElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n}\n\nconst HTMLQuoteElementMap: PropertyMap<\n    JSXQuoteElementInterface,\n    HTMLQuoteElement\n> = {\n    ...HTMLElementMap,\n    cite: {},\n};\n\ninterface JSXScriptElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Type of script */\n    type?: 'application/json' | 'text/json' | 'module' | string | undefined;\n    /** Prevents execution in user agents that support module scripts */\n    nomodule?: boolean | undefined;\n    /** Execute script when available, without blocking while fetching */\n    async?: boolean | undefined;\n    /** Defer script execution */\n    defer?: boolean | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLScriptElementMap: PropertyMap<\n    JSXScriptElementInterface,\n    HTMLScriptElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    type: {},\n    nomodule: {\n        idlName: 'noModule',\n    },\n    async: {},\n    defer: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    integrity: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXSelectElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: number | undefined;\n    /** Value of the element */\n    value?: string | undefined;\n}\n\nconst HTMLSelectElementMap: PropertyMap<\n    JSXSelectElementInterface,\n    HTMLSelectElement\n> = {\n    ...HTMLElementMap,\n    autocomplete: {},\n    disabled: {},\n    form: { idlName: null },\n    multiple: {},\n    name: {},\n    required: {},\n    size: {},\n    value: { makeAttrValue: null },\n};\n\ninterface JSXSlotElementInterface extends JSXElementInterface {\n    /** Name of shadow tree slot */\n    name?: string | undefined;\n}\n\nconst HTMLSlotElementMap: PropertyMap<\n    JSXSlotElementInterface,\n    HTMLSlotElement\n> = {\n    ...HTMLElementMap,\n    name: {},\n};\n\ninterface JSXSourceElementInterface extends JSXElementInterface {\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** (in video or audio) \u2014 Address of the resource */\n    src?: string | undefined;\n    /** (in picture) \u2014 Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** (in picture) \u2014 Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** (in picture) \u2014 Applicable media */\n    media?: string | undefined;\n    /** (in picture) \u2014 Horizontal dimension */\n    width?: number | undefined;\n    /** (in picture) \u2014 Vertical dimension */\n    height?: number | undefined;\n}\n\nconst HTMLSourceElementMap: PropertyMap<\n    JSXSourceElementInterface,\n    HTMLSourceElement & MissingFromTypescriptHTMLSourceElementProperties\n> = {\n    ...HTMLElementMap,\n    type: {},\n    src: {},\n    srcset: {},\n    sizes: {},\n    media: {},\n    width: {},\n    height: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXSpanElementInterface extends JSXElementInterface {}\n\nconst HTMLSpanElementMap: PropertyMap<\n    JSXSpanElementInterface,\n    HTMLSpanElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXStyleElementInterface extends JSXElementInterface {\n    /** Applicable media */\n    media?: string | undefined;\n}\n\nconst HTMLStyleElementMap: PropertyMap<\n    JSXStyleElementInterface,\n    HTMLStyleElement\n> = {\n    ...HTMLElementMap,\n    media: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableElementInterface extends JSXElementInterface {}\n\nconst HTMLTableElementMap: PropertyMap<\n    JSXTableElementInterface,\n    HTMLTableElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableCaptionElementInterface extends JSXElementInterface {}\n\nconst HTMLTableCaptionElementMap: PropertyMap<\n    JSXTableCaptionElementInterface,\n    HTMLTableCaptionElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableSectionElementInterface extends JSXElementInterface {}\n\nconst HTMLTableSectionElementMap: PropertyMap<\n    JSXTableSectionElementInterface,\n    HTMLTableSectionElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTableCellElementInterface extends JSXElementInterface {\n    /** Number of columns that the cell is to span */\n    colspan?: number | undefined;\n    /** Number of rows that the cell is to span */\n    rowspan?: number | undefined;\n    /** The header cells for this cell */\n    headers?: string | undefined;\n}\n\nconst HTMLTableCellElementMap: PropertyMap<\n    JSXTableCellElementInterface,\n    HTMLTableCellElement\n> = {\n    ...HTMLElementMap,\n    colspan: {\n        idlName: 'colSpan',\n    },\n    rowspan: {\n        idlName: 'rowSpan',\n    },\n    headers: {},\n};\n\ninterface JSXTableColElementInterface extends JSXElementInterface {\n    /** Number of columns spanned by the element */\n    span?: number | undefined;\n}\n\nconst HTMLTableColElementMap: PropertyMap<\n    JSXTableColElementInterface,\n    HTMLTableColElement\n> = {\n    ...HTMLElementMap,\n    span: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTemplateElementInterface extends JSXElementInterface {}\n\nconst HTMLTemplateElementMap: PropertyMap<\n    JSXTemplateElementInterface,\n    HTMLTemplateElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTextAreaElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Maximum number of characters per line */\n    cols?: number | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: DirValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Maximum length of value */\n    maxlength?: number | undefined;\n    /** Minimum length of value */\n    minlength?: number | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Number of lines to show */\n    rows?: number | undefined;\n    /** How the value of the form control is to be wrapped for form submission */\n    wrap?: 'soft' | 'hard' | string | undefined;\n}\n\nconst HTMLTextAreaElementMap: PropertyMap<\n    JSXTextAreaElementInterface,\n    HTMLTextAreaElement\n> = {\n    ...HTMLElementMap,\n    autocomplete: {},\n    cols: {},\n    dirname: {\n        idlName: 'dirName',\n    },\n    disabled: {},\n    form: { idlName: null },\n    maxlength: {\n        idlName: 'maxLength',\n    },\n    minlength: {\n        idlName: 'minLength',\n    },\n    name: {},\n    placeholder: {},\n    readonly: {\n        idlName: 'readOnly',\n    },\n    required: {},\n    rows: {},\n    wrap: {},\n};\n\ninterface JSXTimeElementInterface extends JSXElementInterface {\n    /** Machine-readable value */\n    datetime?: string | undefined;\n}\n\nconst HTMLTimeElementMap: PropertyMap<\n    JSXTimeElementInterface,\n    HTMLTimeElement\n> = {\n    ...HTMLElementMap,\n    datetime: {\n        idlName: 'dateTime',\n    },\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTitleElementInterface extends JSXElementInterface {}\n\nconst HTMLTitleElementMap: PropertyMap<\n    JSXTitleElementInterface,\n    HTMLTitleElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableRowElementInterface extends JSXElementInterface {}\n\nconst HTMLTableRowElementMap: PropertyMap<\n    JSXTableRowElementInterface,\n    HTMLTableRowElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTrackElementInterface extends JSXElementInterface {\n    /** The type of text track */\n    kind?:\n        | 'subtitles'\n        | 'captions'\n        | 'descriptions'\n        | 'chapters'\n        | 'metadata'\n        | string\n        | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Language of the text track */\n    srclang?: string | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Enable the track if no other text track is more suitable */\n    default?: boolean | undefined;\n}\n\nconst HTMLTrackElementMap: PropertyMap<\n    JSXTrackElementInterface,\n    HTMLTrackElement\n> = {\n    ...HTMLElementMap,\n    kind: {},\n    src: {},\n    srclang: {},\n    label: {},\n    default: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXUListElementInterface extends JSXElementInterface {}\n\nconst HTMLUListElementMap: PropertyMap<\n    JSXUListElementInterface,\n    HTMLUListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXVideoElementInterface extends JSXMediaElementInterface {\n    /** Poster frame to show prior to video playback */\n    poster?: string | undefined;\n    /** Encourage the user agent to display video content within the element's playback area */\n    playsinline?: string | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n}\n\nconst HTMLVideoElementMap: PropertyMap<\n    JSXVideoElementInterface,\n    HTMLVideoElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    preload: {},\n    autoplay: {},\n    loop: {\n        makeIdlValue: attrBooleanToEmptyString,\n    },\n    muted: {},\n    controls: {},\n    poster: {},\n    playsinline: {\n        idlName: 'playsInline',\n    },\n    width: {},\n    height: {},\n};\n\nexport const ElementTypeMapping = {\n    a: HTMLAnchorElementMap,\n    abbr: HTMLElementMap,\n    address: HTMLElementMap,\n    area: HTMLAreaElementMap,\n    article: HTMLElementMap,\n    aside: HTMLElementMap,\n    audio: HTMLAudioElementMap,\n    b: HTMLElementMap,\n    base: HTMLBaseElementMap,\n    bdi: HTMLElementMap,\n    bdo: HTMLElementMap,\n    blockquote: HTMLElementMap,\n    body: HTMLBodyElementMap,\n    br: HTMLBRElementMap,\n    button: HTMLButtonElementMap,\n    canvas: HTMLCanvasElementMap,\n    caption: HTMLTableCaptionElementMap,\n    cite: HTMLElementMap,\n    code: HTMLElementMap,\n    col: HTMLTableColElementMap,\n    colgroup: HTMLTableColElementMap,\n    data: HTMLDataElementMap,\n    datalist: HTMLDataListElementMap,\n    dd: HTMLElementMap,\n    del: HTMLModElementMap,\n    details: HTMLDetailsElementMap,\n    dfn: HTMLElementMap,\n    dialog: HTMLDialogElementMap,\n    div: HTMLDivElementMap,\n    dl: HTMLDListElementMap,\n    dt: HTMLElementMap,\n    em: HTMLElementMap,\n    embed: HTMLEmbedElementMap,\n    fieldset: HTMLFieldSetElementMap,\n    figcaption: HTMLElementMap,\n    figure: HTMLElementMap,\n    footer: HTMLElementMap,\n    form: HTMLFormElementMap,\n    h1: HTMLElementMap,\n    h2: HTMLElementMap,\n    h3: HTMLElementMap,\n    h4: HTMLElementMap,\n    h5: HTMLElementMap,\n    h6: HTMLElementMap,\n    head: HTMLHeadElementMap,\n    header: HTMLElementMap,\n    heading: HTMLHeadingElementMap,\n    hgroup: HTMLElementMap,\n    hr: HTMLHRElementMap,\n    html: HTMLHtmlElementMap,\n    i: HTMLElementMap,\n    iframe: HTMLIFrameElementMap,\n    image: HTMLImageElementMap,\n    img: HTMLElementMap,\n    input: HTMLInputElementMap,\n    ins: HTMLModElementMap,\n    kbd: HTMLElementMap,\n    label: HTMLLabelElementMap,\n    legend: HTMLLegendElementMap,\n    li: HTMLLIElementMap,\n    link: HTMLLinkElementMap,\n    main: HTMLElementMap,\n    map: HTMLMapElementMap,\n    mark: HTMLElementMap,\n    menu: HTMLMenuElementMap,\n    meta: HTMLMetaElementMap,\n    meter: HTMLMeterElementMap,\n    nav: HTMLElementMap,\n    noscript: HTMLElementMap,\n    object: HTMLObjectElementMap,\n    ol: HTMLOListElementMap,\n    optgroup: HTMLOptGroupElementMap,\n    option: HTMLOptionElementMap,\n    output: HTMLOutputElementMap,\n    p: HTMLParagraphElementMap,\n    param: HTMLParamElementMap,\n    picture: HTMLPictureElementMap,\n    pre: HTMLPreElementMap,\n    progress: HTMLProgressElementMap,\n    quote: HTMLQuoteElementMap,\n    rp: HTMLElementMap,\n    rt: HTMLElementMap,\n    ruby: HTMLElementMap,\n    s: HTMLElementMap,\n    samp: HTMLElementMap,\n    script: HTMLScriptElementMap,\n    section: HTMLElementMap,\n    select: HTMLSelectElementMap,\n    slot: HTMLSlotElementMap,\n    small: HTMLElementMap,\n    source: HTMLSourceElementMap,\n    span: HTMLSpanElementMap,\n    strong: HTMLElementMap,\n    style: HTMLStyleElementMap,\n    sub: HTMLElementMap,\n    summary: HTMLElementMap,\n    sup: HTMLElementMap,\n    table: HTMLTableElementMap,\n    tbody: HTMLTableSectionElementMap,\n    td: HTMLTableCellElementMap,\n    template: HTMLTemplateElementMap,\n    textarea: HTMLTextAreaElementMap,\n    tfoot: HTMLTableSectionElementMap,\n    th: HTMLElementMap,\n    thead: HTMLTableSectionElementMap,\n    time: HTMLTimeElementMap,\n    title: HTMLTitleElementMap,\n    tr: HTMLTableRowElementMap,\n    track: HTMLTrackElementMap,\n    u: HTMLElementMap,\n    ul: HTMLUListElementMap,\n    var: HTMLElementMap,\n    video: HTMLVideoElementMap,\n    wbr: HTMLElementMap,\n} as const;\n\n// TODO: maybe typecheck this?\ninterface ElementTypeMappingField {\n    makeAttrValue?: (jsxAttr: any) => string | undefined;\n    idlName?: any;\n    makeIdlValue?: (jsxAttr: any) => any;\n}\n\n// TODO: maybe typecheck this?\nexport function getElementTypeMapping(\n    elementName: string,\n    property: string\n): ElementTypeMappingField {\n    return (ElementTypeMapping as any)[elementName]?.[property];\n}\n\n/**\n * Good old bivarianceHack to allow assignability of specific event handlers to more generic event handlers :facepalm:\n */\ntype EventHandler<TEvent extends Event> =\n    | undefined\n    | {\n          bivarianceHack(event: TEvent): void;\n      }['bivarianceHack'];\n\ninterface JSXRefProps<TElement extends HTMLElement> {\n    ref?: undefined | Ref<TElement> | ((current: TElement | undefined) => void);\n}\n\ninterface JSXEventProps {\n    'on:abort'?: EventHandler<Event>;\n    'on:auxclick'?: EventHandler<PointerEvent>;\n    'on:beforeinput'?: EventHandler<InputEvent>;\n    'on:blur'?: EventHandler<FocusEvent>;\n    'on:cancel'?: EventHandler<Event>;\n    'on:change'?: EventHandler<Event>;\n    'on:click'?: EventHandler<PointerEvent>;\n    'on:close'?: EventHandler<Event>;\n    'on:compositionend'?: EventHandler<CompositionEvent>;\n    'on:compositionstart'?: EventHandler<CompositionEvent>;\n    'on:compositionupdate'?: EventHandler<CompositionEvent>;\n    'on:connect'?: EventHandler<MessageEvent>;\n    'on:contextlost'?: EventHandler<Event>;\n    'on:contextmenu'?: EventHandler<PointerEvent>;\n    'on:contextrestored'?: EventHandler<Event>;\n    'on:copy'?: EventHandler<Event>;\n    'on:cut'?: EventHandler<Event>;\n    'on:dblclick'?: EventHandler<MouseEvent>;\n    'on:drag'?: EventHandler<DragEvent>;\n    'on:dragend'?: EventHandler<DragEvent>;\n    'on:dragenter'?: EventHandler<DragEvent>;\n    'on:dragleave'?: EventHandler<DragEvent>;\n    'on:dragover'?: EventHandler<DragEvent>;\n    'on:dragstart'?: EventHandler<DragEvent>;\n    'on:drop'?: EventHandler<DragEvent>;\n    'on:emptied'?: EventHandler<Event>;\n    'on:error'?: EventHandler<Event>;\n    'on:focus'?: EventHandler<FocusEvent>;\n    'on:focusin'?: EventHandler<FocusEvent>;\n    'on:focusout'?: EventHandler<FocusEvent>;\n    'on:formdata'?: EventHandler<FormDataEvent>;\n    'on:hashchange'?: EventHandler<HashChangeEvent>;\n    'on:input'?: EventHandler<InputEvent>;\n    'on:invalid'?: EventHandler<Event>;\n    'on:keydown'?: EventHandler<KeyboardEvent>;\n    'on:keyup'?: EventHandler<KeyboardEvent>;\n    'on:languagechange'?: EventHandler<Event>;\n    'on:load'?: EventHandler<Event>;\n    'on:loadstart'?: EventHandler<Event>;\n    'on:message'?: EventHandler<MessageEvent>;\n    'on:messageerror'?: EventHandler<MessageEvent>;\n    'on:mousedown'?: EventHandler<MouseEvent>;\n    'on:mouseenter'?: EventHandler<MouseEvent>;\n    'on:mouseleave'?: EventHandler<MouseEvent>;\n    'on:mousemove'?: EventHandler<MouseEvent>;\n    'on:mouseout'?: EventHandler<MouseEvent>;\n    'on:mouseover'?: EventHandler<MouseEvent>;\n    'on:mouseup'?: EventHandler<MouseEvent>;\n    'on:offline'?: EventHandler<Event>;\n    'on:online'?: EventHandler<Event>;\n    'on:open'?: EventHandler<Event>;\n    'on:pagehide'?: EventHandler<PageTransitionEvent>;\n    'on:pageshow'?: EventHandler<PageTransitionEvent>;\n    'on:paste'?: EventHandler<Event>;\n    'on:popstate'?: EventHandler<PopStateEvent>;\n    'on:progress'?: EventHandler<Event>;\n    'on:readystatechange'?: EventHandler<Event>;\n    'on:rejectionhandled'?: EventHandler<PromiseRejectionEvent>;\n    'on:reset'?: EventHandler<Event>;\n    'on:securitypolicyviolation'?: EventHandler<Event>;\n    'on:select'?: EventHandler<Event>;\n    'on:slotchange'?: EventHandler<Event>;\n    'on:stalled'?: EventHandler<Event>;\n    'on:storage'?: EventHandler<StorageEvent>;\n    'on:submit'?: EventHandler<SubmitEvent>;\n    'on:suspend'?: EventHandler<Event>;\n    'on:toggle'?: EventHandler<Event>;\n    'on:unhandledrejection'?: EventHandler<PromiseRejectionEvent>;\n    'on:unload'?: EventHandler<Event>;\n    'on:visibilitychange'?: EventHandler<Event>;\n    'on:wheel'?: EventHandler<WheelEvent>;\n    [key: `on:${string}`]: EventHandler<Event>;\n}\n\ninterface JSXDataProps {\n    [key: `data-${string}`]:\n        | Calculation<string | undefined>\n        | string\n        | undefined;\n}\n\ntype JSXElementInterfaceProps<TJSXType extends JSXElementInterface> = {\n    [Key in keyof TJSXType]:\n        | (Calculation<any> & (() => TJSXType[Key]))\n        | TJSXType[Key];\n};\n\ntype JSXChildrenProps<HasChildren extends boolean> = HasChildren extends true\n    ? { children?: JSX.Element | JSX.Element[] }\n    : { children?: never }; // TODO: this is not correct, leads to confusing errors; figure out why the types are not working as expected here...\n\ntype WithCalculationsAndRef<\n    TJSXType extends JSXElementInterface,\n    TElement extends HTMLElement,\n    HasChildren extends boolean\n> = JSXRefProps<TElement> &\n    JSXEventProps &\n    JSXDataProps &\n    JSXElementInterfaceProps<TJSXType> &\n    JSXChildrenProps<HasChildren>;\n\nexport interface KnownElements {\n    a: WithCalculationsAndRef<\n        JSXAnchorElementInterface,\n        HTMLAnchorElement,\n        true\n    >;\n    abbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    address: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    area: WithCalculationsAndRef<\n        JSXAreaElementInterface,\n        HTMLAreaElement,\n        false\n    >;\n    article: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    aside: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    audio: WithCalculationsAndRef<\n        JSXAudioElementInterface,\n        HTMLAudioElement,\n        true\n    >;\n    b: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    base: WithCalculationsAndRef<\n        JSXBaseElementInterface,\n        HTMLBaseElement,\n        false\n    >;\n    bdi: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    bdo: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    blockquote: WithCalculationsAndRef<\n        JSXQuoteElementInterface,\n        HTMLQuoteElement,\n        true\n    >;\n    body: WithCalculationsAndRef<\n        JSXBodyElementInterface,\n        HTMLBodyElement,\n        true\n    >;\n    br: WithCalculationsAndRef<JSXBRElementInterface, HTMLBRElement, false>;\n    button: WithCalculationsAndRef<\n        JSXButtonElementInterface,\n        HTMLButtonElement,\n        true\n    >;\n    canvas: WithCalculationsAndRef<\n        JSXCanvasElementInterface,\n        HTMLCanvasElement,\n        true\n    >;\n    caption: WithCalculationsAndRef<\n        JSXTableCaptionElementInterface,\n        HTMLTableCaptionElement,\n        true\n    >;\n    cite: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    code: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    col: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        false\n    >;\n    colgroup: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        true\n    >;\n    data: WithCalculationsAndRef<\n        JSXDataElementInterface,\n        HTMLDataElement,\n        true\n    >;\n    datalist: WithCalculationsAndRef<\n        JSXDataListElementInterface,\n        HTMLDataListElement,\n        true\n    >;\n    dd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    del: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    details: WithCalculationsAndRef<\n        JSXDetailsElementInterface,\n        HTMLDetailsElement,\n        true\n    >;\n    dfn: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    dialog: WithCalculationsAndRef<\n        JSXDialogElementInterface,\n        HTMLDialogElement,\n        true\n    >;\n    div: WithCalculationsAndRef<JSXDivElementInterface, HTMLDivElement, true>;\n    dl: WithCalculationsAndRef<\n        JSXDListElementInterface,\n        HTMLDListElement,\n        true\n    >;\n    dt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    em: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    embed: WithCalculationsAndRef<\n        JSXEmbedElementInterface,\n        HTMLEmbedElement,\n        false\n    >;\n    fieldset: WithCalculationsAndRef<\n        JSXFieldSetElementInterface,\n        HTMLFieldSetElement,\n        true\n    >;\n    figcaption: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    figure: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    footer: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    form: WithCalculationsAndRef<\n        JSXFormElementInterface,\n        HTMLFormElement,\n        true\n    >;\n    h1: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h2: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h3: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h4: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h5: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h6: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    head: WithCalculationsAndRef<\n        JSXHeadElementInterface,\n        HTMLHeadElement,\n        true\n    >;\n    header: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hgroup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hr: WithCalculationsAndRef<JSXHRElementInterface, HTMLHRElement, false>;\n    html: WithCalculationsAndRef<\n        JSXHtmlElementInterface,\n        HTMLHtmlElement,\n        true\n    >;\n    i: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    iframe: WithCalculationsAndRef<\n        JSXIFrameElementInterface,\n        HTMLIFrameElement,\n        true\n    >;\n    img: WithCalculationsAndRef<\n        JSXImageElementInterface,\n        HTMLImageElement,\n        false\n    >;\n    input: WithCalculationsAndRef<\n        JSXInputElementInterface,\n        HTMLInputElement,\n        false\n    >;\n    ins: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    kbd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    label: WithCalculationsAndRef<\n        JSXLabelElementInterface,\n        HTMLLabelElement,\n        true\n    >;\n    legend: WithCalculationsAndRef<\n        JSXLegendElementInterface,\n        HTMLLegendElement,\n        true\n    >;\n    li: WithCalculationsAndRef<JSXLIElementInterface, HTMLLIElement, true>;\n    link: WithCalculationsAndRef<\n        JSXLinkElementInterface,\n        HTMLLinkElement,\n        false\n    >;\n    main: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    map: WithCalculationsAndRef<JSXMapElementInterface, HTMLMapElement, true>;\n    mark: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    menu: WithCalculationsAndRef<\n        JSXMenuElementInterface,\n        HTMLMenuElement,\n        true\n    >;\n    meta: WithCalculationsAndRef<\n        JSXMetaElementInterface,\n        HTMLMetaElement,\n        false\n    >;\n    meter: WithCalculationsAndRef<\n        JSXMeterElementInterface,\n        HTMLMeterElement,\n        true\n    >;\n    nav: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    noscript: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    object: WithCalculationsAndRef<\n        JSXObjectElementInterface,\n        HTMLObjectElement,\n        true\n    >;\n    ol: WithCalculationsAndRef<\n        JSXOListElementInterface,\n        HTMLOListElement,\n        true\n    >;\n    optgroup: WithCalculationsAndRef<\n        JSXOptGroupElementInterface,\n        HTMLOptGroupElement,\n        true\n    >;\n    option: WithCalculationsAndRef<\n        JSXOptionElementInterface,\n        HTMLOptionElement,\n        true\n    >;\n    output: WithCalculationsAndRef<\n        JSXOutputElementInterface,\n        HTMLOutputElement,\n        true\n    >;\n    p: WithCalculationsAndRef<\n        JSXParagraphElementInterface,\n        HTMLParagraphElement,\n        true\n    >;\n    param: WithCalculationsAndRef<\n        JSXParamElementInterface,\n        HTMLParamElement,\n        false\n    >;\n    picture: WithCalculationsAndRef<\n        JSXPictureElementInterface,\n        HTMLPictureElement,\n        true\n    >;\n    pre: WithCalculationsAndRef<JSXPreElementInterface, HTMLPreElement, true>;\n    progress: WithCalculationsAndRef<\n        JSXProgressElementInterface,\n        HTMLProgressElement,\n        true\n    >;\n    q: WithCalculationsAndRef<JSXQuoteElementInterface, HTMLQuoteElement, true>;\n    rp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    rt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ruby: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    s: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    samp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    script: WithCalculationsAndRef<\n        JSXScriptElementInterface,\n        HTMLScriptElement,\n        true\n    >;\n    section: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    select: WithCalculationsAndRef<\n        JSXSelectElementInterface,\n        HTMLSelectElement,\n        true\n    >;\n    slot: WithCalculationsAndRef<\n        JSXSlotElementInterface,\n        HTMLSlotElement,\n        true\n    >;\n    small: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    source: WithCalculationsAndRef<\n        JSXSourceElementInterface,\n        HTMLSourceElement,\n        false\n    >;\n    span: WithCalculationsAndRef<\n        JSXSpanElementInterface,\n        HTMLSpanElement,\n        true\n    >;\n    strong: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    style: WithCalculationsAndRef<\n        JSXStyleElementInterface,\n        HTMLStyleElement,\n        true\n    >;\n    sub: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    summary: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    sup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    table: WithCalculationsAndRef<\n        JSXTableElementInterface,\n        HTMLTableElement,\n        true\n    >;\n    tbody: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    td: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    template: WithCalculationsAndRef<\n        JSXTemplateElementInterface,\n        HTMLTemplateElement,\n        true\n    >;\n    textarea: WithCalculationsAndRef<\n        JSXTextAreaElementInterface,\n        HTMLTextAreaElement,\n        true\n    >;\n    tfoot: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    th: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    thead: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    time: WithCalculationsAndRef<\n        JSXTimeElementInterface,\n        HTMLTimeElement,\n        true\n    >;\n    title: WithCalculationsAndRef<\n        JSXTitleElementInterface,\n        HTMLTitleElement,\n        true\n    >;\n    tr: WithCalculationsAndRef<\n        JSXTableRowElementInterface,\n        HTMLTableRowElement,\n        true\n    >;\n    track: WithCalculationsAndRef<\n        JSXTrackElementInterface,\n        HTMLTrackElement,\n        false\n    >;\n    u: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ul: WithCalculationsAndRef<\n        JSXUListElementInterface,\n        HTMLUListElement,\n        true\n    >;\n    var: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    video: WithCalculationsAndRef<\n        JSXVideoElementInterface,\n        HTMLVideoElement,\n        true\n    >;\n    wbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, false>;\n}\n", "import * as log from './log';\n\n/**\n * A VNode represents a node in the JSX tree structure\n *\n * Since a JSXNode may render to 0, 1, or many DOM nodes, we need to keep track\n * of the virtual tree structure to understand which index to update within the\n * DOM tree.\n */\nexport type VNode = {\n    domNode?: Node;\n    children?: VNode[];\n    domParent?: VNode;\n    onMount?: Function[];\n    onUnmount?: Function[];\n};\n\n/**\n * Get shallow DOM nodes from the virtual tree.\n *\n * For example, with this virtual tree:\n *\n * <root>\n *   <A>...</A>\n *   <B>\n *     <B1>\n *      <div id=\"b_1_1\">...</div>\n *      {false}\n *      {[\n *        <div id=\"b_1_arr_1\">...</div>\n *        <div id=\"b_1_arr_2\">...</div>\n *      ]}\n *      <SubComponent>\n *        <div id=\"b_1_sub_1\">...</div>\n *        <div id=\"b_1_sub_2\">...</div>\n *      </SubComponent>\n *      <div id=\"b_1_3\">...</div>\n *     </B1>\n *   </B>\n *   <C>\n *     ...\n *   </C>\n * </root>\n *\n * If getShallowNodes is called with <B> as the target, this would retrieve:\n * [b_1_1, b_1_arr_1, b_1_arr_2, b_1_sub_1, b_1_sub_2, b_1_3]\n */\nfunction getShallowNodes(vNode: VNode): Node[] {\n    const nodes: Node[] = [];\n    function visit(node: VNode) {\n        if (node.domNode) {\n            nodes.push(node.domNode);\n        } else {\n            node.children?.forEach((child) => visit(child));\n        }\n    }\n    visit(vNode);\n    return nodes;\n}\n\nfunction getDomParentChildIndex(\n    domParent: VNode,\n    immediateParent: VNode,\n    childIndex: number\n): number {\n    let realIndex = 0;\n\n    function visit(node: VNode): boolean {\n        if (node.domNode) {\n            realIndex += 1;\n            return false;\n        } else {\n            return visitChildren(node);\n        }\n    }\n    function visitChildren(node: VNode): boolean {\n        if (node.children) {\n            const visitIndex =\n                node === immediateParent ? childIndex : node.children.length;\n            for (let i = 0; i < visitIndex; ++i) {\n                if (visit(node.children[i])) {\n                    return true;\n                }\n            }\n        }\n        return node === immediateParent;\n    }\n    visitChildren(domParent);\n    return realIndex;\n}\n\nexport function callOnMount(node: VNode) {\n    // Note: we are doing a post-order traversal, so all children onMount are called before parents are called\n    node.children?.forEach((child) => callOnMount(child));\n\n    // Call any onMount listeners\n    if (node.onMount) {\n        node.onMount.forEach((onMount) => {\n            try {\n                onMount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onMount',\n                    node\n                );\n            }\n        });\n    }\n}\n\n/**\n * Collect shallow DOM nodes and conditionally call onUnmount if specified\n */\nfunction performUnmount(\n    node: VNode,\n    shallowDomNodes: Node[] | undefined,\n    runOnUnmount: boolean\n) {\n    if (shallowDomNodes && node.domNode) {\n        shallowDomNodes.push(node.domNode);\n    }\n    // Note: we are doing a post-order traversal, so all children are released/unmounted before parents are released/unmounted\n    node.children?.forEach((child) => {\n        performUnmount(\n            child,\n            node.domNode ? undefined : shallowDomNodes,\n            runOnUnmount\n        );\n    });\n\n    // Call any onUnmount listeners\n    if (runOnUnmount && node.onUnmount) {\n        node.onUnmount.forEach((onUnmount) => {\n            try {\n                onUnmount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onUnmount',\n                    node\n                );\n            }\n        });\n    }\n}\n\nexport function spliceVNode(\n    immediateParent: VNode,\n    childIndex: number,\n    removeCount: number,\n    newNodes: VNode[],\n    { runOnMount = true, runOnUnmount = true } = {}\n) {\n    log.assert(\n        immediateParent.children,\n        'attempted to splice a parent node with no children'\n    );\n    const domParent = immediateParent.domNode\n        ? immediateParent\n        : immediateParent.domParent;\n    if (childIndex > immediateParent.children.length) {\n        childIndex = immediateParent.children.length;\n    }\n    log.assert(\n        domParent && domParent.domNode,\n        'tried to replace a root tree slot with missing domParent'\n    );\n\n    const domParentNode = domParent.domNode;\n\n    const detachedVNodes = immediateParent.children.splice(\n        childIndex,\n        removeCount,\n        ...newNodes\n    );\n\n    // Remove nodes, optimizing for array replacement, where all nodes are completely removed via .replaceChildren()\n    const toRemove: Node[] = [];\n    detachedVNodes.forEach((detachedVNode) => {\n        performUnmount(detachedVNode, toRemove, runOnUnmount);\n    });\n\n    if (domParentNode.childNodes.length === toRemove.length) {\n        // By virtue of having children, this Node must be an Element\n        (domParentNode as Element).replaceChildren();\n    } else {\n        toRemove.forEach((child) => domParentNode.removeChild(child));\n    }\n\n    // Insert nodes via fragment with a single DOM operation\n    if (newNodes.length > 0) {\n        const domIndex = getDomParentChildIndex(\n            domParent,\n            immediateParent,\n            childIndex\n        );\n        const referenceNode: Node | undefined =\n            domParentNode.childNodes[domIndex];\n\n        const fragment = document.createDocumentFragment();\n\n        for (let i = 0; i < newNodes.length; ++i) {\n            const newNode = newNodes[i];\n            newNode.domParent = domParent;\n            const nodesToAdd = getShallowNodes(newNode);\n            nodesToAdd.forEach((addNode) => {\n                fragment.appendChild(addNode);\n            });\n        }\n\n        domParentNode.insertBefore(fragment, referenceNode || null);\n        if (runOnMount) {\n            newNodes.forEach((newNode) => {\n                if (newNode) {\n                    callOnMount(newNode);\n                }\n            });\n        }\n    }\n    return detachedVNodes;\n}\n", "import {\n    effect,\n    retain,\n    release,\n    untracked,\n    addOrderingDep,\n    removeOrderingDep,\n    registerNode,\n    disposeNode,\n    trackCreatedCalculations,\n} from './calc';\nimport { name, debugNameFor } from './debug';\nimport {\n    Collection,\n    Calculation,\n    View,\n    Context,\n    NodeOrdering,\n    isContext,\n    isCalculation,\n    isCollection,\n    isRef,\n    ObserveKey,\n    GetSubscriptionNodeKey,\n    TypeTag,\n    createContext,\n    getContext,\n} from './types';\nimport * as log from './log';\nimport { uniqueid } from './util';\nimport {\n    Component,\n    JSXNode,\n    RenderedElement,\n    getElementTypeMapping,\n} from './jsx';\nimport { VNode, spliceVNode, callOnMount } from './vnode';\n\nexport const Fragment = ({ children }: { children: JSXNode[] }) => children;\n\n// Intrinsic element\nexport function createElement<TProps, TChildren extends JSXNode>(\n    Constructor: string,\n    props: TProps,\n    ...children: TChildren[]\n): RenderedElement<TProps, unknown, TChildren>;\n// Context component\nexport function createElement<\n    TContext,\n    TProps extends { value: TContext },\n    TChildren extends JSXNode\n>(\n    Constructor: Context<TContext>,\n    props: TProps,\n    ...children: TChildren[]\n): RenderedElement<unknown, TContext, TChildren>;\n// Component with one required child\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children: TChildren }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    children: TChildren\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with multiple required children\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children: TChildren[] }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    ...children: TChildren[]\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with one optional child\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children?: TChildren | undefined }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    children?: TChildren | undefined\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with multiple required children\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children?: TChildren[] | undefined }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    ...children: TChildren[]\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with no children\nexport function createElement<TChildren extends JSXNode, TProps extends {}>(\n    Constructor: Component<TProps>,\n    props: TProps\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\nexport function createElement<TProps, TContext, TChildren extends JSXNode>(\n    Constructor:\n        | string\n        | Component<TProps>\n        | Component<TProps & { children?: TChildren }>\n        | Component<TProps & { children: TChildren }>,\n    props: TProps,\n    ...children: TChildren[]\n): RenderedElement<TProps, TContext, TChildren> {\n    if (typeof Constructor === 'string') {\n        return {\n            type: 'intrinsic',\n            element: Constructor,\n            props,\n            children,\n        };\n    }\n    if (isContext(Constructor)) {\n        return {\n            type: 'context',\n            context: Constructor,\n            props: props as unknown as { value: TContext },\n            children,\n        };\n    }\n    return {\n        type: 'component',\n        component: Constructor,\n        props,\n        children,\n    };\n}\n\ncreateElement.Fragment = Fragment;\n\nfunction setAttributeValue(\n    elementType: string,\n    element: Element,\n    key: string,\n    value: unknown,\n    boundEvents: Record<string, (ev: Event) => void>\n) {\n    if (key.startsWith('on:') && typeof value === 'function') {\n        const eventName = key.slice(3);\n        if (boundEvents[key]) {\n            element.removeEventListener(eventName, boundEvents[key]);\n        }\n        element.addEventListener(eventName, value as any);\n        boundEvents[key] = value as any;\n    } else {\n        const attributeNamespace = attributeNamespaceMap[key] || null;\n        const mapping = getElementTypeMapping(elementType, key);\n        if (mapping) {\n            if (mapping.makeAttrValue !== null) {\n                const attributeValue = mapping.makeAttrValue\n                    ? mapping.makeAttrValue(value)\n                    : (value as any);\n                if (\n                    attributeValue === undefined ||\n                    attributeValue === null ||\n                    attributeValue === false\n                ) {\n                    element.removeAttribute(key);\n                } else if (attributeValue === true) {\n                    element.setAttributeNS(attributeNamespace, key, '');\n                } else {\n                    element.setAttributeNS(\n                        attributeNamespace,\n                        key,\n                        attributeValue\n                    );\n                }\n            }\n            if (mapping.idlName !== null) {\n                (element as any)[mapping.idlName ?? key] = mapping.makeIdlValue\n                    ? mapping.makeIdlValue(value)\n                    : value;\n            }\n        } else if (value === false || value === undefined || value === null) {\n            element.removeAttributeNS(attributeNamespace, key);\n        } else if (value === true) {\n            element.setAttributeNS(attributeNamespace, key, '');\n        } else if (typeof value === 'string' || typeof value === 'number') {\n            element.setAttributeNS(attributeNamespace, key, value.toString());\n        }\n    }\n}\n\nfunction isCollectionView(\n    thing: JSXNode\n): thing is Collection<JSXNode> | View<JSXNode> {\n    return isCollection(thing);\n}\n\nfunction jsxNodeToVNode(\n    jsxNode: JSXNode,\n    domParent: VNode,\n    parentOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        jsxNode === false ||\n        jsxNode === true\n    ) {\n        return { domParent };\n    }\n    if (typeof jsxNode === 'string') {\n        const domNode = document.createTextNode(jsxNode);\n        documentFragment.appendChild(domNode);\n        return {\n            domNode,\n            domParent,\n        };\n    }\n    if (typeof jsxNode === 'number') {\n        const domNode = document.createTextNode(jsxNode.toString());\n        documentFragment.appendChild(domNode);\n        return {\n            domNode,\n            domParent,\n        };\n    }\n    if (isCalculation(jsxNode)) {\n        return makeCalculationVNode(\n            jsxNode,\n            domParent,\n            parentOrdering,\n            contextMap,\n            documentFragment\n        );\n    }\n    if (isCollectionView(jsxNode)) {\n        return makeCollectionVNode(\n            jsxNode,\n            domParent,\n            parentOrdering,\n            contextMap,\n            documentFragment\n        );\n    }\n    if (Array.isArray(jsxNode)) {\n        return {\n            domParent,\n            children: jsxNode.map((child) =>\n                jsxNodeToVNode(\n                    child,\n                    domParent,\n                    parentOrdering,\n                    contextMap,\n                    documentFragment\n                )\n            ),\n        };\n    }\n    if (typeof jsxNode === 'function') {\n        log.warn(\n            'Attempted to render JSX node that was a function, not rendering anything'\n        );\n        return { domParent };\n    }\n    if (typeof jsxNode === 'symbol') {\n        log.warn(\n            'Attempted to render JSX node that was a symbol, not rendering anything'\n        );\n        return { domParent };\n    }\n    return renderElementToVNode(\n        jsxNode,\n        domParent,\n        parentOrdering,\n        contextMap,\n        documentFragment\n    );\n}\n\nfunction renderElementToVNode(\n    renderElement: RenderedElement<any, any, any>,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n) {\n    DEBUG && log.debug('view renderElementToVNode', renderElement);\n    switch (renderElement.type) {\n        case 'intrinsic':\n            return makeElementVNode(\n                renderElement.element,\n                renderElement.props,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        case 'context':\n            return makeContextVNode(\n                renderElement.context,\n                renderElement.props.value,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        case 'component':\n            return makeComponentVNode(\n                renderElement.component,\n                renderElement.props,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        default:\n            log.assertExhausted(renderElement);\n    }\n}\n\nconst HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nconst MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nconst XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\nconst XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n\nconst attributeNamespaceMap: Record<string, string> = {\n    'xlink:actuate': XLINK_NAMESPACE,\n    'xlink:arcrole': XLINK_NAMESPACE,\n    'xlink:href': XLINK_NAMESPACE,\n    'xlink:role': XLINK_NAMESPACE,\n    'xlink:show': XLINK_NAMESPACE,\n    'xlink:title': XLINK_NAMESPACE,\n    'xlink:type': XLINK_NAMESPACE,\n    'xml:lang': XML_NAMESPACE,\n    'xml:space': XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n    'xmlns:xlink': XMLNS_NAMESPACE,\n};\nconst elementNamespaceTransitionMap: Record<\n    string,\n    Record<string, { node: string; children: string } | undefined> | undefined\n> = {\n    [HTML_NAMESPACE]: {\n        svg: {\n            node: SVG_NAMESPACE,\n            children: SVG_NAMESPACE,\n        },\n        math: {\n            node: MATHML_NAMESPACE,\n            children: MATHML_NAMESPACE,\n        },\n    },\n    [SVG_NAMESPACE]: {\n        foreignObject: {\n            node: SVG_NAMESPACE,\n            children: HTML_NAMESPACE,\n        },\n    },\n} as const;\n\nconst XmlNamespaceContext = createContext(HTML_NAMESPACE);\n\nfunction makeElementVNode(\n    elementType: string,\n    props: {} | undefined,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n) {\n    let subContextMap = contextMap;\n    let elementXMLNamespace: string = contextMap.has(XmlNamespaceContext)\n        ? contextMap.get(XmlNamespaceContext)\n        : getContext(XmlNamespaceContext);\n    let childElementXMLNamespace: null | string = null;\n    const xmlNamespaceTransition =\n        elementNamespaceTransitionMap[elementXMLNamespace]?.[elementType];\n    if (xmlNamespaceTransition) {\n        elementXMLNamespace = xmlNamespaceTransition.node;\n        childElementXMLNamespace = xmlNamespaceTransition.children;\n    }\n    if (childElementXMLNamespace != null) {\n        subContextMap = new Map(contextMap);\n        subContextMap.set(XmlNamespaceContext, childElementXMLNamespace);\n    }\n    DEBUG &&\n        log.debug('view makeElementVNode', {\n            elementType,\n            elementXMLNamespace,\n            props,\n            children,\n        });\n    const element = document.createElementNS(elementXMLNamespace, elementType);\n    const elementBoundEvents: Record<string, (ev: Event) => void> = {};\n\n    const onReleaseActions: (() => void)[] = [];\n    let refCallback: any = undefined;\n\n    // Bind props\n    if (props) {\n        Object.entries(props).forEach(([key, value]) => {\n            if (key === 'ref') {\n                if (isRef(value)) {\n                    value.current = element;\n                    return;\n                }\n                if (typeof value === 'function' && !isCalculation(value)) {\n                    refCallback = value;\n                    return;\n                }\n            }\n            if (isCalculation(value)) {\n                const boundEffect = effect(() => {\n                    const computedValue = value();\n                    setAttributeValue(\n                        elementType,\n                        element,\n                        key,\n                        computedValue,\n                        elementBoundEvents\n                    );\n                }, `viewattr:${key}`);\n                onReleaseActions.push(() => {\n                    removeOrderingDep(boundEffect, nodeOrdering);\n                    boundEffect.dispose();\n                });\n                addOrderingDep(boundEffect, nodeOrdering);\n\n                boundEffect();\n            } else {\n                setAttributeValue(\n                    elementType,\n                    element,\n                    key,\n                    value,\n                    elementBoundEvents\n                );\n            }\n        });\n    }\n\n    const elementNode: VNode = {\n        domParent,\n        domNode: element,\n        onMount: [\n            () => {\n                if (refCallback) {\n                    refCallback(element);\n                }\n            },\n        ],\n        onUnmount: [\n            () => {\n                onReleaseActions.forEach((action) => action());\n                if (refCallback) {\n                    refCallback(undefined);\n                }\n            },\n        ],\n    };\n\n    if (children && children.length > 0) {\n        const childDocumentFragment = document.createDocumentFragment();\n        const childVNodes = children.map((child) =>\n            jsxNodeToVNode(\n                child,\n                elementNode,\n                nodeOrdering,\n                subContextMap,\n                childDocumentFragment\n            )\n        );\n        elementNode.children = childVNodes;\n        element.appendChild(childDocumentFragment);\n    }\n    documentFragment.appendChild(element);\n\n    return elementNode;\n}\n\nfunction makeContextVNode<TContext>(\n    context: Context<TContext>,\n    value: TContext,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const subContextMap = new Map(contextMap);\n    subContextMap.set(context, value);\n\n    const providerNode: VNode = {\n        domParent,\n    };\n\n    if (children) {\n        providerNode.children = children.map((jsxChild) =>\n            jsxNodeToVNode(\n                jsxChild,\n                domParent,\n                nodeOrdering,\n                subContextMap,\n                documentFragment\n            )\n        );\n    }\n\n    return providerNode;\n}\n\nfunction makeComponentVNode<TProps>(\n    Component: Component<TProps>,\n    props: TProps,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    DEBUG &&\n        log.debug('view makeComponentVNode', { Component, props, children });\n    const onUnmount: Function[] = [];\n    const onMount: Function[] = [];\n\n    let jsxNode: JSXNode;\n    const createdCalculations = trackCreatedCalculations(() => {\n        jsxNode = Component(\n            {\n                ...props,\n                children: children,\n            },\n            {\n                onUnmount: (unmountCallback) => {\n                    onUnmount.push(unmountCallback);\n                },\n                onMount: (mountCallback) => {\n                    onMount.push(mountCallback);\n                },\n                onEffect: (effectCallback: () => void, debugName?: string) => {\n                    const effectCalc = effect(\n                        effectCallback,\n                        `componenteffect:${Component.name}:${debugName ?? '?'}`\n                    );\n                    onMount.push(() => {\n                        retain(effectCalc);\n                        addOrderingDep(nodeOrdering, effectCalc);\n                        effectCalc();\n                    });\n                    onUnmount.push(() => {\n                        removeOrderingDep(nodeOrdering, effectCalc);\n                        release(effectCalc);\n                        effectCalc.dispose();\n                    });\n                },\n                getContext: <TVal>(context: Context<TVal>): TVal => {\n                    if (contextMap.has(context)) {\n                        return contextMap.get(context);\n                    }\n                    return getContext(context);\n                },\n            }\n        );\n    });\n    onUnmount.push(() => {\n        createdCalculations.forEach((calculation) => {\n            calculation.dispose();\n        });\n    });\n\n    const childVNode = jsxNodeToVNode(\n        jsxNode,\n        domParent,\n        nodeOrdering,\n        contextMap,\n        documentFragment\n    );\n\n    const componentNode = {\n        domParent,\n        children: [childVNode],\n        onMount,\n        onUnmount,\n    };\n\n    return componentNode;\n}\n\nfunction makeCalculationVNode(\n    calculation: Calculation<JSXNode>,\n    domParent: VNode,\n    parentNodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const onUnmount: (() => void)[] = [];\n    const calculationNodeChildren: VNode[] = [];\n    const calculationNode: VNode = {\n        domParent,\n        children: calculationNodeChildren,\n        onUnmount,\n    };\n\n    const calculationNodeOrdering = makeNodeOrdering(\n        DEBUG\n            ? `viewcalc:${debugNameFor(calculation) ?? 'node'}:order`\n            : 'viewcalc:order'\n    );\n    registerNode(calculationNodeOrdering);\n\n    let firstRun = true;\n    const resultEffect = effect(() => {\n        const renderElement = calculation();\n        const calculationChild = jsxNodeToVNode(\n            renderElement,\n            domParent,\n            calculationNodeOrdering,\n            contextMap,\n            documentFragment\n        );\n        if (firstRun) {\n            // TODO: can we just call spliceVNode here?\n            firstRun = false;\n            calculationNodeChildren.push(calculationChild);\n        } else {\n            // Untracked here since spliceVNode calls onMount / onUnmount handlers and we don't want to recalculate if those read values\n            untracked(() => {\n                spliceVNode(\n                    calculationNode,\n                    0,\n                    calculationNodeChildren.length,\n                    [calculationChild]\n                );\n            });\n        }\n    }, `viewcalc:${debugNameFor(calculation) ?? 'node'}`);\n\n    addOrderingDep(calculationNodeOrdering, parentNodeOrdering);\n    addOrderingDep(resultEffect, calculationNodeOrdering);\n\n    onUnmount.push(() => {\n        removeOrderingDep(calculationNodeOrdering, parentNodeOrdering);\n        removeOrderingDep(resultEffect, calculationNodeOrdering);\n        resultEffect.dispose();\n        disposeNode(calculationNodeOrdering);\n    });\n\n    resultEffect();\n\n    return calculationNode;\n}\n\nfunction makeCollectionVNode(\n    collection: Collection<JSXNode> | View<JSXNode>,\n    domParent: VNode,\n    parentNodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const onUnmount: (() => void)[] = [];\n\n    const collectionNodeChildren: VNode[] = [];\n    const collectionNode = {\n        domParent,\n        children: collectionNodeChildren,\n        onUnmount,\n    };\n\n    const collectionNodeOrdering = makeNodeOrdering(\n        DEBUG\n            ? `viewcoll:${debugNameFor(collection) ?? 'node'}:order`\n            : 'viewcoll:order'\n    );\n    registerNode(collectionNodeOrdering);\n    addOrderingDep(collectionNodeOrdering, parentNodeOrdering);\n    onUnmount.push(() => {\n        removeOrderingDep(collectionNodeOrdering, parentNodeOrdering);\n    });\n\n    untracked(() => {\n        collectionNode.children.push(\n            ...collection.map((jsxChild) =>\n                jsxNodeToVNode(\n                    jsxChild,\n                    domParent,\n                    collectionNodeOrdering,\n                    contextMap,\n                    documentFragment\n                )\n            )\n        );\n    });\n\n    const unobserve = collection[ObserveKey]((events) => {\n        events.forEach((event) => {\n            if (event.type === 'splice') {\n                untracked(() => {\n                    const { count, index, items } = event;\n                    const childNodes = items.map((jsxChild) =>\n                        jsxNodeToVNode(\n                            jsxChild,\n                            domParent,\n                            collectionNodeOrdering,\n                            contextMap,\n                            documentFragment\n                        )\n                    );\n                    spliceVNode(collectionNode, index, count, childNodes);\n                });\n            } else if (event.type === 'move') {\n                const { fromIndex, fromCount, toIndex } = event;\n                const moved = spliceVNode(\n                    collectionNode,\n                    fromIndex,\n                    fromCount,\n                    [],\n                    { runOnUnmount: false }\n                );\n                spliceVNode(\n                    collectionNode,\n                    fromIndex < toIndex ? toIndex - fromCount : toIndex,\n                    0,\n                    moved,\n                    { runOnMount: false }\n                );\n            } else if (event.type === 'sort') {\n                const { indexes } = event;\n                const removedVNodes = spliceVNode(\n                    collectionNode,\n                    0,\n                    indexes.length,\n                    [],\n                    { runOnUnmount: false }\n                );\n                const sortedVNodes = indexes.map(\n                    (newIndex) => removedVNodes[newIndex]\n                );\n                spliceVNode(collectionNode, 0, 0, sortedVNodes, {\n                    runOnMount: false,\n                });\n            } else {\n                log.assertExhausted(event, 'unhandled collection event');\n            }\n        });\n    });\n\n    const subscriptionNode = collection[GetSubscriptionNodeKey]();\n    registerNode(subscriptionNode);\n    addOrderingDep(subscriptionNode, collectionNodeOrdering);\n    onUnmount.push(unobserve);\n    onUnmount.push(() => {\n        removeOrderingDep(subscriptionNode, collectionNodeOrdering);\n    });\n\n    return collectionNode;\n}\n\nfunction makeNodeOrdering(debugName?: string): NodeOrdering {\n    const nodeOrdering: NodeOrdering = {\n        $__id: uniqueid(),\n        [TypeTag]: 'nodeOrdering',\n    };\n    if (debugName) name(nodeOrdering, debugName);\n    return nodeOrdering;\n}\n\n/**\n * Mount the provided JSX to an element\n */\nexport function mount(parentElement: Element, jsxNode: JSXNode) {\n    const contextMap: Map<Context<any>, any> = new Map();\n    if (\n        parentElement.namespaceURI === SVG_NAMESPACE ||\n        parentElement.namespaceURI === MATHML_NAMESPACE\n    ) {\n        contextMap.set(XmlNamespaceContext, parentElement.namespaceURI);\n    }\n    const nodeOrdering = makeNodeOrdering('mount');\n    retain(nodeOrdering);\n    const anchorNode: VNode = { domNode: parentElement };\n    const documentFragment = document.createDocumentFragment();\n    const rootNode = jsxNodeToVNode(\n        jsxNode,\n        anchorNode,\n        nodeOrdering,\n        contextMap,\n        documentFragment\n    );\n    anchorNode.children = [rootNode];\n\n    parentElement.appendChild(documentFragment);\n\n    // Call onMount callbacks\n    callOnMount(anchorNode);\n\n    return () => {\n        spliceVNode(anchorNode, 0, anchorNode.children?.length ?? 0, []);\n        release(nodeOrdering);\n    };\n}\n", "import {\n    Collection,\n    FilterFunction,\n    FlatMapFunction,\n    InvariantError,\n    MappingFunction,\n    View,\n    NotifyKey,\n    DisposeKey,\n} from './types';\nimport * as log from './log';\nimport { trackedData } from './trackeddata';\n\n// https://tc39.es/ecma262/multipage/indexed-collections.html#sec-sortcompare\nfunction defaultSort(x: any, y: any) {\n    if (x === undefined && y === undefined) return 0;\n    if (x === undefined) return 1;\n    if (y === undefined) return -1;\n    const xStr = '' + x;\n    const yStr = '' + y;\n    if (xStr < yStr) return -1;\n    if (xStr > yStr) return 1;\n    return 0;\n}\n\n/**\n * Make a mutable array to hold state, with some additional convenience methods\n */\nexport function collection<T>(array: T[], debugName?: string): Collection<T> {\n    if (!Array.isArray(array)) {\n        throw new InvariantError('collection must be provided an array');\n    }\n\n    return trackedData(\n        array,\n        'collection' as const,\n        {\n            get(notify, target, key) {\n                return target[key];\n            },\n\n            has(notify, target, key) {\n                return key in target;\n            },\n\n            set(this: Collection<T>, notify, target, key, value) {\n                if (\n                    key === 'length' &&\n                    typeof value === 'number' &&\n                    value < target.length\n                ) {\n                    // Special handling of resizing length smaller than normal length to handle removing of items\n                    this.splice(value, target.length - value);\n                    return true;\n                }\n                const numericKey = Number(key);\n                if (!isNaN(numericKey) && numericKey <= array.length) {\n                    this.splice(numericKey, 1, value);\n                } else {\n                    target[key] = value;\n                }\n                return true;\n            },\n\n            deleteProperty(notify, target, key) {\n                delete target[key];\n                return true;\n            },\n        },\n        ({\n            notify,\n            subscriptionNode,\n            makeView,\n            processFieldChange,\n            processFieldDelete,\n        }) => ({\n            splice: function splice(\n                index: number,\n                count: number,\n                ...items: T[]\n            ): T[] {\n                if (count < 1 && items.length === 0) return []; // noop\n                const origLength = array.length;\n                const removed = array.splice(index, count, ...items);\n                const newLength = array.length;\n                notify({\n                    type: 'splice',\n                    index,\n                    count,\n                    items,\n                    removed,\n                });\n\n                // Cases to consider:\n                // 1. count === items.length: we are replacing count items\n                // 2. count > items.length: we are adding (count - items.length items), notify index to new end\n                // 3. count < items.length: we are removing (items.length - count items), notify index to old end\n\n                // Process changes in *added* items\n                if (origLength === newLength) {\n                    for (let i = index; i < index + count; ++i) {\n                        processFieldChange(i.toString());\n                    }\n                } else {\n                    for (\n                        let i = index;\n                        i < Math.max(newLength, origLength);\n                        ++i\n                    ) {\n                        const key = i.toString();\n                        if (i >= newLength) {\n                            // Field deletion\n                            processFieldDelete(key);\n                        } else {\n                            // Field change\n                            processFieldChange(key);\n                        }\n                    }\n                    processFieldChange('length');\n                }\n                return removed;\n            },\n            pop: function pop(this: Collection<T>): T | undefined {\n                const removed = this.splice(array.length - 1, 1);\n                return removed[0];\n            },\n            shift: function shift(this: Collection<T>): T | undefined {\n                const removed = this.splice(0, 1);\n                return removed[0];\n            },\n            push: function push(this: Collection<T>, ...items: T[]): number {\n                this.splice(array.length, 0, ...items);\n                return array.length;\n            },\n            unshift: function unshift(\n                this: Collection<T>,\n                ...items: T[]\n            ): number {\n                this.splice(0, 0, ...items);\n                return array.length;\n            },\n            reject: function reject(\n                this: Collection<T>,\n                func: (item: T, index: number) => boolean\n            ) {\n                const removed: T[] = [];\n                for (let i = array.length - 1; i >= 0; --i) {\n                    if (func(this[i], i)) {\n                        removed.push(...this.splice(i, 1));\n                    }\n                }\n                return removed;\n            },\n            moveSlice: function moveSlice(\n                this: Collection<T>,\n                fromIndex: number,\n                fromCount: number,\n                toIndex: number\n            ) {\n                if (fromCount <= 0) return; // nothing to slice\n                if (toIndex >= fromIndex && toIndex < fromIndex + fromCount)\n                    return; // destination is inside moved slice, so noop\n                const moved = array.splice(fromIndex, fromCount);\n                if (toIndex < fromIndex) {\n                    array.splice(toIndex, 0, ...moved);\n                } else {\n                    array.splice(toIndex - fromCount, 0, ...moved);\n                }\n                notify({\n                    type: 'move',\n                    fromIndex,\n                    fromCount,\n                    toIndex,\n                    moved,\n                });\n            },\n            sort: function sort(\n                this: Collection<T>,\n                sorter: (a: T, b: T) => number = defaultSort\n            ): T[] {\n                const arrayWithIndexes: [T, number][] = array.map(\n                    (item, index) => [item, index]\n                );\n                array.sort(sorter);\n                arrayWithIndexes.sort((ai, bi) => sorter(ai[0], bi[0]));\n                notify({\n                    type: 'sort',\n                    indexes: arrayWithIndexes.map((pair) => pair[1]),\n                });\n                return this;\n            },\n            reverse: function reverse(\n                this: Collection<T>,\n                sorter: (a: T, b: T) => number = defaultSort\n            ): T[] {\n                if (array.length === 0) return this;\n                array.reverse();\n                // Simulate a resort\n                const indexes: number[] = [];\n                for (let i = array.length - 1; i >= 0; --i) {\n                    indexes.push(i);\n                }\n                notify({\n                    type: 'sort',\n                    indexes,\n                });\n                return this;\n            },\n            makeView,\n            mapView: function mapView<V>(\n                this: Collection<T>,\n                mapper: MappingFunction<T, V>,\n                debugName?: string | undefined\n            ) {\n                return mapViewImplementation(this, mapper, debugName);\n            },\n            filterView: function filterView(\n                this: Collection<T>,\n                filterFn: FilterFunction<T>,\n                debugName?: string\n            ) {\n                return filterViewImplementation(this, filterFn, debugName);\n            },\n            flatMapView: function flatMapView<V>(\n                this: Collection<T>,\n                fn: FlatMapFunction<T, V>,\n                debugName?: string | undefined\n            ) {\n                return flatMapViewImplementation(this, fn, debugName);\n            },\n        }),\n        debugName\n    );\n}\ncollection.dispose = function dispose(c: Collection<any>) {\n    c[DisposeKey]();\n};\n\nfunction mapViewImplementation<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    mapper: MappingFunction<T, V>,\n    debugName?: string | undefined\n): View<V> {\n    // map is a specialization of flatMap\n    return flatMapViewImplementation(\n        sourceCollection,\n        (item) => [mapper(item)],\n        debugName\n    );\n}\n\nfunction filterViewImplementation<T>(\n    sourceCollection: Collection<T> | View<T>,\n    filterFn: FilterFunction<T>,\n    debugName?: string\n): View<T> {\n    // filter is a specialization of flatMap\n    return flatMapViewImplementation(\n        sourceCollection,\n        (item) => (filterFn(item) ? [item] : []),\n        debugName\n    );\n}\n\nfunction flatMapViewImplementation<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    fn: FlatMapFunction<T, V>,\n    debugName?: string | undefined\n): View<V> {\n    const flatMapCount: number[] = [];\n\n    return sourceCollection.makeView(\n        {\n            initialize: (items) => {\n                const flatMapItems: V[] = [];\n                items.forEach((value) => {\n                    const chunk = fn(value);\n                    flatMapItems.push(...chunk);\n                    flatMapCount.push(chunk.length);\n                });\n                return flatMapItems;\n            },\n            processEvent: (view, event, rawArray) => {\n                if (event.type === 'splice') {\n                    const { index, count, items } = event;\n                    let realIndex = 0;\n                    for (let i = 0; i < index; ++i) {\n                        realIndex += flatMapCount[i];\n                    }\n                    let realCount = 0;\n                    for (let i = index; i < index + count; ++i) {\n                        realCount += flatMapCount[i];\n                    }\n                    // Well that's deceptively easy\n                    const realItems: V[] = [];\n                    const realItemCount: number[] = [];\n                    items.forEach((itemValue) => {\n                        const chunk = fn(itemValue);\n                        realItems.push(...chunk);\n                        realItemCount.push(chunk.length);\n                    });\n                    view.splice(realIndex, realCount, ...realItems);\n                    flatMapCount.splice(index, count, ...realItemCount);\n                } else if (event.type === 'move') {\n                    const { fromIndex, fromCount, toIndex } = event;\n                    let realFromCount = 0;\n                    for (let i = fromIndex; i < fromIndex + fromCount; ++i) {\n                        realFromCount += flatMapCount[i];\n                    }\n\n                    if (realFromCount > 0) {\n                        let realFromIndex = 0;\n                        let realToIndex = 0;\n\n                        const lastIndex = Math.max(fromIndex, toIndex);\n                        let count = 0;\n                        for (let i = 0; i <= lastIndex; ++i) {\n                            if (i === fromIndex) realFromIndex = count;\n                            if (i === toIndex) realToIndex = count;\n                            count += flatMapCount[i];\n                        }\n                        view.moveSlice(\n                            realFromIndex,\n                            realFromCount,\n                            realToIndex\n                        );\n                    }\n                    flatMapCount.splice(\n                        toIndex,\n                        0,\n                        ...flatMapCount.splice(fromIndex, fromCount)\n                    );\n                } else if (event.type === 'sort') {\n                    const { indexes } = event;\n\n                    const flatMapIndexes: number[] = [];\n                    let accumulatorIndex = 0;\n                    for (let i = 0; i < flatMapCount.length; ++i) {\n                        flatMapIndexes.push(accumulatorIndex);\n                        accumulatorIndex += flatMapCount[i];\n                    }\n\n                    const copiedSource = rawArray.slice();\n                    const newIndexes: number[] = [];\n                    let destIndex = 0;\n                    indexes.forEach((sourceIndex) => {\n                        const realCount = flatMapCount[sourceIndex];\n                        if (realCount === 0) return;\n                        const realIndex = flatMapIndexes[sourceIndex];\n                        for (let i = 0; i < realCount; ++i) {\n                            newIndexes.push(realIndex + i);\n                            rawArray[destIndex] = copiedSource[realIndex + i];\n                            destIndex += 1;\n                        }\n                    });\n\n                    view[NotifyKey]({\n                        type: 'sort',\n                        indexes: newIndexes,\n                    });\n                } else {\n                    log.assertExhausted(\n                        event,\n                        'unhandled collection event type'\n                    );\n                }\n            },\n        },\n        debugName\n    );\n}\n", "import {\n    Collection,\n    Subscription,\n    ViewSpec,\n    FlushKey,\n    AddDeferredWorkKey,\n    ObserveKey,\n    NotifyKey,\n    GetSubscriptionNodeKey,\n    TypeTag,\n    DataTypeTag,\n    ModelField,\n    TrackedData,\n    DisposeKey,\n} from './types';\nimport { collection } from './collection';\nimport {\n    untracked,\n    addManualDep,\n    removeManualDep,\n    addOrderingDep,\n    removeOrderingDep,\n    addDepToCurrentCalculation,\n    markDirty,\n    registerNode,\n    disposeNode,\n    nextFlush,\n} from './calc';\nimport { uniqueid } from './util';\nimport { name } from './debug';\nimport * as log from './log';\n\ninterface DataImplementation<TEvent> {\n    get(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): any;\n\n    has(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): boolean;\n\n    set(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol,\n        value: any\n    ): boolean;\n\n    deleteProperty(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): boolean;\n}\n\nexport function trackedData<\n    TDataTypeTag,\n    TData extends object,\n    TEvent,\n    TMethods extends object\n>(\n    initialValue: TData,\n    typeTag: TDataTypeTag,\n    implSpec: DataImplementation<TEvent>,\n    bindMethods: (bindSpec: {\n        notify: (event: TEvent) => void;\n        observe: (observer: (events: TEvent[]) => void) => () => void;\n        makeView: <V>(\n            spec: ViewSpec<TData, V, TEvent>,\n            viewDebugName?: string | undefined\n        ) => Collection<V>;\n        subscriptionNode: Subscription;\n        processFieldChange: (field: string | symbol) => void;\n        processFieldDelete: (field: string | symbol) => void;\n    }) => TMethods,\n    debugName?: string\n): TrackedData<TDataTypeTag, TEvent> & TData & TMethods {\n    type Observer = (events: TEvent[]) => void;\n\n    const fieldRecords: Map<string | number | symbol, ModelField> = new Map();\n\n    let subscriptionEvents: Map<Observer, TEvent[]> = new Map();\n    let observers: Observer[] = [];\n    let isDisposed = false;\n\n    let deferredTasks: (() => void)[] = [];\n\n    const subscriptionNode: Subscription = {\n        $__id: uniqueid(),\n        [TypeTag]: 'subscription',\n        [FlushKey]: flushSubscription,\n        item: null, // assigned later\n    };\n    name(subscriptionNode, `${debugName || '?'}:sub`);\n\n    function flushSubscription() {\n        log.assert(!isDisposed, 'data already disposed');\n        let processed = false;\n        const toProcess = subscriptionEvents;\n        subscriptionEvents = new Map();\n        toProcess.forEach((events, observer) => {\n            processed = true;\n            observer(events);\n        });\n        return processed;\n    }\n\n    function flush() {\n        log.assert(!isDisposed, 'data already disposed');\n        const toProcess = deferredTasks;\n        let processed = false;\n        deferredTasks = [];\n        toProcess.forEach((task) => {\n            processed = true;\n            task();\n        });\n        return processed;\n    }\n\n    function addDeferredTask(task: () => void) {\n        log.assert(!isDisposed, 'data already disposed');\n        deferredTasks.push(task);\n        markDirty(proxy);\n    }\n\n    function notify(event: TEvent) {\n        log.assert(!isDisposed, 'data already disposed');\n        if (observers.length > 0) {\n            observers.forEach((observer) => {\n                let observerEvents = subscriptionEvents.get(observer);\n                if (!observerEvents) {\n                    observerEvents = [];\n                    subscriptionEvents.set(observer, observerEvents);\n                }\n                observerEvents.push(event);\n            });\n            markDirty(subscriptionNode);\n        }\n    }\n\n    function getSubscriptionNode() {\n        log.assert(!isDisposed, 'data already disposed');\n        return subscriptionNode;\n    }\n\n    function observe(observer: (events: TEvent[]) => void) {\n        log.assert(!isDisposed, 'data already disposed');\n        if (observers.length === 0) {\n            registerNode(proxy);\n            registerNode(subscriptionNode);\n            addManualDep(proxy, subscriptionNode);\n            fieldRecords.forEach((field) => {\n                addOrderingDep(field, subscriptionNode);\n            });\n        }\n        observers.push(observer);\n        return () => {\n            observers = observers.filter((obs) => obs !== observer);\n            if (observers.length === 0) {\n                removeManualDep(proxy, subscriptionNode);\n                fieldRecords.forEach((field) => {\n                    removeOrderingDep(field, subscriptionNode);\n                });\n            }\n        };\n    }\n\n    function makeView<V>(\n        spec: ViewSpec<TData, V, TEvent>,\n        viewDebugName?: string | undefined\n    ) {\n        log.assert(!isDisposed, 'data already disposed');\n        const viewArray: V[] = untracked(() => spec.initialize(initialValue));\n        const view = collection(viewArray, viewDebugName);\n        observe((events: TEvent[]) => {\n            view[AddDeferredWorkKey](() => {\n                events.forEach((event) => {\n                    spec.processEvent(view, event, viewArray);\n                });\n            });\n        });\n        addManualDep(subscriptionNode, view);\n        return view;\n    }\n\n    function processFieldChange(key: string | symbol) {\n        log.assert(!isDisposed, 'data already disposed');\n        const field = getField(key);\n        markDirty(field);\n    }\n\n    function processFieldDelete(key: string | symbol) {\n        log.assert(!isDisposed, 'data already disposed');\n        const field = getField(key);\n        markDirty(field);\n    }\n\n    function dispose() {\n        log.assert(!isDisposed, 'data already disposed');\n        // Delete and clean everything up\n        fieldRecords.forEach((field) => {\n            removeOrderingDep(proxy, field);\n            if (observers.length > 0) {\n                removeOrderingDep(field, subscriptionNode);\n            }\n            disposeNode(field);\n        });\n        fieldRecords.clear();\n        disposeNode(proxy);\n        disposeNode(subscriptionNode);\n\n        observers.splice(0, observers.length);\n        subscriptionEvents.clear();\n        deferredTasks.splice(0, deferredTasks.length);\n        // TODO: this is very gross!\n        nextFlush().then(() => {\n            revokableProxy.revoke();\n        });\n        isDisposed = true;\n    }\n\n    const pseudoPrototype = {\n        $__id: uniqueid(),\n        [TypeTag]: 'data',\n        [DataTypeTag]: typeTag,\n        [FlushKey]: flush,\n        [AddDeferredWorkKey]: addDeferredTask,\n        [ObserveKey]: observe,\n        [NotifyKey]: notify,\n        [GetSubscriptionNodeKey]: getSubscriptionNode,\n        [DisposeKey]: dispose,\n        ...bindMethods({\n            observe,\n            notify,\n            makeView,\n            subscriptionNode,\n            processFieldChange,\n            processFieldDelete,\n        }),\n    };\n\n    function getField(key: string | number | symbol): ModelField {\n        let field = fieldRecords.get(key);\n        if (!field) {\n            field = {\n                model: proxy as any,\n                key,\n                $__id: uniqueid(),\n            };\n            if (debugName) name(field, debugName);\n            fieldRecords.set(key, field);\n            registerNode(field);\n            addOrderingDep(proxy, field);\n            if (observers.length > 0) {\n                addOrderingDep(field, subscriptionNode);\n            }\n        }\n        return field;\n    }\n\n    const revokableProxy = Proxy.revocable(initialValue, {\n        get(target: any, key: string | symbol) {\n            if (key in pseudoPrototype) {\n                return (pseudoPrototype as any)[key];\n            }\n            const field = getField(key);\n            addDepToCurrentCalculation(field);\n            return implSpec.get.call(proxy, notify, target, key);\n        },\n\n        has(target: any, key: string | symbol) {\n            if (key in pseudoPrototype) {\n                return true;\n            }\n            const field = getField(key);\n            addDepToCurrentCalculation(field);\n            return implSpec.has.call(proxy, notify, target, key);\n        },\n\n        set(target: any, key: string | symbol, value: any) {\n            if (key in pseudoPrototype) {\n                log.error(`Overriding ${String(key)} not supported`, key);\n                return false;\n            }\n            const changed = implSpec.set.call(\n                proxy,\n                notify,\n                target,\n                key,\n                value\n            );\n            if (changed) {\n                const field = getField(key);\n                markDirty(field);\n            }\n            return changed;\n        },\n\n        deleteProperty(target: any, key: string | symbol) {\n            if (key in pseudoPrototype) {\n                log.error(`Deleting ${String(key)} not supported`, key);\n                return false;\n            }\n            const changed = implSpec.deleteProperty.call(\n                proxy,\n                notify,\n                target,\n                key\n            );\n            if (changed) {\n                const field = getField(key);\n                markDirty(field); // Anything depending on this value will need to be recalculated\n            }\n            return changed;\n        },\n    });\n    const proxy: TrackedData<TDataTypeTag, TEvent> & TData & TMethods =\n        revokableProxy.proxy;\n\n    subscriptionNode.item = proxy;\n\n    if (debugName) name(proxy, debugName);\n    registerNode(proxy);\n\n    return proxy;\n}\n", "import {\n    InvariantError,\n    MakeModelViewKey,\n    DisposeKey,\n    Model,\n    View,\n} from './types';\nimport { trackedData } from './trackeddata';\n\nexport function model<T extends {}>(obj: T, debugName?: string): Model<T> {\n    if (typeof obj !== 'object' || !obj) {\n        throw new InvariantError('model must be provided an object');\n    }\n\n    const knownFields: Set<string | number | symbol> = new Set(\n        Object.keys(obj)\n    );\n\n    return trackedData(\n        obj,\n        'model' as const,\n        {\n            get: (_notify, target, key) => {\n                return target[key];\n            },\n            has: (notify, target, key) => {\n                return knownFields.has(key);\n            },\n            set: (notify, target, key, value) => {\n                const changed = !knownFields.has(key) || target[key] !== value;\n                target[key] = value;\n                if (changed) {\n                    if (!knownFields.has(key)) {\n                        knownFields.add(key);\n                        notify({ type: 'add', key });\n                    }\n                    notify({ type: 'set', key, value });\n                }\n                return true;\n            },\n            deleteProperty: (notify, target, key) => {\n                const changed = knownFields.has(key);\n                delete target[key];\n                if (changed) {\n                    knownFields.delete(key);\n                    notify({ type: 'delete', key });\n                }\n                return true;\n            },\n        },\n        ({ makeView, notify, observe, subscriptionNode }) => {\n            return {\n                [MakeModelViewKey]: makeView,\n            };\n        },\n        debugName\n    );\n}\nmodel.keys = function keys<T>(\n    target: Model<T>,\n    debugName?: string\n): View<string> {\n    const keysSet = new Set<string>();\n\n    const view = target[MakeModelViewKey]<string>(\n        {\n            initialize: (obj) => {\n                const keys = Object.keys(obj);\n                keys.forEach((key) => keysSet.add(key));\n                return keys;\n            },\n            processEvent: (modelView, event) => {\n                if (event.type === 'add') {\n                    const { key } = event;\n                    if (typeof key === 'number' || typeof key === 'string') {\n                        const stringKey = key.toString();\n                        if (!keysSet.has(stringKey)) {\n                            keysSet.add(stringKey);\n                            modelView.push(stringKey);\n                        }\n                    }\n                } else if (event.type === 'delete') {\n                    const { key } = event;\n                    if (typeof key === 'number' || typeof key === 'string') {\n                        const stringKey = key.toString();\n                        if (keysSet.has(stringKey)) {\n                            keysSet.delete(stringKey);\n                            modelView.reject((k) => k === stringKey);\n                        }\n                    }\n                }\n            },\n        },\n        debugName\n    );\n\n    return view;\n};\nmodel.dispose = function dispose(m: Model<any>) {\n    m[DisposeKey]();\n};\n"],
  "mappings": "6rBAAA,gXCAO,mBAA6B,MAAM,CAEtC,YAAY,EAAa,EAAc,CACnC,MAAM,GAFV,iBAGI,KAAK,OAAS,IAIT,EAAU,OAAO,WACjB,GAAmB,OAAO,iBAC1B,GAAc,OAAO,eACrB,GAAqB,OAAO,mBAC5B,GAA4B,OAAO,0BACnC,GAA2B,OAAO,yBAClC,GAAyB,OAAO,uBAEhC,GAAa,OAAO,WACpB,GAAyB,OAAO,uBAChC,GAAmB,OAAO,iBAC1B,EAAa,OAAO,WACpB,GAAW,OAAO,SAClB,GAAqB,OAAO,mBAC5B,GAAY,OAAO,UAWzB,YAAe,EAA+B,CACjD,MAAO,IAAO,EAAI,KAAa,MAM5B,YAAgB,EAAiB,CACpC,MAAO,EACF,GAAU,MACX,QAAS,GAwJV,YAA+B,EAA8B,CAChE,MAAO,QAAO,OACV,IAAM,CACF,KAAM,IAAI,OAAM,sCAEpB,EACK,IAAmB,IAAM,GACzB,GAAU,YAKhB,YAA4B,EAAkC,CACjE,MAAO,GAAQ,MAGZ,YAAmB,EAA+B,CACrD,MAAO,CAAC,CAAE,IAAO,EAAI,KAAa,WA0B/B,YAAiB,EAAqC,CACzD,MAAO,CAAC,CACJ,IACA,EAAM,KAAa,QACnB,EAAM,MAAiB,SAIxB,YAAsB,EAAiC,CAC1D,MAAO,CAAC,CACJ,IACA,CAAC,EAAM,IACP,CAAC,CAAC,EAAM,OACR,CAAC,CAAC,EAAM,MAAM,KAIf,WAAsB,EAAkD,CAC3E,MAAO,CAAC,CACJ,IACA,EAAM,KAAa,QACnB,EAAM,MAAiB,cAIxB,WAAuB,EAAuC,CACjE,MAAO,CAAC,CAAE,IAAS,EAAM,KAAa,eAGnC,YAAkB,EAAsC,CAC3D,MAAO,GAAM,MAAwB,SAGlC,YAAwB,EAAmC,CAC9D,MAAO,CAAC,CAAE,IAAS,EAAM,KAAa,gBAGnC,YAAwB,EAAmC,CAC9D,MAAO,CAAC,CAAE,IAAS,EAAM,KAAa,gBCjR1C,GAAM,GAAmC,CACrC,MAAO,EACP,KAAM,EACN,KAAM,EACN,MAAO,GAEP,EAAuB,EAAO,KAE3B,aAAiC,CACpC,MAAI,IAAgB,EAAO,KAAa,OACpC,GAAgB,EAAO,KAAa,OACpC,GAAgB,EAAO,MAAc,QAClC,QAEJ,YAAqB,EAAoB,CAC5C,GAAU,IAAM,IAAY,GAAQ,GACpC,EAAe,EAAO,GAenB,eAAiB,EAAc,CAClC,AAAI,GAAgB,EAAO,MACvB,QAAQ,KAAK,GAAG,GAIjB,cAAkB,EAAc,CACnC,AAAI,GAAgB,EAAO,OACvB,QAAQ,MAAM,GAAG,GAIlB,YAAmB,KAAmB,EAAc,CACvD,AAAI,YAAqB,OACrB,GAAM,GACN,EAAM,GAAG,IAET,EAAM,EAAW,GAAG,GAIrB,YAAmB,KAAqB,EAAc,CACzD,AAAK,KACD,EAAM,kBAAmB,EAAM,WAAY,gBAAiB,GAAG,GAIhE,WAAgB,EAAY,EAA4B,CAC3D,GAAI,CAAC,EACD,QACI,oBACA,IAAU,OACJ,YACA,IAAU,KACV,OACA,EAAM,WACZ,gBACA,GAEE,GAAI,GAAe,sBAAsB,KAIhD,WAAyB,KAAmB,EAAqB,CACpE,QAAM,oBAAqB,EAAS,mBAAoB,GAAG,GACrD,GAAI,GAAe,oBAAqB,CAAE,UAAS,UC9EtD,GAAM,IAAO,IAAM,GAEb,EAAY,KAAM,CAC3B,GAAI,GAAK,EACT,MAAO,IAAO,MAAM,eAoBjB,YACH,EACA,EACiB,CACjB,GAAM,GAA6B,GAAI,KACvC,SAAM,QAAQ,AAAC,GAAS,CACpB,GAAM,CAAC,EAAK,GAAO,EAAQ,GACvB,EAAQ,EAAQ,IAAI,GACxB,AAAK,GACD,GAAQ,GACR,EAAQ,IAAI,EAAK,IAErB,EAAM,KAAK,KAER,EAyBJ,aAA4B,CAC/B,MAAO,GAGJ,YAAwB,EAAM,EAAe,CAChD,MAAO,KAAM,ECnDV,WAAiC,CAepC,aAAc,CATN,iBACA,mBACA,mBACA,qBACA,sBAEA,gBACA,uBAGJ,KAAK,OAAS,EACd,KAAK,SAAW,GAChB,KAAK,SAAW,GAChB,KAAK,MAAQ,GACb,KAAK,aAAe,GACpB,KAAK,WAAa,GAClB,KAAK,YAAc,GAGf,MAAM,EAAoB,CAC9B,MAAQ,GAAa,MAGzB,QAAQ,EAAqB,CACzB,GAAM,GAAS,KAAK,MAAM,GAC1B,MAAI,MAAK,SAAS,GAAgB,GAClC,MAAK,MAAM,GAAU,GACrB,KAAK,aAAa,GAAU,GAC5B,KAAK,SAAS,GAAU,EACjB,IAGX,QAAQ,EAAqB,CACzB,MAAO,CAAC,CAAC,KAAK,SAAS,KAAK,MAAM,IAGtC,cAAc,EAAkB,CAC5B,KAAK,WAAW,KAAK,MAAM,IAAS,GAGhC,8BAA8B,EAIpC,CACE,GAAM,GAAkD,GAClD,EAAqB,GACvB,EAAa,GACX,EAAQ,AAAC,GAAoB,CAE/B,AADI,EAAa,KAAa,GAAG,GAAa,IAC1C,GAAa,IACb,KAAY,GAAQ,EAAW,KAAK,KAAK,SAAS,IACtD,EAAa,GAAW,EACxB,KAAK,qBAAqB,EAAS,EAAM,UAAU,QAC/C,AAAC,GAAS,CACN,EAAM,KAGd,EAAa,GAAW,IAG5B,SAAM,GACC,CAAE,eAAc,aAAY,QAAS,GAGhD,yBAAyB,EAAoB,CACzC,GAAM,GAAS,KAAK,MAAM,GACpB,CAAE,aAAY,WAChB,KAAK,8BAA8B,GACvC,MAAI,GAAO,CAAC,EAAS,0CACd,EAGX,eAAyB,CACrB,MAAO,QAAO,KAAK,KAAK,YAAY,OAAS,EAMjD,QAAQ,EAAgB,EAAc,EAAyB,CAC3D,GAAM,GAAS,KAAK,MAAM,GACpB,EAAO,KAAK,MAAM,GACxB,KAAK,aAAa,EAAQ,EAAM,GAG5B,aACJ,EACA,EACA,EACI,CACJ,AAAI,EACA,CAAC,CAAC,KAAK,SAAS,GAChB,iDAEJ,AAAI,EACA,CAAC,CAAC,KAAK,SAAS,GAChB,+CAEJ,KAAK,MAAM,GAAQ,GAAS,MAAK,MAAM,GAAQ,IAAS,GAAK,EAC7D,KAAK,aAAa,GAAM,GACnB,MAAK,aAAa,GAAM,IAAW,GAAK,EAMjD,WAAW,EAAgB,EAAc,EAA0B,CAC/D,GAAM,GAAS,KAAK,MAAM,GACpB,EAAO,KAAK,MAAM,GACxB,KAAK,gBAAgB,EAAQ,EAAM,GAG/B,gBACJ,EACA,EACA,EACF,CACE,AAAI,EACA,CAAC,CAAC,KAAK,SAAS,GAChB,oDAEJ,AAAI,EACA,CAAC,CAAC,KAAK,SAAS,GAChB,kDAEJ,KAAK,MAAM,GAAQ,GAAS,MAAK,MAAM,GAAQ,IAAS,GAAK,CAAC,EAC9D,KAAK,aAAa,GAAM,GACnB,MAAK,aAAa,GAAM,IAAW,GAAK,CAAC,EAGlD,WAAW,EAAY,CACnB,GAAM,GAAS,KAAK,MAAM,GAC1B,KAAK,gBAAgB,GAGjB,gBAAgB,EAAgB,CACpC,AAAI,EACA,CAAC,KAAK,SAAS,GACf,uCAEJ,GAAM,GAAQ,KAAK,qBAAqB,GAIxC,AAHgB,KAAK,4BAA4B,GAGzC,QAAQ,AAAC,GAAW,CACxB,KAAK,MAAM,GAAQ,GAAU,EAC7B,KAAK,aAAa,GAAQ,GAAU,IAGxC,EAAM,QAAQ,AAAC,GAAS,CACpB,KAAK,aAAa,GAAM,GAAU,EAClC,KAAK,MAAM,GAAQ,GAAQ,IAE/B,MAAO,MAAK,SAAS,GACrB,MAAO,MAAK,WAAW,GACvB,MAAO,MAAK,SAAS,GACrB,MAAO,MAAK,YAAY,GAG5B,OAAO,EAAY,CACf,GAAM,GAAS,KAAK,MAAM,GAC1B,AAAI,EAAO,CAAC,KAAK,SAAS,GAAS,iBACnC,KAAK,SAAS,GAAU,GAG5B,QAAQ,EAAY,CAChB,GAAM,GAAS,KAAK,MAAM,GAC1B,AAAI,EAAO,KAAK,SAAS,GAAS,kBAClC,MAAO,MAAK,SAAS,GAGzB,gBAAgB,EAAY,EAA0B,CAClD,GAAM,GAAO,KAAK,MAAM,GAElB,EAAgB,KAAK,4BACvB,EACA,EAAM,WAEJ,EAAgB,GAAI,KAAI,GACxB,EAAa,EAAiB,IAAI,AAAC,GACrC,KAAK,MAAM,IAET,EAAa,GAAI,KAAI,GAC3B,EAAc,QAAQ,AAAC,GAAW,CAC9B,AAAK,EAAW,IAAI,IAChB,KAAK,gBAAgB,EAAQ,EAAM,EAAM,aAGjD,EAAW,QAAQ,AAAC,GAAW,CAC3B,AAAK,EAAc,IAAI,IACnB,KAAK,aAAa,EAAQ,EAAM,EAAM,aAKlD,eAAe,EAAY,CACvB,GAAM,GAAO,KAAK,MAAM,GAGxB,AADgB,KAAK,4BAA4B,GACzC,QAAQ,AAAC,GAAW,CACxB,KAAK,gBAAgB,EAAQ,EAAM,EAAM,aAOzC,qBACJ,EACA,EAA+B,EAAM,SAC7B,CACR,MAAK,MAAK,MAAM,GACT,OAAO,KAAK,KAAK,MAAM,IAAS,OACnC,AAAC,GAAU,MAAK,MAAM,GAAQ,IAAS,GAAK,GAFhB,GAS5B,4BACJ,EACA,EAA+B,EAAM,SAC7B,CACR,MAAK,MAAK,aAAa,GAChB,OAAO,KAAK,KAAK,aAAa,IAAS,OAC1C,AAAC,GAAY,MAAK,aAAa,GAAQ,IAAW,GAAK,GAFpB,GAS3C,gBACI,EACA,EAA+B,EAAM,SAC/B,CACN,GAAM,GAAS,KAAK,MAAM,GAC1B,MAAO,MAAK,qBAAqB,EAAQ,GAAU,IAC/C,AAAC,GAAS,KAAK,SAAS,IAyBxB,mBAAoB,CAOxB,GAAI,GAAQ,EACN,EAAqC,GACrC,EAAkB,GAClB,EAA8B,GAE9B,EAAgB,AAAC,GAAmB,CAsCtC,GArCA,EAAO,MAAQ,EACf,EAAO,QAAU,EACjB,EAAQ,EAAQ,EAChB,EAAM,KAAK,GACX,EAAO,QAAU,GAGjB,KAAK,4BAA4B,EAAO,QAAQ,QAAQ,AAAC,GAAS,CAC9D,AAAK,EAAW,IACZ,GAAW,GAAQ,CACf,OAAQ,IAGhB,GAAM,GAAW,EAAW,GAC5B,AAAI,EAAS,QAAU,OAEnB,GAAc,GACd,EAAO,QAAU,KAAK,IAElB,EAAO,QAEP,EAAS,UAEN,EAAS,SAKhB,GAAO,QAAU,KAAK,IAElB,EAAO,QACP,EAAS,UAMjB,EAAO,UAAY,EAAO,MAAO,CAEjC,GAAM,GAAsB,GAC5B,OAAS,CAEL,GAAM,GAAW,EAAM,MAIvB,GAHA,EAAS,QAAU,GAEnB,EAAU,KAAK,GACX,IAAa,EACb,MAIR,EAAgB,KAAK,KAI7B,cAAO,KAAK,KAAK,UAAU,QAAQ,AAAC,GAAW,CAC3C,AAAI,KAAK,SAAS,IAAW,CAAC,EAAW,IACrC,GAAW,GAAU,CACjB,UAEJ,EAAc,EAAW,OAO1B,EAGH,UAAU,EAAuB,CAQrC,GAAI,GAAQ,EACN,EAAqC,GACrC,EAAkB,GAClB,EAA8B,GAE9B,EAAgB,AAAC,GAAmB,CA0CtC,GAzCA,EAAO,MAAQ,EACf,EAAO,QAAU,EACjB,EAAQ,EAAQ,EAChB,EAAM,KAAK,GACX,EAAO,QAAU,GAGjB,KAAK,qBAAqB,EAAO,QAAQ,QAAQ,AAAC,GAAS,CACvD,AAAK,EAAW,IACZ,GAAW,GAAQ,CACf,OAAQ,EACR,gBAAiB,CAAC,CAAC,KAAK,SAAS,KAGzC,GAAM,GAAW,EAAW,GAC5B,AAAI,EAAS,QAAU,OAEnB,GAAc,GACd,EAAO,QAAU,KAAK,IAElB,EAAO,QAEP,EAAS,UAEN,EAAS,SAKhB,GAAO,QAAU,KAAK,IAElB,EAAO,QACP,EAAS,QAGb,EAAS,iBACT,GAAO,gBAAkB,MAK7B,EAAO,UAAY,EAAO,MAAO,CAEjC,GAAM,GAAsB,GAC5B,OAAS,CAEL,GAAM,GAAW,EAAM,MAIvB,GAHA,EAAS,QAAU,GAEnB,EAAU,KAAK,GACX,IAAa,EACb,MAIR,EAAgB,KAAK,KAI7B,SAAY,QAAQ,AAAC,GAAW,CAC5B,AAAK,EAAW,IACZ,GAAW,GAAU,CACjB,SACA,gBAAiB,CAAC,CAAC,KAAK,SAAS,IAErC,EAAc,EAAW,OAI1B,EAAgB,UA0F3B,QAAQ,EAAgE,CAEpE,OAAO,KAAK,KAAK,YAAY,QAAQ,AAAC,GAAW,CAC7C,AAAI,KAAK,WAAW,IAChB,EAAS,KAAK,SAAS,GAAS,gBAIxC,GAAI,GAAkB,GACtB,EACI,GAAkB,GAClB,KAAK,oBAAoB,QAAQ,AAAC,GAAc,CAC5C,GAAM,GAAU,EAAU,OAAS,EAC7B,EAAU,GAAI,KAChB,EAAU,IAAI,AAAC,GAAW,EAAO,SAMrC,EAAQ,QAAQ,AAAC,GAAW,CAExB,AAAI,AADa,CAAC,CAAC,KAAK,YAAY,KACnB,GACb,GAAS,KAAK,SAAS,GAAS,cAChC,KAAK,WAAW,GAAU,GAC1B,KAAK,YAAY,GAAU,KAMnC,EAAQ,QAAQ,AAAC,GAAW,CACxB,AAAI,KAAK,WAAW,IAKZ,CAJoB,EACpB,KAAK,SAAS,GACd,EAAU,QAAU,gBAGpB,KAAK,qBACD,EACA,EAAM,WACR,QAAQ,AAAC,GAAS,CAChB,AAAK,EAAQ,IAAI,IACb,MAAK,WAAW,GAAQ,GACxB,EAAS,KAAK,SAAS,GAAO,iBAI1C,EAAkB,GAClB,MAAO,MAAK,WAAW,cAI9B,GAIT,GAAM,GAAmC,GACnC,EAAkB,AAAC,GAAmB,CACxC,AAAI,EAAQ,IACZ,GAAQ,GAAU,GAClB,EAAS,KAAK,SAAS,GAAS,cAChC,KAAK,qBAAqB,EAAQ,EAAM,WAAW,QAC/C,AAAC,GAAS,CACN,EAAgB,OAI5B,OAAO,KAAK,KAAK,YAAY,QAAQ,AAAC,GAAW,CAC7C,AAAI,KAAK,WAAW,IAChB,GAAgB,GAChB,MAAO,MAAK,WAAW,MAQnC,SACI,EAIF,CACE,GAAM,GAAQ,CACV,kBAEA,+CAGE,EAAU,OAAO,KAAK,KAAK,UAAU,OACvC,AAAC,GAAW,CAAC,CAAC,KAAK,SAAS,IAE1B,EAGF,GACJ,EAAQ,QAAQ,AAAC,GAAW,CACxB,EAAe,GAAU,EACrB,EACA,KAAK,SAAS,MAGtB,GAAM,GAAe,GAAQ,EAAS,AAAC,GAC5B,CAAC,EAAe,GAAQ,SAAU,IAGzC,EAAY,EAChB,SAAa,QAAQ,CAAC,EAAS,IAAU,CACrC,AAAI,GACA,EAAM,KACF,oBAAoB,QACpB,kBACA,oBAER,EAAQ,QAAQ,AAAC,GAAW,CACxB,GAAM,GAAgC,CAClC,MAAO,KAAK,SAAS,GAAU,MAAQ,UACvC,MAAO,EAAe,GAAQ,MAC9B,SAAU,EAAe,GAAQ,SACjC,UAAW,KAAK,WAAW,GAAU,UAAY,WAErD,EAAM,KACF,UAAU,MAAW,OAAO,QAAQ,GAC/B,IACG,CAAC,CAAC,EAAK,KAAW,GAAG,KAAO,KAAK,UAAU,MAE9C,KAAK,YAGd,GAAO,EAAM,KAAK,OAG1B,EAAQ,QAAQ,AAAC,GAAW,CAIxB,AAHwB,MAAM,KAC1B,GAAI,KAAI,OAAO,KAAK,KAAK,MAAM,MAEnB,QAAQ,AAAC,GAAS,CAC9B,AAAI,KAAK,MAAM,GAAQ,GAAQ,EAAM,WACjC,EAAM,KACF,UAAU,aAAkB,sBAGhC,KAAK,MAAM,GAAQ,GAAQ,EAAM,WACjC,EAAM,KACF,UAAU,aAAkB,2BAM5C,EAAM,KAAK,KAEJ,EAAM,KAAK;AAAA,KAzqBnB,IACY,EADZ,EACY,YAAY,GACpB,EAFJ,EAEI,YAAY,GACZ,EAHJ,EAGI,YAAY,GACJ,EAJZ,EAIY,WAAW,GCX9B,GAAI,GAAgC,GAAI,SAEjC,aAAsB,CACzB,EAAU,GAAI,SAGX,YAAsB,EAAyB,CAE9C,MAAO,GA4BR,WAAiB,EAAS,EAAiB,CAClC,MAAO,GC1BvB,GAAI,GACA,GAEA,EAAwB,GAAI,GAE5B,GAAsC,GAKnC,aAAiB,CACpB,EAAqB,GAErB,EAAwB,GAAI,GAC5B,GAAc,GACd,KAGJ,GAAI,GAIG,YAAkC,EAAoC,CACzE,GAAM,GAAS,EACf,EAAsB,GACtB,GAAI,CACA,WACiB,SAEnB,CACE,EAAsB,GAqBvB,YACH,EACA,EACA,EACgB,CAChB,AAAI,MAAO,IAAY,UAAU,GAAY,GACzC,MAAO,IAAY,YAAY,GAAU,IACzC,MAAO,IAAc,UAAU,GAAY,QAC/C,GAAM,GAAc,GAAgB,EAAM,EAAS,IACnD,MAAI,IAAW,EAAK,EAAa,GAC7B,GAAqB,EAAoB,KAAK,GAC3C,EAcJ,YACH,EACA,EACiB,CACjB,GAAM,GAAc,GAChB,EACA,GACA,IAEJ,MAAI,IAAW,EAAK,EAAa,GAC7B,GAAqB,EAAoB,KAAK,GAC3C,EAGJ,YAAyB,EAAwB,CACpD,EAAmB,KAAK,CAAE,KAAM,KAAM,KAAM,KAC5C,GAAI,CACA,MAAO,YACT,CACE,EAAmB,OAY3B,oBAA+B,MAAM,CAEjC,YAAY,EAAa,EAAwB,CAC7C,MAAM,GAFH,wBAGH,KAAK,cAAgB,IAI7B,gBAA8B,MAAM,GAEpC,YACI,EACA,EACA,EACgB,CAChB,GAAI,MAAO,IAAoB,WAC3B,KAAM,IAAI,GAAe,2CAG7B,GAAI,GACA,EAA0B,EAC1B,EAEA,EAAa,GAEX,EAAgC,OAAO,OAAO,EAAiB,CACjE,MAAO,KACN,GAAU,eACV,IAAqB,EACf,SACA,eACN,IAAyB,GACzB,IAA4B,GAC5B,IAA2B,EAC5B,QAAS,EACT,QAAS,IAGb,EAAsB,QAAQ,GAE9B,YAA2B,CAOvB,OANA,AAAI,EAAO,CAAC,EAAY,gCACnB,GAED,GAA2B,GAGvB,OACC,GAAgC,CACjC,EAAQ,EACR,EAAmB,KAAK,CAAE,KAAM,EAAa,KAAM,KACnD,GAAM,GAAa,EACnB,GAAI,CACA,EAAS,CAAE,OAAQ,WACd,EAAP,CACE,GAAM,GAAa,EAAmB,MACtC,AAAI,EACA,GAAY,OAAS,EACrB,mCAEJ,EAAsB,gBAClB,EACA,EAAW,MAEf,GAAM,GAAU,YAAa,IAgB7B,GAfA,EAAQ,EACF,EACA,EACN,AAAI,EACA,EAAS,CACL,OAAQ,EAAa,EAAU,QAAU,UAM7C,EAAS,OAIT,GAAU,EAAmB,SAAW,EACxC,MAAO,IACH,EAAQ,EAAW,OAAQ,EAAO,QAChC,EAAW,OACX,EAAO,OAEjB,KAAI,GACM,EAEJ,GAAI,IACN,gEACA,GAGR,EAAQ,EACR,GAAM,GAAa,EAAmB,MACtC,MAAI,GACA,GAAY,OAAS,EACrB,mCAEJ,EAAsB,gBAClB,EACA,EAAW,MAER,GAAc,EAAQ,EAAW,OAAQ,EAAO,QACjD,EAAW,OACX,EAAO,WAEZ,GAED,GADA,EAAQ,EACJ,GACA,GAAS,CACL,OAAQ,EAAa,UAMrB,EAAmB,SAAW,GAC9B,MAAO,GAAO,OAGtB,KAAM,IAAI,IACN,qDAGH,GACD,GAAI,EACA,MAAO,GAAO,OAElB,KAAM,IAAI,GACN,wDAEH,GACD,GAAI,EACA,MAAO,GAAO,OAElB,KAAM,IAAI,OACN,qDAEH,GACD,GAAI,EACA,MAAO,GAAO,OAElB,KAAM,IAAI,OAAM,sCAEhB,AAAI,EAAgB,EAAO,iCAIvC,YAAiC,CAE7B,OADA,AAAI,EAAO,CAAC,EAAY,gCAChB,OACC,GACD,KAAM,IAAI,GACN,2DAEH,GACD,WACC,GAMD,EAAsB,eAAe,GACrC,EAAQ,EACR,UACC,OACA,GAA8B,CAG/B,EAAQ,EACR,cAGA,AAAI,EAAgB,EAAO,iCAIvC,YAA+B,CAE3B,OADA,AAAI,EAAO,CAAC,EAAY,gCAChB,OACC,GACD,KAAM,IAAI,GACN,6EAGH,OACA,OACA,OACA,GAED,GADA,EAAQ,EACJ,EAAc,CACd,GAAI,GAAgB,GACd,EAAY,EAAa,SAC/B,MAAI,IACA,GAAgB,EAAQ,EAAO,OAAQ,IAEtC,GACD,GAAS,CAAE,OAAQ,IAEhB,CAAC,MAER,OAAI,GACA,GAAS,OACF,IAEJ,WAIX,AAAI,EAAgB,EAAO,iCAIvC,YAAkC,CAE9B,OADA,AAAI,EAAO,CAAC,EAAY,gCAChB,OACC,GACD,KAAM,IAAI,GACN,mEAGH,OACA,OACA,GAA+B,CAChC,GAAM,GAAc,EACpB,GAAI,CACA,SACF,EAGF,MACI,IACA,GACA,EAAQ,EAAY,OAAQ,EAAO,QAEnC,GAAS,EACF,IAEJ,OAEN,GACD,KAAM,IAAI,GACN,0EAGJ,AAAI,EAAgB,EAAO,iCAIvC,WACI,EACF,CACE,MAAI,GAAO,CAAC,EAAY,gCACxB,EAAe,EACR,EAGX,YAA8B,CAC1B,AAAI,EAAO,CAAC,EAAY,gCACxB,EAAsB,WAAW,GAGjC,EAAS,OACT,EAAe,OAEf,EAAa,GAGjB,MAAO,GAGJ,YAAoC,EAAiB,CACxD,GAAI,EAAmB,SAAW,EAAG,OAGrC,AADI,EAAmB,EAAmB,OAAS,GAC9B,KAAK,KAAK,GAY5B,YAAsB,EAAqB,EAAmB,CACjE,EAAsB,QAAQ,GAC9B,EAAsB,QAAQ,GAC9B,EAAsB,QAAQ,EAAU,EAAQ,EAAM,WAUnD,WAAsB,EAAiB,CAC1C,EAAsB,QAAQ,GAG3B,YAAqB,EAAiB,CACzC,EAAsB,WAAW,GAG9B,WAAwB,EAAqB,EAAmB,CACnE,EAAsB,QAAQ,EAAU,EAAQ,EAAM,WAUnD,YAAyB,EAAqB,EAAmB,CACpE,EAAsB,WAAW,EAAU,EAAQ,EAAM,WAUtD,WAA2B,EAAqB,EAAmB,CACtE,EAAsB,WAAW,EAAU,EAAQ,EAAM,WAUtD,WAAmB,EAAiB,CAEvC,EAAsB,QAAQ,GAC9B,EAAsB,cAAc,GACpC,KAIJ,GAAI,GAAa,GACb,GAA8B,QAAQ,UACtC,GAAkC,GAClC,GAA8B,IAAM,WAAW,IAAM,KAAS,GAE3D,aAAqB,CACxB,MAAK,GACE,GADiB,QAAQ,UAc7B,YAAmB,EAAqB,GAAY,CACvD,GAAoB,EAChB,GACA,KAIR,aAAyB,CACrB,AAAK,GACD,GAAa,GACb,MAIR,aAAkB,CACd,GAAI,CACA,GAAe,GAAI,SAAQ,AAAC,GAAY,CACpC,GAAsB,IAE1B,WACK,EAAP,CACE,AAAI,GAAU,EAAG,iCAOzB,GAAI,IACA,KAKG,aAAiB,CACpB,AAAI,CAAC,GAGL,GAAa,GAKb,EAAsB,QAAQ,CAAC,EAAM,IAAW,CAC5C,GAAI,GAAkB,GAEtB,OAAQ,OACC,QACD,GAAI,EAAc,GACd,EAAkB,EAAK,UAEvB,MAAM,IAAI,OAAM,kCAEpB,UACC,aACD,AAAI,EAAc,IACd,EAAK,MAET,UACC,cACD,AAAI,EAAc,GACd,EAAkB,EAAK,MAEvB,GAAa,IACb,GAAQ,IACR,GAAe,KAEf,GAAkB,EAAK,OAE3B,cAEA,AAAI,EAAgB,GAc5B,MAAO,KAGP,EAAsB,iBAEtB,KAKJ,MAMG,YAAgB,EAAiB,CACpC,GAAM,GAAW,GAAY,EAAK,QAAU,EACtC,EAAc,EAAW,EAC/B,AAAI,IAAa,GAOR,GAAsB,QAAQ,IAC/B,EAAsB,QAAQ,GAElC,EAAsB,OAAO,IASjC,GAAY,EAAK,OAAS,EAOvB,YAAiB,EAAiB,CACrC,GAAM,GAAW,GAAY,EAAK,QAAU,EACtC,EAAc,KAAK,IAAI,EAAW,EAAG,GAC3C,AAAI,EAAW,GACX,AAAI,EACA,qCAAqC,GAAa,KAClD,GAGJ,EAAc,GAOd,EAAsB,QAAQ,GASlC,GAAY,EAAK,OAAS,EAMvB,YAAe,EAA0B,CAC5C,MAAO,GAAsB,SAAS,CAAC,EAAI,IAAS,CAChD,GAAI,GACJ,MAAI,IAAQ,IACR,GAAW,GAEX,EAAa,IACb,GAAW,GAEX,GAAa,IACb,GAAW,EAAK,OAEhB,GAAe,IACf,GAAW,EAAK,MAEb,CACH,MAAO,GAAG;AAAA,EAAO,GAAa,KAC9B,WACA,SAAU,IAAe,EAAO,MAAQ,SAK7C,aAAsB,CACzB,MAAO,CACH,wBACA,qBACA,eACA,aACA,gBACA,uBACA,sBAID,YACH,EACF,CACE,GAAoB,EC1rBjB,GAAM,IAAa,OAAO,cAsD3B,GAAe,OAAO,UAwD5B,YACI,EACkB,CAClB,GAAI,EAAC,EACL,MAAO,GAEX,YACI,EACkB,CAClB,GAAI,IAAQ,OACZ,MAAO,OAAO,IAAQ,SAAW,EAAM,SAAS,GAEpD,YAAmB,EAAyD,CACxE,GAAI,IAAQ,OACZ,MAAO,KAAQ,KAuTZ,GAAM,GAGT,CACA,UAAW,CACP,QAAS,aAEb,cAAe,CACX,QAAS,cAEb,oBAAqB,CACjB,QAAS,oBAEb,YAAa,CACT,QAAS,YAEb,eAAgB,CACZ,QAAS,eAEb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,oBAAqB,CAIjB,QAAS,oBAEb,eAAgB,CACZ,QAAS,eAEb,eAAgB,CACZ,QAAS,eAQb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,cAAe,CACX,QAAS,cAEb,eAAgB,CAIZ,QAAS,eAEb,oBAAqB,CACjB,QAAS,oBAEb,aAAc,CACV,QAAS,aAEb,aAAc,CACV,QAAS,aAEb,YAAa,CACT,QAAS,YAEb,aAAc,CACV,QAAS,aAEb,iBAAkB,CACd,QAAS,iBAEb,uBAAwB,CACpB,QAAS,uBAEb,mBAAoB,CAChB,QAAS,mBAEb,mBAAoB,CAChB,QAAS,mBAEb,gBAAiB,CACb,QAAS,gBAEb,eAAgB,CACZ,QAAS,eAEb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,uBAAwB,CACpB,QAAS,uBAEb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,oBAAqB,CAIjB,QAAS,oBAEb,eAAgB,CACZ,QAAS,eAEb,gBAAiB,CACb,QAAS,gBAEb,eAAgB,CACZ,QAAS,eAEb,YAAa,CACT,QAAS,YAEb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,gBAAiB,CACb,QAAS,gBAEb,iBAAkB,CACd,QAAS,iBAEb,eAAgB,GAChB,UAAW,GAGX,MAAO,CACH,QAAS,aAEb,gBAAiB,CACb,QAAS,mBAEb,IAAK,GACL,UAAW,GACX,aAAc,CACV,QAAS,gBAEb,OAAQ,GACR,GAAI,GACJ,UAAW,CACP,QAAS,aAEb,GAAI,CAAE,QAAS,MACf,OAAQ,CAAE,QAAS,MACnB,SAAU,CAAE,QAAS,MACrB,QAAS,CAAE,QAAS,MACpB,UAAW,CAAE,QAAS,MACtB,SAAU,CAAE,QAAS,MACrB,KAAM,GACN,MAAO,GACP,KAAM,GACN,KAAM,GACN,WAAY,GACZ,MAAO,GACP,SAAU,CACN,QAAS,WACT,aAAc,IAElB,MAAO,GACP,UAAW,CACP,aAAc,KAuBhB,GAGF,IACG,EACH,KAAM,GACN,OAAQ,GACR,SAAU,GACV,KAAM,GACN,IAAK,GACL,SAAU,GACV,KAAM,GACN,eAAgB,CACZ,QAAS,mBAyBX,GAGF,IACG,EACH,IAAK,GACL,OAAQ,GACR,MAAO,GACP,KAAM,GACN,OAAQ,GACR,SAAU,GACV,KAAM,GACN,IAAK,GACL,eAAgB,CACZ,QAAS,mBAwBX,GAGF,IACG,EACH,IAAK,GACL,YAAa,CACT,QAAS,eAEb,QAAS,GACT,SAAU,GACV,KAAM,CACF,aAAc,IAElB,MAAO,GACP,SAAU,IAMR,GAAsE,IACrE,GAQD,GAGF,IACG,EACH,KAAM,GACN,OAAQ,IAMN,GAGF,IACG,GAgBD,GAGF,IACG,EACH,SAAU,GACV,KAAM,CAAE,QAAS,MACjB,WAAY,CACR,QAAS,cAEb,YAAa,CACT,QAAS,eAEb,WAAY,CACR,QAAS,cAEb,eAAgB,CACZ,QAAS,kBAEb,WAAY,CACR,QAAS,cAEb,KAAM,GACN,KAAM,GACN,MAAO,IAQL,GAGF,IACG,EACH,MAAO,GACP,OAAQ,IAMN,GAGF,IACG,GAOD,GAGF,IACG,EACH,MAAO,IAML,GAGF,IACG,GAOD,GAGF,IACG,EACH,KAAM,IAOJ,GAGF,IACG,EACH,KAAM,IAMJ,GAAyE,IACxE,GAUD,GAGF,IACG,EACH,IAAK,GACL,KAAM,GACN,MAAO,GACP,OAAQ,IASN,GAGF,IACG,EACH,SAAU,GACV,KAAM,CAAE,QAAS,MACjB,KAAM,IAeJ,GAGF,IACG,EACH,iBAAkB,CACd,QAAS,iBAEb,OAAQ,GACR,aAAc,GACd,QAAS,GACT,OAAQ,GACR,KAAM,GACN,WAAY,CACR,QAAS,cAEb,OAAQ,GACR,IAAK,IAMH,GAGF,IACG,GAMD,GAGF,IACG,GAMD,GAAsE,IACrE,GAMD,GAGF,IACG,GA2BD,GAGF,IACG,EACH,IAAK,GACL,OAAQ,GACR,KAAM,GACN,QAAS,GACT,MAAO,GACP,gBAAiB,CACb,QAAS,mBAEb,MAAO,GACP,OAAQ,GACR,eAAgB,CACZ,QAAS,kBAEb,QAAS,IA8BP,GAGF,IACG,EACH,IAAK,GACL,IAAK,GACL,OAAQ,GACR,MAAO,GACP,YAAa,CACT,QAAS,eAEb,OAAQ,CACJ,QAAS,UAEb,MAAO,CACH,QAAS,SAEb,MAAO,GACP,OAAQ,GACR,eAAgB,CACZ,QAAS,kBAEb,SAAU,GACV,QAAS,IA4FP,GAGF,IACG,EACH,OAAQ,GACR,IAAK,GACL,aAAc,GACd,QAAS,GACT,QAAS,CACL,QAAS,WAEb,SAAU,GACV,KAAM,GACN,WAAY,CACR,QAAS,cAEb,YAAa,CACT,QAAS,eAEb,WAAY,CACR,QAAS,cAEb,eAAgB,CACZ,QAAS,kBAEb,WAAY,CACR,QAAS,cAEb,OAAQ,GACR,cAAe,CACX,cAAe,MAEnB,KAAM,GACN,IAAK,GACL,UAAW,GACX,IAAK,GACL,UAAW,CACP,QAAS,aAEb,SAAU,GACV,KAAM,GACN,QAAS,GACT,YAAa,GACb,SAAU,CACN,QAAS,YAEb,SAAU,GACV,KAAM,GACN,IAAK,GACL,KAAM,GACN,KAAM,GACN,MAAO,GACP,MAAO,IAUL,GAAyE,IACxE,EACH,KAAM,GACN,SAAU,CACN,QAAS,aASX,GAGF,IACG,EACH,IAAK,CACD,QAAS,YAOX,GAGF,IACG,GAQD,GAAsE,IACrE,EACH,MAAO,IAmCL,GAGF,IACG,EACH,KAAM,GACN,YAAa,CACT,QAAS,eAEb,IAAK,GACL,MAAO,GACP,UAAW,GACX,SAAU,GACV,KAAM,GACN,eAAgB,CACZ,QAAS,kBAEb,MAAO,GACP,YAAa,CACT,QAAS,eAEb,WAAY,CACR,QAAS,cAEb,GAAI,GACJ,MAAO,CACH,QAAS,MAEb,SAAU,IAQR,GAAyE,IACxE,EACH,KAAM,IAMJ,GAGF,IACG,GA0BD,GAGF,IACG,EACH,KAAM,GACN,aAAc,CACV,QAAS,aAEb,QAAS,GACT,QAAS,CACL,QAAS,MAEb,MAAO,IAkBL,GAGF,IACG,EACH,MAAO,GACP,IAAK,GACL,IAAK,GACL,IAAK,GACL,KAAM,GACN,QAAS,IAkBP,GAGF,IACG,EACH,KAAM,GACN,KAAM,GACN,KAAM,GACN,KAAM,CACF,QAAS,MAEb,MAAO,GACP,OAAQ,IAmBN,GAGF,IACG,EACH,SAAU,GACV,MAAO,GACP,KAAM,IAUJ,GAGF,IACG,EACH,SAAU,GACV,MAAO,IAcL,GAGF,IACG,EACH,SAAU,GACV,MAAO,GACP,SAAU,GACV,MAAO,IAYL,GAGF,IACG,EACH,IAAK,CACD,QAAS,WAEb,KAAM,CAAE,QAAS,MACjB,KAAM,IAMJ,GAGF,IACG,GAUD,GAGF,IACG,EACH,KAAM,GACN,MAAO,IAML,GAGF,IACG,GAMD,GAAyE,IACxE,GAUD,GAGF,IACG,EACH,MAAO,GACP,IAAK,IAQH,GAGF,IACG,EACH,KAAM,IAsBJ,GAGF,IACG,EACH,IAAK,GACL,KAAM,GACN,SAAU,CACN,QAAS,YAEb,MAAO,GACP,MAAO,GACP,YAAa,CACT,QAAS,eAEb,UAAW,GACX,eAAgB,CACZ,QAAS,mBAuBX,GAGF,IACG,EACH,aAAc,GACd,SAAU,GACV,KAAM,CAAE,QAAS,MACjB,SAAU,GACV,KAAM,GACN,SAAU,GACV,KAAM,GACN,MAAO,CAAE,cAAe,OAQtB,GAGF,IACG,EACH,KAAM,IAoBJ,GAGF,IACG,EACH,KAAM,GACN,IAAK,GACL,OAAQ,GACR,MAAO,GACP,MAAO,GACP,MAAO,GACP,OAAQ,IAMN,GAGF,IACG,GAQD,GAGF,IACG,EACH,MAAO,IAML,GAGF,IACG,GAMD,GAGF,IACG,GAMD,GAGF,IACG,GAYD,GAGF,IACG,EACH,QAAS,CACL,QAAS,WAEb,QAAS,CACL,QAAS,WAEb,QAAS,IAQP,GAGF,IACG,EACH,KAAM,IAMJ,GAGF,IACG,GAgCD,GAGF,IACG,EACH,aAAc,GACd,KAAM,GACN,QAAS,CACL,QAAS,WAEb,SAAU,GACV,KAAM,CAAE,QAAS,MACjB,UAAW,CACP,QAAS,aAEb,UAAW,CACP,QAAS,aAEb,KAAM,GACN,YAAa,GACb,SAAU,CACN,QAAS,YAEb,SAAU,GACV,KAAM,GACN,KAAM,IAQJ,GAGF,IACG,EACH,SAAU,CACN,QAAS,aAOX,GAGF,IACG,GAMD,GAGF,IACG,GAuBD,GAGF,IACG,EACH,KAAM,GACN,IAAK,GACL,QAAS,GACT,MAAO,GACP,QAAS,IAMP,GAGF,IACG,GAcD,GAGF,IACG,EACH,IAAK,GACL,YAAa,CACT,QAAS,eAEb,QAAS,GACT,SAAU,GACV,KAAM,CACF,aAAc,IAElB,MAAO,GACP,SAAU,GACV,OAAQ,GACR,YAAa,CACT,QAAS,eAEb,MAAO,GACP,OAAQ,IAGC,GAAqB,CAC9B,EAAG,GACH,KAAM,EACN,QAAS,EACT,KAAM,GACN,QAAS,EACT,MAAO,EACP,MAAO,GACP,EAAG,EACH,KAAM,GACN,IAAK,EACL,IAAK,EACL,WAAY,EACZ,KAAM,GACN,GAAI,GACJ,OAAQ,GACR,OAAQ,GACR,QAAS,GACT,KAAM,EACN,KAAM,EACN,IAAK,GACL,SAAU,GACV,KAAM,GACN,SAAU,GACV,GAAI,EACJ,IAAK,GACL,QAAS,GACT,IAAK,EACL,OAAQ,GACR,IAAK,GACL,GAAI,GACJ,GAAI,EACJ,GAAI,EACJ,MAAO,GACP,SAAU,GACV,WAAY,EACZ,OAAQ,EACR,OAAQ,EACR,KAAM,GACN,GAAI,EACJ,GAAI,EACJ,GAAI,EACJ,GAAI,EACJ,GAAI,EACJ,GAAI,EACJ,KAAM,GACN,OAAQ,EACR,QAAS,GACT,OAAQ,EACR,GAAI,GACJ,KAAM,GACN,EAAG,EACH,OAAQ,GACR,MAAO,GACP,IAAK,EACL,MAAO,GACP,IAAK,GACL,IAAK,EACL,MAAO,GACP,OAAQ,GACR,GAAI,GACJ,KAAM,GACN,KAAM,EACN,IAAK,GACL,KAAM,EACN,KAAM,GACN,KAAM,GACN,MAAO,GACP,IAAK,EACL,SAAU,EACV,OAAQ,GACR,GAAI,GACJ,SAAU,GACV,OAAQ,GACR,OAAQ,GACR,EAAG,GACH,MAAO,GACP,QAAS,GACT,IAAK,GACL,SAAU,GACV,MAAO,GACP,GAAI,EACJ,GAAI,EACJ,KAAM,EACN,EACA,KAAM,EACN,OAAQ,GACR,QAAS,EACT,OAAQ,GACR,KAAM,GACN,MAAO,EACP,OAAQ,GACR,KAAM,GACN,OAAQ,EACR,MAAO,GACP,IAAK,EACL,QAAS,EACT,IAAK,EACL,MAAO,GACP,MAAO,GACP,GAAI,GACJ,SAAU,GACV,SAAU,GACV,MAAO,GACP,GAAI,EACJ,MAAO,GACP,KAAM,GACN,MAAO,GACP,GAAI,GACJ,MAAO,GACP,EAAG,EACH,GAAI,GACJ,IAAK,EACL,MAAO,GACP,IAAK,GAWF,YACH,EACA,EACuB,CACvB,MAAQ,IAA2B,KAAe,GCjiEtD,YAAyB,EAAsB,CAC3C,GAAM,GAAgB,GACtB,WAAe,EAAa,CACxB,AAAI,EAAK,QACL,EAAM,KAAK,EAAK,SAEhB,EAAK,UAAU,QAAQ,AAAC,GAAU,EAAM,IAGhD,SAAM,GACC,EAGX,YACI,EACA,EACA,EACM,CACN,GAAI,GAAY,EAEhB,WAAe,EAAsB,CACjC,MAAI,GAAK,QACL,IAAa,EACN,IAEA,EAAc,GAG7B,WAAuB,EAAsB,CACzC,GAAI,EAAK,SAAU,CACf,GAAM,GACF,IAAS,EAAkB,EAAa,EAAK,SAAS,OAC1D,OAAS,GAAI,EAAG,EAAI,EAAY,EAAE,EAC9B,GAAI,EAAM,EAAK,SAAS,IACpB,MAAO,GAInB,MAAO,KAAS,EAEpB,SAAc,GACP,EAGJ,YAAqB,EAAa,CAErC,EAAK,UAAU,QAAQ,AAAC,GAAU,GAAY,IAG1C,EAAK,SACL,EAAK,QAAQ,QAAQ,AAAC,GAAY,CAC9B,GAAI,CACA,UACK,EAAP,CACE,AAAI,GACA,EACA,yCACA,MAUpB,YACI,EACA,EACA,EACF,CACE,AAAI,GAAmB,EAAK,SACxB,EAAgB,KAAK,EAAK,SAG9B,EAAK,UAAU,QAAQ,AAAC,GAAU,CAC9B,GACI,EACA,EAAK,QAAU,OAAY,EAC3B,KAKJ,GAAgB,EAAK,WACrB,EAAK,UAAU,QAAQ,AAAC,GAAc,CAClC,GAAI,CACA,UACK,EAAP,CACE,AAAI,GACA,EACA,2CACA,MAOb,WACH,EACA,EACA,EACA,EACA,CAAE,aAAa,GAAM,eAAe,IAAS,GAC/C,CACE,AAAI,EACA,EAAgB,SAChB,sDAEJ,GAAM,GAAY,EAAgB,QAC5B,EACA,EAAgB,UACtB,AAAI,EAAa,EAAgB,SAAS,QACtC,GAAa,EAAgB,SAAS,QAE1C,AAAI,EACA,GAAa,EAAU,QACvB,4DAGJ,GAAM,GAAgB,EAAU,QAE1B,EAAiB,EAAgB,SAAS,OAC5C,EACA,EACA,GAAG,GAID,EAAmB,GAazB,GAZA,EAAe,QAAQ,AAAC,GAAkB,CACtC,GAAe,EAAe,EAAU,KAG5C,AAAI,EAAc,WAAW,SAAW,EAAS,OAE5C,EAA0B,kBAE3B,EAAS,QAAQ,AAAC,GAAU,EAAc,YAAY,IAItD,EAAS,OAAS,EAAG,CACrB,GAAM,GAAW,GACb,EACA,EACA,GAEE,EACF,EAAc,WAAW,GAEvB,EAAW,SAAS,yBAE1B,OAAS,GAAI,EAAG,EAAI,EAAS,OAAQ,EAAE,EAAG,CACtC,GAAM,GAAU,EAAS,GACzB,EAAQ,UAAY,EAEpB,AADmB,GAAgB,GACxB,QAAQ,AAAC,GAAY,CAC5B,EAAS,YAAY,KAI7B,EAAc,aAAa,EAAU,GAAiB,MAClD,GACA,EAAS,QAAQ,AAAC,GAAY,CAC1B,AAAI,GACA,GAAY,KAK5B,MAAO,GCtLJ,GAAM,IAAW,CAAC,CAAE,cAAwC,EA2D5D,YACH,EAKA,KACG,EACyC,CAC5C,MAAI,OAAO,IAAgB,SAChB,CACH,KAAM,YACN,QAAS,EACT,QACA,YAGJ,GAAU,GACH,CACH,KAAM,UACN,QAAS,EACT,MAAO,EACP,YAGD,CACH,KAAM,YACN,UAAW,EACX,QACA,YAIR,GAAc,SAAW,GAEzB,YACI,EACA,EACA,EACA,EACA,EACF,CACE,GAAI,EAAI,WAAW,QAAU,MAAO,IAAU,WAAY,CACtD,GAAM,GAAY,EAAI,MAAM,GAC5B,AAAI,EAAY,IACZ,EAAQ,oBAAoB,EAAW,EAAY,IAEvD,EAAQ,iBAAiB,EAAW,GACpC,EAAY,GAAO,MAChB,CACH,GAAM,GAAqB,GAAsB,IAAQ,KACnD,EAAU,GAAsB,EAAa,GACnD,GAAI,EAAS,CACT,GAAI,EAAQ,gBAAkB,KAAM,CAChC,GAAM,GAAiB,EAAQ,cACzB,EAAQ,cAAc,GACrB,EACP,AACI,AACA,GAAmB,MACnB,IAAmB,GAEnB,EAAQ,gBAAgB,GACrB,AAAI,IAAmB,GAC1B,EAAQ,eAAe,EAAoB,EAAK,IAEhD,EAAQ,eACJ,EACA,EACA,GAIZ,AAAI,EAAQ,UAAY,MACnB,GAAgB,EAAQ,SAAW,GAAO,EAAQ,aAC7C,EAAQ,aAAa,GACrB,OAEP,AAAI,KAAU,IAAS,IAAU,QAAa,IAAU,KAC3D,EAAQ,kBAAkB,EAAoB,GAC3C,AAAI,IAAU,GACjB,EAAQ,eAAe,EAAoB,EAAK,IACzC,OAAO,IAAU,UAAY,MAAO,IAAU,WACrD,EAAQ,eAAe,EAAoB,EAAK,EAAM,aAKlE,YACI,EAC4C,CAC5C,MAAO,GAAa,GAGxB,WACI,EACA,EACA,EACA,EACA,EACK,CACL,GACI,GAAY,MAEZ,IAAY,IACZ,IAAY,GAEZ,MAAO,CAAE,aAEb,GAAI,MAAO,IAAY,SAAU,CAC7B,GAAM,GAAU,SAAS,eAAe,GACxC,SAAiB,YAAY,GACtB,CACH,UACA,aAGR,GAAI,MAAO,IAAY,SAAU,CAC7B,GAAM,GAAU,SAAS,eAAe,EAAQ,YAChD,SAAiB,YAAY,GACtB,CACH,UACA,aAGR,MAAI,GAAc,GACP,GACH,EACA,EACA,EACA,EACA,GAGJ,GAAiB,GACV,GACH,EACA,EACA,EACA,EACA,GAGJ,MAAM,QAAQ,GACP,CACH,YACA,SAAU,EAAQ,IAAI,AAAC,GACnB,EACI,EACA,EACA,EACA,EACA,KAKZ,MAAO,IAAY,WACnB,CAAI,GACA,4EAEG,CAAE,cAET,MAAO,IAAY,SACnB,CAAI,GACA,0EAEG,CAAE,cAEN,GACH,EACA,EACA,EACA,EACA,GAIR,YACI,EACA,EACA,EACA,EACA,EACF,CAEE,OAAQ,EAAc,UACb,YACD,MAAO,IACH,EAAc,QACd,EAAc,MACd,EAAc,SACd,EACA,EACA,EACA,OAEH,UACD,MAAO,IACH,EAAc,QACd,EAAc,MAAM,MACpB,EAAc,SACd,EACA,EACA,EACA,OAEH,YACD,MAAO,IACH,EAAc,UACd,EAAc,MACd,EAAc,SACd,EACA,EACA,EACA,WAGJ,AAAI,EAAgB,IAIhC,GAAM,IAAiB,+BACjB,GAAgB,6BAChB,GAAmB,qCACnB,EAAkB,+BAClB,GAAgB,uCAChB,GAAkB,gCAElB,GAAgD,CAClD,gBAAiB,EACjB,gBAAiB,EACjB,aAAc,EACd,aAAc,EACd,aAAc,EACd,cAAe,EACf,aAAc,EACd,WAAY,GACZ,YAAa,GACb,MAAO,GACP,cAAe,IAEb,GAGF,EACC,IAAiB,CACd,IAAK,CACD,KAAM,GACN,SAAU,IAEd,KAAM,CACF,KAAM,GACN,SAAU,MAGjB,IAAgB,CACb,cAAe,CACX,KAAM,GACN,SAAU,MAKhB,GAAsB,GAAc,IAE1C,YACI,EACA,EACA,EACA,EACA,EACA,EACA,EACF,CACE,GAAI,GAAgB,EAChB,EAA8B,EAAW,IAAI,IAC3C,EAAW,IAAI,IACf,GAAW,IACb,EAA0C,KACxC,EACF,GAA8B,KAAuB,GACzD,AAAI,GACA,GAAsB,EAAuB,KAC7C,EAA2B,EAAuB,UAElD,GAA4B,MAC5B,GAAgB,GAAI,KAAI,GACxB,EAAc,IAAI,GAAqB,IAS3C,GAAM,GAAU,SAAS,gBAAgB,EAAqB,GACxD,EAA0D,GAE1D,EAAmC,GACrC,EAGJ,AAAI,GACA,OAAO,QAAQ,GAAO,QAAQ,CAAC,CAAC,EAAK,KAAW,CAC5C,GAAI,IAAQ,MAAO,CACf,GAAI,GAAM,GAAQ,CACd,EAAM,QAAU,EAChB,OAEJ,GAAI,MAAO,IAAU,YAAc,CAAC,EAAc,GAAQ,CACtD,EAAc,EACd,QAGR,GAAI,EAAc,GAAQ,CACtB,GAAM,GAAc,GAAO,IAAM,CAC7B,GAAM,IAAgB,IACtB,GACI,EACA,EACA,EACA,GACA,IAEL,YAAY,KACf,EAAiB,KAAK,IAAM,CACxB,EAAkB,EAAa,GAC/B,EAAY,YAEhB,EAAe,EAAa,GAE5B,QAEA,IACI,EACA,EACA,EACA,EACA,KAMhB,GAAM,GAAqB,CACvB,YACA,QAAS,EACT,QAAS,CACL,IAAM,CACF,AAAI,GACA,EAAY,KAIxB,UAAW,CACP,IAAM,CACF,EAAiB,QAAQ,AAAC,GAAW,KACjC,GACA,EAAY,WAM5B,GAAI,GAAY,EAAS,OAAS,EAAG,CACjC,GAAM,GAAwB,SAAS,yBACjC,EAAc,EAAS,IAAI,AAAC,GAC9B,EACI,EACA,EACA,EACA,EACA,IAGR,EAAY,SAAW,EACvB,EAAQ,YAAY,GAExB,SAAiB,YAAY,GAEtB,EAGX,YACI,EACA,EACA,EACA,EACA,EACA,EACA,EACK,CACL,GAAM,GAAgB,GAAI,KAAI,GAC9B,EAAc,IAAI,EAAS,GAE3B,GAAM,GAAsB,CACxB,aAGJ,MAAI,IACA,GAAa,SAAW,EAAS,IAAI,AAAC,GAClC,EACI,EACA,EACA,EACA,EACA,KAKL,EAGX,YACI,EACA,EACA,EACA,EACA,EACA,EACA,EACK,CAGL,GAAM,GAAwB,GACxB,EAAsB,GAExB,EACE,EAAsB,GAAyB,IAAM,CACvD,EAAU,EACN,IACO,EACH,SAAU,GAEd,CACI,UAAW,AAAC,GAAoB,CAC5B,EAAU,KAAK,IAEnB,QAAS,AAAC,GAAkB,CACxB,EAAQ,KAAK,IAEjB,SAAU,CAAC,EAA4B,IAAuB,CAC1D,GAAM,GAAa,GACf,EACA,mBAAmB,EAAU,QAAQ,GAAa,OAEtD,EAAQ,KAAK,IAAM,CACf,GAAO,GACP,EAAe,EAAc,GAC7B,MAEJ,EAAU,KAAK,IAAM,CACjB,EAAkB,EAAc,GAChC,GAAQ,GACR,EAAW,aAGnB,WAAY,AAAO,GACX,EAAW,IAAI,GACR,EAAW,IAAI,GAEnB,GAAW,OAKlC,EAAU,KAAK,IAAM,CACjB,EAAoB,QAAQ,AAAC,GAAgB,CACzC,EAAY,cAIpB,GAAM,GAAa,EACf,EACA,EACA,EACA,EACA,GAUJ,MAPsB,CAClB,YACA,SAAU,CAAC,GACX,UACA,aAMR,YACI,EACA,EACA,EACA,EACA,EACK,CACL,GAAM,GAA4B,GAC5B,EAAmC,GACnC,EAAyB,CAC3B,YACA,SAAU,EACV,aAGE,EAA0B,GAGtB,kBAEV,EAAa,GAEb,GAAI,GAAW,GACT,EAAe,GAAO,IAAM,CAC9B,GAAM,GAAgB,IAChB,EAAmB,EACrB,EACA,EACA,EACA,EACA,GAEJ,AAAI,EAEA,GAAW,GACX,EAAwB,KAAK,IAG7B,GAAU,IAAM,CACZ,EACI,EACA,EACA,EAAwB,OACxB,CAAC,OAId,YAAY,GAAa,IAAgB,UAE5C,SAAe,EAAyB,GACxC,EAAe,EAAc,GAE7B,EAAU,KAAK,IAAM,CACjB,EAAkB,EAAyB,GAC3C,EAAkB,EAAc,GAChC,EAAa,UACb,GAAY,KAGhB,IAEO,EAGX,YACI,EACA,EACA,EACA,EACA,EACK,CACL,GAAM,GAA4B,GAG5B,EAAiB,CACnB,YACA,SAHoC,GAIpC,aAGE,EAAyB,GAGrB,kBAEV,EAAa,GACb,EAAe,EAAwB,GACvC,EAAU,KAAK,IAAM,CACjB,EAAkB,EAAwB,KAG9C,GAAU,IAAM,CACZ,EAAe,SAAS,KACpB,GAAG,EAAW,IAAI,AAAC,GACf,EACI,EACA,EACA,EACA,EACA,OAMhB,GAAM,GAAY,EAAW,IAAY,AAAC,GAAW,CACjD,EAAO,QAAQ,AAAC,GAAU,CACtB,GAAI,EAAM,OAAS,SACf,GAAU,IAAM,CACZ,GAAM,CAAE,QAAO,QAAO,SAAU,EAC1B,EAAa,EAAM,IAAI,AAAC,GAC1B,EACI,EACA,EACA,EACA,EACA,IAGR,EAAY,EAAgB,EAAO,EAAO,aAEvC,EAAM,OAAS,OAAQ,CAC9B,GAAM,CAAE,YAAW,YAAW,WAAY,EACpC,EAAQ,EACV,EACA,EACA,EACA,GACA,CAAE,aAAc,KAEpB,EACI,EACA,EAAY,EAAU,EAAU,EAAY,EAC5C,EACA,EACA,CAAE,WAAY,aAEX,EAAM,OAAS,OAAQ,CAC9B,GAAM,CAAE,WAAY,EACd,EAAgB,EAClB,EACA,EACA,EAAQ,OACR,GACA,CAAE,aAAc,KAEd,EAAe,EAAQ,IACzB,AAAC,GAAa,EAAc,IAEhC,EAAY,EAAgB,EAAG,EAAG,EAAc,CAC5C,WAAY,SAGhB,AAAI,GAAgB,EAAO,kCAKjC,EAAmB,EAAW,MACpC,SAAa,GACb,EAAe,EAAkB,GACjC,EAAU,KAAK,GACf,EAAU,KAAK,IAAM,CACjB,EAAkB,EAAkB,KAGjC,EAGX,YAA0B,EAAkC,CACxD,GAAM,GAA6B,CAC/B,MAAO,KACN,GAAU,gBAEf,MAAI,IAAW,EAAK,EAAc,GAC3B,EAMJ,YAAe,EAAwB,EAAkB,CAC5D,GAAM,GAAqC,GAAI,KAC/C,AACI,GAAc,eAAiB,IAC/B,EAAc,eAAiB,KAE/B,EAAW,IAAI,GAAqB,EAAc,cAEtD,GAAM,GAAe,GAAiB,SACtC,GAAO,GACP,GAAM,GAAoB,CAAE,QAAS,GAC/B,EAAmB,SAAS,yBAC5B,EAAW,EACb,EACA,EACA,EACA,EACA,GAEJ,SAAW,SAAW,CAAC,GAEvB,EAAc,YAAY,GAG1B,GAAY,GAEL,IAAM,CACT,EAAY,EAAY,EAAG,EAAW,UAAU,QAAU,EAAG,IAC7D,GAAQ,ICjxBhB,YAAqB,EAAQ,EAAQ,CACjC,GAAI,IAAM,QAAa,IAAM,OAAW,MAAO,GAC/C,GAAI,IAAM,OAAW,MAAO,GAC5B,GAAI,IAAM,OAAW,MAAO,GAC5B,GAAM,GAAO,GAAK,EACZ,EAAO,GAAK,EAClB,MAAI,GAAO,EAAa,GACpB,EAAO,EAAa,EACjB,EAMJ,YAAuB,EAAY,EAAmC,CACzE,GAAI,CAAC,MAAM,QAAQ,GACf,KAAM,IAAI,GAAe,wCAG7B,MAAO,IACH,EACA,aACA,CACI,IAAI,EAAQ,EAAQ,EAAK,CACrB,MAAO,GAAO,IAGlB,IAAI,EAAQ,EAAQ,EAAK,CACrB,MAAO,KAAO,IAGlB,IAAyB,EAAQ,EAAQ,EAAK,EAAO,CACjD,GACI,IAAQ,UACR,MAAO,IAAU,UACjB,EAAQ,EAAO,OAGf,YAAK,OAAO,EAAO,EAAO,OAAS,GAC5B,GAEX,GAAM,GAAa,OAAO,GAC1B,MAAI,CAAC,MAAM,IAAe,GAAc,EAAM,OAC1C,KAAK,OAAO,EAAY,EAAG,GAE3B,EAAO,GAAO,EAEX,IAGX,eAAe,EAAQ,EAAQ,EAAK,CAChC,aAAO,GAAO,GACP,KAGf,CAAC,CACG,SACA,mBACA,WACA,qBACA,wBACG,EACH,OAAQ,SACJ,EACA,KACG,EACA,CACH,GAAI,EAAQ,GAAK,EAAM,SAAW,EAAG,MAAO,GAC5C,GAAM,GAAa,EAAM,OACnB,EAAU,EAAM,OAAO,EAAO,EAAO,GAAG,GACxC,EAAY,EAAM,OAexB,GAdA,EAAO,CACH,KAAM,SACN,QACA,QACA,QACA,YASA,IAAe,EACf,OAAS,GAAI,EAAO,EAAI,EAAQ,EAAO,EAAE,EACrC,EAAmB,EAAE,gBAEtB,CACH,OACQ,GAAI,EACR,EAAI,KAAK,IAAI,EAAW,GACxB,EAAE,EACJ,CACE,GAAM,GAAM,EAAE,WACd,AAAI,GAAK,EAEL,EAAmB,GAGnB,EAAmB,GAG3B,EAAmB,UAEvB,MAAO,IAEX,IAAK,UAAiD,CAElD,MAAO,AADS,MAAK,OAAO,EAAM,OAAS,EAAG,GAC/B,IAEnB,MAAO,UAAmD,CAEtD,MAAO,AADS,MAAK,OAAO,EAAG,GAChB,IAEnB,KAAM,YAAsC,EAAoB,CAC5D,YAAK,OAAO,EAAM,OAAQ,EAAG,GAAG,GACzB,EAAM,QAEjB,QAAS,YAEF,EACG,CACN,YAAK,OAAO,EAAG,EAAG,GAAG,GACd,EAAM,QAEjB,OAAQ,SAEJ,EACF,CACE,GAAM,GAAe,GACrB,OAAS,GAAI,EAAM,OAAS,EAAG,GAAK,EAAG,EAAE,EACrC,AAAI,EAAK,KAAK,GAAI,IACd,EAAQ,KAAK,GAAG,KAAK,OAAO,EAAG,IAGvC,MAAO,IAEX,UAAW,SAEP,EACA,EACA,EACF,CAEE,GADI,GAAa,GACb,GAAW,GAAa,EAAU,EAAY,EAC9C,OACJ,GAAM,GAAQ,EAAM,OAAO,EAAW,GACtC,AAAI,EAAU,EACV,EAAM,OAAO,EAAS,EAAG,GAAG,GAE5B,EAAM,OAAO,EAAU,EAAW,EAAG,GAAG,GAE5C,EAAO,CACH,KAAM,OACN,YACA,YACA,UACA,WAGR,KAAM,SAEF,EAAiC,GAC9B,CACH,GAAM,GAAkC,EAAM,IAC1C,CAAC,EAAM,IAAU,CAAC,EAAM,IAE5B,SAAM,KAAK,GACX,EAAiB,KAAK,CAAC,EAAI,IAAO,EAAO,EAAG,GAAI,EAAG,KACnD,EAAO,CACH,KAAM,OACN,QAAS,EAAiB,IAAI,AAAC,GAAS,EAAK,MAE1C,MAEX,QAAS,SAEL,EAAiC,GAC9B,CACH,GAAI,EAAM,SAAW,EAAG,MAAO,MAC/B,EAAM,UAEN,GAAM,GAAoB,GAC1B,OAAS,GAAI,EAAM,OAAS,EAAG,GAAK,EAAG,EAAE,EACrC,EAAQ,KAAK,GAEjB,SAAO,CACH,KAAM,OACN,YAEG,MAEX,WACA,QAAS,SAEL,EACA,EACF,CACE,MAAO,IAAsB,KAAM,EAAQ,IAE/C,WAAY,SAER,EACA,EACF,CACE,MAAO,IAAyB,KAAM,EAAU,IAEpD,YAAa,SAET,EACA,EACF,CACE,MAAO,IAA0B,KAAM,EAAI,MAGnD,GAGR,GAAW,QAAU,SAAiB,EAAoB,CACtD,EAAE,MAGN,YACI,EACA,EACA,EACO,CAEP,MAAO,IACH,EACA,AAAC,GAAS,CAAC,EAAO,IAClB,GAIR,YACI,EACA,EACA,EACO,CAEP,MAAO,IACH,EACA,AAAC,GAAU,EAAS,GAAQ,CAAC,GAAQ,GACrC,GAIR,YACI,EACA,EACA,EACO,CACP,GAAM,GAAyB,GAE/B,MAAO,GAAiB,SACpB,CACI,WAAY,AAAC,GAAU,CACnB,GAAM,GAAoB,GAC1B,SAAM,QAAQ,AAAC,GAAU,CACrB,GAAM,GAAQ,EAAG,GACjB,EAAa,KAAK,GAAG,GACrB,EAAa,KAAK,EAAM,UAErB,GAEX,aAAc,CAAC,EAAM,EAAO,IAAa,CACrC,GAAI,EAAM,OAAS,SAAU,CACzB,GAAM,CAAE,QAAO,QAAO,SAAU,EAC5B,EAAY,EAChB,OAAS,GAAI,EAAG,EAAI,EAAO,EAAE,EACzB,GAAa,EAAa,GAE9B,GAAI,GAAY,EAChB,OAAS,GAAI,EAAO,EAAI,EAAQ,EAAO,EAAE,EACrC,GAAa,EAAa,GAG9B,GAAM,GAAiB,GACjB,EAA0B,GAChC,EAAM,QAAQ,AAAC,GAAc,CACzB,GAAM,GAAQ,EAAG,GACjB,EAAU,KAAK,GAAG,GAClB,EAAc,KAAK,EAAM,UAE7B,EAAK,OAAO,EAAW,EAAW,GAAG,GACrC,EAAa,OAAO,EAAO,EAAO,GAAG,WAC9B,EAAM,OAAS,OAAQ,CAC9B,GAAM,CAAE,YAAW,YAAW,WAAY,EACtC,EAAgB,EACpB,OAAS,GAAI,EAAW,EAAI,EAAY,EAAW,EAAE,EACjD,GAAiB,EAAa,GAGlC,GAAI,EAAgB,EAAG,CACnB,GAAI,GAAgB,EAChB,EAAc,EAEZ,EAAY,KAAK,IAAI,EAAW,GAClC,EAAQ,EACZ,OAAS,GAAI,EAAG,GAAK,EAAW,EAAE,EAC9B,AAAI,IAAM,GAAW,GAAgB,GACjC,IAAM,GAAS,GAAc,GACjC,GAAS,EAAa,GAE1B,EAAK,UACD,EACA,EACA,GAGR,EAAa,OACT,EACA,EACA,GAAG,EAAa,OAAO,EAAW,YAE/B,EAAM,OAAS,OAAQ,CAC9B,GAAM,CAAE,WAAY,EAEd,EAA2B,GAC7B,EAAmB,EACvB,OAAS,GAAI,EAAG,EAAI,EAAa,OAAQ,EAAE,EACvC,EAAe,KAAK,GACpB,GAAoB,EAAa,GAGrC,GAAM,GAAe,EAAS,QACxB,EAAuB,GACzB,EAAY,EAChB,EAAQ,QAAQ,AAAC,GAAgB,CAC7B,GAAM,GAAY,EAAa,GAC/B,GAAI,IAAc,EAAG,OACrB,GAAM,GAAY,EAAe,GACjC,OAAS,GAAI,EAAG,EAAI,EAAW,EAAE,EAC7B,EAAW,KAAK,EAAY,GAC5B,EAAS,GAAa,EAAa,EAAY,GAC/C,GAAa,IAIrB,EAAK,IAAW,CACZ,KAAM,OACN,QAAS,QAGb,AAAI,GACA,EACA,qCAKhB,GCrTD,YAMH,EACA,EACA,EACA,EAWA,EACoD,CAGpD,GAAM,GAA0D,GAAI,KAEhE,EAA8C,GAAI,KAClD,EAAwB,GACxB,EAAa,GAEb,EAAgC,GAE9B,EAAiC,CACnC,MAAO,KACN,GAAU,gBACV,IAAW,EACZ,KAAM,MAEV,EAAK,EAAkB,GAAG,GAAa,WAEvC,YAA6B,CACzB,AAAI,EAAO,CAAC,EAAY,yBACxB,GAAI,GAAY,GACV,EAAY,EAClB,SAAqB,GAAI,KACzB,EAAU,QAAQ,CAAC,EAAQ,IAAa,CACpC,EAAY,GACZ,EAAS,KAEN,EAGX,YAAiB,CACb,AAAI,EAAO,CAAC,EAAY,yBACxB,GAAM,GAAY,EACd,EAAY,GAChB,SAAgB,GAChB,EAAU,QAAQ,AAAC,GAAS,CACxB,EAAY,GACZ,MAEG,EAGX,WAAyB,EAAkB,CACvC,AAAI,EAAO,CAAC,EAAY,yBACxB,EAAc,KAAK,GACnB,EAAU,GAGd,WAAgB,EAAe,CAC3B,AAAI,EAAO,CAAC,EAAY,yBACpB,EAAU,OAAS,GACnB,GAAU,QAAQ,AAAC,GAAa,CAC5B,GAAI,GAAiB,EAAmB,IAAI,GAC5C,AAAK,GACD,GAAiB,GACjB,EAAmB,IAAI,EAAU,IAErC,EAAe,KAAK,KAExB,EAAU,IAIlB,YAA+B,CAC3B,MAAI,GAAO,CAAC,EAAY,yBACjB,EAGX,WAAiB,EAAsC,CACnD,MAAI,GAAO,CAAC,EAAY,yBACpB,EAAU,SAAW,GACrB,GAAa,GACb,EAAa,GACb,GAAa,EAAO,GACpB,EAAa,QAAQ,AAAC,GAAU,CAC5B,EAAe,EAAO,MAG9B,EAAU,KAAK,GACR,IAAM,CACT,EAAY,EAAU,OAAO,AAAC,GAAQ,IAAQ,GAC1C,EAAU,SAAW,GACrB,IAAgB,EAAO,GACvB,EAAa,QAAQ,AAAC,GAAU,CAC5B,EAAkB,EAAO,OAMzC,WACI,EACA,EACF,CACE,AAAI,EAAO,CAAC,EAAY,yBACxB,GAAM,GAAiB,GAAU,IAAM,EAAK,WAAW,IACjD,EAAO,GAAW,EAAW,GACnC,SAAQ,AAAC,IAAqB,CAC1B,EAAK,IAAoB,IAAM,CAC3B,GAAO,QAAQ,AAAC,IAAU,CACtB,EAAK,aAAa,EAAM,GAAO,SAI3C,GAAa,EAAkB,GACxB,EAGX,WAA4B,EAAsB,CAC9C,AAAI,EAAO,CAAC,EAAY,yBACxB,GAAM,GAAQ,EAAS,GACvB,EAAU,GAGd,YAA4B,EAAsB,CAC9C,AAAI,EAAO,CAAC,EAAY,yBACxB,GAAM,GAAQ,EAAS,GACvB,EAAU,GAGd,aAAmB,CACf,AAAI,EAAO,CAAC,EAAY,yBAExB,EAAa,QAAQ,AAAC,GAAU,CAC5B,EAAkB,EAAO,GACrB,EAAU,OAAS,GACnB,EAAkB,EAAO,GAE7B,GAAY,KAEhB,EAAa,QACb,GAAY,GACZ,GAAY,GAEZ,EAAU,OAAO,EAAG,EAAU,QAC9B,EAAmB,QACnB,EAAc,OAAO,EAAG,EAAc,QAEtC,KAAY,KAAK,IAAM,CACnB,GAAe,WAEnB,EAAa,GAGjB,GAAM,IAAkB,CACpB,MAAO,KACN,GAAU,QACV,IAAc,GACd,IAAW,GACX,IAAqB,GACrB,IAAa,GACb,IAAY,GACZ,IAAyB,GACzB,GAAa,MACX,EAAY,CACX,UACA,SACA,WACA,mBACA,qBACA,yBAIR,WAAkB,EAA2C,CACzD,GAAI,GAAQ,EAAa,IAAI,GAC7B,MAAK,IACD,GAAQ,CACJ,MAAO,EACP,MACA,MAAO,KAEP,GAAW,EAAK,EAAO,GAC3B,EAAa,IAAI,EAAK,GACtB,EAAa,GACb,EAAe,EAAO,GAClB,EAAU,OAAS,GACnB,EAAe,EAAO,IAGvB,EAGX,GAAM,IAAiB,MAAM,UAAU,EAAc,CACjD,IAAI,EAAa,EAAsB,CACnC,GAAI,IAAO,IACP,MAAQ,IAAwB,GAEpC,GAAM,GAAQ,EAAS,GACvB,UAA2B,GACpB,EAAS,IAAI,KAAK,EAAO,EAAQ,EAAQ,IAGpD,IAAI,EAAa,EAAsB,CACnC,GAAI,IAAO,IACP,MAAO,GAEX,GAAM,GAAQ,EAAS,GACvB,UAA2B,GACpB,EAAS,IAAI,KAAK,EAAO,EAAQ,EAAQ,IAGpD,IAAI,EAAa,EAAsB,EAAY,CAC/C,GAAI,IAAO,IACP,MAAI,GAAM,cAAc,OAAO,mBAAsB,GAC9C,GAEX,GAAM,GAAU,EAAS,IAAI,KACzB,EACA,EACA,EACA,EACA,GAEJ,GAAI,EAAS,CACT,GAAM,IAAQ,EAAS,GACvB,EAAU,IAEd,MAAO,IAGX,eAAe,EAAa,EAAsB,CAC9C,GAAI,IAAO,IACP,MAAI,GAAM,YAAY,OAAO,mBAAsB,GAC5C,GAEX,GAAM,GAAU,EAAS,eAAe,KACpC,EACA,EACA,EACA,GAEJ,GAAI,EAAS,CACT,GAAM,GAAQ,EAAS,GACvB,EAAU,GAEd,MAAO,MAGT,EACF,GAAe,MAEnB,SAAiB,KAAO,EAEpB,GAAW,EAAK,EAAO,GAC3B,EAAa,GAEN,EC/TJ,YAA6B,EAAQ,EAA8B,CACtE,GAAI,MAAO,IAAQ,UAAY,CAAC,EAC5B,KAAM,IAAI,GAAe,oCAG7B,GAAM,GAA6C,GAAI,KACnD,OAAO,KAAK,IAGhB,MAAO,IACH,EACA,QACA,CACI,IAAK,CAAC,EAAS,EAAQ,IACZ,EAAO,GAElB,IAAK,CAAC,EAAQ,EAAQ,IACX,EAAY,IAAI,GAE3B,IAAK,CAAC,EAAQ,EAAQ,EAAK,IAAU,CACjC,GAAM,GAAU,CAAC,EAAY,IAAI,IAAQ,EAAO,KAAS,EACzD,SAAO,GAAO,EACV,GACK,GAAY,IAAI,IACjB,GAAY,IAAI,GAChB,EAAO,CAAE,KAAM,MAAO,SAE1B,EAAO,CAAE,KAAM,MAAO,MAAK,WAExB,IAEX,eAAgB,CAAC,EAAQ,EAAQ,IAAQ,CACrC,GAAM,GAAU,EAAY,IAAI,GAChC,aAAO,GAAO,GACV,GACA,GAAY,OAAO,GACnB,EAAO,CAAE,KAAM,SAAU,SAEtB,KAGf,CAAC,CAAE,WAAU,SAAQ,UAAS,sBACnB,GACF,IAAmB,IAG5B,GAGR,GAAM,KAAO,SACT,EACA,EACY,CACZ,GAAM,GAAU,GAAI,KAkCpB,MAhCa,GAAO,IAChB,CACI,WAAY,AAAC,GAAQ,CACjB,GAAM,GAAO,OAAO,KAAK,GACzB,SAAK,QAAQ,AAAC,GAAQ,EAAQ,IAAI,IAC3B,GAEX,aAAc,CAAC,EAAW,IAAU,CAChC,GAAI,EAAM,OAAS,MAAO,CACtB,GAAM,CAAE,OAAQ,EAChB,GAAI,MAAO,IAAQ,UAAY,MAAO,IAAQ,SAAU,CACpD,GAAM,GAAY,EAAI,WACtB,AAAK,EAAQ,IAAI,IACb,GAAQ,IAAI,GACZ,EAAU,KAAK,aAGhB,EAAM,OAAS,SAAU,CAChC,GAAM,CAAE,OAAQ,EAChB,GAAI,MAAO,IAAQ,UAAY,MAAO,IAAQ,SAAU,CACpD,GAAM,GAAY,EAAI,WACtB,AAAI,EAAQ,IAAI,IACZ,GAAQ,OAAO,GACf,EAAU,OAAO,AAAC,GAAM,IAAM,QAMlD,IAKR,GAAM,QAAU,SAAiB,EAAe,CAC5C,EAAE,MZpEN,GAAO,IAAQ,GAEF,GACyB",
  "names": []
}
