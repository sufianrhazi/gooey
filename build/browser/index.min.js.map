{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/types.ts", "../../src/log.ts", "../../src/util.ts", "../../src/dag.ts", "../../src/debug.ts", "../../src/calc.ts", "../../src/jsx.ts", "../../src/vnode.ts", "../../src/view.ts", "../../src/collection.ts", "../../src/trackeddata.ts", "../../src/model.ts"],
  "sourcesContent": ["export { getLogLevel, setLogLevel } from './log';\nexport type { LogLevel } from './log';\nimport { createElement } from './view';\nexport { Fragment, mount } from './view';\nexport type { Component } from './jsx';\nexport { model } from './model';\nexport { collection } from './collection';\nexport {\n    calc,\n    effect,\n    reset,\n    subscribe,\n    flush,\n    nextFlush,\n    retain,\n    release,\n    debug,\n    debugSubscribe,\n} from './calc';\n\nexport type {\n    Ref,\n    Calculation,\n    Collection,\n    View,\n    Model,\n    Context,\n} from './types';\nexport { ref, createContext, InvariantError } from './types';\n\nexport default createElement;\n\nexport const VERSION = LIB_VERSION;\n", "export class InvariantError extends Error {\n    detail?: any;\n    constructor(msg: string, detail?: any) {\n        super(msg);\n        this.detail = detail;\n    }\n}\n\nexport const TypeTag = Symbol('reviseType');\nexport const DataTypeTag = Symbol('dataTypeTag');\nconst CalculationTypeTag = Symbol('calculationType');\nexport const RecalculationTag = Symbol('recalculate');\n\nexport const ObserveKey = Symbol('observe');\nexport const GetSubscriptionNodeKey = Symbol('getSubscriptionNode');\nexport const MakeModelViewKey = Symbol('makeModelView');\nexport const FlushKey = Symbol('flush');\nexport const AddDeferredWorkKey = Symbol('addDeferredWork');\nexport const NotifyKey = Symbol('notify');\n\n/**\n * A ref object that can be passed to native elements.\n */\nexport type Ref<T> = {\n    [TypeTag]: 'ref';\n    current: T | undefined;\n};\nexport function isRef(ref: any): ref is Ref<unknown> {\n    return ref && ref[TypeTag] === 'ref';\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val?: T): Ref<T> {\n    return {\n        [TypeTag]: 'ref',\n        current: val,\n    };\n}\n\nexport type ModelEvent =\n    | {\n          type: 'add';\n          key: string | number | symbol;\n      }\n    | {\n          type: 'set';\n          key: string | number | symbol;\n          value: any;\n      }\n    | {\n          type: 'delete';\n          key: string | number | symbol;\n      };\nexport type ModelObserver = (event: ModelEvent) => void;\n\nexport type EqualityFunc<T> = (a: T, b: T) => boolean;\nexport type MappingFunction<T, V> = (item: T) => V;\nexport type FilterFunction<T> = (item: T) => boolean;\nexport type FlatMapFunction<T, V> = (item: T) => V[];\n\nexport interface ViewSpec<TInitialize, TItem, TEvent> {\n    /**\n     * Return initial items\n     */\n    initialize: (items: TInitialize) => TItem[];\n\n    /**\n     * Process subscription events\n     */\n    processEvent: (\n        view: Collection<TItem>,\n        event: TEvent,\n        initialValue: TItem[]\n    ) => void;\n}\n\nexport type CollectionEvent<T> =\n    | {\n          type: 'splice';\n          index: number;\n          count: number;\n          items: readonly T[];\n          removed: readonly T[];\n      }\n    | {\n          type: 'move';\n          fromIndex: number;\n          fromCount: number;\n          toIndex: number;\n          moved: readonly T[];\n      }\n    | {\n          type: 'sort';\n          indexes: readonly number[];\n      };\n\nexport type TrackedData<TImplementation, TTypeTag, TEvent> = TImplementation & {\n    [TypeTag]: 'data';\n    [DataTypeTag]: TTypeTag;\n    [FlushKey]: () => void;\n    [AddDeferredWorkKey]: (task: () => void) => void;\n    [ObserveKey]: (\n        listener: (events: TEvent[], subscriptionNode: Subscription) => void\n    ) => () => void;\n    [GetSubscriptionNodeKey]: () => Subscription;\n    [NotifyKey]: (event: TEvent) => void;\n};\n\n/**\n * A mutable object to hold state\n */\nexport type Model<T> = TrackedData<T, 'model', ModelEvent> & {\n    [MakeModelViewKey]: <V>(\n        modelViewSpec: ViewSpec<Readonly<T>, V, ModelEvent>,\n        debugName?: string\n    ) => View<V>;\n};\n\n/**\n * A mutable array to hold state, with some additional convenience methods\n */\nexport type Collection<T> = TrackedData<\n    Array<T>,\n    'collection',\n    CollectionEvent<T>\n> & {\n    makeView<V>(\n        viewSpec: ViewSpec<readonly T[], V, CollectionEvent<T>>,\n        debugName?: string\n    ): View<V>;\n    mapView<V>(mapFn: MappingFunction<T, V>, debugName?: string): View<V>;\n    filterView(filterFn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(\n        flatMapFn: MappingFunction<T, V[]>,\n        debugName?: string\n    ): View<V>;\n    reject(shouldReject: (item: T, index: number) => boolean): void;\n    moveSlice(fromIndex: number, fromCount: number, toIndex: number): void;\n};\n\n/**\n * A readonly array to hold projected state\n */\nexport type View<T> = TrackedData<\n    ReadonlyArray<T>,\n    'collection',\n    CollectionEvent<T>\n> & {\n    makeView<V>(\n        viewSpec: ViewSpec<readonly T[], V, CollectionEvent<T>>,\n        debugName?: string\n    ): View<V>;\n    mapView<V>(mapFn: MappingFunction<T, V>, debugName?: string): View<V>;\n    filterView(filterFn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(\n        flatMapFn: MappingFunction<T, V[]>,\n        debugName?: string\n    ): View<V>;\n};\n\nexport interface Subscription {\n    [TypeTag]: 'subscription';\n    item: any;\n    [FlushKey]: () => void;\n}\n\nexport interface NodeOrdering {\n    [TypeTag]: 'nodeOrdering';\n}\n\n/**\n * A key-value pair that is active for a subtree\n */\nexport interface Context<TValue> {\n    /**\n     * Note: although this function has a signature, it does not actually take arguments when called directly.\n     *\n     * This is solely present so that TypeScript can auto-complete the \"value\" prop of Contexts\n     */\n    (unusedOnlyForJsxTypeInferrence?: { value: TValue }): TValue;\n    [TypeTag]: 'context';\n}\n\nexport function createContext<TValue>(val: TValue): Context<TValue> {\n    return Object.assign(() => val, {\n        [TypeTag]: 'context' as const,\n    });\n}\n\nexport function isContext(val: any): val is Context<any> {\n    return !!(val && val[TypeTag] === 'context');\n}\n\n/**\n * A calculation cell that recalculates when dependencies change\n */\nexport type Calculation<Result> = (() => Result) & {\n    [TypeTag]: 'calculation';\n    [CalculationTypeTag]: 'calculation' | 'effect';\n    [RecalculationTag]: () => boolean;\n};\n\nexport interface ModelField {\n    model: {\n        [DataTypeTag]: any;\n    };\n    key: string | number | symbol;\n}\n\nexport function makeCalculation<Ret>(\n    fn: () => Ret,\n    recalcFn: () => boolean\n): Calculation<Ret> {\n    return Object.assign(fn, {\n        [TypeTag]: 'calculation' as const,\n        [CalculationTypeTag]: 'calculation' as const,\n        [RecalculationTag]: recalcFn,\n    });\n}\n\nexport function makeEffect(\n    fn: () => void,\n    recalcFn: () => boolean\n): Calculation<void> {\n    return Object.assign(fn, {\n        [TypeTag]: 'calculation' as const,\n        [CalculationTypeTag]: 'effect' as const,\n        [RecalculationTag]: recalcFn,\n    });\n}\n\nexport function isModel(thing: any): thing is Model<unknown> {\n    return !!(\n        thing &&\n        thing[TypeTag] === 'data' &&\n        thing[DataTypeTag] === 'model'\n    );\n}\n\nexport function isModelField(thing: any): thing is ModelField {\n    return !!(\n        thing &&\n        !thing[TypeTag] &&\n        !!thing.model &&\n        !!thing.model[DataTypeTag]\n    );\n}\n\nexport function isCollection(thing: any): thing is Collection<any> | View<any> {\n    return !!(\n        thing &&\n        thing[TypeTag] === 'data' &&\n        thing[DataTypeTag] === 'collection'\n    );\n}\n\nexport function isCalculation(thing: any): thing is Calculation<any> {\n    return !!(thing && thing[TypeTag] === 'calculation');\n}\n\nexport function isEffect(thing: Calculation<unknown>): boolean {\n    return thing[CalculationTypeTag] === 'effect';\n}\n\nexport function isSubscription(thing: any): thing is Subscription {\n    return !!(thing && thing[TypeTag] === 'subscription');\n}\n\nexport function isNodeOrdering(thing: any): thing is NodeOrdering {\n    return !!(thing && thing[TypeTag] === 'nodeOrdering');\n}\n\nexport type DAGNode =\n    | Model<any>\n    | Collection<any>\n    | Calculation<any>\n    | ModelField\n    | View<any>\n    | Subscription\n    | NodeOrdering;\n", "import { InvariantError } from './types';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function getLogLevel(): LogLevel {\n    if (currentLevel >= levels.info) return 'info';\n    if (currentLevel >= levels.warn) return 'warn';\n    if (currentLevel >= levels.debug) return 'debug';\n    return 'error';\n}\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function assert(check: any, msg: string): asserts check {\n    if (!check) {\n        error(\n            'Assertion failure',\n            check === undefined\n                ? 'undefined'\n                : check === null\n                ? 'null'\n                : check.toString(),\n            'is not truthy',\n            msg\n        );\n        throw new InvariantError(`Assertion failure: ${msg}`);\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new InvariantError('Assertion failure', { context, items });\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy<TItem, TKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TKey, TVal]\n): Map<TKey, TVal[]> {\n    const grouped: Map<TKey, TVal[]> = new Map();\n    items.forEach((item) => {\n        const [key, val] = grouper(item);\n        let inner = grouped.get(key);\n        if (!inner) {\n            inner = [];\n            grouped.set(key, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function strictEqual<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low)) + low;\n}\n", "import * as log from './log';\nimport { groupBy } from './util';\n\n/**\n * A directed acyclic graph\n *\n * Edges may me marked as DAG.EDGE_SOFT (visualized as ->) or DAG.EDGE_HARD (visualized as =>):\n * - An EDGE_SOFT edge from A to B indicate an order dependency, but not a data dependency\n *   - If A and B are both dirty, A should be flushed **after** B is flushed\n *   - If A is not dirty and B is dirty and B is visited and B does not short-circuit, A does not get marked as dirty\n *   - Used to ensure that the DOM structure is updated in the correct order\n *     - onEffect() effects are executed after all of the calc() present in a component's DOM\n *     - \"parent\" calc() view nodes are executed after \"child\" calc() view nodes\n * - An EDGE_HARD edge from A to B indicates both order dependency and data dependency\n *   - If A and B are both dirty, A should be flushed **after** B is flushed\n *   - If A is not dirty and B is dirty and B is visited and B does not short-circuit, A gets marked as dirty and is visited\n */\nexport class DAG<Type extends object> {\n    private static EDGE_NONE = 0b00 as const;\n    static EDGE_SOFT = 0b01 as const;\n    static EDGE_HARD = 0b10 as const;\n    private static EDGE_ANY = 0b11 as const;\n\n    private nextId: number;\n    private idMap: WeakMap<Type, string>;\n    private nodesSet: Record<string, Type>;\n    private retained: Record<string, true>;\n    private dirtyNodes: Record<string, true>;\n\n    private graph: Record<string, Record<string, number>>;\n    private reverseGraph: Record<string, Record<string, number>>;\n\n    constructor() {\n        this.nextId = 1;\n        this.idMap = new WeakMap();\n        this.nodesSet = {};\n        this.retained = {};\n        this.graph = {};\n        this.reverseGraph = {};\n        this.dirtyNodes = {};\n    }\n\n    private getId(node: Type): string {\n        let id = this.idMap.get(node);\n        if (id === undefined) {\n            id = this.nextId.toString();\n            this.nextId += 1;\n            this.idMap.set(node, id);\n        }\n        return id;\n    }\n\n    addNode(node: Type): boolean {\n        const nodeId = this.getId(node);\n        if (this.nodesSet[nodeId]) return false;\n        this.graph[nodeId] = {};\n        this.reverseGraph[nodeId] = {};\n        this.nodesSet[nodeId] = node;\n        return true;\n    }\n\n    hasNode(node: Type): boolean {\n        return !!this.nodesSet[this.getId(node)];\n    }\n\n    markNodeDirty(node: Type): boolean {\n        const nodeId = this.getId(node);\n        if (this.dirtyNodes[nodeId]) return false;\n        this.dirtyNodes[nodeId] = true;\n        return true;\n    }\n\n    /**\n     * Indicate that toNode needs to be updated if fromNode has changed\n     */\n    addEdge(fromNode: Type, toNode: Type, kind: 0b01 | 0b10): void {\n        const fromId = this.getId(fromNode);\n        const toId = this.getId(toNode);\n        log.assert(\n            !!this.nodesSet[fromId],\n            'cannot add edge from node that does not exist'\n        );\n        log.assert(\n            !!this.nodesSet[toId],\n            'cannot add edge to node that does not exist'\n        );\n        this.graph[fromId][toId] = (this.graph[fromId][toId] || 0) | kind;\n        this.reverseGraph[toId][fromId] =\n            (this.reverseGraph[toId][fromId] || 0) | kind;\n    }\n\n    /**\n     * Returns true if edge is removed\n     */\n    removeEdge(\n        fromNode: Type,\n        toNode: Type,\n        kind: 0b01 | 0b10 | 0b11\n    ): boolean {\n        const fromId = this.getId(fromNode);\n        const toId = this.getId(toNode);\n        if (!this.nodesSet[fromId]) return false;\n        if (!this.nodesSet[toId]) return false;\n        if (!(this.graph[fromId][toId] & kind)) return false;\n        this.graph[fromId][toId] = (this.graph[fromId][toId] || 0) & ~kind;\n        this.reverseGraph[toId][fromId] =\n            (this.reverseGraph[toId][fromId] || 0) & ~kind;\n        return true;\n    }\n\n    private removeNodeInner(nodeId: string) {\n        log.assert(\n            !this.retained[nodeId],\n            'attempted to remove a retained node'\n        ); // Is this right?\n        const toIds = this.getDependenciesInner(nodeId);\n        const fromIds = this.getReverseDependenciesInner(nodeId);\n\n        // delete fromId -> nodeId for fromId in fromIds\n        fromIds.forEach((fromId) => {\n            this.graph[fromId][nodeId] = 0;\n            this.reverseGraph[nodeId][fromId] = 0;\n        });\n        // delete nodeId -> toId for toId in toIds\n        toIds.forEach((toId) => {\n            this.reverseGraph[toId][nodeId] = 0;\n            this.graph[nodeId][toId] = 0;\n        });\n        delete this.nodesSet[nodeId];\n        delete this.dirtyNodes[nodeId];\n        delete this.retained[nodeId];\n    }\n\n    /**\n     * Remove a node and all its edges from the graph, returns true if node not present\n     */\n    removeNode(node: Type): boolean {\n        const nodeId = this.getId(node);\n        if (!this.nodesSet[nodeId]) return true;\n        this.removeNodeInner(nodeId);\n        return false;\n    }\n\n    retain(node: Type) {\n        const nodeId = this.getId(node);\n        log.assert(!this.retained[nodeId], 'double-retain');\n        this.retained[nodeId] = true;\n    }\n\n    release(node: Type) {\n        const nodeId = this.getId(node);\n        log.assert(this.retained[nodeId], 'double-release');\n        delete this.retained[nodeId];\n    }\n\n    removeIncoming(node: Type) {\n        const nodeId = this.getId(node);\n\n        const fromIds = this.getReverseDependenciesInner(nodeId);\n        fromIds.forEach((fromId) => {\n            if (this.reverseGraph[nodeId][fromId] & DAG.EDGE_HARD) {\n                this.graph[fromId][nodeId] =\n                    (this.graph[fromId][nodeId] || 0) & ~DAG.EDGE_HARD;\n                this.reverseGraph[nodeId][fromId] =\n                    (this.reverseGraph[nodeId][fromId] || 0) & ~DAG.EDGE_HARD;\n            }\n        });\n    }\n\n    /**\n     * Get dependencies (specify EDGE_SOFT, EDGE_HARD, or EDGE_ANY)\n     */\n    private getDependenciesInner(\n        nodeId: string,\n        edgeType: 0b01 | 0b10 | 0b11 = DAG.EDGE_ANY\n    ): string[] {\n        if (!this.graph[nodeId]) return [];\n        return Object.keys(this.graph[nodeId]).filter(\n            (toId) => (this.graph[nodeId][toId] || 0) & edgeType\n        );\n    }\n\n    /**\n     * Get reverse dependencies (either EDGE_SOFT or EDGE_HARD)\n     */\n    private getReverseDependenciesInner(nodeId: string): string[] {\n        if (!this.reverseGraph[nodeId]) return [];\n        return Object.keys(this.reverseGraph[nodeId]).filter(\n            (fromId) => !!this.reverseGraph[nodeId][fromId]\n        );\n    }\n\n    /**\n     * Get list of things need to be updated, when fromNode has changed?\n     */\n    getDependencies(\n        fromNode: Type,\n        edgeType: 0b01 | 0b10 | 0b11 = DAG.EDGE_ANY\n    ): Type[] {\n        const nodeId = this.getId(fromNode);\n        return this.getDependenciesInner(nodeId, edgeType).map(\n            (toId) => this.nodesSet[toId]\n        );\n    }\n\n    /**\n     * Process the DAG, visiting dirty nodes topologically that have a data dependency on a retained node.\n     *\n     * When building topologically sorted list, refcount dirtiness (the number of incoming edges that are from dirty\n     * nodes).\n     *\n     * If a recalculation produces the same value, decrement the refcount on all destination edges.\n     *\n     * If a node while visiting topologically is at 0, no need to recalculate; decrement all of its destination nodes\n     * and proceed.\n     *\n     * This way we can prevent recalculations that are triggered if the calculation is \"equal\".\n     *\n     */\n    process(callback: (node: Type) => boolean) {\n        // Build topologically sorted list via DFS discoverable only from dirty nodes.\n        // After visiting all nodes, the list is in reverse topological order\n        const visited: Record<string, boolean> = {};\n        const reachesRetained: Record<string, boolean> = {};\n        const sortedIds: string[] = [];\n        const strayIds: string[] = [];\n        const dfsRecurse = (nodeId: string): boolean => {\n            if (visited[nodeId]) return reachesRetained[nodeId];\n            visited[nodeId] = true;\n            reachesRetained[nodeId] = this.retained[nodeId];\n            const toIds = this.getDependenciesInner(nodeId);\n            let anyDependenciesRetained = false;\n            toIds.forEach((toId) => {\n                if (dfsRecurse(toId)) {\n                    anyDependenciesRetained = true;\n                }\n            });\n            if (anyDependenciesRetained) reachesRetained[nodeId] = true;\n            sortedIds.push(nodeId);\n            if (!reachesRetained[nodeId]) {\n                strayIds.push(nodeId);\n                return false;\n            } else {\n                return true;\n            }\n        };\n        Object.keys(this.dirtyNodes).forEach((nodeId) => {\n            dfsRecurse(nodeId);\n        });\n\n        // Visit the dirty nodes in topological order, skipping nodes that are not retained\n        // If a node is not dirty, skip it.\n        // If a node is dirty and the visitor returns true, the node is considered \"not dirty\" and processing continues\n        // If a node is dirty and the visitor returns false, the node is considered \"dirty\" and all adjacent destination nodes are marked as dirty.\n        for (let i = sortedIds.length - 1; i >= 0; --i) {\n            const nodeId = sortedIds[i];\n            if (this.dirtyNodes[nodeId] && reachesRetained[nodeId]) {\n                const node = this.nodesSet[nodeId];\n                const isEqual = callback(node);\n                if (!isEqual) {\n                    const toIds = this.getDependenciesInner(nodeId);\n                    toIds.forEach((toId) => {\n                        if (this.graph[nodeId][toId] & DAG.EDGE_HARD) {\n                            this.dirtyNodes[toId] = true;\n                        }\n                    });\n                }\n                delete this.dirtyNodes[nodeId];\n            }\n        }\n\n        // Garbage collect all the detected stray nodes\n        // TODO: this doesn't need to happen each time...\n        strayIds.forEach((nodeId) => {\n            this.removeNodeInner(nodeId);\n        });\n    }\n\n    /**\n     * Generate a dot file structure of the graph\n     */\n    graphviz(\n        getAttributes: (\n            label: string,\n            item: Type\n        ) => { label: string; subgraph: object | undefined; penwidth: string }\n    ) {\n        const lines = [\n            'digraph dag {',\n            //'graph [rankdir=\"LR\"];',\n            'node [style=\"filled\", fillcolor=\"#DDDDDD\"];',\n        ];\n\n        const nodeIds = Object.keys(this.nodesSet).filter(\n            (nodeId) => !!this.nodesSet[nodeId]\n        );\n        const nodeAttributes: Record<\n            string,\n            { label: string; subgraph: object | undefined; penwidth: string }\n        > = {};\n        nodeIds.forEach((nodeId) => {\n            nodeAttributes[nodeId] = getAttributes(\n                nodeId,\n                this.nodesSet[nodeId]\n            );\n        });\n        const groupedNodes = groupBy(nodeIds, (nodeId) => {\n            return [nodeAttributes[nodeId].subgraph, nodeId];\n        });\n\n        let clusterId = 0;\n        groupedNodes.forEach((nodeIds, group) => {\n            if (group)\n                lines.push(\n                    `subgraph cluster_${clusterId++} {`,\n                    'style=\"filled\";',\n                    'color=\"#AAAAAA\";'\n                );\n            nodeIds.forEach((nodeId) => {\n                const props: Record<string, string> = {\n                    shape: this.retained[nodeId] ? 'box' : 'ellipse',\n                    label: nodeAttributes[nodeId].label,\n                    penwidth: nodeAttributes[nodeId].penwidth,\n                    fillcolor: this.dirtyNodes[nodeId] ? '#FFDDDD' : '#DDDDDD',\n                };\n                lines.push(\n                    `  item_${nodeId} [${Object.entries(props)\n                        .map(\n                            ([key, value]) => `${key}=${JSON.stringify(value)}`\n                        )\n                        .join(',')}];`\n                );\n            });\n            if (group) lines.push('}');\n        });\n\n        nodeIds.forEach((fromId) => {\n            this.getDependenciesInner(fromId).forEach((toId) => {\n                if (this.graph[fromId][toId] & DAG.EDGE_HARD) {\n                    lines.push(\n                        `  item_${fromId} -> item_${toId} [style=\"solid\"];`\n                    );\n                }\n                if (this.graph[fromId][toId] & DAG.EDGE_SOFT) {\n                    lines.push(\n                        `  item_${fromId} -> item_${toId} [style=\"dashed\"];`\n                    );\n                }\n            });\n        });\n\n        lines.push('}');\n\n        return lines.join('\\n');\n    }\n}\n", "import {\n    DAGNode,\n    isCalculation,\n    isCollection,\n    isEffect,\n    isModel,\n    isSubscription,\n    isNodeOrdering,\n} from './types';\n\nlet nameMap: WeakMap<any, string> = new WeakMap();\n\nexport function clearNames() {\n    nameMap = new WeakMap();\n}\n\nexport function debugNameFor(item: DAGNode): string {\n    if (!DEBUG) {\n        return '';\n    }\n    if (isCollection(item)) {\n        return `collection:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isCalculation(item)) {\n        return `${isEffect(item) ? 'effect' : 'calc'}:${\n            nameMap.get(item) ?? '?'\n        }`;\n    }\n    if (isModel(item)) {\n        return `model:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isSubscription(item)) {\n        return `sub:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isNodeOrdering(item)) {\n        return `ord:${nameMap.get(item) ?? '?'}`;\n    }\n    return `field:${nameMap.get(item.model) ?? '?'}:${String(item.key)}`;\n}\n\nexport function name<T>(item: T, name: string): T {\n    if (!DEBUG) return item;\n    nameMap.set(item, name);\n    return item;\n}\n", "import {\n    InvariantError,\n    Calculation,\n    Collection,\n    View,\n    DAGNode,\n    FlushKey,\n    isCalculation,\n    isCollection,\n    isModel,\n    isModelField,\n    isSubscription,\n    makeCalculation,\n    makeEffect,\n    EqualityFunc,\n    RecalculationTag,\n} from './types';\nimport * as log from './log';\nimport { DAG } from './dag';\nimport { noop, alwaysTrue, strictEqual } from './util';\nimport { clearNames, debugNameFor, name } from './debug';\n\nlet activeCalculations: (null | Calculation<any>)[] = [];\n\nlet globalDependencyGraph = new DAG<DAGNode>();\n\nlet refcountMap: WeakMap<\n    Calculation<any> | Collection<any> | View<any>,\n    number\n> = new WeakMap();\n\n/**\n * Reset all data to a clean slate.\n */\nexport function reset() {\n    activeCalculations = [];\n\n    globalDependencyGraph = new DAG();\n    refcountMap = new WeakMap();\n    clearNames();\n}\n\n/**\n * Create a calculation cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be recalculated when any of those dependencies are changed. The result of this function is\n * treated as a dependency, so if recalculations change the result, any dependent calculations are recalculated.\n */\nexport function calc<Ret>(func: () => Ret): Calculation<Ret>;\nexport function calc<Ret>(func: () => Ret, debugName: string): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual: EqualityFunc<Ret>\n): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual: EqualityFunc<Ret>,\n    debugName: string\n): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual?: string | EqualityFunc<Ret>,\n    debugName?: string\n): Calculation<Ret> {\n    if (typeof isEqual === 'string') debugName = isEqual;\n    if (typeof isEqual !== 'function') isEqual = strictEqual;\n    if (typeof debugName !== 'string') debugName = undefined;\n    const calculation = trackCalculation(func, isEqual, false);\n    if (debugName) name(calculation, debugName);\n    return calculation;\n}\n\n/**\n * Create an effect cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be re-executed when any of those dependencies are changed.\n *\n * Effect cells are not be added as dependencies to the current computation.\n *\n * Note: Since nothing depends on created effects, they must be be manually retained and released if you want the effect\n * to re-run when its dependencies change. Failure to do so will not automatically re-run the effect (which may be\n * desired if you want to trigger behavior only once within a computation)\n */\nexport function effect(\n    func: () => void,\n    debugName?: string\n): Calculation<void> {\n    const calculation = trackCalculation(\n        func,\n        alwaysTrue /* effects always return true for equality */,\n        true\n    );\n    if (debugName) name(calculation, debugName);\n    return calculation;\n}\n\nexport function untracked<TRet>(func: () => TRet): TRet {\n    activeCalculations.push(null);\n    const result = func();\n    activeCalculations.pop();\n    return result;\n}\n\nfunction trackCalculation<Ret>(\n    func: () => Ret,\n    isEqual: (a: Ret, b: Ret) => boolean,\n    isEffect: boolean\n): Calculation<Ret> {\n    if (typeof func !== 'function') {\n        throw new InvariantError('calculation must be provided a function');\n    }\n\n    let result: { result: Ret } | undefined = undefined;\n\n    // Note: typescript gets confused, this *should* be\n    // - Calculation<Ret> when isEffect is false and\n    // - Calculation<Ret> when isEffect is true, infering Ret to void\n    // But infers to Calculation<void> because makeEffect is present\n    const trackedCalculation: Calculation<Ret> = (\n        isEffect\n            ? makeEffect(runCalculation, recalculate)\n            : makeCalculation(runCalculation, recalculate)\n    ) as Calculation<Ret>;\n\n    function runCalculation() {\n        if (!isEffect) {\n            // effects return void, so they **cannot** have an effect on the current calculation\n            addDepToCurrentCalculation(trackedCalculation);\n        }\n\n        if (result) {\n            return result.result;\n        }\n\n        globalDependencyGraph.removeIncoming(trackedCalculation);\n\n        activeCalculations.push(trackedCalculation);\n        result = { result: func() };\n\n        const sanityCheck = activeCalculations.pop();\n        if (sanityCheck !== trackedCalculation) {\n            throw new InvariantError('Active calculation stack inconsistency!');\n        }\n        return result.result;\n    }\n    globalDependencyGraph.addNode(trackedCalculation);\n\n    function recalculate() {\n        if (!result) {\n            trackedCalculation();\n            return false;\n        }\n        const prevResult = result.result;\n        result = undefined;\n        const newResult = trackedCalculation();\n        const eq = isEqual(prevResult, newResult);\n        if (eq) {\n            // Ensure future invocations reuse original calculated value\n            result = { result: prevResult };\n        }\n        return eq;\n    }\n\n    return trackedCalculation;\n}\n\nexport function addDepToCurrentCalculation(item: DAGNode) {\n    const dependentCalculation =\n        activeCalculations[activeCalculations.length - 1];\n    if (dependentCalculation) {\n        globalDependencyGraph.addNode(item);\n        if (!globalDependencyGraph.hasNode(dependentCalculation)) {\n            globalDependencyGraph.addNode(dependentCalculation);\n        }\n        globalDependencyGraph.addEdge(\n            item,\n            dependentCalculation,\n            DAG.EDGE_HARD\n        );\n        DEBUG &&\n            log.debug(\n                'New global dependency',\n                debugNameFor(item),\n                '->',\n                debugNameFor(dependentCalculation)\n            );\n    }\n}\n\nexport function addManualDep(fromNode: DAGNode, toNode: DAGNode) {\n    globalDependencyGraph.addNode(fromNode);\n    globalDependencyGraph.addNode(toNode);\n    globalDependencyGraph.addEdge(fromNode, toNode, DAG.EDGE_HARD);\n    DEBUG &&\n        log.debug(\n            'New manual dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function addOrderingDep(fromNode: DAGNode, toNode: DAGNode) {\n    globalDependencyGraph.addNode(fromNode);\n    globalDependencyGraph.addNode(toNode);\n    globalDependencyGraph.addEdge(fromNode, toNode, DAG.EDGE_SOFT);\n    DEBUG &&\n        log.debug(\n            'New manual ordering dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function removeManualDep(fromNode: DAGNode, toNode: DAGNode) {\n    if (globalDependencyGraph.removeEdge(fromNode, toNode, DAG.EDGE_HARD)) {\n        DEBUG &&\n            log.debug(\n                'Removed manual dependency',\n                debugNameFor(fromNode),\n                '->',\n                debugNameFor(toNode)\n            );\n    }\n}\n\nexport function removeOrderingDep(fromNode: DAGNode, toNode: DAGNode) {\n    if (globalDependencyGraph.removeEdge(fromNode, toNode, DAG.EDGE_SOFT)) {\n        DEBUG &&\n            log.debug(\n                'Removed manual ordering dependency',\n                debugNameFor(fromNode),\n                '->',\n                debugNameFor(toNode)\n            );\n    }\n}\n\nexport function processChange(item: DAGNode) {\n    globalDependencyGraph.addNode(item);\n    const hardEdges = globalDependencyGraph.getDependencies(\n        item,\n        DAG.EDGE_HARD\n    );\n    if (hardEdges.length > 0) {\n        const marked = globalDependencyGraph.markNodeDirty(item);\n        DEBUG && log.debug('processChange', item, marked ? 'fresh' : 'stale');\n        if (!needsFlush) {\n            needsFlush = true;\n            notify();\n        }\n    }\n}\n\ntype Listener = () => void;\nlet needsFlush = false;\nlet flushPromise: Promise<void> = Promise.resolve();\nlet resolveFlushPromise: () => void = noop;\nlet subscribeListener: Listener = () => setTimeout(() => flush(), 0);\n\nexport function nextFlush() {\n    if (!needsFlush) return Promise.resolve();\n    return flushPromise;\n}\n\n/**\n * Call provided callback when any pending calculations are created. Use to configure how/when the application flushes calculations.\n *\n * If any pending calculations are needed when this function is called, the provided callback is called synchronously.\n *\n * By default, the subscribe mechanism is to call flush() on setTimeout. Calling subscribe removes this default and\n * replaces it with whatever mechanism you'd like.\n *\n * Example: subscribe(() => requestAnimationFrame(() => flush()));\n */\nexport function subscribe(listener: Listener): void {\n    subscribeListener = listener;\n    if (needsFlush) {\n        subscribeListener();\n    }\n}\n\nfunction notify() {\n    try {\n        flushPromise = new Promise((resolve) => {\n            resolveFlushPromise = resolve;\n        });\n        subscribeListener();\n    } catch (e) {\n        log.exception(e, 'uncaught exception in notify');\n    }\n}\n\n/**\n * Hoo boy this is probably a mistake. Stream the graph while we flush\n */\nlet debugSubscription: ((graphViz: string, detail: string) => void) | null =\n    null;\n\n/**\n * Recalculate all pending calculations.\n */\nexport function flush() {\n    if (!needsFlush) {\n        return;\n    }\n    needsFlush = false;\n\n    DEBUG && debugSubscription && debugSubscription(debug(), '0: flush start');\n\n    // Then flush dependencies in topological order\n    globalDependencyGraph.process((item) => {\n        let result = false;\n        if (isCalculation(item)) {\n            DEBUG && log.debug('flushing calculation', debugNameFor(item));\n            const recalculation = item[RecalculationTag];\n            result = recalculation();\n        } else if (isCollection(item)) {\n            DEBUG && log.debug('flushing collection', debugNameFor(item));\n            item[FlushKey]();\n        } else if (isModel(item)) {\n            DEBUG && log.debug('flushing model', debugNameFor(item));\n            item[FlushKey]();\n        } else if (isSubscription(item)) {\n            DEBUG && log.debug('flushing subscription', debugNameFor(item));\n            item[FlushKey]();\n        } else {\n            DEBUG && log.debug('flushing other', debugNameFor(item));\n        }\n\n        DEBUG &&\n            debugSubscription &&\n            debugSubscription(\n                debug(item),\n                `1: visited ${debugNameFor(item)}: isEqual=${result}`\n            );\n        return result;\n    });\n\n    DEBUG && debugSubscription && debugSubscription(debug(), `2: after visit`);\n\n    resolveFlushPromise();\n}\n\n/**\n * Retain a calculation (increase the refcount)\n */\nexport function retain(item: DAGNode) {\n    const refcount = refcountMap.get(item) ?? 0;\n    const newRefcount = refcount + 1;\n    if (refcount === 0) {\n        DEBUG &&\n            log.debug(\n                `retain ${debugNameFor(\n                    item\n                )} retained; refcount ${refcount} -> ${newRefcount}`\n            );\n        if (!globalDependencyGraph.hasNode(item)) {\n            globalDependencyGraph.addNode(item);\n        }\n        globalDependencyGraph.retain(item);\n    } else {\n        DEBUG &&\n            log.debug(\n                `retain ${debugNameFor(\n                    item\n                )} incremented; refcount ${refcount} -> ${newRefcount}`\n            );\n    }\n    refcountMap.set(item, newRefcount);\n}\n\n/**\n * Release a calculation (decrease the refcount). If the refcount reaches zero, the calculation will be garbage\n * collected.\n */\nexport function release(item: DAGNode) {\n    const refcount = refcountMap.get(item) ?? 0;\n    const newRefcount = Math.min(refcount - 1, 0);\n    if (refcount < 1) {\n        log.error(\n            `release called on unretained item ${debugNameFor(item)}`,\n            item\n        );\n    }\n    if (newRefcount < 1) {\n        DEBUG &&\n            log.debug(\n                `release ${debugNameFor(\n                    item\n                )} released; refcount ${refcount} -> ${newRefcount}`\n            );\n        globalDependencyGraph.release(item);\n    } else {\n        DEBUG &&\n            log.debug(\n                `release ${debugNameFor(\n                    item\n                )} decremented; refcount ${refcount} -> ${newRefcount}`\n            );\n    }\n    refcountMap.set(item, newRefcount);\n}\n\n/**\n * Return a graphviz formatted directed graph\n */\nexport function debug(activeItem?: any): string {\n    return globalDependencyGraph.graphviz((id, item) => {\n        let subgraph: object | undefined = undefined;\n        if (isModel(item)) {\n            subgraph = item;\n        }\n        if (isCollection(item)) {\n            subgraph = item;\n        }\n        if (isModelField(item)) {\n            subgraph = item.model;\n        }\n        if (isSubscription(item)) {\n            subgraph = item.item;\n        }\n        return {\n            label: `${id}\\n${debugNameFor(item)}`,\n            subgraph,\n            penwidth: activeItem === item ? '5.0' : '1.0',\n        };\n    });\n}\n\nexport function debugSubscribe(\n    callback: ((graphviz: string, detail: string) => void) | null\n) {\n    debugSubscription = callback;\n}\n", "import { TypeTag, Ref, Calculation, Collection, Context } from './types';\n\n// General component props\ntype PropsWithChildren<P> = P & { children?: JSXNode[] };\n\ntype OnUnmountCallback = () => void;\ntype OnMountCallback = () => void;\ntype EffectCallback = () => void;\n\ntype ComponentListeners = {\n    onUnmount: (callback: OnUnmountCallback) => void;\n    onMount: (callback: OnMountCallback) => void;\n    onEffect: (callback: EffectCallback) => void;\n    getContext: <TVal>(context: Context<TVal>) => TVal;\n};\nexport type Component<P extends {}> = (\n    props: PropsWithChildren<P>,\n    listeners: ComponentListeners\n) => JSXNode;\n\ntype JsxRawNode = string | number | boolean | null | undefined | Function;\n\n/**\n * The type returnable by JSX (raw nodes)\n */\ntype JSXNodeSingle =\n    | JsxRawNode\n    | Calculation<JsxRawNode>\n    | Calculation<JsxRawNode[]>\n    | RenderElement<any>\n    | RenderComponent<any>\n    | RenderProvider<any>;\nexport type JSXNode =\n    | JSXNodeSingle\n    | JSXNodeSingle[]\n    | Collection<JSXNodeSingle>;\n\nexport type RenderElement<ElementName extends keyof JSX.IntrinsicElements> = {\n    [TypeTag]: 'element';\n    element: ElementName;\n    props?: JSX.IntrinsicElements[ElementName];\n    children: JSXNode[];\n};\nexport function isRenderElement(\n    jsxNode: JSXNode\n): jsxNode is RenderElement<any> {\n    return !!(\n        jsxNode &&\n        typeof jsxNode === 'object' &&\n        !Array.isArray(jsxNode) &&\n        jsxNode[TypeTag] === 'element'\n    );\n}\n\nexport type RenderComponent<Props extends {}> = {\n    [TypeTag]: 'component';\n    component: Component<Props>;\n    props?: Props;\n    children: JSXNode[];\n};\nexport function isRenderComponent(\n    jsxNode: JSXNode\n): jsxNode is RenderComponent<any> {\n    return !!(\n        jsxNode &&\n        typeof jsxNode === 'object' &&\n        !Array.isArray(jsxNode) &&\n        jsxNode[TypeTag] === 'component'\n    );\n}\n\nexport type RenderProvider<TValue> = {\n    [TypeTag]: 'provider';\n    context: Context<TValue>;\n    value: TValue;\n    children: JSXNode[];\n};\n\nexport function isRenderProvider(\n    jsxNode: JSXNode\n): jsxNode is RenderProvider<any> {\n    return !!(\n        jsxNode &&\n        typeof jsxNode === 'object' &&\n        !Array.isArray(jsxNode) &&\n        jsxNode[TypeTag] === 'provider'\n    );\n}\n\n/*\n * Interfaces adopted from HTML Living Standard Last Updated 30 November 2021: https://html.spec.whatwg.org/\n */\nfunction attrBooleanToEmptyString(\n    val: boolean | undefined\n): string | undefined {\n    if (!val) return undefined;\n    return '';\n}\nfunction attrStringOrNumberToNumber(\n    val: string | number | undefined\n): number | undefined {\n    if (val === undefined) return undefined;\n    return typeof val === 'number' ? val : parseInt(val);\n}\nfunction attrYesNo(val: '' | 'yes' | 'no' | undefined): boolean | undefined {\n    if (val === undefined) return undefined;\n    return val === 'no' ? false : true;\n}\n\n// Note: TypeScript has some notably missing IDL properties from its HTMLElement interface, this adds them in lieu of those properties:\ninterface MissingFromTypescriptHTMLElementProperties {\n    // https://w3c.github.io/aria/#idl-reflection-attribute-values\n    ariaColIndexText?: string | undefined;\n    ariaInvalid?: string | undefined;\n    ariaRowIndexText?: string | undefined;\n    role?: string | undefined;\n\n    // https://html.spec.whatwg.org/multipage/dom.html#htmlorsvgelement\n    autofocus?: boolean | undefined;\n\n    itemscope?: string | undefined;\n}\n\n// Note: TypeScript has some notably missing IDL properties from its HTMLDialog interface, this adds them in lieu of those properties:\ninterface MissingFromTypescriptHTMLDialogElementProperties {\n    // https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element\n    open?: boolean | undefined;\n}\n\ninterface MissingFromTypescriptHTMLIframeElementProperties {\n    // https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element\n    loading?: LazyLoadingValue | undefined;\n}\n\ninterface MissingFromTypescriptHTMLMetaElementProperties {\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-meta-media\n    media?: string | undefined;\n}\n\ninterface MissingFromTypescriptHTMLSourceElementProperties {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#the-source-element\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\ntype PropertyMapField<TJSXField, TElement, TIDLName extends keyof TElement> =\n    | {\n          makeAttrValue?:\n              | ((jsxAttr: Exclude<TJSXField, undefined>) => string | undefined)\n              | null;\n      }\n    | {\n          makeAttrValue?:\n              | ((jsxAttr: Exclude<TJSXField, undefined>) => string | undefined)\n              | null;\n          idlName?: TIDLName | null;\n          makeIdlValue?: (\n              jsxAttr: Exclude<TJSXField, undefined>\n          ) => TElement[TIDLName];\n      };\n\ntype PropertyMap<TJSXElementInterface, TElement> = {\n    [TJSXKey in keyof Required<TJSXElementInterface>]: PropertyMapField<\n        TJSXElementInterface[TJSXKey],\n        TElement,\n        keyof TElement\n    >;\n};\n\n// Note: abstract roles are **not** in this list, as \"Authors MUST NOT use abstract roles in content\"\ntype AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'associationlist'\n    | 'associationlistitemkey'\n    | 'associationlistitemvalue'\n    | 'banner'\n    | 'blockquote'\n    | 'button'\n    | 'caption'\n    | 'cell'\n    | 'checkbox'\n    | 'code'\n    | 'columnheader'\n    | 'combobox'\n    | 'comment'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'deletion'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'emphasis'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'generic'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'insertion'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'mark'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'meter'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'paragraph'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'strong'\n    | 'subscript'\n    | 'suggestion'\n    | 'superscript'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'time'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | string;\n\ntype DirValue = 'ltr' | 'rtl' | 'auto' | string;\n\ntype BrowsingContextValue = '_blank' | '_self' | '_parent' | '_top' | string;\n\ntype ReferrerPolicyValue =\n    | ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'same-origin'\n    | 'origin'\n    | 'strict-origin'\n    | 'origin-when-cross-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url'\n    | string;\n\ntype CrossOriginValue = 'anonymous' | '' | 'use-credentials';\n\ntype LazyLoadingValue = 'lazy' | 'eager' | string;\n\ntype ImageDecodingHintValue = 'sync' | 'async' | 'auto' | string;\n\ntype SandboxValue =\n    | 'allow-forms'\n    | 'allow-modals'\n    | 'allow-orientation-lock'\n    | 'allow-pointer-lock'\n    | 'allow-popups'\n    | 'allow-popups-to-escape-sandbox'\n    | 'allow-presentation'\n    | 'allow-same-origin'\n    | 'allow-scripts'\n    | 'allow-top-navigation'\n    | 'allow-top-navigation-by-user-activation'\n    | 'allow-downloads'\n    | string;\n\ntype EncTypeValue =\n    | 'application/x-www-form-urlencoded'\n    | 'multipart/form-data'\n    | 'text/plain'\n    | string;\n\ntype FormMethodValue = 'get' | 'post' | 'dialog' | string;\n\ntype AutocompleteValue = 'on' | 'off' | string;\n\ninterface JSXElementInterface {\n    /** a guide for creating a keyboard shortcut that activates or focuses the element */\n    accesskey?: string | undefined;\n    'aria-atomic'?: string | undefined; //  ariaAtomic\n    'aria-autocomplete'?: string | undefined; //  ariaAutoComplete\n    'aria-busy'?: string | undefined; //  ariaBusy\n    'aria-checked'?: string | undefined; //  ariaChecked\n    'aria-colcount'?: string | undefined; //  ariaColCount\n    'aria-colindex'?: string | undefined; //  ariaColIndex\n    'aria-colindextext'?: string | undefined; //  ariaColIndexText\n    'aria-colspan'?: string | undefined; //  ariaColSpan\n    'aria-current'?: string | undefined; //  ariaCurrent\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description'?: string | undefined; //  ariaDescription\n    */\n    'aria-disabled'?: string | undefined; //  ariaDisabled\n    'aria-expanded'?: string | undefined; //  ariaExpanded\n    'aria-haspopup'?: string | undefined; //  ariaHasPopup\n    'aria-hidden'?: string | undefined; //  ariaHidden\n    'aria-invalid'?: string | undefined; //  ariaInvalid\n    'aria-keyshortcuts'?: string | undefined; //  ariaKeyShortcuts\n    'aria-label'?: string | undefined; //  ariaLabel\n    'aria-level'?: string | undefined; //  ariaLevel\n    'aria-live'?: string | undefined; //  ariaLive\n    'aria-modal'?: string | undefined; //  ariaModal\n    'aria-multiline'?: string | undefined; //  ariaMultiLine\n    'aria-multiselectable'?: string | undefined; //  ariaMultiSelectable\n    'aria-orientation'?: string | undefined; //  ariaOrientation\n    'aria-placeholder'?: string | undefined; //  ariaPlaceholder\n    'aria-posinset'?: string | undefined; //  ariaPosInSet\n    'aria-pressed'?: string | undefined; //  ariaPressed\n    'aria-readonly'?: string | undefined; //  ariaReadOnly\n    'aria-required'?: string | undefined; //  ariaRequired\n    'aria-roledescription'?: string | undefined; //  ariaRoleDescription\n    'aria-rowcount'?: string | undefined; //  ariaRowCount\n    'aria-rowindex'?: string | undefined; //  ariaRowIndex\n    'aria-rowindextext'?: string | undefined; //  ariaRowIndexText\n    'aria-rowspan'?: string | undefined; //  ariaRowSpan\n    'aria-selected'?: string | undefined; //  ariaSelected\n    'aria-setsize'?: string | undefined; //  ariaSetSize\n    'aria-sort'?: string | undefined; //  ariaSort\n    'aria-valuemax'?: string | undefined; //  ariaValueMax\n    'aria-valuemin'?: string | undefined; //  ariaValueMin\n    'aria-valuenow'?: string | undefined; //  ariaValueNow\n    'aria-valuetext'?: string | undefined; //  ariaValueText\n    /** autocapitalization hint */\n    autocapitalize?:\n        | 'off'\n        | 'none'\n        | 'on'\n        | 'sentences'\n        | 'words'\n        | 'characters'\n        | string\n        | undefined;\n    /** focus as soon as the page is loaded or as soon as the dialog within which it finds itself is shown */\n    autofocus?: boolean | undefined;\n    /** the various classes that the element belongs to */\n    class?: string | undefined;\n    /** indicates if the element is editable */\n    contenteditable?: '' | 'true' | 'false' | string | undefined;\n    /** specifies the element's text directionality */\n    dir?: DirValue | undefined;\n    /** specifies the element's drag behavior */\n    draggable?: boolean | undefined;\n    /** specifies what action label (or icon) to present for the enter key on virtual keyboards */\n    enterkeyhint?:\n        | 'enter'\n        | 'done'\n        | 'go'\n        | 'next'\n        | 'previous'\n        | 'search'\n        | 'send'\n        | string\n        | undefined;\n    /** indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user */\n    hidden?: boolean | undefined;\n    /** the unique id of the element */\n    id?: string | undefined;\n    inputmode?:\n        | 'none'\n        | 'text'\n        | 'tel'\n        | 'url'\n        | 'email'\n        | 'numeric'\n        | 'decimal'\n        | 'search'\n        | string\n        | undefined;\n    is?: string | undefined;\n    itemid?: string | undefined;\n    itemprop?: string | undefined;\n    itemref?: string | undefined;\n    itemscope?: boolean | undefined;\n    itemtype?: string | undefined;\n    lang?: string | undefined;\n    nonce?: string | undefined;\n    role?: AriaRole | undefined;\n    slot?: string | undefined;\n    spellcheck?: boolean | undefined;\n    style?: string | undefined;\n    tabindex?: -1 | 0 | number | undefined; // \"-1\" and \"0\" used as convenience\n    title?: string | undefined;\n    translate?: '' | 'yes' | 'no' | undefined;\n}\n\nexport const HTMLElementMap: PropertyMap<\n    JSXElementInterface,\n    HTMLElement & MissingFromTypescriptHTMLElementProperties\n> = {\n    accesskey: {\n        idlName: 'accessKey',\n    },\n    'aria-atomic': {\n        idlName: 'ariaAtomic',\n    },\n    'aria-autocomplete': {\n        idlName: 'ariaAutoComplete',\n    },\n    'aria-busy': {\n        idlName: 'ariaBusy',\n    },\n    'aria-checked': {\n        idlName: 'ariaChecked',\n    },\n    'aria-colcount': {\n        idlName: 'ariaColCount',\n    },\n    'aria-colindex': {\n        idlName: 'ariaColIndex',\n    },\n    'aria-colindextext': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaColIndexText\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaColIndexText',\n    },\n    'aria-colspan': {\n        idlName: 'ariaColSpan',\n    },\n    'aria-current': {\n        idlName: 'ariaCurrent',\n    },\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description': {\n        idlName: 'ariaDescription',\n    },\n    */\n    'aria-disabled': {\n        idlName: 'ariaDisabled',\n    },\n    'aria-expanded': {\n        idlName: 'ariaExpanded',\n    },\n    'aria-haspopup': {\n        idlName: 'ariaHasPopup',\n    },\n    'aria-hidden': {\n        idlName: 'ariaHidden',\n    },\n    'aria-invalid': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaInvalid\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaInvalid',\n    },\n    'aria-keyshortcuts': {\n        idlName: 'ariaKeyShortcuts',\n    },\n    'aria-label': {\n        idlName: 'ariaLabel',\n    },\n    'aria-level': {\n        idlName: 'ariaLevel',\n    },\n    'aria-live': {\n        idlName: 'ariaLive',\n    },\n    'aria-modal': {\n        idlName: 'ariaModal',\n    },\n    'aria-multiline': {\n        idlName: 'ariaMultiLine',\n    },\n    'aria-multiselectable': {\n        idlName: 'ariaMultiSelectable',\n    },\n    'aria-orientation': {\n        idlName: 'ariaOrientation',\n    },\n    'aria-placeholder': {\n        idlName: 'ariaPlaceholder',\n    },\n    'aria-posinset': {\n        idlName: 'ariaPosInSet',\n    },\n    'aria-pressed': {\n        idlName: 'ariaPressed',\n    },\n    'aria-readonly': {\n        idlName: 'ariaReadOnly',\n    },\n    'aria-required': {\n        idlName: 'ariaRequired',\n    },\n    'aria-roledescription': {\n        idlName: 'ariaRoleDescription',\n    },\n    'aria-rowcount': {\n        idlName: 'ariaRowCount',\n    },\n    'aria-rowindex': {\n        idlName: 'ariaRowIndex',\n    },\n    'aria-rowindextext': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaColIndexText\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaRowIndexText',\n    },\n    'aria-rowspan': {\n        idlName: 'ariaRowSpan',\n    },\n    'aria-selected': {\n        idlName: 'ariaSelected',\n    },\n    'aria-setsize': {\n        idlName: 'ariaSetSize',\n    },\n    'aria-sort': {\n        idlName: 'ariaSort',\n    },\n    'aria-valuemax': {\n        idlName: 'ariaValueMax',\n    },\n    'aria-valuemin': {\n        idlName: 'ariaValueMin',\n    },\n    'aria-valuenow': {\n        idlName: 'ariaValueNow',\n    },\n    'aria-valuetext': {\n        idlName: 'ariaValueText',\n    },\n    autocapitalize: {},\n    autofocus: {\n        // Note: The \"autofocus\" property exists in HTMLElement interface: https://html.spec.whatwg.org/multipage/dom.html#htmlorsvgelement\n    },\n    class: {\n        idlName: 'className',\n    },\n    contenteditable: {\n        idlName: 'contentEditable',\n    },\n    dir: {},\n    draggable: {},\n    enterkeyhint: {\n        idlName: 'enterKeyHint',\n    },\n    hidden: {},\n    id: {},\n    inputmode: {\n        idlName: 'inputMode',\n    },\n    is: { idlName: null },\n    itemid: { idlName: null },\n    itemprop: { idlName: null },\n    itemref: { idlName: null },\n    itemscope: { idlName: null },\n    itemtype: { idlName: null },\n    lang: {},\n    nonce: {},\n    role: {},\n    slot: {},\n    spellcheck: {},\n    style: {},\n    tabindex: {\n        idlName: 'tabIndex',\n        makeIdlValue: attrStringOrNumberToNumber,\n    },\n    title: {},\n    translate: {\n        makeIdlValue: attrYesNo,\n    },\n};\n\ninterface JSXAnchorElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** Browsing context for hyperlink navigation */\n    target?: BrowsingContextValue | undefined;\n    /** Whether to download the resource instead of navigating to it, and its filename if so */\n    download?: string | undefined;\n    /** URLs to ping */\n    ping?: string | undefined;\n    /** Relationship between the location in the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLAnchorElementMap: PropertyMap<\n    JSXAnchorElementInterface,\n    HTMLAnchorElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    target: {},\n    download: {},\n    ping: {},\n    rel: {},\n    hreflang: {},\n    type: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXAreaElementInterface extends JSXElementInterface {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    shape?:\n        | 'circle'\n        | 'circ'\n        | 'default'\n        | 'poly'\n        | 'polygon'\n        | 'rect'\n        | 'rectangle'\n        | string\n        | undefined;\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n    download?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLAreaElementMap: PropertyMap<\n    JSXAreaElementInterface,\n    HTMLAreaElement\n> = {\n    ...HTMLElementMap,\n    alt: {},\n    coords: {},\n    shape: {},\n    href: {},\n    target: {},\n    download: {},\n    ping: {},\n    rel: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXMediaElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Hints how much buffering the media resource will likely need */\n    preload?: 'none' | 'metadata' | 'auto' | undefined;\n    /** Hint that the media resource can be started automatically when the page is loaded */\n    autoplay?: boolean | undefined;\n    /** Whether to loop the media resource */\n    loop?: boolean | undefined;\n    /** Whether to mute the media resource by default */\n    muted?: boolean | undefined;\n    /** Show user agent controls */\n    controls?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXAudioElementInterface extends JSXMediaElementInterface {}\n\nconst HTMLAudioElementMap: PropertyMap<\n    JSXAudioElementInterface,\n    HTMLAudioElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    preload: {},\n    autoplay: {},\n    loop: {\n        makeIdlValue: attrBooleanToEmptyString,\n    },\n    muted: {},\n    controls: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBRElementInterface extends JSXElementInterface {}\n\nconst HTMLBRElementMap: PropertyMap<JSXBRElementInterface, HTMLBRElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXBaseElementInterface extends JSXElementInterface {\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n}\n\nconst HTMLBaseElementMap: PropertyMap<\n    JSXBaseElementInterface,\n    HTMLBaseElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    target: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBodyElementInterface extends JSXElementInterface {}\n\nconst HTMLBodyElementMap: PropertyMap<\n    JSXBodyElementInterface,\n    HTMLBodyElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXButtonElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formaction?: string | undefined;\n    formenctype?: EncTypeValue | undefined;\n    formmethod?: FormMethodValue | undefined;\n    formnovalidate?: boolean | undefined;\n    formtarget?: BrowsingContextValue | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | string | undefined;\n    value?: string | undefined;\n}\n\nconst HTMLButtonElementMap: PropertyMap<\n    JSXButtonElementInterface,\n    HTMLButtonElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    form: { idlName: null }, // Note: form IDL not ever written\n    formaction: {\n        idlName: 'formAction',\n    },\n    formenctype: {\n        idlName: 'formEnctype',\n    },\n    formmethod: {\n        idlName: 'formMethod',\n    },\n    formnovalidate: {\n        idlName: 'formNoValidate',\n    },\n    formtarget: {\n        idlName: 'formTarget',\n    },\n    name: {},\n    type: {},\n    value: {},\n};\n\ninterface JSXCanvasElementInterface extends JSXElementInterface {\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\nconst HTMLCanvasElementMap: PropertyMap<\n    JSXCanvasElementInterface,\n    HTMLCanvasElement\n> = {\n    ...HTMLElementMap,\n    width: {},\n    height: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDListElementInterface extends JSXElementInterface {}\n\nconst HTMLDListElementMap: PropertyMap<\n    JSXDListElementInterface,\n    HTMLDListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXDataElementInterface extends JSXElementInterface {\n    value?: string | undefined;\n}\n\nconst HTMLDataElementMap: PropertyMap<\n    JSXDataElementInterface,\n    HTMLDataElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDataListElementInterface extends JSXElementInterface {}\n\nconst HTMLDataListElementMap: PropertyMap<\n    JSXDataListElementInterface,\n    HTMLDataListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXDetailsElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\nconst HTMLDetailsElementMap: PropertyMap<\n    JSXDetailsElementInterface,\n    HTMLDetailsElement\n> = {\n    ...HTMLElementMap,\n    open: {},\n};\n\ninterface JSXDialogElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\nconst HTMLDialogElementMap: PropertyMap<\n    JSXDialogElementInterface,\n    HTMLDialogElement & MissingFromTypescriptHTMLDialogElementProperties\n> = {\n    ...HTMLElementMap,\n    open: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDivElementInterface extends JSXElementInterface {}\n\nconst HTMLDivElementMap: PropertyMap<JSXDivElementInterface, HTMLDivElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXEmbedElementInterface extends JSXElementInterface {\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\nconst HTMLEmbedElementMap: PropertyMap<\n    JSXEmbedElementInterface,\n    HTMLEmbedElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    type: {},\n    width: {},\n    height: {},\n};\n\ninterface JSXFieldSetElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\nconst HTMLFieldSetElementMap: PropertyMap<\n    JSXFieldSetElementInterface,\n    HTMLFieldSetElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    form: { idlName: null }, // form IDL not ever written\n    name: {},\n};\n\ninterface JSXFormElementInterface extends JSXElementInterface {\n    'accept-charset'?: 'UTF-8' | string | undefined;\n    action?: string | undefined;\n    autocomplete?: AutocompleteValue | undefined;\n    enctype?: EncTypeValue | undefined;\n    method?: FormMethodValue | undefined;\n    name?: string | undefined;\n    novalidate?: boolean | undefined;\n    target?: BrowsingContextValue | undefined;\n    rel?: string | undefined;\n}\n\nconst HTMLFormElementMap: PropertyMap<\n    JSXFormElementInterface,\n    HTMLFormElement\n> = {\n    ...HTMLElementMap,\n    'accept-charset': {\n        idlName: 'acceptCharset',\n    },\n    action: {},\n    autocomplete: {},\n    enctype: {},\n    method: {},\n    name: {},\n    novalidate: {\n        idlName: 'noValidate',\n    },\n    target: {},\n    rel: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadingElementInterface extends JSXElementInterface {}\n\nconst HTMLHeadingElementMap: PropertyMap<\n    JSXHeadingElementInterface,\n    HTMLHeadingElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadElementInterface extends JSXElementInterface {}\n\nconst HTMLHeadElementMap: PropertyMap<\n    JSXHeadElementInterface,\n    HTMLHeadElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHRElementInterface extends JSXElementInterface {}\n\nconst HTMLHRElementMap: PropertyMap<JSXHRElementInterface, HTMLHRElement> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHtmlElementInterface extends JSXElementInterface {}\n\nconst HTMLHtmlElementMap: PropertyMap<\n    JSXHtmlElementInterface,\n    HTMLHtmlElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXIFrameElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** A document to render in the iframe */\n    srcdoc?: string | undefined;\n    /** Name of nested browsing context */\n    name?: string | undefined;\n    /** Security rules for nested content */\n    sandbox?: SandboxValue | undefined; // TODO: This _could_ be a SandboxValue[], but feels awkward\n    /** Permissions policy to be applied to the iframe's contents */\n    allow?: string | undefined;\n    /** Whether to allow the iframe's contents to use requestFullscreen() */\n    allowfullscreen?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\nconst HTMLIFrameElementMap: PropertyMap<\n    JSXIFrameElementInterface,\n    HTMLIFrameElement & MissingFromTypescriptHTMLIframeElementProperties\n> = {\n    ...HTMLElementMap,\n    src: {},\n    srcdoc: {},\n    name: {},\n    sandbox: {},\n    allow: {},\n    allowfullscreen: {\n        idlName: 'allowFullscreen',\n    },\n    width: {},\n    height: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    loading: {},\n};\n\ninterface JSXImageElementInterface extends JSXElementInterface {\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Name of image map to use */\n    usemap?: string | undefined;\n    /** Whether the image is a server-side image map */\n    ismap?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Decoding hint to use when processing this image for presentation */\n    decoding?: ImageDecodingHintValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\nconst HTMLImageElementMap: PropertyMap<\n    JSXImageElementInterface,\n    HTMLImageElement\n> = {\n    ...HTMLElementMap,\n    alt: {},\n    src: {},\n    srcset: {},\n    sizes: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    usemap: {\n        idlName: 'useMap',\n    },\n    ismap: {\n        idlName: 'isMap',\n    },\n    width: {},\n    height: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    decoding: {},\n    loading: {},\n};\n\ntype FormInputTypeValues =\n    | 'button'\n    | 'checkbox'\n    | 'color'\n    | 'date'\n    | 'datetime-local'\n    | 'email'\n    | 'file'\n    | 'hidden'\n    | 'image'\n    | 'month'\n    | 'number'\n    | 'password'\n    | 'radio'\n    | 'range'\n    | 'reset'\n    | 'search'\n    | 'submit'\n    | 'tel'\n    | 'text'\n    | 'time'\n    | 'url'\n    | 'week'\n    | string;\n\ninterface JSXInputElementInterface extends JSXElementInterface {\n    /** Hint for expected file type in file upload controls */\n    accept?: string | undefined;\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the control is checked */\n    checked?: boolean | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: string | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** URL to use for form submission */\n    formaction?: string | undefined;\n    /** Entry list encoding type to use for form submission */\n    formenctype?: EncTypeValue | undefined;\n    /** Variant to use for form submission */\n    formmethod?: FormMethodValue | undefined;\n    /** Bypass form control validation for form submission */\n    formnovalidate?: boolean | undefined;\n    /** Browsing context for form submission */\n    formtarget?: BrowsingContextValue | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Third, indeterminate state for checkboxes */\n    indeterminate?: boolean | undefined;\n    /** List of autocomplete options */\n    list?: string | undefined;\n    /** Maximum value */\n    max?: number | undefined;\n    /** Maximum length of value */\n    maxlength?: number | undefined;\n    /** Minimum value */\n    min?: number | undefined;\n    /** Minimum length of value */\n    minlength?: number | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Pattern to be matched by the form control's value */\n    pattern?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: number | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Granularity to be matched by the form control's value */\n    step?: number | undefined;\n    /** Type of form control */\n    type?: FormInputTypeValues | undefined;\n    /** Value of the form control */\n    value?: string | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n}\nconst HTMLInputElementMap: PropertyMap<\n    JSXInputElementInterface,\n    HTMLInputElement\n> = {\n    ...HTMLElementMap,\n    accept: {},\n    alt: {},\n    autocomplete: {},\n    checked: {},\n    dirname: {\n        idlName: 'dirName',\n    },\n    disabled: {},\n    form: {},\n    formaction: {\n        idlName: 'formAction',\n    },\n    formenctype: {\n        idlName: 'formEnctype',\n    },\n    formmethod: {\n        idlName: 'formMethod',\n    },\n    formnovalidate: {\n        idlName: 'formNoValidate',\n    },\n    formtarget: {\n        idlName: 'formTarget',\n    },\n    height: {},\n    indeterminate: {\n        makeAttrValue: null, // TODO: what other IDL attributes don't set html attributes?\n    },\n    list: {},\n    max: {},\n    maxlength: {},\n    min: {},\n    minlength: {\n        idlName: 'minLength',\n    },\n    multiple: {},\n    name: {},\n    pattern: {},\n    placeholder: {},\n    readonly: {\n        idlName: 'readOnly',\n    },\n    required: {},\n    size: {},\n    src: {},\n    step: {},\n    type: {},\n    value: {},\n    width: {},\n};\n\ninterface JSXModElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n    /** Date and (optionally) time of the change */\n    datetime?: string | undefined;\n}\n\nconst HTMLModElementMap: PropertyMap<JSXModElementInterface, HTMLModElement> = {\n    ...HTMLElementMap,\n    cite: {},\n    datetime: {\n        idlName: 'dateTime',\n    },\n};\n\ninterface JSXLabelElementInterface extends JSXElementInterface {\n    /** Associate the label with form control */\n    for?: string | undefined;\n}\n\nconst HTMLLabelElementMap: PropertyMap<\n    JSXLabelElementInterface,\n    HTMLLabelElement\n> = {\n    ...HTMLElementMap,\n    for: {\n        idlName: 'htmlFor',\n    },\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLegendElementInterface extends JSXElementInterface {}\n\nconst HTMLLegendElementMap: PropertyMap<\n    JSXLegendElementInterface,\n    HTMLLegendElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXLIElementInterface extends JSXElementInterface {\n    /** Ordinal value of the list item */\n    value?: string | undefined;\n}\n\nconst HTMLLIElementMap: PropertyMap<JSXLIElementInterface, HTMLLIElement> = {\n    ...HTMLElementMap,\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLinkElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Relationship between the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Sizes of the icons (for rel=\"icon\") */\n    sizes?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel=\"preload\") */\n    imagesrcset?: string | undefined;\n    /** Image sizes for different page layouts (for rel=\"preload\") */\n    imagesizes?: string | undefined;\n    /** Potential destination for a preload request (for rel=\"preload\" and rel=\"modulepreload\") */\n    as?: string | undefined;\n    /** Color to use when customizing a site's icon (for rel=\"mask-icon\") */\n    color?: string | undefined;\n    /** Whether the link is disabled */\n    disabled?: boolean | undefined;\n}\n\nconst HTMLLinkElementMap: PropertyMap<\n    JSXLinkElementInterface,\n    HTMLLinkElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    rel: {},\n    media: {},\n    integrity: {},\n    hreflang: {},\n    type: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    sizes: {},\n    imagesrcset: {\n        idlName: 'imageSrcset',\n    },\n    imagesizes: {\n        idlName: 'imageSizes',\n    },\n    as: {},\n    color: {\n        idlName: null, // TODO: confirm\n    },\n    disabled: {},\n};\n\ninterface JSXMapElementInterface extends JSXElementInterface {\n    /** Name of image map to reference from the usemap attribute */\n    name?: string | undefined;\n}\n\nconst HTMLMapElementMap: PropertyMap<JSXMapElementInterface, HTMLMapElement> = {\n    ...HTMLElementMap,\n    name: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXMenuElementInterface extends JSXElementInterface {}\n\nconst HTMLMenuElementMap: PropertyMap<\n    JSXMenuElementInterface,\n    HTMLMenuElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXMetaElementInterface extends JSXElementInterface {\n    /** Metadata name */\n    name?:\n        | 'application-name'\n        | 'author'\n        | 'description'\n        | 'generator'\n        | 'keywords'\n        | 'referrer'\n        | 'theme-color'\n        | 'color-scheme'\n        | string\n        | undefined;\n    /** Pragma directive */\n    'http-equiv'?: string | undefined;\n    /** Value of the element */\n    content?: string | undefined;\n    /** Character encoding declaration */\n    charset?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n}\n\nconst HTMLMetaElementMap: PropertyMap<\n    JSXMetaElementInterface,\n    HTMLMetaElement & MissingFromTypescriptHTMLMetaElementProperties\n> = {\n    ...HTMLElementMap,\n    name: {},\n    'http-equiv': {\n        idlName: 'httpEquiv',\n    },\n    content: {},\n    charset: {\n        idlName: null, // TODO: confirm\n    },\n    media: {},\n};\n\ninterface JSXMeterElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: number | undefined;\n    /** Lower bound of range */\n    min?: number | undefined;\n    /** Upper bound of range */\n    max?: number | undefined;\n    /** High limit of low range */\n    low?: number | undefined;\n    /** Low limit of high range */\n    high?: number | undefined;\n    /** Optimum value in gauge */\n    optimum?: number | undefined;\n}\n\nconst HTMLMeterElementMap: PropertyMap<\n    JSXMeterElementInterface,\n    HTMLMeterElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n    min: {},\n    max: {},\n    low: {},\n    high: {},\n    optimum: {},\n};\n\ninterface JSXObjectElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    data?: string | undefined;\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** Name of nested browsing context */\n    name?: BrowsingContextValue | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | undefined;\n    /** Vertical dimension */\n    height?: string | undefined;\n}\n\nconst HTMLObjectElementMap: PropertyMap<\n    JSXObjectElementInterface,\n    HTMLObjectElement\n> = {\n    ...HTMLElementMap,\n    data: {},\n    type: {},\n    name: {},\n    form: {\n        idlName: null,\n    },\n    width: {},\n    height: {},\n};\n\ninterface JSXOListElementInterface extends JSXElementInterface {\n    /** Number the list backwards */\n    reversed?: boolean | undefined;\n    /** Starting value of the list */\n    start?: number | undefined;\n    /** Kind of list marker */\n    type?:\n        | 'decimal'\n        | 'lower-alpha'\n        | 'upper-alpha'\n        | 'lower-roman'\n        | 'upper-roman'\n        | string\n        | undefined;\n}\n\nconst HTMLOListElementMap: PropertyMap<\n    JSXOListElementInterface,\n    HTMLOListElement\n> = {\n    ...HTMLElementMap,\n    reversed: {},\n    start: {},\n    type: {},\n};\n\ninterface JSXOptGroupElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n}\n\nconst HTMLOptGroupElementMap: PropertyMap<\n    JSXOptGroupElementInterface,\n    HTMLOptGroupElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    label: {},\n};\n\ninterface JSXOptionElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Whether the option is selected by default */\n    selected?: boolean | undefined;\n    /** Value to be used for form submission */\n    value?: string | undefined;\n}\n\nconst HTMLOptionElementMap: PropertyMap<\n    JSXOptionElementInterface,\n    HTMLOptionElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    label: {},\n    selected: {},\n    value: {},\n};\n\ninterface JSXOutputElementInterface extends JSXElementInterface {\n    /** Specifies controls from which the output was calculated */\n    for?: string | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Name of the element to use in the form.elements API. */\n    name?: string | undefined;\n}\n\nconst HTMLOutputElementMap: PropertyMap<\n    JSXOutputElementInterface,\n    HTMLOutputElement\n> = {\n    ...HTMLElementMap,\n    for: {\n        idlName: 'htmlFor',\n    },\n    form: { idlName: null },\n    name: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXParagraphElementInterface extends JSXElementInterface {}\n\nconst HTMLParagraphElementMap: PropertyMap<\n    JSXParagraphElementInterface,\n    HTMLParagraphElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXParamElementInterface extends JSXElementInterface {\n    /** Name of parameter */\n    name?: string | undefined;\n    /** Value of parameter */\n    value?: string | undefined;\n}\n\nconst HTMLParamElementMap: PropertyMap<\n    JSXParamElementInterface,\n    HTMLParamElement\n> = {\n    ...HTMLElementMap,\n    name: {},\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPictureElementInterface extends JSXElementInterface {}\n\nconst HTMLPictureElementMap: PropertyMap<\n    JSXPictureElementInterface,\n    HTMLPictureElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPreElementInterface extends JSXElementInterface {}\n\nconst HTMLPreElementMap: PropertyMap<JSXPreElementInterface, HTMLPreElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXProgressElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: number | undefined;\n    /** Upper bound of range */\n    max?: number | undefined;\n}\n\nconst HTMLProgressElementMap: PropertyMap<\n    JSXProgressElementInterface,\n    HTMLProgressElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n    max: {},\n};\n\ninterface JSXQuoteElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n}\n\nconst HTMLQuoteElementMap: PropertyMap<\n    JSXQuoteElementInterface,\n    HTMLQuoteElement\n> = {\n    ...HTMLElementMap,\n    cite: {},\n};\n\ninterface JSXScriptElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Type of script */\n    type?: 'application/json' | 'text/json' | 'module' | string | undefined;\n    /** Prevents execution in user agents that support module scripts */\n    nomodule?: boolean | undefined;\n    /** Execute script when available, without blocking while fetching */\n    async?: boolean | undefined;\n    /** Defer script execution */\n    defer?: boolean | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLScriptElementMap: PropertyMap<\n    JSXScriptElementInterface,\n    HTMLScriptElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    type: {},\n    nomodule: {\n        idlName: 'noModule',\n    },\n    async: {},\n    defer: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    integrity: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXSelectElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: number | undefined;\n    /** Value of the element */\n    value?: string | undefined;\n}\n\nconst HTMLSelectElementMap: PropertyMap<\n    JSXSelectElementInterface,\n    HTMLSelectElement\n> = {\n    ...HTMLElementMap,\n    autocomplete: {},\n    disabled: {},\n    form: { idlName: null },\n    multiple: {},\n    name: {},\n    required: {},\n    size: {},\n    value: { makeAttrValue: null },\n};\n\ninterface JSXSlotElementInterface extends JSXElementInterface {\n    /** Name of shadow tree slot */\n    name?: string | undefined;\n}\n\nconst HTMLSlotElementMap: PropertyMap<\n    JSXSlotElementInterface,\n    HTMLSlotElement\n> = {\n    ...HTMLElementMap,\n    name: {},\n};\n\ninterface JSXSourceElementInterface extends JSXElementInterface {\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** (in video or audio) \u2014 Address of the resource */\n    src?: string | undefined;\n    /** (in picture) \u2014 Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** (in picture) \u2014 Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** (in picture) \u2014 Applicable media */\n    media?: string | undefined;\n    /** (in picture) \u2014 Horizontal dimension */\n    width?: number | undefined;\n    /** (in picture) \u2014 Vertical dimension */\n    height?: number | undefined;\n}\n\nconst HTMLSourceElementMap: PropertyMap<\n    JSXSourceElementInterface,\n    HTMLSourceElement & MissingFromTypescriptHTMLSourceElementProperties\n> = {\n    ...HTMLElementMap,\n    type: {},\n    src: {},\n    srcset: {},\n    sizes: {},\n    media: {},\n    width: {},\n    height: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXSpanElementInterface extends JSXElementInterface {}\n\nconst HTMLSpanElementMap: PropertyMap<\n    JSXSpanElementInterface,\n    HTMLSpanElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXStyleElementInterface extends JSXElementInterface {\n    /** Applicable media */\n    media?: string | undefined;\n}\n\nconst HTMLStyleElementMap: PropertyMap<\n    JSXStyleElementInterface,\n    HTMLStyleElement\n> = {\n    ...HTMLElementMap,\n    media: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableElementInterface extends JSXElementInterface {}\n\nconst HTMLTableElementMap: PropertyMap<\n    JSXTableElementInterface,\n    HTMLTableElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableCaptionElementInterface extends JSXElementInterface {}\n\nconst HTMLTableCaptionElementMap: PropertyMap<\n    JSXTableCaptionElementInterface,\n    HTMLTableCaptionElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableSectionElementInterface extends JSXElementInterface {}\n\nconst HTMLTableSectionElementMap: PropertyMap<\n    JSXTableSectionElementInterface,\n    HTMLTableSectionElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTableCellElementInterface extends JSXElementInterface {\n    /** Number of columns that the cell is to span */\n    colspan?: number | undefined;\n    /** Number of rows that the cell is to span */\n    rowspan?: number | undefined;\n    /** The header cells for this cell */\n    headers?: string | undefined;\n}\n\nconst HTMLTableCellElementMap: PropertyMap<\n    JSXTableCellElementInterface,\n    HTMLTableCellElement\n> = {\n    ...HTMLElementMap,\n    colspan: {\n        idlName: 'colSpan',\n    },\n    rowspan: {\n        idlName: 'rowSpan',\n    },\n    headers: {},\n};\n\ninterface JSXTableColElementInterface extends JSXElementInterface {\n    /** Number of columns spanned by the element */\n    span?: number | undefined;\n}\n\nconst HTMLTableColElementMap: PropertyMap<\n    JSXTableColElementInterface,\n    HTMLTableColElement\n> = {\n    ...HTMLElementMap,\n    span: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTemplateElementInterface extends JSXElementInterface {}\n\nconst HTMLTemplateElementMap: PropertyMap<\n    JSXTemplateElementInterface,\n    HTMLTemplateElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTextAreaElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Maximum number of characters per line */\n    cols?: number | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: DirValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Maximum length of value */\n    maxlength?: number | undefined;\n    /** Minimum length of value */\n    minlength?: number | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Number of lines to show */\n    rows?: number | undefined;\n    /** How the value of the form control is to be wrapped for form submission */\n    wrap?: 'soft' | 'hard' | string | undefined;\n}\n\nconst HTMLTextAreaElementMap: PropertyMap<\n    JSXTextAreaElementInterface,\n    HTMLTextAreaElement\n> = {\n    ...HTMLElementMap,\n    autocomplete: {},\n    cols: {},\n    dirname: {\n        idlName: 'dirName',\n    },\n    disabled: {},\n    form: { idlName: null },\n    maxlength: {\n        idlName: 'maxLength',\n    },\n    minlength: {\n        idlName: 'minLength',\n    },\n    name: {},\n    placeholder: {},\n    readonly: {\n        idlName: 'readOnly',\n    },\n    required: {},\n    rows: {},\n    wrap: {},\n};\n\ninterface JSXTimeElementInterface extends JSXElementInterface {\n    /** Machine-readable value */\n    datetime?: string | undefined;\n}\n\nconst HTMLTimeElementMap: PropertyMap<\n    JSXTimeElementInterface,\n    HTMLTimeElement\n> = {\n    ...HTMLElementMap,\n    datetime: {\n        idlName: 'dateTime',\n    },\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTitleElementInterface extends JSXElementInterface {}\n\nconst HTMLTitleElementMap: PropertyMap<\n    JSXTitleElementInterface,\n    HTMLTitleElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableRowElementInterface extends JSXElementInterface {}\n\nconst HTMLTableRowElementMap: PropertyMap<\n    JSXTableRowElementInterface,\n    HTMLTableRowElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTrackElementInterface extends JSXElementInterface {\n    /** The type of text track */\n    kind?:\n        | 'subtitles'\n        | 'captions'\n        | 'descriptions'\n        | 'chapters'\n        | 'metadata'\n        | string\n        | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Language of the text track */\n    srclang?: string | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Enable the track if no other text track is more suitable */\n    default?: boolean | undefined;\n}\n\nconst HTMLTrackElementMap: PropertyMap<\n    JSXTrackElementInterface,\n    HTMLTrackElement\n> = {\n    ...HTMLElementMap,\n    kind: {},\n    src: {},\n    srclang: {},\n    label: {},\n    default: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXUListElementInterface extends JSXElementInterface {}\n\nconst HTMLUListElementMap: PropertyMap<\n    JSXUListElementInterface,\n    HTMLUListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXVideoElementInterface extends JSXMediaElementInterface {\n    /** Poster frame to show prior to video playback */\n    poster?: string | undefined;\n    /** Encourage the user agent to display video content within the element's playback area */\n    playsinline?: string | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n}\n\nconst HTMLVideoElementMap: PropertyMap<\n    JSXVideoElementInterface,\n    HTMLVideoElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    preload: {},\n    autoplay: {},\n    loop: {\n        makeIdlValue: attrBooleanToEmptyString,\n    },\n    muted: {},\n    controls: {},\n    poster: {},\n    playsinline: {\n        idlName: 'playsInline',\n    },\n    width: {},\n    height: {},\n};\n\nexport const ElementTypeMapping = {\n    a: HTMLAnchorElementMap,\n    abbr: HTMLElementMap,\n    address: HTMLElementMap,\n    area: HTMLAreaElementMap,\n    article: HTMLElementMap,\n    aside: HTMLElementMap,\n    audio: HTMLAudioElementMap,\n    b: HTMLElementMap,\n    base: HTMLBaseElementMap,\n    bdi: HTMLElementMap,\n    bdo: HTMLElementMap,\n    blockquote: HTMLElementMap,\n    body: HTMLBodyElementMap,\n    br: HTMLBRElementMap,\n    button: HTMLButtonElementMap,\n    canvas: HTMLCanvasElementMap,\n    caption: HTMLTableCaptionElementMap,\n    cite: HTMLElementMap,\n    code: HTMLElementMap,\n    col: HTMLTableColElementMap,\n    colgroup: HTMLTableColElementMap,\n    data: HTMLDataElementMap,\n    datalist: HTMLDataListElementMap,\n    dd: HTMLElementMap,\n    del: HTMLModElementMap,\n    details: HTMLDetailsElementMap,\n    dfn: HTMLElementMap,\n    dialog: HTMLDialogElementMap,\n    div: HTMLDivElementMap,\n    dl: HTMLDListElementMap,\n    dt: HTMLElementMap,\n    em: HTMLElementMap,\n    embed: HTMLEmbedElementMap,\n    fieldset: HTMLFieldSetElementMap,\n    figcaption: HTMLElementMap,\n    figure: HTMLElementMap,\n    footer: HTMLElementMap,\n    form: HTMLFormElementMap,\n    h1: HTMLElementMap,\n    h2: HTMLElementMap,\n    h3: HTMLElementMap,\n    h4: HTMLElementMap,\n    h5: HTMLElementMap,\n    h6: HTMLElementMap,\n    head: HTMLHeadElementMap,\n    header: HTMLElementMap,\n    heading: HTMLHeadingElementMap,\n    hgroup: HTMLElementMap,\n    hr: HTMLHRElementMap,\n    html: HTMLHtmlElementMap,\n    i: HTMLElementMap,\n    iframe: HTMLIFrameElementMap,\n    image: HTMLImageElementMap,\n    img: HTMLElementMap,\n    input: HTMLInputElementMap,\n    ins: HTMLModElementMap,\n    kbd: HTMLElementMap,\n    label: HTMLLabelElementMap,\n    legend: HTMLLegendElementMap,\n    li: HTMLLIElementMap,\n    link: HTMLLinkElementMap,\n    main: HTMLElementMap,\n    map: HTMLMapElementMap,\n    mark: HTMLElementMap,\n    menu: HTMLMenuElementMap,\n    meta: HTMLMetaElementMap,\n    meter: HTMLMeterElementMap,\n    nav: HTMLElementMap,\n    noscript: HTMLElementMap,\n    object: HTMLObjectElementMap,\n    ol: HTMLOListElementMap,\n    optgroup: HTMLOptGroupElementMap,\n    option: HTMLOptionElementMap,\n    output: HTMLOutputElementMap,\n    p: HTMLParagraphElementMap,\n    param: HTMLParamElementMap,\n    picture: HTMLPictureElementMap,\n    pre: HTMLPreElementMap,\n    progress: HTMLProgressElementMap,\n    quote: HTMLQuoteElementMap,\n    rp: HTMLElementMap,\n    rt: HTMLElementMap,\n    ruby: HTMLElementMap,\n    s: HTMLElementMap,\n    samp: HTMLElementMap,\n    script: HTMLScriptElementMap,\n    section: HTMLElementMap,\n    select: HTMLSelectElementMap,\n    slot: HTMLSlotElementMap,\n    small: HTMLElementMap,\n    source: HTMLSourceElementMap,\n    span: HTMLSpanElementMap,\n    strong: HTMLElementMap,\n    style: HTMLStyleElementMap,\n    sub: HTMLElementMap,\n    summary: HTMLElementMap,\n    sup: HTMLElementMap,\n    table: HTMLTableElementMap,\n    tbody: HTMLTableSectionElementMap,\n    td: HTMLTableCellElementMap,\n    template: HTMLTemplateElementMap,\n    textarea: HTMLTextAreaElementMap,\n    tfoot: HTMLTableSectionElementMap,\n    th: HTMLElementMap,\n    thead: HTMLTableSectionElementMap,\n    time: HTMLTimeElementMap,\n    title: HTMLTitleElementMap,\n    tr: HTMLTableRowElementMap,\n    track: HTMLTrackElementMap,\n    u: HTMLElementMap,\n    ul: HTMLUListElementMap,\n    var: HTMLElementMap,\n    video: HTMLVideoElementMap,\n    wbr: HTMLElementMap,\n} as const;\n\n// TODO: maybe typecheck this?\ninterface ElementTypeMappingField {\n    makeAttrValue?: (jsxAttr: any) => string | undefined;\n    idlName?: any;\n    makeIdlValue?: (jsxAttr: any) => any;\n}\n\n// TODO: maybe typecheck this?\nexport function getElementTypeMapping(\n    elementName: string,\n    property: string\n): ElementTypeMappingField {\n    return (ElementTypeMapping as any)[elementName]?.[property];\n}\n\ntype WithCalculationsAndRef<\n    TJSXType extends JSXElementInterface,\n    TElement extends HTMLElement\n> = {\n    ref?: undefined | Ref<TElement> | ((current: TElement | undefined) => void);\n\n    'on:abort'?: (event: Event) => void;\n    'on:auxclick'?: (event: PointerEvent) => void;\n    'on:beforeinput'?: (event: InputEvent) => void;\n    'on:blur'?: (event: FocusEvent) => void;\n    'on:cancel'?: (event: Event) => void;\n    'on:change'?: (event: Event) => void;\n    'on:click'?: (event: PointerEvent) => void;\n    'on:close'?: (event: Event) => void;\n    'on:compositionend'?: (event: CompositionEvent) => void;\n    'on:compositionstart'?: (event: CompositionEvent) => void;\n    'on:compositionupdate'?: (event: CompositionEvent) => void;\n    'on:connect'?: (event: MessageEvent) => void;\n    'on:contextlost'?: (event: Event) => void;\n    'on:contextmenu'?: (event: PointerEvent) => void;\n    'on:contextrestored'?: (event: Event) => void;\n    'on:copy'?: (event: Event) => void;\n    'on:cut'?: (event: Event) => void;\n    'on:dblclick'?: (event: MouseEvent) => void;\n    'on:drag'?: (event: DragEvent) => void;\n    'on:dragend'?: (event: DragEvent) => void;\n    'on:dragenter'?: (event: DragEvent) => void;\n    'on:dragleave'?: (event: DragEvent) => void;\n    'on:dragover'?: (event: DragEvent) => void;\n    'on:dragstart'?: (event: DragEvent) => void;\n    'on:drop'?: (event: DragEvent) => void;\n    'on:emptied'?: (event: Event) => void;\n    'on:error'?: (event: Event) => void;\n    'on:focus'?: (event: FocusEvent) => void;\n    'on:focusin'?: (event: FocusEvent) => void;\n    'on:focusout'?: (event: FocusEvent) => void;\n    'on:formdata'?: (event: FormDataEvent) => void;\n    'on:hashchange'?: (event: HashChangeEvent) => void;\n    'on:input'?: (event: InputEvent) => void;\n    'on:invalid'?: (event: Event) => void;\n    'on:keydown'?: (event: KeyboardEvent) => void;\n    'on:keyup'?: (event: KeyboardEvent) => void;\n    'on:languagechange'?: (event: Event) => void;\n    'on:load'?: (event: Event) => void;\n    'on:loadstart'?: (event: Event) => void;\n    'on:message'?: (event: MessageEvent) => void;\n    'on:messageerror'?: (event: MessageEvent) => void;\n    'on:mousedown'?: (event: MouseEvent) => void;\n    'on:mouseenter'?: (event: MouseEvent) => void;\n    'on:mouseleave'?: (event: MouseEvent) => void;\n    'on:mousemove'?: (event: MouseEvent) => void;\n    'on:mouseout'?: (event: MouseEvent) => void;\n    'on:mouseover'?: (event: MouseEvent) => void;\n    'on:mouseup'?: (event: MouseEvent) => void;\n    'on:offline'?: (event: Event) => void;\n    'on:online'?: (event: Event) => void;\n    'on:open'?: (event: Event) => void;\n    'on:pagehide'?: (event: PageTransitionEvent) => void;\n    'on:pageshow'?: (event: PageTransitionEvent) => void;\n    'on:paste'?: (event: Event) => void;\n    'on:popstate'?: (event: PopStateEvent) => void;\n    'on:progress'?: (event: Event) => void;\n    'on:readystatechange'?: (event: Event) => void;\n    'on:rejectionhandled'?: (event: PromiseRejectionEvent) => void;\n    'on:reset'?: (event: Event) => void;\n    'on:securitypolicyviolation'?: (event: Event) => void;\n    'on:select'?: (event: Event) => void;\n    'on:slotchange'?: (event: Event) => void;\n    'on:stalled'?: (event: Event) => void;\n    'on:storage'?: (event: StorageEvent) => void;\n    'on:submit'?: (event: SubmitEvent) => void;\n    'on:suspend'?: (event: Event) => void;\n    'on:toggle'?: (event: Event) => void;\n    'on:unhandledrejection'?: (event: PromiseRejectionEvent) => void;\n    'on:unload'?: (event: Event) => void;\n    'on:visibilitychange'?: (event: Event) => void;\n    'on:wheel'?: (event: WheelEvent) => void;\n} & {\n    //[key: `on:${string}`]: EventHandler<Event> | undefined;\n    [key: `data-${string}`]:\n        | Calculation<string | undefined>\n        | string\n        | undefined;\n} & {\n    [Key in keyof TJSXType]: Calculation<TJSXType[Key]> | TJSXType[Key];\n};\n\nexport interface KnownElements {\n    a: WithCalculationsAndRef<JSXAnchorElementInterface, HTMLAnchorElement>;\n    abbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    address: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    area: WithCalculationsAndRef<JSXAreaElementInterface, HTMLAreaElement>;\n    article: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    aside: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    audio: WithCalculationsAndRef<JSXAudioElementInterface, HTMLAudioElement>;\n    b: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    base: WithCalculationsAndRef<JSXBaseElementInterface, HTMLBaseElement>;\n    bdi: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    bdo: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    blockquote: WithCalculationsAndRef<\n        JSXQuoteElementInterface,\n        HTMLQuoteElement\n    >;\n    body: WithCalculationsAndRef<JSXBodyElementInterface, HTMLBodyElement>;\n    br: WithCalculationsAndRef<JSXBRElementInterface, HTMLBRElement>;\n    button: WithCalculationsAndRef<\n        JSXButtonElementInterface,\n        HTMLButtonElement\n    >;\n    canvas: WithCalculationsAndRef<\n        JSXCanvasElementInterface,\n        HTMLCanvasElement\n    >;\n    caption: WithCalculationsAndRef<\n        JSXTableCaptionElementInterface,\n        HTMLTableCaptionElement\n    >;\n    cite: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    code: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    col: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement\n    >;\n    colgroup: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement\n    >;\n    data: WithCalculationsAndRef<JSXDataElementInterface, HTMLDataElement>;\n    datalist: WithCalculationsAndRef<\n        JSXDataListElementInterface,\n        HTMLDataListElement\n    >;\n    dd: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    del: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement>;\n    details: WithCalculationsAndRef<\n        JSXDetailsElementInterface,\n        HTMLDetailsElement\n    >;\n    dfn: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    dialog: WithCalculationsAndRef<\n        JSXDialogElementInterface,\n        HTMLDialogElement\n    >;\n    div: WithCalculationsAndRef<JSXDivElementInterface, HTMLDivElement>;\n    dl: WithCalculationsAndRef<JSXDListElementInterface, HTMLDListElement>;\n    dt: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    em: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    embed: WithCalculationsAndRef<JSXEmbedElementInterface, HTMLEmbedElement>;\n    fieldset: WithCalculationsAndRef<\n        JSXFieldSetElementInterface,\n        HTMLFieldSetElement\n    >;\n    figcaption: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    figure: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    footer: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    form: WithCalculationsAndRef<JSXFormElementInterface, HTMLFormElement>;\n    h1: WithCalculationsAndRef<JSXHeadingElementInterface, HTMLHeadingElement>;\n    h2: WithCalculationsAndRef<JSXHeadingElementInterface, HTMLHeadingElement>;\n    h3: WithCalculationsAndRef<JSXHeadingElementInterface, HTMLHeadingElement>;\n    h4: WithCalculationsAndRef<JSXHeadingElementInterface, HTMLHeadingElement>;\n    h5: WithCalculationsAndRef<JSXHeadingElementInterface, HTMLHeadingElement>;\n    h6: WithCalculationsAndRef<JSXHeadingElementInterface, HTMLHeadingElement>;\n    head: WithCalculationsAndRef<JSXHeadElementInterface, HTMLHeadElement>;\n    header: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    hgroup: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    hr: WithCalculationsAndRef<JSXHRElementInterface, HTMLHRElement>;\n    html: WithCalculationsAndRef<JSXHtmlElementInterface, HTMLHtmlElement>;\n    i: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    iframe: WithCalculationsAndRef<\n        JSXIFrameElementInterface,\n        HTMLIFrameElement\n    >;\n    img: WithCalculationsAndRef<JSXImageElementInterface, HTMLImageElement>;\n    input: WithCalculationsAndRef<JSXInputElementInterface, HTMLInputElement>;\n    ins: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement>;\n    kbd: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    label: WithCalculationsAndRef<JSXLabelElementInterface, HTMLLabelElement>;\n    legend: WithCalculationsAndRef<\n        JSXLegendElementInterface,\n        HTMLLegendElement\n    >;\n    li: WithCalculationsAndRef<JSXLIElementInterface, HTMLLIElement>;\n    link: WithCalculationsAndRef<JSXLinkElementInterface, HTMLLinkElement>;\n    main: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    map: WithCalculationsAndRef<JSXMapElementInterface, HTMLMapElement>;\n    mark: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    menu: WithCalculationsAndRef<JSXMenuElementInterface, HTMLMenuElement>;\n    meta: WithCalculationsAndRef<JSXMetaElementInterface, HTMLMetaElement>;\n    meter: WithCalculationsAndRef<JSXMeterElementInterface, HTMLMeterElement>;\n    nav: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    noscript: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    object: WithCalculationsAndRef<\n        JSXObjectElementInterface,\n        HTMLObjectElement\n    >;\n    ol: WithCalculationsAndRef<JSXOListElementInterface, HTMLOListElement>;\n    optgroup: WithCalculationsAndRef<\n        JSXOptGroupElementInterface,\n        HTMLOptGroupElement\n    >;\n    option: WithCalculationsAndRef<\n        JSXOptionElementInterface,\n        HTMLOptionElement\n    >;\n    output: WithCalculationsAndRef<\n        JSXOutputElementInterface,\n        HTMLOutputElement\n    >;\n    p: WithCalculationsAndRef<\n        JSXParagraphElementInterface,\n        HTMLParagraphElement\n    >;\n    param: WithCalculationsAndRef<JSXParamElementInterface, HTMLParamElement>;\n    picture: WithCalculationsAndRef<\n        JSXPictureElementInterface,\n        HTMLPictureElement\n    >;\n    pre: WithCalculationsAndRef<JSXPreElementInterface, HTMLPreElement>;\n    progress: WithCalculationsAndRef<\n        JSXProgressElementInterface,\n        HTMLProgressElement\n    >;\n    q: WithCalculationsAndRef<JSXQuoteElementInterface, HTMLQuoteElement>;\n    rp: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    rt: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    ruby: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    s: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    samp: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    script: WithCalculationsAndRef<\n        JSXScriptElementInterface,\n        HTMLScriptElement\n    >;\n    section: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    select: WithCalculationsAndRef<\n        JSXSelectElementInterface,\n        HTMLSelectElement\n    >;\n    slot: WithCalculationsAndRef<JSXSlotElementInterface, HTMLSlotElement>;\n    small: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    source: WithCalculationsAndRef<\n        JSXSourceElementInterface,\n        HTMLSourceElement\n    >;\n    span: WithCalculationsAndRef<JSXSpanElementInterface, HTMLSpanElement>;\n    strong: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    style: WithCalculationsAndRef<JSXStyleElementInterface, HTMLStyleElement>;\n    sub: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    summary: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    sup: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    table: WithCalculationsAndRef<JSXTableElementInterface, HTMLTableElement>;\n    tbody: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement\n    >;\n    td: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement\n    >;\n    template: WithCalculationsAndRef<\n        JSXTemplateElementInterface,\n        HTMLTemplateElement\n    >;\n    textarea: WithCalculationsAndRef<\n        JSXTextAreaElementInterface,\n        HTMLTextAreaElement\n    >;\n    tfoot: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement\n    >;\n    th: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement\n    >;\n    thead: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement\n    >;\n    time: WithCalculationsAndRef<JSXTimeElementInterface, HTMLTimeElement>;\n    title: WithCalculationsAndRef<JSXTitleElementInterface, HTMLTitleElement>;\n    tr: WithCalculationsAndRef<\n        JSXTableRowElementInterface,\n        HTMLTableRowElement\n    >;\n    track: WithCalculationsAndRef<JSXTrackElementInterface, HTMLTrackElement>;\n    u: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    ul: WithCalculationsAndRef<JSXUListElementInterface, HTMLUListElement>;\n    var: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n    video: WithCalculationsAndRef<JSXVideoElementInterface, HTMLVideoElement>;\n    wbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement>;\n}\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        interface IntrinsicElements extends KnownElements {\n            [unknownElement: string]: any;\n        }\n        type Element = JSXNode;\n    }\n}\n", "import { JSXNode } from './jsx';\nimport { groupBy } from './util';\nimport * as log from './log';\n\n/**\n * A VNode represents a node in the JSX tree structure\n *\n * Since a JSXNode may render to 0, 1, or many DOM nodes, we need to keep track\n * of the virtual tree structure to understand which index to update within the\n * DOM tree.\n */\nexport type ChildVNode = {\n    domNode: Node | null;\n    children: VNode[];\n    domParent: VNode;\n    mountFragment: DocumentFragment | null;\n    jsxNode: JSXNode | null;\n    onMount: Function[];\n    onUnmount: Function[];\n};\nexport type RootVNode = {\n    domNode: Node | null;\n    children: VNode[];\n    domParent: VNode;\n    mountFragment: DocumentFragment | null;\n    jsxNode: JSXNode | null;\n    onMount: Function[];\n    onUnmount: Function[];\n};\nexport type VNode = ChildVNode | RootVNode;\n\nexport function makeRootVNode({ domNode }: { domNode: Node }): RootVNode {\n    const rootVNode: RootVNode = {\n        domNode,\n        children: [],\n        domParent: null,\n        mountFragment: document.createDocumentFragment(),\n        jsxNode: null,\n        onMount: [],\n        onUnmount: [],\n    } as unknown as RootVNode; // We lie here since domParent needs to be self-referential\n    rootVNode.domParent = rootVNode;\n    return rootVNode;\n}\n\nexport function makeChildVNode({\n    jsxNode,\n    domNode,\n    domParent,\n    onMount,\n    onUnmount,\n}: {\n    domParent: VNode;\n    jsxNode: JSXNode | null;\n    domNode: Node | null;\n    onMount: Function[];\n    onUnmount: Function[];\n}): ChildVNode {\n    return {\n        domNode,\n        children: [],\n        domParent,\n        mountFragment: domNode ? document.createDocumentFragment() : null,\n        jsxNode,\n        onMount,\n        onUnmount,\n    };\n}\n\n/**\n * Get shallow DOM nodes from the virtual tree.\n *\n * For example, with this virtual tree:\n *\n * <root>\n *   <A>...</A>\n *   <B>\n *     <B1>\n *      <div id=\"b_1_1\">...</div>\n *      {false}\n *      {[\n *        <div id=\"b_1_arr_1\">...</div>\n *        <div id=\"b_1_arr_2\">...</div>\n *      ]}\n *      <SubComponent>\n *        <div id=\"b_1_sub_1\">...</div>\n *        <div id=\"b_1_sub_2\">...</div>\n *      </SubComponent>\n *      <div id=\"b_1_3\">...</div>\n *     </B1>\n *   </B>\n *   <C>\n *     ...\n *   </C>\n * </root>\n *\n * If getShallowNodes is called with <B> as the target, this would retrieve:\n * [b_1_1, b_1_arr_1, b_1_arr_2, b_1_sub_1, b_1_sub_2, b_1_3]\n */\nfunction getShallowNodes(vNode: VNode): Node[] {\n    const nodes: Node[] = [];\n    function visit(node: VNode) {\n        if (node.domNode) {\n            nodes.push(node.domNode);\n        } else {\n            node.children.forEach((child) => visit(child));\n        }\n    }\n    visit(vNode);\n    return nodes;\n}\n\nfunction getDomParentChildIndex(\n    domParent: VNode,\n    immediateParent: VNode,\n    childIndex: number\n): number {\n    let realIndex = 0;\n\n    function visit(node: VNode): boolean {\n        if (node.domNode) {\n            realIndex += 1;\n            return false;\n        } else {\n            return visitChildren(node);\n        }\n    }\n    function visitChildren(node: VNode): boolean {\n        const visitIndex =\n            node === immediateParent ? childIndex : node.children.length;\n        for (let i = 0; i < visitIndex; ++i) {\n            if (visit(node.children[i])) {\n                return true;\n            }\n        }\n        return node === immediateParent;\n    }\n    visitChildren(domParent);\n    return realIndex;\n}\n\nexport function callOnMount(node: VNode) {\n    // Note: we are doing a post-order traversal, so all children onMount are called before parents are called\n    node.children.forEach((child) => callOnMount(child));\n\n    // Call any onMount listeners\n    if (node.onMount) {\n        node.onMount.forEach((onMount) => {\n            try {\n                onMount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onMount',\n                    node\n                );\n            }\n        });\n    }\n}\n\nfunction callOnUnmount(node: VNode) {\n    // Note: we are doing a post-order traversal, so all children are released/unmounted before parents are released/unmounted\n    node.children.forEach((child) => callOnUnmount(child));\n\n    // Call any onUnmount listeners\n    if (node.onUnmount) {\n        node.onUnmount.forEach((onUnmount) => {\n            try {\n                onUnmount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onUnmount',\n                    node\n                );\n            }\n        });\n    }\n}\n\nexport function mountVNode(vNode: VNode) {\n    if (vNode.domNode && vNode.domParent.mountFragment) {\n        vNode.domParent.mountFragment.appendChild(vNode.domNode);\n    }\n}\n\nexport function spliceVNode(\n    immediateParent: VNode,\n    childIndex: number,\n    removeCount: number,\n    newNodes: VNode[],\n    { dispose = true, runOnMount = true, runOnUnmount = true } = {}\n) {\n    let domParent: VNode;\n    if (immediateParent.children[childIndex]) {\n        domParent = immediateParent.children[childIndex].domParent;\n    } else {\n        childIndex = immediateParent.children.length;\n        domParent = immediateParent.domNode\n            ? immediateParent\n            : immediateParent.domParent;\n    }\n    log.assert(\n        domParent,\n        'tried to replace a root tree slot with missing domParent'\n    );\n\n    const detachedVNodes = immediateParent.children.splice(\n        childIndex,\n        removeCount,\n        ...newNodes\n    );\n\n    // Remove nodes, optimizing for array replacement, where all nodes are completely removed via .replaceChildren()\n    const toRemove: [ParentNode, Node][] = [];\n    detachedVNodes.forEach((detachedVNode) => {\n        if (runOnUnmount) {\n            callOnUnmount(detachedVNode);\n        }\n\n        const nodesToRemove = getShallowNodes(detachedVNode);\n        nodesToRemove.forEach((node) => {\n            if (node.parentNode) {\n                toRemove.push([node.parentNode, node]);\n            }\n        });\n        if (dispose) {\n            detachedVNode.domParent = null as any;\n            detachedVNode.mountFragment = null as any;\n            detachedVNode.children = null as any;\n            detachedVNode.domNode = null as any;\n            detachedVNode.onMount = null as any;\n            detachedVNode.onUnmount = null as any;\n        }\n    });\n    const groupedToRemove = groupBy(toRemove, (item) => item);\n    groupedToRemove.forEach((childNodes, parentNode) => {\n        if (parentNode.childNodes.length === childNodes.length) {\n            parentNode.replaceChildren();\n        } else {\n            childNodes.forEach((child) => parentNode.removeChild(child));\n        }\n    });\n\n    if (!domParent.domNode) {\n        throw new Error('Invariant: domParent missing domNode');\n    }\n    const domParentNode = domParent.domNode;\n\n    // Insert nodes via fragment with a single DOM operation\n    if (newNodes.length > 0) {\n        const domIndex = getDomParentChildIndex(\n            domParent,\n            immediateParent,\n            childIndex\n        );\n        const referenceNode: Node | undefined =\n            domParentNode.childNodes[domIndex];\n\n        const fragment = document.createDocumentFragment();\n\n        for (let i = 0; i < newNodes.length; ++i) {\n            const newNode = newNodes[i];\n            newNode.domParent = domParent;\n            const nodesToAdd = getShallowNodes(newNode);\n            nodesToAdd.forEach((addNode) => {\n                fragment.appendChild(addNode);\n            });\n        }\n\n        domParentNode.insertBefore(fragment, referenceNode || null);\n        if (runOnMount) {\n            newNodes.forEach((newNode) => {\n                callOnMount(newNode);\n            });\n        }\n    }\n    return detachedVNodes;\n}\n", "import {\n    effect,\n    retain,\n    release,\n    untracked,\n    addOrderingDep,\n    removeOrderingDep,\n} from './calc';\nimport { name, debugNameFor } from './debug';\nimport {\n    Collection,\n    View,\n    Context,\n    NodeOrdering,\n    isContext,\n    isCalculation,\n    isCollection,\n    isRef,\n    ObserveKey,\n    GetSubscriptionNodeKey,\n    TypeTag,\n} from './types';\nimport * as log from './log';\nimport {\n    Component,\n    JSXNode,\n    isRenderComponent,\n    isRenderElement,\n    isRenderProvider,\n    getElementTypeMapping,\n} from './jsx';\nimport {\n    VNode,\n    ChildVNode,\n    mountVNode,\n    spliceVNode,\n    makeChildVNode,\n    makeRootVNode,\n    callOnMount,\n} from './vnode';\n\nexport function createElement(\n    Constructor: string,\n    props?: any,\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<TContext>(\n    Constructor: Context<TContext>,\n    props: { value: TContext },\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<Props extends {}>(\n    Constructor: Component<Props>,\n    props?: Props,\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<Props extends {}>(\n    Constructor: Component<Props>,\n    props?: Props,\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<TContext, Props extends {}>(\n    Constructor: string | Component<Props> | Context<TContext>,\n    props?: any | Props | { value: TContext },\n    ...children: JSXNode[]\n): JSXNode {\n    if (typeof Constructor === 'string') {\n        return {\n            [TypeTag]: 'element',\n            element: Constructor,\n            props,\n            children,\n        };\n    }\n    if (isContext(Constructor)) {\n        return {\n            [TypeTag]: 'provider',\n            context: Constructor,\n            value: props.value,\n            children,\n        };\n    }\n    return {\n        [TypeTag]: 'component',\n        component: Constructor as Component<Props>,\n        props,\n        children,\n    };\n}\n\nconst boundEvents = new WeakMap<Element, Record<string, (ev: Event) => void>>();\n\nfunction setAttributeValue(\n    elementType: string,\n    element: Element,\n    key: string,\n    value: unknown\n) {\n    if (key.startsWith('on:') && typeof value === 'function') {\n        const eventName = key.slice(3);\n        let attributes = boundEvents.get(element);\n        if (!attributes) {\n            attributes = {};\n            boundEvents.set(element, attributes);\n        }\n        if (attributes[key]) {\n            element.removeEventListener(eventName, attributes[key]);\n        }\n        element.addEventListener(eventName, value as any);\n        attributes[key] = value as any;\n    } else {\n        const mapping = getElementTypeMapping(elementType, key);\n        if (mapping) {\n            if (mapping.makeAttrValue !== null) {\n                const attributeValue = mapping.makeAttrValue\n                    ? mapping.makeAttrValue(value)\n                    : (value as any);\n                if (\n                    attributeValue === undefined ||\n                    attributeValue === null ||\n                    attributeValue === false\n                ) {\n                    element.removeAttribute(key);\n                } else if (attributeValue === true) {\n                    element.setAttribute(key, '');\n                } else {\n                    element.setAttribute(key, attributeValue);\n                }\n            }\n            if (mapping.idlName !== null) {\n                (element as any)[mapping.idlName ?? key] = mapping.makeIdlValue\n                    ? mapping.makeIdlValue(value)\n                    : value;\n            }\n        } else if (value === false || value === undefined || value === null) {\n            element.removeAttribute(key);\n        } else if (value === true) {\n            element.setAttribute(key, '');\n        } else if (typeof value === 'string') {\n            element.setAttribute(key, value);\n        }\n    }\n}\n\nfunction jsxNodeToVNode({\n    domParent,\n    jsxNode,\n    contextMap,\n    parentNodeOrdering,\n}: {\n    domParent: VNode;\n    jsxNode: JSXNode;\n    contextMap: Map<Context<any>, any>;\n    parentNodeOrdering: NodeOrdering;\n}): ChildVNode {\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        jsxNode === false ||\n        jsxNode === true\n    ) {\n        const emptyVNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount: [],\n        });\n        mountVNode(emptyVNode);\n        return emptyVNode;\n    }\n    if (typeof jsxNode === 'string') {\n        const stringVNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: document.createTextNode(jsxNode),\n            onMount: [],\n            onUnmount: [],\n        });\n        mountVNode(stringVNode);\n        return stringVNode;\n    }\n    if (typeof jsxNode === 'number') {\n        const numberVNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: document.createTextNode(jsxNode.toString()),\n            onMount: [],\n            onUnmount: [],\n        });\n        mountVNode(numberVNode);\n        return numberVNode;\n    }\n    if (isRenderElement(jsxNode)) {\n        const element = document.createElement(jsxNode.element);\n\n        const onReleaseActions: (() => void)[] = [];\n        let refCallback: any = undefined;\n\n        // Bind props\n        if (jsxNode.props) {\n            Object.entries(jsxNode.props).forEach(([key, value]) => {\n                if (key === 'ref') {\n                    if (isRef(value)) {\n                        value.current = element;\n                        return;\n                    }\n                    if (typeof value === 'function' && !isCalculation(value)) {\n                        refCallback = value;\n                        return;\n                    }\n                }\n                if (isCalculation(value)) {\n                    const boundEffect = effect(() => {\n                        const computedValue = value();\n                        setAttributeValue(\n                            jsxNode.element,\n                            element,\n                            key,\n                            computedValue\n                        );\n                    }, `viewattr:${key}`);\n                    onReleaseActions.push(() => {\n                        removeOrderingDep(boundEffect, parentNodeOrdering);\n                    });\n                    addOrderingDep(boundEffect, parentNodeOrdering);\n\n                    boundEffect();\n                } else {\n                    setAttributeValue(jsxNode.element, element, key, value);\n                }\n            });\n        }\n\n        const elementNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: element,\n            onMount: [\n                () => {\n                    if (refCallback) {\n                        refCallback(element);\n                    }\n                },\n            ],\n            onUnmount: [\n                () => {\n                    onReleaseActions.forEach((action) => action());\n                    if (refCallback) {\n                        refCallback(undefined);\n                    }\n                },\n            ],\n        });\n        elementNode.children = jsxNode.children.map((childJsxNode) =>\n            jsxNodeToVNode({\n                domParent: elementNode,\n                jsxNode: childJsxNode,\n                contextMap,\n                parentNodeOrdering,\n            })\n        );\n\n        // Mount self\n        if (elementNode.mountFragment) {\n            element.appendChild(elementNode.mountFragment);\n            elementNode.mountFragment = null;\n        }\n        mountVNode(elementNode);\n\n        return elementNode;\n    }\n    if (isCollection(jsxNode)) {\n        const trackedCollection: Collection<any> | View<any> = jsxNode;\n        const onUnmount: (() => void)[] = [];\n\n        const collectionNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount,\n        });\n\n        const collectionNodeOrdering = makeNodeOrdering(\n            DEBUG\n                ? `viewcoll:${debugNameFor(jsxNode) ?? 'node'}:order`\n                : 'viewcoll:order'\n        );\n        addOrderingDep(collectionNodeOrdering, parentNodeOrdering);\n        onUnmount.push(() => {\n            removeOrderingDep(collectionNodeOrdering, parentNodeOrdering);\n        });\n\n        untracked(() => {\n            collectionNode.children.push(\n                ...trackedCollection.map((jsxChild) =>\n                    jsxNodeToVNode({\n                        domParent: collectionNode.domParent,\n                        jsxNode: jsxChild,\n                        contextMap,\n                        parentNodeOrdering: collectionNodeOrdering,\n                    })\n                )\n            );\n        });\n\n        const unobserve = trackedCollection[ObserveKey]((events) => {\n            events.forEach((event) => {\n                if (event.type === 'splice') {\n                    untracked(() => {\n                        const { count, index, items } = event;\n                        const childNodes = items.map((jsxChild) =>\n                            jsxNodeToVNode({\n                                domParent: collectionNode.domParent,\n                                jsxNode: jsxChild,\n                                contextMap,\n                                parentNodeOrdering: collectionNodeOrdering,\n                            })\n                        );\n                        spliceVNode(collectionNode, index, count, childNodes);\n                    });\n                } else if (event.type === 'move') {\n                    const { fromIndex, fromCount, toIndex } = event;\n                    const moved = spliceVNode(\n                        collectionNode,\n                        fromIndex,\n                        fromCount,\n                        [],\n                        { dispose: false, runOnUnmount: false }\n                    );\n                    spliceVNode(\n                        collectionNode,\n                        fromIndex < toIndex ? toIndex - fromCount : toIndex,\n                        0,\n                        moved,\n                        { runOnMount: false }\n                    );\n                } else if (event.type === 'sort') {\n                    const { indexes } = event;\n                    const removedVNodes = spliceVNode(\n                        collectionNode,\n                        0,\n                        indexes.length,\n                        [],\n                        { dispose: false, runOnUnmount: false }\n                    );\n                    const sortedVNodes = indexes.map(\n                        (newIndex) => removedVNodes[newIndex]\n                    );\n                    spliceVNode(collectionNode, 0, 0, sortedVNodes, {\n                        runOnMount: false,\n                    });\n                } else {\n                    log.assertExhausted(event, 'unhandled collection event');\n                }\n            });\n        });\n        const subscriptionNode = trackedCollection[GetSubscriptionNodeKey]();\n\n        addOrderingDep(subscriptionNode, collectionNodeOrdering);\n        onUnmount.push(unobserve);\n        onUnmount.push(() => {\n            removeOrderingDep(subscriptionNode, collectionNodeOrdering);\n        });\n\n        // Mount self\n        mountVNode(collectionNode);\n\n        return collectionNode;\n    }\n    if (isCalculation(jsxNode)) {\n        const trackedCalculation = jsxNode;\n        const onUnmount: (() => void)[] = [];\n        const calculationNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount,\n        });\n\n        const calculationNodeOrdering = makeNodeOrdering(\n            DEBUG\n                ? `viewcalc:${debugNameFor(jsxNode) ?? 'node'}:order`\n                : 'viewcalc:order'\n        );\n        addOrderingDep(calculationNodeOrdering, parentNodeOrdering);\n        onUnmount.push(() => {\n            removeOrderingDep(calculationNodeOrdering, parentNodeOrdering);\n        });\n\n        let firstRun = true;\n        const resultEffect = effect(() => {\n            const jsxChild = trackedCalculation();\n            const childVNode = jsxNodeToVNode({\n                domParent: calculationNode.domParent,\n                jsxNode: jsxChild,\n                contextMap,\n                parentNodeOrdering: calculationNodeOrdering,\n            });\n            if (firstRun) {\n                firstRun = false;\n                calculationNode.children.push(childVNode);\n            } else {\n                spliceVNode(\n                    calculationNode,\n                    0,\n                    calculationNode.children.length,\n                    [childVNode]\n                );\n            }\n        }, `viewcalc:${debugNameFor(jsxNode) ?? 'node'}`);\n\n        onUnmount.push(() => {\n            removeOrderingDep(resultEffect, calculationNodeOrdering);\n        });\n        addOrderingDep(resultEffect, calculationNodeOrdering);\n\n        resultEffect();\n\n        // Mount self\n        mountVNode(calculationNode);\n\n        return calculationNode;\n    }\n    if (isRenderProvider(jsxNode)) {\n        const renderProvider = jsxNode;\n        const providerNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount: [],\n        });\n\n        const subMap = new Map(contextMap);\n        subMap.set(renderProvider.context, renderProvider.value);\n\n        providerNode.children.push(\n            ...renderProvider.children.map((jsxChild) =>\n                jsxNodeToVNode({\n                    domParent: domParent,\n                    jsxNode: jsxChild,\n                    contextMap: subMap,\n                    parentNodeOrdering,\n                })\n            )\n        );\n\n        // Mount self\n        mountVNode(providerNode);\n\n        return providerNode;\n    }\n    if (isRenderComponent(jsxNode)) {\n        const onUnmount: Function[] = [];\n\n        const componentNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount,\n        });\n\n        const Component = jsxNode.component;\n        const onComponentMount: Function[] = [];\n        const jsxChild = Component(\n            {\n                ...(jsxNode.props || {}),\n                children: jsxNode.children,\n            },\n            {\n                onUnmount: (unmountCallback) => {\n                    onUnmount.push(unmountCallback);\n                },\n                onMount: (mountCallback) => {\n                    onComponentMount.push(mountCallback);\n                },\n                onEffect: (effectCallback: () => void, debugName?: string) => {\n                    const effectCalc = effect(\n                        effectCallback,\n                        `componenteffect:${jsxNode.component.name}:${\n                            debugName ?? onComponentMount.length\n                        }`\n                    );\n                    onComponentMount.push(() => {\n                        retain(effectCalc);\n                        addOrderingDep(parentNodeOrdering, effectCalc);\n                        effectCalc();\n                    });\n                    onUnmount.push(() => {\n                        removeOrderingDep(parentNodeOrdering, effectCalc);\n                        release(effectCalc);\n                    });\n                },\n                getContext: <TVal>(context: Context<TVal>): TVal => {\n                    if (contextMap.has(context)) {\n                        return contextMap.get(context);\n                    }\n                    return context();\n                },\n            }\n        );\n\n        const childVNode = jsxNodeToVNode({\n            domParent: componentNode.domParent,\n            jsxNode: jsxChild,\n            contextMap,\n            parentNodeOrdering,\n        });\n        componentNode.children.push(childVNode);\n\n        onComponentMount.forEach((mountCallback) =>\n            componentNode.onMount.push(mountCallback)\n        );\n\n        // Mount self\n        mountVNode(componentNode);\n\n        return componentNode;\n    }\n    if (Array.isArray(jsxNode)) {\n        const items = jsxNode;\n        const arrayNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount: [],\n        });\n\n        arrayNode.children.push(\n            ...items.map((jsxChild) =>\n                jsxNodeToVNode({\n                    domParent: domParent,\n                    jsxNode: jsxChild,\n                    contextMap,\n                    parentNodeOrdering,\n                })\n            )\n        );\n\n        // Mount self\n        mountVNode(arrayNode);\n\n        return arrayNode;\n    }\n    if (typeof jsxNode === 'function') {\n        const functionVNode = makeChildVNode({\n            domParent: domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onMount: [],\n            onUnmount: [],\n        });\n        log.warn(\n            'Attempted to render JSX node that was a function, not rendering anything'\n        );\n\n        // Mount self\n        mountVNode(functionVNode);\n\n        return functionVNode;\n    }\n    log.assertExhausted(jsxNode, 'unexpected render type');\n}\n\nfunction makeNodeOrdering(debugName?: string): NodeOrdering {\n    const nodeOrdering: NodeOrdering = {\n        [TypeTag]: 'nodeOrdering',\n    };\n    if (debugName) name(nodeOrdering, debugName);\n    return nodeOrdering;\n}\n\n/**\n * Mount the provided JSX to an element\n */\nexport function mount(parentElement: Element, jsxNode: JSXNode) {\n    const nodeOrdering = makeNodeOrdering('mount');\n    retain(nodeOrdering);\n    const rootNode = makeRootVNode({ domNode: parentElement });\n    rootNode.children.push(\n        jsxNodeToVNode({\n            domParent: rootNode,\n            jsxNode: jsxNode,\n            contextMap: new Map(),\n            parentNodeOrdering: nodeOrdering,\n        })\n    );\n\n    // Mount self\n    if (rootNode.mountFragment) {\n        parentElement.appendChild(rootNode.mountFragment);\n        rootNode.mountFragment = null;\n    }\n\n    // Call onMount callbacks\n    callOnMount(rootNode);\n\n    return () => {\n        spliceVNode(rootNode, 0, rootNode.children.length, []);\n        release(nodeOrdering);\n    };\n}\n\nexport const Fragment = ({ children }: { children: JSXNode[] }) => children;\n", "import {\n    Collection,\n    FilterFunction,\n    FlatMapFunction,\n    InvariantError,\n    MappingFunction,\n    View,\n    NotifyKey,\n} from './types';\nimport * as log from './log';\nimport { trackedData } from './trackeddata';\n\n// https://tc39.es/ecma262/multipage/indexed-collections.html#sec-sortcompare\nfunction defaultSort(x: any, y: any) {\n    if (x === undefined && y === undefined) return 0;\n    if (x === undefined) return 1;\n    if (y === undefined) return -1;\n    const xStr = '' + x;\n    const yStr = '' + y;\n    if (xStr < yStr) return -1;\n    if (xStr > yStr) return 1;\n    return 0;\n}\n\n/**\n * Make a mutable array to hold state, with some additional convenience methods\n */\nexport function collection<T>(array: T[], debugName?: string): Collection<T> {\n    if (!Array.isArray(array)) {\n        throw new InvariantError('collection must be provided an array');\n    }\n\n    return trackedData(\n        array,\n        'collection' as const,\n        {\n            get(notify, target, key) {\n                return target[key];\n            },\n\n            has(notify, target, key) {\n                return key in target;\n            },\n\n            set(this: Collection<T>, notify, target, key, value) {\n                if (\n                    key === 'length' &&\n                    typeof value === 'number' &&\n                    value < target.length\n                ) {\n                    // Special handling of resizing length smaller than normal length to handle removing of items\n                    this.splice(value, target.length - value);\n                    return true;\n                }\n                const numericKey = Number(key);\n                if (!isNaN(numericKey) && numericKey <= array.length) {\n                    this.splice(numericKey, 1, value);\n                } else {\n                    target[key] = value;\n                }\n                return true;\n            },\n\n            deleteProperty(notify, target, key) {\n                delete target[key];\n                return true;\n            },\n        },\n        ({\n            notify,\n            subscriptionNode,\n            makeView,\n            processFieldChange,\n            processFieldDelete,\n        }) => ({\n            splice: function splice(\n                index: number,\n                count: number,\n                ...items: T[]\n            ): T[] {\n                if (count < 1 && items.length === 0) return []; // noop\n                const origLength = array.length;\n                const removed = array.splice(index, count, ...items);\n                const newLength = array.length;\n                notify({\n                    type: 'splice',\n                    index,\n                    count,\n                    items,\n                    removed,\n                });\n\n                // Cases to consider:\n                // 1. count === items.length: we are replacing count items\n                // 2. count > items.length: we are adding (count - items.length items), notify index to new end\n                // 3. count < items.length: we are removing (items.length - count items), notify index to old end\n\n                // Process changes in *added* items\n                if (origLength === newLength) {\n                    for (let i = index; i < index + count; ++i) {\n                        processFieldChange(i.toString());\n                    }\n                } else {\n                    for (\n                        let i = index;\n                        i < Math.max(newLength, origLength);\n                        ++i\n                    ) {\n                        const key = i.toString();\n                        if (i >= newLength) {\n                            // Field deletion\n                            processFieldDelete(key);\n                        } else {\n                            // Field change\n                            processFieldChange(key);\n                        }\n                    }\n                    processFieldChange('length');\n                }\n                return removed;\n            },\n            pop: function pop(this: Collection<T>): T | undefined {\n                const removed = this.splice(array.length - 1, 1);\n                return removed[0];\n            },\n            shift: function shift(this: Collection<T>): T | undefined {\n                const removed = this.splice(0, 1);\n                return removed[0];\n            },\n            push: function push(this: Collection<T>, ...items: T[]): number {\n                this.splice(array.length, 0, ...items);\n                return array.length;\n            },\n            unshift: function unshift(\n                this: Collection<T>,\n                ...items: T[]\n            ): number {\n                this.splice(0, 0, ...items);\n                return array.length;\n            },\n            reject: function reject(\n                this: Collection<T>,\n                func: (item: T, index: number) => boolean\n            ) {\n                for (let i = array.length - 1; i >= 0; --i) {\n                    if (func(this[i], i)) {\n                        this.splice(i, 1);\n                    }\n                }\n            },\n            moveSlice: function moveSlice(\n                this: Collection<T>,\n                fromIndex: number,\n                fromCount: number,\n                toIndex: number\n            ) {\n                if (fromCount <= 0) return; // nothing to slice\n                if (toIndex >= fromIndex && toIndex < fromIndex + fromCount)\n                    return; // destination is inside moved slice, so noop\n                const moved = array.splice(fromIndex, fromCount);\n                if (toIndex < fromIndex) {\n                    array.splice(toIndex, 0, ...moved);\n                } else {\n                    array.splice(toIndex - fromCount, 0, ...moved);\n                }\n                notify({\n                    type: 'move',\n                    fromIndex,\n                    fromCount,\n                    toIndex,\n                    moved,\n                });\n            },\n            sort: function sort(\n                this: Collection<T>,\n                sorter: (a: T, b: T) => number = defaultSort\n            ): T[] {\n                const arrayWithIndexes: [T, number][] = array.map(\n                    (item, index) => [item, index]\n                );\n                array.sort(sorter);\n                arrayWithIndexes.sort((ai, bi) => sorter(ai[0], bi[0]));\n                notify({\n                    type: 'sort',\n                    indexes: arrayWithIndexes.map((pair) => pair[1]),\n                });\n                return this;\n            },\n            reverse: function reverse(\n                this: Collection<T>,\n                sorter: (a: T, b: T) => number = defaultSort\n            ): T[] {\n                if (array.length === 0) return this;\n                array.reverse();\n                // Simulate a resort\n                const indexes: number[] = [];\n                for (let i = array.length - 1; i >= 0; --i) {\n                    indexes.push(i);\n                }\n                notify({\n                    type: 'sort',\n                    indexes,\n                });\n                return this;\n            },\n            makeView,\n            mapView: function mapView<V>(\n                this: Collection<T>,\n                mapper: MappingFunction<T, V>,\n                debugName?: string | undefined\n            ) {\n                return mapViewImplementation(this, mapper, debugName);\n            },\n            filterView: function filterView(\n                this: Collection<T>,\n                filterFn: FilterFunction<T>,\n                debugName?: string\n            ) {\n                return filterViewImplementation(this, filterFn, debugName);\n            },\n            flatMapView: function flatMapView<V>(\n                this: Collection<T>,\n                fn: FlatMapFunction<T, V>,\n                debugName?: string | undefined\n            ) {\n                return flatMapViewImplementation(this, fn, debugName);\n            },\n        }),\n        debugName\n    );\n}\n\nfunction mapViewImplementation<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    mapper: MappingFunction<T, V>,\n    debugName?: string | undefined\n): View<V> {\n    // map is a specialization of flatMap\n    return flatMapViewImplementation(\n        sourceCollection,\n        (item) => [mapper(item)],\n        debugName\n    );\n}\n\nfunction filterViewImplementation<T>(\n    sourceCollection: Collection<T> | View<T>,\n    filterFn: FilterFunction<T>,\n    debugName?: string\n): View<T> {\n    // filter is a specialization of flatMap\n    return flatMapViewImplementation(\n        sourceCollection,\n        (item) => (filterFn(item) ? [item] : []),\n        debugName\n    );\n}\n\nfunction flatMapViewImplementation<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    fn: FlatMapFunction<T, V>,\n    debugName?: string | undefined\n): View<V> {\n    const flatMapCount: number[] = [];\n\n    return sourceCollection.makeView(\n        {\n            initialize: (items) => {\n                const flatMapItems: V[] = [];\n                items.forEach((value) => {\n                    const chunk = fn(value);\n                    flatMapItems.push(...chunk);\n                    flatMapCount.push(chunk.length);\n                });\n                return flatMapItems;\n            },\n            processEvent: (view, event, rawArray) => {\n                if (event.type === 'splice') {\n                    const { index, count, items } = event;\n                    let realIndex = 0;\n                    for (let i = 0; i < index; ++i) {\n                        realIndex += flatMapCount[i];\n                    }\n                    let realCount = 0;\n                    for (let i = index; i < index + count; ++i) {\n                        realCount += flatMapCount[i];\n                    }\n                    // Well that's deceptively easy\n                    const realItems: V[] = [];\n                    const realItemCount: number[] = [];\n                    items.forEach((itemValue) => {\n                        const chunk = fn(itemValue);\n                        realItems.push(...chunk);\n                        realItemCount.push(chunk.length);\n                    });\n                    view.splice(realIndex, realCount, ...realItems);\n                    flatMapCount.splice(index, count, ...realItemCount);\n                } else if (event.type === 'move') {\n                    const { fromIndex, fromCount, toIndex } = event;\n                    let realFromCount = 0;\n                    for (let i = fromIndex; i < fromIndex + fromCount; ++i) {\n                        realFromCount += flatMapCount[i];\n                    }\n\n                    if (realFromCount > 0) {\n                        let realFromIndex = 0;\n                        let realToIndex = 0;\n\n                        const lastIndex = Math.max(fromIndex, toIndex);\n                        let count = 0;\n                        for (let i = 0; i <= lastIndex; ++i) {\n                            if (i === fromIndex) realFromIndex = count;\n                            if (i === toIndex) realToIndex = count;\n                            count += flatMapCount[i];\n                        }\n                        view.moveSlice(\n                            realFromIndex,\n                            realFromCount,\n                            realToIndex\n                        );\n                    }\n                    flatMapCount.splice(\n                        toIndex,\n                        0,\n                        ...flatMapCount.splice(fromIndex, fromCount)\n                    );\n                } else if (event.type === 'sort') {\n                    const { indexes } = event;\n\n                    const flatMapIndexes: number[] = [];\n                    let accumulatorIndex = 0;\n                    for (let i = 0; i < flatMapCount.length; ++i) {\n                        flatMapIndexes.push(accumulatorIndex);\n                        accumulatorIndex += flatMapCount[i];\n                    }\n\n                    const copiedSource = rawArray.slice();\n                    const newIndexes: number[] = [];\n                    let destIndex = 0;\n                    indexes.forEach((sourceIndex) => {\n                        const realCount = flatMapCount[sourceIndex];\n                        if (realCount === 0) return;\n                        const realIndex = flatMapIndexes[sourceIndex];\n                        for (let i = 0; i < realCount; ++i) {\n                            newIndexes.push(realIndex + i);\n                            rawArray[destIndex] = copiedSource[realIndex + i];\n                            destIndex += 1;\n                        }\n                    });\n\n                    view[NotifyKey]({\n                        type: 'sort',\n                        indexes: newIndexes,\n                    });\n                } else {\n                    log.assertExhausted(\n                        event,\n                        'unhandled collection event type'\n                    );\n                }\n            },\n        },\n        debugName\n    );\n}\n", "import {\n    Collection,\n    Subscription,\n    ViewSpec,\n    FlushKey,\n    AddDeferredWorkKey,\n    ObserveKey,\n    NotifyKey,\n    GetSubscriptionNodeKey,\n    TypeTag,\n    DataTypeTag,\n    ModelField,\n    TrackedData,\n} from './types';\nimport { collection } from './collection';\nimport {\n    untracked,\n    addManualDep,\n    removeManualDep,\n    addOrderingDep,\n    removeOrderingDep,\n    addDepToCurrentCalculation,\n    processChange,\n} from './calc';\nimport { name } from './debug';\nimport * as log from './log';\n\ninterface DataImplementation<TEvent> {\n    get(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): any;\n\n    has(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): boolean;\n\n    set(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol,\n        value: any\n    ): boolean;\n\n    deleteProperty(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): boolean;\n}\n\nexport function trackedData<\n    TDataTypeTag,\n    TData extends object,\n    TEvent,\n    TMethods extends object\n>(\n    initialValue: TData,\n    typeTag: TDataTypeTag,\n    implSpec: DataImplementation<TEvent>,\n    bindMethods: (bindSpec: {\n        notify: (event: TEvent) => void;\n        observe: (observer: (events: TEvent[]) => void) => () => void;\n        makeView: <V>(\n            spec: ViewSpec<TData, V, TEvent>,\n            viewDebugName?: string | undefined\n        ) => Collection<V>;\n        subscriptionNode: Subscription;\n        processFieldChange: (field: string | symbol) => void;\n        processFieldDelete: (field: string | symbol) => void;\n    }) => TMethods,\n    debugName?: string\n): TrackedData<TData & TMethods, TDataTypeTag, TEvent> {\n    type Observer = (events: TEvent[]) => void;\n\n    const fieldRecords: Map<string | number | symbol, ModelField> = new Map();\n\n    let subscriptionEvents: Map<Observer, TEvent[]> = new Map();\n    let observers: Observer[] = [];\n\n    let deferredTasks: (() => void)[] = [];\n\n    const subscriptionNode: Subscription = {\n        [TypeTag]: 'subscription',\n        [FlushKey]: flushSubscription,\n        item: null, // assigned later\n    };\n    name(subscriptionNode, `${debugName || '?'}:sub`);\n\n    function flushSubscription() {\n        const toProcess = subscriptionEvents;\n        subscriptionEvents = new Map();\n        toProcess.forEach((events, observer) => {\n            observer(events);\n        });\n    }\n\n    function flush() {\n        const toProcess = deferredTasks;\n        deferredTasks = [];\n        toProcess.forEach((task) => {\n            task();\n        });\n    }\n\n    function addDeferredTask(task: () => void) {\n        deferredTasks.push(task);\n        processChange(proxy);\n    }\n\n    function notify(event: TEvent) {\n        if (observers.length > 0) {\n            observers.forEach((observer) => {\n                let observerEvents = subscriptionEvents.get(observer);\n                if (!observerEvents) {\n                    observerEvents = [];\n                    subscriptionEvents.set(observer, observerEvents);\n                }\n                observerEvents.push(event);\n            });\n            processChange(subscriptionNode);\n        }\n    }\n\n    function getSubscriptionNode() {\n        return subscriptionNode;\n    }\n\n    function observe(observer: (events: TEvent[]) => void) {\n        if (observers.length === 0) {\n            addManualDep(proxy, subscriptionNode);\n            fieldRecords.forEach((field) => {\n                addOrderingDep(proxy, field);\n                addOrderingDep(field, subscriptionNode);\n            });\n        }\n        observers.push(observer);\n        return () => {\n            observers = observers.filter((obs) => obs !== observer);\n            if (observers.length === 0) {\n                removeManualDep(proxy, subscriptionNode);\n                fieldRecords.forEach((field) => {\n                    removeOrderingDep(proxy, field);\n                    removeOrderingDep(field, subscriptionNode);\n                });\n            }\n        };\n    }\n\n    function makeView<V>(\n        spec: ViewSpec<TData, V, TEvent>,\n        viewDebugName?: string | undefined\n    ) {\n        const viewArray: V[] = untracked(() => spec.initialize(initialValue));\n        const view = collection(viewArray, viewDebugName);\n        observe((events: TEvent[]) => {\n            view[AddDeferredWorkKey](() => {\n                events.forEach((event) => {\n                    spec.processEvent(view, event, viewArray);\n                });\n            });\n        });\n        addManualDep(subscriptionNode, view);\n        return view;\n    }\n\n    function processFieldChange(key: string | symbol) {\n        const field = getField(key);\n        processChange(field);\n    }\n\n    function processFieldDelete(key: string | symbol) {\n        const field = getField(key);\n        processChange(field);\n    }\n\n    const pseudoPrototype = {\n        [TypeTag]: 'data',\n        [DataTypeTag]: typeTag,\n        [FlushKey]: flush,\n        [AddDeferredWorkKey]: addDeferredTask,\n        [ObserveKey]: observe,\n        [NotifyKey]: notify,\n        [GetSubscriptionNodeKey]: getSubscriptionNode,\n        ...bindMethods({\n            observe,\n            notify,\n            makeView,\n            subscriptionNode,\n            processFieldChange,\n            processFieldDelete,\n        }),\n    };\n\n    function getField(key: string | number | symbol): ModelField {\n        let field = fieldRecords.get(key);\n        if (!field) {\n            field = {\n                model: proxy as any,\n                key,\n            };\n            if (debugName) name(field, debugName);\n            fieldRecords.set(key, field);\n            if (observers.length > 0) {\n                addOrderingDep(proxy, field);\n                addOrderingDep(field, subscriptionNode);\n            }\n        }\n        return field;\n    }\n\n    const proxy: TrackedData<TData & TMethods, TDataTypeTag, TEvent> =\n        new Proxy(initialValue, {\n            get(target: any, key: string | symbol) {\n                if (key in pseudoPrototype) {\n                    return (pseudoPrototype as any)[key];\n                }\n                const field = getField(key);\n                addDepToCurrentCalculation(field);\n                return implSpec.get.call(proxy, notify, target, key);\n            },\n\n            has(target: any, key: string | symbol) {\n                if (key in pseudoPrototype) {\n                    return true;\n                }\n                const field = getField(key);\n                addDepToCurrentCalculation(field);\n                return implSpec.has.call(proxy, notify, target, key);\n            },\n\n            set(target: any, key: string | symbol, value: any) {\n                if (key in pseudoPrototype) {\n                    log.error(`Overriding ${String(key)} not supported`, key);\n                    return false;\n                }\n                const changed = implSpec.set.call(\n                    proxy,\n                    notify,\n                    target,\n                    key,\n                    value\n                );\n                if (changed) {\n                    const field = getField(key);\n                    processChange(field);\n                }\n                return changed;\n            },\n\n            deleteProperty(target: any, key: string | symbol) {\n                if (key in pseudoPrototype) {\n                    log.error(`Deleting ${String(key)} not supported`, key);\n                    return false;\n                }\n                const changed = implSpec.deleteProperty.call(\n                    proxy,\n                    notify,\n                    target,\n                    key\n                );\n                if (changed) {\n                    const field = getField(key);\n                    processChange(field); // Anything depending on this value will need to be recalculated\n                }\n                return changed;\n            },\n        });\n\n    subscriptionNode.item = proxy;\n\n    if (debugName) name(proxy, debugName);\n\n    return proxy;\n}\n", "import { InvariantError, MakeModelViewKey, Model, View } from './types';\nimport { trackedData } from './trackeddata';\n\nexport function model<T extends {}>(obj: T, debugName?: string): Model<T> {\n    if (typeof obj !== 'object' || !obj) {\n        throw new InvariantError('model must be provided an object');\n    }\n\n    const knownFields: Set<string | number | symbol> = new Set(\n        Object.keys(obj)\n    );\n\n    return trackedData(\n        obj,\n        'model' as const,\n        {\n            get: (_notify, target, key) => {\n                return target[key];\n            },\n            has: (notify, target, key) => {\n                return knownFields.has(key);\n            },\n            set: (notify, target, key, value) => {\n                const changed = !knownFields.has(key) || target[key] !== value;\n                target[key] = value;\n                if (changed) {\n                    if (!knownFields.has(key)) {\n                        knownFields.add(key);\n                        notify({ type: 'add', key });\n                    }\n                    notify({ type: 'set', key, value });\n                }\n                return true;\n            },\n            deleteProperty: (notify, target, key) => {\n                const changed = knownFields.has(key);\n                delete target[key];\n                if (changed) {\n                    knownFields.delete(key);\n                    notify({ type: 'delete', key });\n                }\n                return true;\n            },\n        },\n        ({ makeView, notify, observe, subscriptionNode }) => {\n            return {\n                [MakeModelViewKey]: makeView,\n            };\n        },\n        debugName\n    );\n}\nmodel.keys = function keys<T>(\n    target: Model<T>,\n    debugName?: string\n): View<string> {\n    const keysSet = new Set<string>();\n\n    const view = target[MakeModelViewKey]<string>(\n        {\n            initialize: (obj) => {\n                const keys = Object.keys(obj);\n                keys.forEach((key) => keysSet.add(key));\n                return keys;\n            },\n            processEvent: (modelView, event) => {\n                if (event.type === 'add') {\n                    const { key } = event;\n                    if (typeof key === 'number' || typeof key === 'string') {\n                        const stringKey = key.toString();\n                        if (!keysSet.has(stringKey)) {\n                            keysSet.add(stringKey);\n                            modelView.push(stringKey);\n                        }\n                    }\n                } else if (event.type === 'delete') {\n                    const { key } = event;\n                    if (typeof key === 'number' || typeof key === 'string') {\n                        const stringKey = key.toString();\n                        if (keysSet.has(stringKey)) {\n                            keysSet.delete(stringKey);\n                            modelView.reject((k) => k === stringKey);\n                        }\n                    }\n                }\n            },\n        },\n        debugName\n    );\n\n    return view;\n};\n"],
  "mappings": "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",
  "names": []
}
