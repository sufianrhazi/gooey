{
  "version": 3,
  "sources": ["../src/log.ts", "../src/types.ts", "../src/sentinel.ts", "../src/dag.ts", "../src/debug.ts", "../src/calc.ts", "../src/jsx.ts", "../src/vnode.ts", "../src/view.ts", "../src/collection.ts", "../src/model.ts", "../src/index.ts", "../src/test/types.ts", "../src/util.ts", "../src/test/rpc.ts", "../src/testrunner.tsx"],
  "sourcesContent": ["type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function assert(check: any, ...items: any[]): asserts check {\n    if (!check) {\n        error('Assertion failure', check.toString(), 'is not truthy', ...items);\n        throw new Error('Assertion failure');\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new Error('Assertion failure');\n}\n", "export class InvariantError extends Error { }\n\nexport const TypeTag = Symbol('reviseType');\nconst CalculationTypeTag = Symbol('calculationType');\n\nexport const OwnKeysField = Symbol('ownKeys');\nexport const ObserveKey = Symbol('observe');\nexport const GetRawArrayKey = Symbol('getRawArray');\nexport const FlushKey = Symbol('flush');\nexport const NotifyKey = Symbol('notifyEvent');\n\n/**\n * A ref object that can be passed to native elements.\n */\nexport type Ref<T> = {\n    [TypeTag]: 'ref';\n    current?: T;\n};\nexport function isRef(ref: any): ref is Ref<unknown> {\n    return ref && ref[TypeTag] === 'ref';\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val?: T): Ref<T> {\n    return {\n        [TypeTag]: 'ref',\n        current: val,\n    };\n}\n\nexport type CollectionEvent<T> =\n    | {\n        type: 'splice';\n        index: number;\n        count: number;\n        items: readonly T[];\n        removed: readonly T[];\n    }\n    | {\n        type: 'init';\n        items: readonly T[];\n    };\n\nexport type CollectionObserver<T> = (event: CollectionEvent<T>) => void;\n\nexport type ModelEvent =\n    | {\n        type: 'add';\n        key: string | number | symbol;\n    }\n    | {\n        type: 'set';\n        key: string | number | symbol;\n        value: any;\n    }\n    | {\n        type: 'delete';\n        key: string | number | symbol;\n    }\n    | {\n        type: 'init';\n        keys: (string | number | symbol)[];\n    };\nexport type ModelObserver = (event: ModelEvent) => void;\n\n/**\n * A mutable object to hold state\n */\nexport type Model<T> = T & {\n    [TypeTag]: 'model';\n    [ObserveKey]: (observer: ModelObserver) => () => void;\n    /** internal Object.keys pseudo-result field; only used for tracking key changes */\n    [OwnKeysField]: any;\n};\n\nexport type MappingFunction<T, V> = (item: T, index: number) => V;\nexport type FilterFunction<T> = (item: T, index: number) => boolean;\nexport type FlatMapFunction<T, V> = (item: T, index: number) => V[];\nexport type SortFunction<T> = (a: T, b: T) => number;\n\nexport const OnCollectionRelease = Symbol('OnCollectionRelease');\n\n/**\n * A mutable array to hold state, with some additional convenience methods\n */\nexport interface Collection<T> extends Array<T> {\n    [TypeTag]: 'collection';\n    [ObserveKey]: (observer: CollectionObserver<T>) => () => void;\n    [FlushKey]: () => void;\n    [GetRawArrayKey]: () => T[];\n    mapView<V>(fn: MappingFunction<T, V>, debugName?: string): View<V>;\n    sortedView(fn: SortFunction<T>, debugName?: string): View<T>;\n    filterView(fn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(fn: MappingFunction<T, V[]>, debugName?: string): View<V>;\n    reject(fn: (item: T, index: number) => boolean): void;\n    [OnCollectionRelease]: (fn: () => void) => void;\n\n    /** Note: collections do not support sorting. Use sortedView to create a sorted view. */\n    sort(fn: never): never;\n}\n\n/**\n * A readonly array to hold projected state\n */\nexport interface View<T> extends ReadonlyArray<T> {\n    [TypeTag]: 'collection';\n    [ObserveKey]: (observer: CollectionObserver<T>) => () => void;\n    [FlushKey]: () => void;\n    mapView<V>(fn: MappingFunction<T, V>, debugName?: string): View<V>;\n    sortedView(fn: SortFunction<T>, debugName?: string): View<T>;\n    filterView(fn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(fn: MappingFunction<T, V[]>, debugName?: string): View<V>;\n    [OnCollectionRelease]: (fn: () => void) => void;\n}\n\n/**\n * A calculation cell that recalculates when dependencies change\n */\nexport type Calculation<Result> = (() => Result) & {\n    [TypeTag]: 'calculation';\n    [CalculationTypeTag]: 'calculation' | 'effect';\n};\n\nexport interface ModelField<T> {\n    model: Model<T> | Collection<T>;\n    key: string | number | symbol;\n}\n\nexport function makeCalculation<Ret>(fn: () => Ret): Calculation<Ret> {\n    return Object.assign(fn, {\n        [TypeTag]: 'calculation' as const,\n        [CalculationTypeTag]: 'calculation' as const,\n    });\n}\n\nexport function makeEffect(fn: () => void): Calculation<void> {\n    return Object.assign(fn, {\n        [TypeTag]: 'calculation' as const,\n        [CalculationTypeTag]: 'effect' as const,\n    });\n}\n\nexport function isModel(thing: any): thing is Model<unknown> {\n    return !!(thing && (thing as any)[TypeTag] === 'model');\n}\n\nexport function isCollection(thing: any): thing is (Collection<unknown> | View<unknown>) {\n    return !!(thing && (thing as any)[TypeTag] === 'collection');\n}\n\nexport function isCalculation(thing: any): thing is Calculation<unknown> {\n    return !!(thing && (thing as any)[TypeTag] === 'calculation');\n}\n\nexport function isEffect(thing: Calculation<unknown>): boolean {\n    return thing[CalculationTypeTag] === 'effect';\n}\n", "declare const sentinelMarker: unique symbol;\n\n/**\n * A unique singleton type\n */\nexport type Sentinel = Readonly<{\n    [sentinelMarker]: true;\n}>;\n\nexport const sentinel = {} as Sentinel;\n\nexport const isSentinel = (value: any): value is Sentinel => {\n    return value === sentinel;\n};\n", "import * as log from './log';\nimport { Sentinel, isSentinel, sentinel } from './sentinel';\n\nexport class DAG<Type extends object> {\n    private maxId: number;\n    private sentinelId: string;\n    private idMap: WeakMap<Type | Sentinel, string>;\n\n    public nodes: Record<string, Type | Sentinel>;\n    public refCount: Record<string, number>; // The number of *outgoing* edges from a node. We want to cull nodes that have no outgoing edges.\n    public cullableSet: Record<string, true>; // Set of nodeIds where refcount === 0\n    public edgeMap: Record<string, Record<string, Type | Sentinel>>;\n    public reverseEdgeMap: Record<string, Record<string, Type | Sentinel>>;\n\n    constructor() {\n        this.maxId = 0;\n        this.idMap = new WeakMap();\n        this.nodes = {};\n        this.edgeMap = {};\n        this.reverseEdgeMap = {};\n        this.refCount = {};\n        this.cullableSet = {};\n\n        this._addNode(sentinel);\n        this.sentinelId = this.getItemId(sentinel);\n    }\n\n    getItemId(item: Sentinel | Type): string {\n        let id;\n        if ((id = this.idMap.get(item)) === undefined) {\n            id = this.maxId.toString();\n            this.maxId += 1;\n            this.idMap.set(item, id);\n        }\n        return id;\n    }\n\n    addNode(node: Type): boolean {\n        return this._addNode(node);\n    }\n\n    private _addNode(node: Sentinel | Type): boolean {\n        const itemId = this.getItemId(node);\n        if (!this.nodes[itemId]) {\n            this.refCount[itemId] = 0;\n            if (!isSentinel(node)) {\n                this.cullableSet[itemId] = true;\n            }\n            this.nodes[itemId] = node;\n            this.edgeMap[itemId] = {};\n            this.reverseEdgeMap[itemId] = {};\n            return true;\n        }\n        return false;\n    }\n\n    hasNode(node: Type): boolean {\n        return !!this.nodes[this.getItemId(node)];\n    }\n\n    /**\n     * Indicate that toNode needs to be updated if fromNode has changed\n     *\n     * Returns true if edge is added\n     */\n    addEdge(fromNode: Type, toNode: Type): boolean {\n        const fromId = this.getItemId(fromNode);\n        const toId = this.getItemId(toNode);\n        return this._addEdge(fromId, toId);\n    }\n\n    private _addEdge(fromId: string, toId: string): boolean {\n        const fromNode = this.nodes[fromId] as Type | Sentinel;\n        const toNode = this.nodes[toId] as Type;\n        log.invariant(\n            () => fromId === this.sentinelId || !!this.nodes[fromId],\n            'addEdge fromNode does not exist',\n            fromNode\n        );\n        log.invariant(\n            () => !!this.nodes[toId],\n            'addEdge toNode does not exist',\n            toNode\n        );\n        if (!this.edgeMap[fromId]) {\n            this.edgeMap[fromId] = {};\n        }\n        if (this.edgeMap[fromId][toId]) {\n            // already exists\n            return false;\n        }\n        this.edgeMap[fromId][toId] = toNode;\n\n        // upkeeping\n        if (!this.reverseEdgeMap[toId]) {\n            this.reverseEdgeMap[toId] = {};\n        }\n        this.reverseEdgeMap[toId][fromId] = fromNode;\n        this.refCount[fromId] += 1;\n        delete this.cullableSet[fromId];\n        return true;\n    }\n\n    /**\n     * Indicate that toNode no longer needs to be updated if fromNode has changed\n     */\n    removeEdge(fromNode: Type, toNode: Type): boolean {\n        const fromId = this.getItemId(fromNode);\n        const toId = this.getItemId(toNode);\n        const result = this._removeEdge(fromId, toId);\n        log.invariant(\n            () => result === false,\n            'removeEdge attempted on nonexistent edge',\n            { fromNode, toNode }\n        );\n        return result;\n    }\n\n    /**\n     * Remove a node and all its edges from the graph, returns true if node not present\n     */\n    removeNode(node: Type): boolean {\n        const itemId = this.getItemId(node);\n        return this._removeNode(itemId);\n    }\n\n    private _removeNode(itemId: string): boolean {\n        if (!this.nodes[itemId]) return true;\n        const node = this.nodes[itemId];\n        Object.keys(this.edgeMap[itemId]).forEach((toId) =>\n            this._removeEdge(itemId, toId)\n        );\n        Object.keys(this.reverseEdgeMap[itemId]).forEach((fromId) =>\n            this._removeEdge(fromId, itemId)\n        );\n\n        log.invariant(\n            () => this.refCount[itemId] === 0,\n            'still has refcount after deleting edges',\n            node\n        );\n        log.invariant(\n            () => this.cullableSet[itemId] === true,\n            'not cullable after deleting edges',\n            node\n        );\n        delete this.nodes[itemId];\n        delete this.edgeMap[itemId];\n        delete this.reverseEdgeMap[itemId];\n        delete this.refCount[itemId];\n        delete this.cullableSet[itemId];\n        return false;\n    }\n\n    private _removeEdge(fromId: string, toId: string): boolean {\n        log.assert(\n            !!this.edgeMap[fromId],\n            '_removeEdge fromId not found in edgeMap',\n            fromId\n        );\n        log.assert(\n            !!this.reverseEdgeMap[toId],\n            '_removeEdge toId not found in reverseEdgeMap',\n            toId\n        );\n        if (!this.edgeMap[fromId][toId]) {\n            log.error('_removeEdge edge not found', { fromId, toId });\n            return true;\n        }\n\n        // Remove fromId -> toId\n        delete this.edgeMap[fromId][toId];\n        this.refCount[fromId] -= 1;\n        if (this.refCount[fromId] === 0) {\n            this.cullableSet[fromId] = true;\n        }\n\n        delete this.reverseEdgeMap[toId][fromId];\n        return false;\n    }\n\n    retain(node: Type) {\n        const retained = this._addEdge(this.getItemId(node), this.sentinelId);\n        log.invariant(() => !!retained, 'double-retained', node);\n    }\n\n    release(node: Type) {\n        const releaseFailed = this._removeEdge(\n            this.getItemId(node),\n            this.sentinelId\n        );\n        log.invariant(\n            () => !releaseFailed,\n            'released a non-retained node',\n            node\n        );\n    }\n\n    removeEdges(edges: [Type, Type][]) {\n        edges.forEach(([fromNode, toNode]) => {\n            const fromId = this.getItemId(fromNode);\n            const toId = this.getItemId(toNode);\n            this._removeEdge(fromId, toId);\n        });\n    }\n\n    /**\n     * Get list of things need to be updated, when fromNode has changed?\n     */\n    getDependencies(fromNode: Type): Type[] {\n        const fromId = this.getItemId(fromNode);\n        if (!this.edgeMap[fromId]) {\n            return [];\n        }\n        const deps: Type[] = [];\n        Object.values(this.edgeMap[fromId]).forEach((node) => {\n            if (!isSentinel(node)) {\n                deps.push(node);\n            }\n        });\n        return deps;\n    }\n\n    /**\n     * Get list of things that cause toNode to updated\n     */\n    getReverseDependencies(toNode: Type): Type[] {\n        const toId = this.getItemId(toNode);\n        if (!this.reverseEdgeMap[toId]) {\n            return [];\n        }\n        const revDeps: Type[] = [];\n        Object.values(this.reverseEdgeMap[toId]).forEach((node) => {\n            if (!isSentinel(node)) {\n                revDeps.push(node);\n            }\n        });\n        return revDeps;\n    }\n\n    /**\n     * Visit topological graph\n     */\n    visitTopological(callback: (node: Type) => void) {\n        const visited: Record<string, boolean> = {};\n        const sorted: Type[] = [];\n        const dfsRecurse = (nodeId: string) => {\n            if (visited[nodeId]) return;\n            visited[nodeId] = true;\n            Object.keys(this.edgeMap[nodeId] || {}).forEach((toId) => {\n                dfsRecurse(toId);\n            });\n            const node = this.nodes[nodeId];\n            if (!isSentinel(node)) {\n                sorted.unshift(node);\n            }\n        };\n        Object.keys(this.nodes).forEach((nodeId) => {\n            dfsRecurse(nodeId);\n        });\n        sorted.forEach((node) => {\n            callback(node);\n        });\n    }\n\n    garbageCollect(): Type[] {\n        const culled: Type[] = [];\n        while (Object.keys(this.cullableSet).length > 0) {\n            Object.keys(this.cullableSet).forEach((nodeId) => {\n                const node = this.nodes[nodeId];\n                log.assert(\n                    !isSentinel(node),\n                    'tried to garbage collect sentinel'\n                );\n                culled.push(node);\n                this._removeNode(nodeId);\n            });\n        }\n        return culled;\n    }\n\n    /**\n     * Generate a dot file structure of the graph\n     */\n    graphviz(makeName: (label: string, item: Type) => string) {\n        const lines = ['digraph dag {'];\n        Object.entries(this.nodes).forEach(([nodeId, node]) => {\n            if (isSentinel(node)) return;\n            const props: Record<string, string> = {\n                label: makeName(nodeId, node),\n            };\n            lines.push(\n                `  item_${nodeId} [${Object.entries(props)\n                    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n                    .join(',')}];`\n            );\n        });\n        Object.entries(this.edgeMap).forEach(([fromNodeId, toNodeMap]) => {\n            Object.keys(toNodeMap).forEach((toNodeId) => {\n                if (\n                    toNodeId === this.sentinelId ||\n                    fromNodeId === this.sentinelId\n                )\n                    return;\n                lines.push(`  item_${fromNodeId} -> item_${toNodeId};`);\n            });\n        });\n        lines.push('}');\n        return lines.join('\\n');\n    }\n}\n", "import {\n    Calculation,\n    Collection,\n    Model,\n    ModelField,\n    isCalculation,\n    isEffect,\n    isCollection,\n    isModel,\n    View,\n} from './types';\n\nlet nameMap: WeakMap<any, string> = new WeakMap();\n\nexport function clearNames() {\n    nameMap = new WeakMap();\n}\n\nexport function debugNameFor(\n    item:\n        | Collection<unknown>\n        | View<unknown>\n        | Calculation<unknown>\n        | Model<unknown>\n        | ModelField<unknown>\n): string {\n    if (isCollection(item)) {\n        return `collection:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isCalculation(item)) {\n        return `${isEffect(item) ? 'effect' : 'calc'}:${nameMap.get(item) ?? '?'\n            }`;\n    }\n    if (isModel(item)) {\n        return `model:${nameMap.get(item) ?? '?'}`;\n    }\n    return `field:${nameMap.get(item.model) ?? '?'}:${String(item.key)}`;\n}\n\nexport function name<T>(item: T, name: string): T {\n    nameMap.set(item, name);\n    return item;\n}\n", "import {\n    InvariantError,\n    Calculation,\n    Collection,\n    View,\n    FlushKey,\n    ModelField,\n    isCalculation,\n    isCollection,\n    makeCalculation,\n    makeEffect,\n} from './types';\nimport * as log from './log';\nimport { DAG } from './dag';\nimport { clearNames, debugNameFor, name } from './debug';\n\nlet activeCalculations: Calculation<unknown>[] = [];\nlet calculationToInvalidationMap: Map<\n    Calculation<unknown>,\n    Function\n> = new Map();\n\nlet partialDag = new DAG<\n    Collection<unknown> | Calculation<unknown> | ModelField<unknown> | View<unknown>\n>();\nlet globalDependencyGraph = new DAG<\n    Collection<unknown> | Calculation<unknown> | ModelField<unknown> | View<unknown>\n>();\n\nlet refcountMap: WeakMap<\n    Calculation<any> | Collection<any> | View<any>,\n    number\n> = new WeakMap();\n\n/**\n * Reset all data to a clean slate.\n */\nexport function reset() {\n    partialDag = new DAG();\n    activeCalculations = [];\n    calculationToInvalidationMap = new Map();\n\n    globalDependencyGraph = new DAG();\n    refcountMap = new WeakMap();\n    clearNames();\n}\n\n/**\n * Create a calculation cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be recalculated when any of those dependencies are changed. The result of this function is\n * treated as a dependency, so if recalculations change the result, any dependent calculations are recalculated.\n */\nexport function calc<Ret>(\n    func: () => Ret,\n    debugName?: string\n): Calculation<Ret> {\n    const calculation = trackCalculation(func, false);\n    if (debugName) name(calculation, debugName);\n    return calculation;\n}\n\n/**\n * Create an effect cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be re-executed when any of those dependencies are changed.\n *\n * Effect cells are not be added as dependencies to the current computation.\n *\n * Note: Since nothing depends on created effects, they must be be manually retained and released if you want the effect\n * to re-run when its dependencies change. Failure to do so will not automatically re-run the effect (which may be\n * desired if you want to trigger behavior only once within a computation)\n */\nexport function effect(\n    func: () => void,\n    debugName?: string\n): Calculation<void> {\n    const calculation = trackCalculation(func, true);\n    if (debugName) name(calculation, debugName);\n    return calculation;\n}\n\nfunction trackCalculation<Ret>(\n    func: () => Ret,\n    isEffect: boolean\n): Calculation<Ret> {\n    if (typeof func !== 'function') {\n        throw new InvariantError('calculation must be provided a function');\n    }\n\n    let result: { result: Ret } | undefined = undefined;\n\n    const invalidate = () => {\n        result = undefined;\n    };\n\n    const trackedCalculation = (isEffect ? makeEffect : makeCalculation)(\n        function runCalculation() {\n            if (!isEffect) {\n                // effects return void, so they **cannot** have an effect on the current calculation\n                addDepToCurrentCalculation(trackedCalculation);\n            }\n\n            if (result) {\n                return result.result;\n            }\n\n            const edgesToRemove: [\n                Collection<any> | Calculation<any> | ModelField<any> | View<any>,\n                Calculation<any>\n            ][] = globalDependencyGraph\n                .getReverseDependencies(trackedCalculation)\n                .map((fromNode) => {\n                    return [fromNode, trackedCalculation];\n                });\n            globalDependencyGraph.removeEdges(edgesToRemove);\n\n            activeCalculations.push(trackedCalculation);\n            result = { result: func() };\n\n            const sanityCheck = activeCalculations.pop();\n            if (sanityCheck !== trackedCalculation) {\n                throw new InvariantError(\n                    'Active calculation stack inconsistency!'\n                );\n            }\n            return result.result;\n        }\n    );\n\n    globalDependencyGraph.addNode(trackedCalculation);\n\n    calculationToInvalidationMap.set(trackedCalculation, invalidate);\n\n    // Note: typescript gets confused, this *should* be\n    // - Calculation<Ret> when isEffect is true and\n    // - Calculation<Ret> when isEffect is false\n    // But infers to Calculation<void> because makeEffect is present\n    return trackedCalculation as Calculation<Ret>;\n}\n\nexport function addDepToCurrentCalculation<T, Ret>(\n    item: Calculation<Ret> | ModelField<T>\n) {\n    const dependentCalculation =\n        activeCalculations[activeCalculations.length - 1];\n    if (dependentCalculation) {\n        globalDependencyGraph.addNode(item);\n        if (!globalDependencyGraph.hasNode(dependentCalculation)) {\n            globalDependencyGraph.addNode(dependentCalculation);\n        }\n        if (globalDependencyGraph.addEdge(item, dependentCalculation)) {\n            log.debug(\n                'New global dependency',\n                debugNameFor(item),\n                '->',\n                debugNameFor(dependentCalculation)\n            );\n        }\n    }\n}\n\nexport function addManualDep<T, V>(\n    fromNode: Collection<T> | ModelField<T> | Calculation<T>,\n    toNode: Collection<V> | ModelField<V> | Calculation<V>\n) {\n    globalDependencyGraph.addNode(fromNode);\n    globalDependencyGraph.addNode(toNode);\n    if (globalDependencyGraph.addEdge(fromNode, toNode)) {\n        log.debug(\n            'New manual dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n    }\n}\n\nexport function processChange(item: ModelField<unknown> | Collection<unknown>) {\n    const chain: string[] = [];\n    const addNode = (\n        node: Collection<unknown> | Calculation<unknown> | ModelField<unknown> | View<unknown>\n    ) => {\n        chain.push(debugNameFor(node));\n        partialDag.addNode(node);\n        const dependencies = globalDependencyGraph.getDependencies(node);\n        dependencies.forEach((dependentItem) => {\n            if (!partialDag.hasNode(dependentItem)) {\n                addNode(dependentItem);\n            }\n            if (partialDag.addEdge(node, dependentItem)) {\n                log.debug(\n                    'New local dependency',\n                    debugNameFor(item),\n                    '->',\n                    debugNameFor(dependentItem)\n                );\n            }\n            if (!needsFlush) {\n                needsFlush = true;\n                notify();\n            }\n        });\n    };\n    addNode(item);\n    log.debug('processChange', chain);\n}\n\ntype Listener = () => void;\nlet needsFlush = false;\nlet subscribeListener: Listener = () => setTimeout(() => flush(), 0);\n\n/**\n * Call provided callback when any pending calculations are created. Use to configure how/when the application flushes calculations.\n *\n * If any pending calculations are needed when this function is called, the provided callback is called synchronously.\n *\n * By default, the subscribe mechanism is to call flush() on setTimeout. Calling subscribe removes this default and\n * replaces it with whatever mechanism you'd like.\n *\n * Example: subscribe(() => requestAnimationFrame(() => flush()));\n */\nexport function subscribe(listener: Listener): void {\n    subscribeListener = listener;\n    if (needsFlush) {\n        notify();\n    }\n}\n\nfunction notify() {\n    try {\n        subscribeListener();\n    } catch (e) {\n        log.exception(e, 'uncaught exception in notify');\n    }\n}\n\n/**\n * Recalculate all pending calculations.\n */\nexport function flush() {\n    if (!needsFlush) {\n        return;\n    }\n    needsFlush = false;\n    const oldPartialDag = partialDag;\n    partialDag = new DAG();\n    oldPartialDag.visitTopological((item) => {\n        if (isCalculation(item)) {\n            log.debug('flushing calculation', debugNameFor(item));\n            const invalidation = calculationToInvalidationMap.get(item);\n            if (invalidation) {\n                invalidation();\n            }\n            item();\n        } else if (isCollection(item)) {\n            log.debug('flushing collection', debugNameFor(item));\n            item[FlushKey]();\n        } else {\n            log.debug('flushing model', debugNameFor(item));\n        }\n    });\n    globalDependencyGraph.garbageCollect().forEach((item) => {\n        if (isCalculation(item)) {\n            log.debug('GC calculation', debugNameFor(item));\n        } else if (isCollection(item)) {\n            log.debug('GC collection', debugNameFor(item));\n        } else {\n            log.debug('GC model', debugNameFor(item));\n        }\n    });\n}\n\n/**\n * Retain a calculation (increase the refcount)\n */\nexport function retain(item: Calculation<any> | Collection<any> | View<any>) {\n    const refcount = refcountMap.get(item) ?? 0;\n    const newRefcount = refcount + 1;\n    if (refcount === 0) {\n        log.debug(\n            `retain ${debugNameFor(\n                item\n            )} retained; refcount ${refcount} -> ${newRefcount}`\n        );\n        if (!globalDependencyGraph.hasNode(item)) {\n            globalDependencyGraph.addNode(item);\n        }\n        globalDependencyGraph.retain(item);\n    } else {\n        log.debug(\n            `retain ${debugNameFor(\n                item\n            )} incremented; refcount ${refcount} -> ${newRefcount}`\n        );\n    }\n    refcountMap.set(item, newRefcount);\n}\n\n/**\n * Release a calculation (decrease the refcount). If the refcount reaches zero, the calculation will be garbage\n * collected.\n */\nexport function release(item: Calculation<any> | Collection<any> | View<any>) {\n    const refcount = refcountMap.get(item) ?? 0;\n    const newRefcount = Math.min(refcount - 1, 0);\n    if (refcount < 1) {\n        log.error(\n            `release called on unretained item ${debugNameFor(item)}`,\n            item\n        );\n    }\n    if (newRefcount < 1) {\n        log.debug(\n            `release ${debugNameFor(\n                item\n            )} released; refcount ${refcount} -> ${newRefcount}`\n        );\n        globalDependencyGraph.release(item);\n    } else {\n        log.debug(\n            `release ${debugNameFor(\n                item\n            )} decremented; refcount ${refcount} -> ${newRefcount}`\n        );\n    }\n    refcountMap.set(item, newRefcount);\n}\n\n/**\n * Return a graphviz formatted directed graph\n */\nexport function debug(): string {\n    return globalDependencyGraph.graphviz((id, item) => {\n        return `${id}\\n${debugNameFor(item)}`;\n    });\n}\n", "import { Ref, Calculation, Collection } from './types';\n\n// General component props\ntype PropsWithChildren<P> = P & { children?: JSXNode[] };\n\ntype OnUnmountCallback = () => void;\ntype OnMountCallback = () => void;\ntype EffectCallback = () => void;\n\ntype ComponentListeners = {\n    onUnmount: (callback: OnUnmountCallback) => void;\n    onMount: (callback: OnMountCallback) => void;\n    onEffect: (callback: EffectCallback) => void;\n};\nexport type Component<P extends {}> = (\n    props: PropsWithChildren<P>,\n    listeners: ComponentListeners\n) => JSXNode;\n\ntype JsxRawNode = string | number | boolean | null | undefined | Function;\n\n/**\n * The type returnable by JSX (raw nodes)\n */\ntype JSXNodeSingle =\n    | JsxRawNode\n    | Calculation<JsxRawNode>\n    | Calculation<JsxRawNode[]>\n    | RenderElement\n    | RenderComponent<any>;\nexport type JSXNode =\n    | JSXNodeSingle\n    | JSXNodeSingle[]\n    | Collection<JSXNodeSingle>;\n\nexport type RenderElement = {\n    type: 'element';\n    element: string;\n    props?: ElementProps;\n    children: JSXNode[];\n};\nexport function isRenderElement(jsxNode: JSXNode): jsxNode is RenderElement {\n    return !!(\n        jsxNode &&\n        typeof jsxNode === 'object' &&\n        'type' in jsxNode &&\n        jsxNode.type === 'element'\n    );\n}\n\ntype EventHandler<T> = (event: T) => void;\n\nexport type ElementProps = {\n    ref?: Ref<Element> | ((el?: Element) => void);\n\n    // AnimationEvent\n    'on:animationstart'?: EventHandler<AnimationEvent>;\n    'on:animationiteration'?: EventHandler<AnimationEvent>;\n    'on:animationend'?: EventHandler<AnimationEvent>;\n    'on:animationcancel'?: EventHandler<AnimationEvent>;\n    // ClipboardEvent\n    'on:copy'?: EventHandler<ClipboardEvent>;\n    'on:paste'?: EventHandler<ClipboardEvent>;\n    // DOMContentLoaded\n    'on:DOMContentLoaded'?: EventHandler<Event>;\n    // DragEvent\n    'on:dragend'?: EventHandler<DragEvent>;\n    'on:dragenter'?: EventHandler<DragEvent>;\n    'on:dragleave'?: EventHandler<DragEvent>;\n    'on:dragover'?: EventHandler<DragEvent>;\n    'on:dragstart'?: EventHandler<DragEvent>;\n    'on:drag'?: EventHandler<DragEvent>;\n    'on:drop'?: EventHandler<DragEvent>;\n    // Full Screen\n    'on:fullscreenchange'?: EventHandler<Event>;\n    'on:fullscreenerror'?: EventHandler<Event>;\n    // Pointer Capture\n    'on:gotpointercapture'?: EventHandler<PointerEvent>;\n    'on:lostpointercapture'?: EventHandler<PointerEvent>;\n    // PointerEvent\n    'on:pointercancel'?: EventHandler<PointerEvent>;\n    'on:pointerdown'?: EventHandler<PointerEvent>;\n    'on:pointerenter'?: EventHandler<PointerEvent>;\n    'on:pointerleave'?: EventHandler<PointerEvent>;\n    'on:pointerlockchange'?: EventHandler<PointerEvent>;\n    'on:pointerlockerror'?: EventHandler<PointerEvent>;\n    'on:pointermove'?: EventHandler<PointerEvent>;\n    'on:pointerout'?: EventHandler<PointerEvent>;\n    'on:pointerover'?: EventHandler<PointerEvent>;\n    'on:pointerup'?: EventHandler<PointerEvent>;\n    // KeyboardEvent\n    'on:keydown'?: EventHandler<KeyboardEvent>;\n    'on:keypress'?: EventHandler<KeyboardEvent>;\n    'on:keyup'?: EventHandler<KeyboardEvent>;\n    // readyState\n    'on:readystatechange'?: EventHandler<Event>;\n    // Scroll\n    'on:scroll'?: EventHandler<Event>;\n    // Selection\n    'on:selectionchange'?: EventHandler<Event>;\n    'on:selectstart'?: EventHandler<Event>;\n    'on:select'?: EventHandler<Event | UIEvent>;\n    // Touch\n    'on:touchcancel'?: EventHandler<TouchEvent>;\n    'on:touchend'?: EventHandler<TouchEvent>;\n    'on:touchmove'?: EventHandler<TouchEvent>;\n    'on:touchstart'?: EventHandler<TouchEvent>;\n    // Transition\n    'on:transitioncancel'?: EventHandler<TransitionEvent>;\n    'on:transitionend'?: EventHandler<TransitionEvent>;\n    'on:transitionrun'?: EventHandler<TransitionEvent>;\n    'on:transitionstart'?: EventHandler<TransitionEvent>;\n    // Visibility\n    'on:visibilitychange'?: EventHandler<Event>;\n    // Wheel\n    'on:wheel'?: EventHandler<WheelEvent>;\n    // Mouse\n    'on:auxclick'?: EventHandler<MouseEvent>;\n    'on:click'?: EventHandler<MouseEvent>;\n    'on:dblclick'?: EventHandler<MouseEvent>;\n    'on:contextmenu'?: EventHandler<MouseEvent>;\n    'on:mousedown'?: EventHandler<MouseEvent>;\n    'on:mouseenter'?: EventHandler<MouseEvent>;\n    'on:mouseleave'?: EventHandler<MouseEvent>;\n    'on:mouseout'?: EventHandler<MouseEvent>;\n    'on:mouseover'?: EventHandler<MouseEvent>;\n    'on:mouseup'?: EventHandler<MouseEvent>;\n    // Focus\n    'on:focus'?: EventHandler<FocusEvent>;\n    'on:focusin'?: EventHandler<FocusEvent>;\n    'on:focusout'?: EventHandler<FocusEvent>;\n    'on:blur'?: EventHandler<FocusEvent>;\n    // Composition\n    'on:compositionend'?: EventHandler<CompositionEvent>;\n    'on:compositionstart'?: EventHandler<CompositionEvent>;\n    'on:compositionupdate'?: EventHandler<CompositionEvent>;\n    // Error\n    'on:error'?: EventHandler<Event | UIEvent>; // TODO: different elements have different events\n    // TODO: generate this from spec\n} & {\n    [key: `on:${string}`]: EventHandler<Event>;\n    [key: string]:\n        | Function\n        | string\n        | number\n        | boolean\n        | null\n        | undefined\n        | Calculation<\n              () => Function | string | number | boolean | null | undefined\n          >;\n};\n\nexport type RenderComponent<Props extends {}> = {\n    type: 'component';\n    component: Component<Props>;\n    props?: Props;\n    children: JSXNode[];\n};\nexport function isRenderComponent(\n    jsxNode: JSXNode\n): jsxNode is RenderComponent<any> {\n    return !!(\n        jsxNode &&\n        typeof jsxNode === 'object' &&\n        'type' in jsxNode &&\n        jsxNode.type === 'component'\n    );\n}\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        interface IntrinsicElements {\n            [unknownElement: string]: {\n                'on:click': (event: MouseEvent) => void;\n            } & any;\n        }\n        type Element = JSXNode;\n    }\n}\n", "import { JSXNode } from './jsx';\nimport * as log from './log';\n\nconst VNodeSymbol = Symbol('VNode');\n\n/**\n * A VNode represents a node in the virtual tree structure\n *\n * Since a JSXNode may render to 0, 1, or many DOM nodes, which may be at any\n * index within the DOM tree.\n */\nexport type ChildVNode = {\n    domNode: Node | null;\n    children: VNode[];\n    parentNode: VNode;\n    domParent: VNode;\n    jsxNode: JSXNode | null;\n    onUnmount: Function[];\n    [VNodeSymbol]: true;\n};\nexport type RootVNode = {\n    domNode: Node | null;\n    children: VNode[];\n    parentNode: null;\n    domParent: VNode;\n    jsxNode: JSXNode | null;\n    onUnmount: Function[];\n    [VNodeSymbol]: true;\n};\nexport type VNode = ChildVNode | RootVNode;\n\nexport function makeRootVNode({ domNode }: { domNode: Node }): RootVNode {\n    const rootVNode: RootVNode = {\n        domNode,\n        children: [],\n        parentNode: null,\n        domParent: null,\n        jsxNode: null,\n        onUnmount: [],\n        [VNodeSymbol]: true,\n    } as unknown as RootVNode; // We lie here since domParent needs to be self-referential\n    rootVNode.domParent = rootVNode;\n    return rootVNode;\n}\n\nexport function makeChildVNode({\n    jsxNode,\n    domNode,\n    domParent,\n    onUnmount,\n    parentNode,\n}: {\n    parentNode: VNode;\n    domParent: VNode;\n    jsxNode: JSXNode | null;\n    domNode: Node | null;\n    onUnmount: Function[];\n}): ChildVNode {\n    return {\n        domNode,\n        children: [],\n        parentNode,\n        domParent,\n        jsxNode,\n        onUnmount,\n        [VNodeSymbol]: true,\n    };\n}\n\nexport function makeEmptyVNode({\n    parentNode,\n    domParent,\n}: {\n    parentNode: VNode;\n    domParent: VNode;\n}): ChildVNode {\n    return {\n        domNode: null,\n        children: [],\n        parentNode,\n        domParent,\n        jsxNode: null,\n        onUnmount: [],\n        [VNodeSymbol]: true,\n    };\n}\n\nexport function isVNode(x: any): x is VNode {\n    return !!x[VNodeSymbol];\n}\n\nfunction getShallowNodes(vNode: VNode): Node[] {\n    const nodes: Node[] = [];\n    function visit(node: VNode) {\n        if (node.domNode) {\n            nodes.push(node.domNode);\n        } else {\n            node.children.forEach((child) => visit(child));\n        }\n    }\n    visit(vNode);\n    return nodes;\n}\n\nfunction getDomParentChildIndex(\n    domParent: VNode,\n    immediateParent: VNode,\n    childIndex: number\n): number {\n    let realIndex = 0;\n\n    function visit(node: VNode): boolean {\n        if (node.domNode) {\n            realIndex += 1;\n            return false;\n        } else {\n            return visitChildren(node);\n        }\n    }\n    function visitChildren(node: VNode): boolean {\n        const visitIndex =\n            node === immediateParent ? childIndex : node.children.length;\n        for (let i = 0; i < visitIndex; ++i) {\n            if (visit(node.children[i])) {\n                return true;\n            }\n        }\n        return node === immediateParent;\n    }\n    visitChildren(domParent);\n    return realIndex;\n}\n\nfunction callOnUnmount(node: VNode) {\n    // Note: we are doing a post-order traversal, so all children are released/unmounted before parents are released/unmounted\n    node.children.forEach((child) => callOnUnmount(child));\n\n    // Call any onUnmount listeners\n    if (node.onUnmount) {\n        node.onUnmount.forEach((onUnmount) => {\n            try {\n                onUnmount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onUnmount',\n                    node\n                );\n            }\n        });\n    }\n}\n\nexport function replaceVNode(\n    replaceNode: ChildVNode,\n    newNode: VNode\n): VNode | undefined {\n    return spliceVNode(replaceNode.parentNode, replaceNode, 1, [newNode])[0];\n}\n\nexport function spliceVNode(\n    immediateParent: VNode,\n    replaceNode: VNode | null,\n    removeCount: number,\n    newNodes: VNode[]\n) {\n    let domParent: VNode;\n    let childIndex: number;\n    if (replaceNode) {\n        childIndex = immediateParent.children.indexOf(replaceNode);\n        if (childIndex === -1) {\n            childIndex = immediateParent.children.length;\n        }\n        domParent = replaceNode.domParent;\n    } else {\n        childIndex = immediateParent.children.length;\n        domParent = immediateParent.domNode\n            ? immediateParent\n            : immediateParent.domParent;\n    }\n    log.assert(\n        domParent,\n        'tried to replace a root tree slot with missing domParent'\n    );\n\n    const detachedVNodes = immediateParent.children.splice(\n        childIndex,\n        removeCount,\n        ...newNodes\n    );\n\n    detachedVNodes.forEach((detachedVNode) => {\n        callOnUnmount(detachedVNode);\n\n        const nodesToRemove = getShallowNodes(detachedVNode);\n        nodesToRemove.forEach((node) => {\n            if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        });\n    });\n\n    if (!domParent.domNode) {\n        throw new Error('Invariant: domParent missing domNode');\n    }\n    const domParentNode = domParent.domNode;\n\n    newNodes.forEach((newNode) => {\n        newNode.parentNode = immediateParent;\n        newNode.domParent = domParent;\n        if (newNode.domNode) {\n            const domIndex = getDomParentChildIndex(\n                domParent,\n                immediateParent,\n                childIndex\n            );\n            const referenceNode: Node | undefined =\n                domParentNode.childNodes[domIndex];\n            domParentNode.insertBefore(newNode.domNode, referenceNode || null);\n        }\n    });\n    return detachedVNodes;\n}\n", "import { effect, retain, release } from './calc';\nimport { debugNameFor } from './debug';\nimport {\n    Calculation,\n    isCalculation,\n    isCollection,\n    isRef,\n    ObserveKey,\n} from './types';\nimport * as log from './log';\nimport {\n    Component,\n    JSXNode,\n    ElementProps,\n    isRenderComponent,\n    isRenderElement,\n} from './jsx';\nimport {\n    VNode,\n    ChildVNode,\n    replaceVNode,\n    spliceVNode,\n    makeChildVNode,\n    makeRootVNode,\n    makeEmptyVNode,\n} from './vnode';\n\nexport function createElement(\n    Constructor: string,\n    props?: ElementProps,\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<Props extends {}>(\n    Constructor: Component<Props>,\n    props?: Props,\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<Props extends {}>(\n    Constructor: Component<Props>,\n    props?: Props,\n    ...children: JSXNode[]\n): JSXNode;\nexport function createElement<Props extends {}>(\n    Constructor: string | Component<Props>,\n    props?: ElementProps | Props,\n    ...children: JSXNode[]\n): JSXNode {\n    if (typeof Constructor === 'string') {\n        return {\n            type: 'element',\n            element: Constructor,\n            props,\n            children,\n        };\n    }\n    return {\n        type: 'component',\n        component: Constructor,\n        props,\n        children,\n    };\n}\n\nconst boundEvents = new WeakMap<Element, Record<string, (ev: Event) => void>>();\n\nfunction setBooleanPropertyValue(\n    element: Element,\n    key: string,\n    value: boolean\n) {\n    if (\n        element instanceof HTMLInputElement &&\n        (key === 'checked' || key === 'indeterminate') &&\n        element[key] !== value\n    ) {\n        element[key] = value;\n    }\n    if (\n        element instanceof HTMLOptionElement &&\n        key == 'selected' &&\n        element[key] !== value\n    ) {\n        element[key] = value;\n    }\n    if (\n        element instanceof HTMLDetailsElement &&\n        key == 'open' &&\n        element[key] !== value\n    ) {\n        element[key] = value;\n    }\n}\n\nfunction setStringPropertyValue(element: Element, key: string, value: string) {\n    if (\n        element instanceof HTMLInputElement &&\n        key === 'value' &&\n        element[key] !== value\n    ) {\n        element[key] = value;\n    }\n    if (\n        element instanceof HTMLTextAreaElement &&\n        key === 'value' &&\n        element[key] !== value\n    ) {\n        element[key] = value;\n    }\n    if (\n        element instanceof HTMLOptionElement &&\n        key === 'value' &&\n        element[key] !== value\n    ) {\n        element[key] = value;\n    }\n}\n\nfunction setAttributeValue(element: Element, key: string, value: unknown) {\n    if (value === null || value === undefined || value === false) {\n        element.removeAttribute(key);\n        setBooleanPropertyValue(element, key, false);\n        setStringPropertyValue(element, key, '');\n    } else if (value === true) {\n        element.setAttribute(key, '');\n        setBooleanPropertyValue(element, key, true);\n    } else if (typeof value === 'string') {\n        element.setAttribute(key, value);\n        setStringPropertyValue(element, key, value);\n    } else if (typeof value === 'number') {\n        element.setAttribute(key, value.toString());\n        setStringPropertyValue(element, key, value.toString());\n    } else if (key.startsWith('on:') && typeof value === 'function') {\n        const eventName = key.slice(3);\n        let attributes = boundEvents.get(element);\n        if (!attributes) {\n            attributes = {};\n            boundEvents.set(element, attributes);\n        }\n        if (attributes[key]) {\n            element.removeEventListener(eventName, attributes[key]);\n        }\n        element.addEventListener(eventName, value as any);\n        attributes[key] = value as any;\n    }\n}\n\nfunction renderAppending({\n    domParent,\n    parentNode,\n    jsxNode,\n}: {\n    domParent: VNode;\n    parentNode: VNode;\n    jsxNode: JSXNode;\n}) {\n    const emptyChildVNode = makeEmptyVNode({\n        domParent,\n        parentNode,\n    });\n    parentNode.children.push(emptyChildVNode);\n    renderReplacing({\n        nodeToReplace: emptyChildVNode,\n        jsxNode,\n    });\n}\n\nfunction renderReplacing({\n    nodeToReplace,\n    jsxNode,\n}: {\n    nodeToReplace: ChildVNode;\n    jsxNode: JSXNode;\n}): ChildVNode {\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        jsxNode === false ||\n        jsxNode === true\n    ) {\n        const emptyVNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onUnmount: [],\n        });\n        replaceVNode(nodeToReplace, emptyVNode);\n        return emptyVNode;\n    }\n    if (typeof jsxNode === 'string') {\n        const stringVNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: document.createTextNode(jsxNode),\n            onUnmount: [],\n        });\n        replaceVNode(nodeToReplace, stringVNode);\n        return stringVNode;\n    }\n    if (typeof jsxNode === 'number') {\n        const numberVNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: document.createTextNode(jsxNode.toString()),\n            onUnmount: [],\n        });\n        replaceVNode(nodeToReplace, numberVNode);\n        return numberVNode;\n    }\n    if (isRenderElement(jsxNode)) {\n        const element = document.createElement(jsxNode.element);\n\n        const boundEffects: Calculation<any>[] = [];\n        let refCallback: any = undefined;\n\n        // Bind props\n        if (jsxNode.props) {\n            Object.entries(jsxNode.props).forEach(([key, value]) => {\n                if (key === 'ref') {\n                    if (isRef(value)) {\n                        value.current = element;\n                        return;\n                    }\n                    if (typeof value === 'function' && !isCalculation(value)) {\n                        refCallback = value;\n                        return;\n                    }\n                }\n                if (isCalculation(value)) {\n                    const boundEffect = effect(() => {\n                        const computedValue = value();\n                        setAttributeValue(element, key, computedValue);\n                    }, `viewattr:${key}`);\n                    retain(boundEffect);\n                    boundEffects.push(boundEffect);\n                    boundEffect();\n                } else {\n                    setAttributeValue(element, key, value);\n                }\n            });\n        }\n\n        const elementNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: element,\n            onUnmount: [\n                () => {\n                    boundEffects.forEach((boundEffect) => release(boundEffect));\n                    if (refCallback) {\n                        refCallback(undefined);\n                    }\n                },\n            ],\n        });\n        replaceVNode(nodeToReplace, elementNode);\n\n        jsxNode.children.forEach((child) => {\n            renderAppending({\n                domParent: elementNode,\n                parentNode: elementNode,\n                jsxNode: child,\n            });\n        });\n\n        if (refCallback) {\n            refCallback(element);\n        }\n\n        return elementNode;\n    }\n    if (isCollection(jsxNode)) {\n        const trackedCollection = jsxNode;\n        const onUnmount: (() => void)[] = [];\n\n        const collectionNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onUnmount,\n        });\n        replaceVNode(nodeToReplace, collectionNode);\n\n        const unobserve = trackedCollection[ObserveKey]((event) => {\n            if (event.type === 'init') {\n                const { items } = event;\n                items.forEach((jsxChild) => {\n                    renderAppending({\n                        domParent: collectionNode.domParent,\n                        parentNode: collectionNode,\n                        jsxNode: jsxChild,\n                    });\n                });\n            } else if (event.type === 'splice') {\n                const { count, index, items } = event;\n                const childNodes = items.map(() =>\n                    makeEmptyVNode({\n                        domParent: collectionNode.domParent,\n                        parentNode: collectionNode,\n                    })\n                );\n                spliceVNode(\n                    collectionNode,\n                    collectionNode.children[index],\n                    count,\n                    childNodes\n                );\n                items.forEach((jsxChild, index) => {\n                    renderReplacing({\n                        nodeToReplace: childNodes[index],\n                        jsxNode: jsxChild,\n                    });\n                });\n            }\n        });\n\n        retain(trackedCollection);\n        onUnmount.push(unobserve);\n        onUnmount.push(() => {\n            release(trackedCollection);\n        });\n\n        return collectionNode;\n    }\n    if (isCalculation(jsxNode)) {\n        const trackedCalculation = jsxNode;\n        const onUnmount: Function[] = [];\n        const calculationNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onUnmount,\n        });\n        replaceVNode(nodeToReplace, calculationNode);\n\n        // Create a virtual node for the result of the calculation\n        let calculationResultNode = makeEmptyVNode({\n            parentNode: calculationNode,\n            domParent: calculationNode.domParent,\n        });\n        calculationNode.children.push(calculationResultNode);\n\n        const resultEffect = effect(() => {\n            const jsxChild = trackedCalculation();\n\n            calculationResultNode = renderReplacing({\n                nodeToReplace: calculationResultNode,\n                jsxNode: jsxChild,\n            });\n        }, `viewcalc:${debugNameFor(jsxNode) ?? 'node'}`);\n\n        retain(resultEffect);\n        onUnmount.push(() => release(resultEffect));\n\n        resultEffect();\n        return calculationNode;\n    }\n    if (isRenderComponent(jsxNode)) {\n        const onUnmount: Function[] = [];\n        const componentNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onUnmount,\n        });\n        replaceVNode(nodeToReplace, componentNode);\n\n        // Create a virtual node for the result of the component render\n        let componentResultNode = makeEmptyVNode({\n            parentNode: componentNode,\n            domParent: componentNode.domParent,\n        });\n        componentNode.children.push(componentResultNode);\n\n        const Component = jsxNode.component;\n        const resultEffect = effect(() => {\n            const onComponentMount: Function[] = [];\n            const jsxChild = Component(\n                {\n                    ...(jsxNode.props || {}),\n                    children: jsxNode.children,\n                },\n                {\n                    onUnmount: (unmountCallback) => {\n                        onUnmount.push(unmountCallback);\n                    },\n                    onMount: (mountCallback) => {\n                        onComponentMount.push(mountCallback);\n                    },\n                    onEffect: (\n                        effectCallback: () => void,\n                        debugName?: string\n                    ) => {\n                        const effectCalc = effect(\n                            effectCallback,\n                            `componenteffect:${jsxNode.component.name}:${\n                                debugName ?? onComponentMount.length\n                            }`\n                        );\n                        onComponentMount.push(() => {\n                            retain(effectCalc);\n                            effectCalc();\n                        });\n                        onUnmount.push(() => {\n                            release(effectCalc);\n                        });\n                    },\n                }\n            );\n\n            componentResultNode = renderReplacing({\n                nodeToReplace: componentResultNode,\n                jsxNode: jsxChild,\n            });\n\n            onComponentMount.forEach((mountCallback) => mountCallback());\n        }, `component:${jsxNode.component.name}`);\n\n        retain(resultEffect);\n        onUnmount.push(() => release(resultEffect));\n\n        resultEffect();\n        return componentNode;\n    }\n    if (Array.isArray(jsxNode)) {\n        const items = jsxNode;\n        const arrayNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode,\n            domNode: null,\n            onUnmount: [],\n        });\n        replaceVNode(nodeToReplace, arrayNode);\n\n        items.forEach((jsxChild) => {\n            renderAppending({\n                domParent: arrayNode.domParent,\n                parentNode: arrayNode,\n                jsxNode: jsxChild,\n            });\n        });\n        return arrayNode;\n    }\n    if (typeof jsxNode === 'function') {\n        const functionVNode = makeChildVNode({\n            parentNode: nodeToReplace.parentNode,\n            domParent: nodeToReplace.domParent,\n            jsxNode: jsxNode,\n            domNode: null,\n            onUnmount: [],\n        });\n        replaceVNode(nodeToReplace, functionVNode);\n        log.warn(\n            'Attempted to render JSX node that was a function, not rendering anything'\n        );\n        return functionVNode;\n    }\n    log.assertExhausted(jsxNode, 'unexpected render type');\n}\n\n/**\n * Mount the provided JSX to an element\n */\nexport function mount(parentElement: Element, jsxNode: JSXNode) {\n    const rootNode = makeRootVNode({ domNode: parentElement });\n    renderAppending({\n        domParent: rootNode,\n        parentNode: rootNode,\n        jsxNode: jsxNode,\n    });\n}\n\nexport const Fragment = ({ children }: { children: JSXNode[] }) => children;\n", "import {\n    InvariantError,\n    TypeTag,\n    Collection,\n    View,\n    CollectionEvent,\n    CollectionObserver,\n    ModelField,\n    ObserveKey,\n    GetRawArrayKey,\n    FlushKey,\n    SortFunction,\n    MappingFunction,\n    FilterFunction,\n    FlatMapFunction,\n} from './types';\nimport {\n    processChange,\n    addManualDep,\n    addDepToCurrentCalculation,\n} from './calc';\nimport { name } from './debug';\nimport * as log from './log';\n\n/**\n * Find the index of `item` using binary search in a sorted array\n *\n * Returns [lastComparison, index]\n * - if lastComparison < 0, item would be inserted before index\n * - if lastComparison > 0, item would be inserted after index\n * - if lastComparison == 0, item is compared equal to index\n */\nfunction binarySearchIndex<T>(\n    sortedArray: T[],\n    item: T,\n    sorter: SortFunction<T>\n): [lastComparison: number, index: number] {\n    let min = 0;\n    let max = sortedArray.length - 1;\n    let pivot = min;\n    let result = -1; // if sortedArray.length == 0, we want -1, so on a miss, we insert \"before\" index 0: arr.splice(0, 0, item)\n    while (min <= max) {\n        pivot = (min + max) >> 1; // floor((L+R)/2)\n        result = sorter(item, sortedArray[pivot]);\n        if (result < 0) {\n            max = pivot - 1;\n        } else if (result > 0) {\n            min = pivot + 1;\n        } else {\n            return [result, pivot];\n        }\n    }\n    return [result, pivot];\n}\n\n/**\n * Make a mutable array to hold state, with some additional convenience methods\n */\nexport function collection<T>(array: T[], debugName?: string): Collection<T> {\n    if (!Array.isArray(array)) {\n        throw new InvariantError('collection must be provided an array');\n    }\n\n    const fields: Map<string | number | symbol, ModelField<T>> = new Map();\n    let observers: CollectionObserver<T>[] = [];\n\n    function notify(event: CollectionEvent<T>) {\n        observers.forEach((observer) => {\n            observer(event);\n        });\n    }\n\n    function splice(index: number, count: number, ...items: T[]): T[] {\n        if (count < 1 && items.length === 0) return []; // noop\n        const origLength = array.length;\n        const removed = array.splice(index, count, ...items);\n        const newLength = array.length;\n        notify({\n            type: 'splice',\n            index,\n            count,\n            items,\n            removed,\n        });\n\n        // Cases to consider:\n        // 1. count === items.length: we are replacing count items\n        // 2. count > items.length: we are adding (count - items.length items), notify index to new end\n        // 3. count < items.length: we are removing (items.length - count items), notify index to old end\n\n        // Process changes in *added* items\n        if (origLength === newLength) {\n            for (let i = index; i < index + count; ++i) {\n                processChange(getField(i.toString()));\n            }\n        } else {\n            for (let i = index; i < Math.max(newLength, origLength); ++i) {\n                processChange(getField(i.toString()));\n            }\n            processChange(getField('length'));\n        }\n        processChange(proxy);\n        return removed;\n    }\n\n    function pop(): T | undefined {\n        const removed = splice(array.length - 1, 1);\n        return removed[0];\n    }\n\n    function shift(): T | undefined {\n        const removed = splice(0, 1);\n        return removed[0];\n    }\n\n    function push(...items: T[]): number {\n        splice(array.length, 0, ...items);\n        return array.length;\n    }\n\n    function unshift(...items: T[]): number {\n        splice(0, 0, ...items);\n        return array.length;\n    }\n\n    function reject(func: (item: T, index: number) => boolean) {\n        for (let i = proxy.length - 1; i >= 0; --i) {\n            if (!func(proxy[i], i)) {\n                proxy.splice(i, 1);\n            }\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    function sort(_sorter: never): T[] {\n        throw new Error('sort not implemented');\n    }\n\n    const deferred: (() => void)[] = [];\n\n    function sortedView(\n        sorter: SortFunction<T>,\n        viewDebugName?: string\n    ): View<T> {\n        let sortedDebugName: string | undefined;\n        if (viewDebugName) {\n            sortedDebugName = viewDebugName;\n        } else if (debugName) {\n            sortedDebugName = `${debugName}:sortedView`;\n        }\n        const sorted: Collection<T> = collection([], sortedDebugName);\n        proxy[ObserveKey]((event) => {\n            if (event.type === 'init') {\n                const initialItems = event.items.slice();\n                initialItems.sort(sorter);\n                sorted.push(...initialItems);\n                return;\n            } else if (event.type === 'splice') {\n                deferred.push(() => {\n                    const { items, removed } = event;\n                    // First handle removals\n                    const rawArray = sorted[GetRawArrayKey]();\n                    removed.forEach((removedItem, removedItemIndex) => {\n                        const [lastComparison, index] = binarySearchIndex(\n                            rawArray,\n                            removedItem,\n                            sorter\n                        );\n                        log.assert(\n                            lastComparison === 0,\n                            'Missing item removed from source array in sortedView splice',\n                            { removedItem, removedItemIndex, event }\n                        );\n                        sorted.splice(index, 1);\n                    });\n\n                    // Then handle insertions\n                    items.forEach((item) => {\n                        const [lastComparison, insertionIndex] =\n                            binarySearchIndex(rawArray, item, sorter);\n                        sorted.splice(\n                            lastComparison > 0\n                                ? insertionIndex + 1\n                                : insertionIndex,\n                            0,\n                            item\n                        );\n                    });\n                });\n            }\n        });\n        return sorted;\n    }\n\n    function mapView<V>(\n        mapper: MappingFunction<T, V>,\n        viewDebugName?: string\n    ): View<V> {\n        let mappedDebugName: string | undefined;\n        if (viewDebugName) {\n            mappedDebugName = viewDebugName;\n        } else if (debugName) {\n            mappedDebugName = `${debugName}:mapView`;\n        }\n        const mapped = collection(array.map(mapper), mappedDebugName);\n        proxy[ObserveKey]((event) => {\n            if (event.type === 'splice') {\n                deferred.push(() => {\n                    const { index, count, items } = event;\n                    // Well that's deceptively easy\n                    mapped.splice(index, count, ...items.map(mapper));\n                });\n            }\n        });\n        addManualDep(proxy, mapped);\n        return mapped;\n    }\n\n    function filterView(\n        fn: FilterFunction<T>,\n        viewDebugName?: string\n    ): View<T> {\n        let mappedDebugName: string | undefined;\n        if (viewDebugName) {\n            mappedDebugName = viewDebugName;\n        } else if (debugName) {\n            mappedDebugName = `${debugName}:filterView`;\n        }\n        // TODO: this could probably be more efficient, each time splice() is called, we iterate from 0 to index+count\n        // We may be able to precalculate a mapping from index -> filteredIndex\n        const filterPresent: boolean[] = [];\n        const filtered: Collection<T> = collection([], mappedDebugName);\n        array.forEach((value, index) => {\n            const present = fn(value, index);\n            filterPresent.push(present);\n            if (present) {\n                filtered.push(value);\n            }\n        });\n\n        proxy[ObserveKey]((event) => {\n            if (event.type === 'splice') {\n                deferred.push(() => {\n                    const { index, count, items } = event;\n                    let realIndex = 0;\n                    let realCount = 0;\n                    for (let i = 0; i < index; ++i) {\n                        if (filterPresent[i]) {\n                            realIndex++;\n                        }\n                    }\n                    for (let i = 0; i < count; ++i) {\n                        if (filterPresent[index + i]) {\n                            realCount++;\n                        }\n                    }\n                    const presentItems = items.map(fn);\n                    filterPresent.splice(index, count, ...presentItems);\n                    filtered.splice(\n                        realIndex,\n                        realCount,\n                        ...items.filter((_value, index) => presentItems[index])\n                    );\n                });\n            }\n        });\n        addManualDep(proxy, filtered);\n        return filtered;\n    }\n\n    function flatMapView<V>(\n        fn: FlatMapFunction<T, V>,\n        viewDebugName?: string\n    ): View<V> {\n        let mappedDebugName: string | undefined;\n        if (viewDebugName) {\n            mappedDebugName = viewDebugName;\n        } else if (debugName) {\n            mappedDebugName = `${debugName}:flatMapView`;\n        }\n        const flatMapped: Collection<V> = collection([], mappedDebugName);\n        const flatMapCount: number[] = [];\n        array.forEach((value, index) => {\n            const chunk = fn(value, index);\n            flatMapped.push(...chunk);\n            flatMapCount.push(chunk.length);\n        });\n\n        proxy[ObserveKey]((event) => {\n            if (event.type === 'splice') {\n                deferred.push(() => {\n                    const { index, count, items } = event;\n                    let realIndex = 0;\n                    for (let i = 0; i < index; ++i) {\n                        realIndex += flatMapCount[i];\n                    }\n                    let realCount = 0;\n                    for (let i = index; i < index + count; ++i) {\n                        realCount += flatMapCount[i];\n                    }\n                    // Well that's deceptively easy\n                    const realItems: V[] = [];\n                    const realItemCount: number[] = [];\n                    items.forEach((itemValue, itemIndex) => {\n                        const chunk = fn(itemValue, itemIndex);\n                        realItems.push(...chunk);\n                        realItemCount.push(chunk.length);\n                    });\n                    flatMapped.splice(realIndex, realCount, ...realItems);\n                    flatMapCount.splice(index, count, ...realItemCount);\n                });\n            }\n        });\n        addManualDep(proxy, flatMapped);\n        return flatMapped;\n    }\n\n    function set(index: number, val: T): void {\n        splice(index, 1, val);\n    }\n\n    function observe(observer: CollectionObserver<T>) {\n        observers.push(observer);\n        observer({\n            type: 'init',\n            items: array,\n        });\n        return () => {\n            observers = observers.filter((obs) => obs !== observer);\n        };\n    }\n\n    function flush() {\n        let thunk;\n        while ((thunk = deferred.shift())) {\n            thunk();\n        }\n    }\n\n    function getRawArray() {\n        return array;\n    }\n\n    const methods = {\n        splice,\n        pop,\n        shift,\n        push,\n        unshift,\n        [ObserveKey]: observe,\n        [FlushKey]: flush,\n        [GetRawArrayKey]: getRawArray,\n        sort,\n        reject,\n        sortedView,\n        mapView,\n        filterView,\n        flatMapView,\n    };\n\n    function getField(key: string | number | symbol) {\n        let field = fields.get(key);\n        if (!field) {\n            field = {\n                model: proxy,\n                key,\n            };\n            if (debugName) name(field, debugName);\n            fields.set(key, field);\n        }\n        return field;\n    }\n\n    const proxy: Collection<T> = new Proxy(array, {\n        get(target: any, key: string | symbol) {\n            if (key in methods) {\n                return (methods as any)[key];\n            }\n            if (key === TypeTag) {\n                return 'collection';\n            }\n            const field = getField(key);\n            addManualDep(proxy, field);\n            addDepToCurrentCalculation(field);\n            return target[key];\n        },\n\n        set(target: any, key: string | number | symbol, value: any) {\n            if (key in methods) {\n                log.error(\n                    'Overriding certain collection methods not supported',\n                    key\n                );\n                // TODO(sufian): maybe support this?\n                return false;\n            }\n            const numericKey = Number(key);\n            if (!isNaN(numericKey) && numericKey <= array.length) {\n                set(numericKey, value);\n                // Implicitly calls processChange via splice\n            } else {\n                target[key] = value;\n                const field = getField(key);\n                processChange(field);\n                processChange(proxy);\n            }\n            return true;\n        },\n\n        deleteProperty(target: any, key) {\n            if (key in methods) {\n                log.error(\n                    'Deleting certain collection methods not supported',\n                    key\n                );\n                // TODO(sufian): maybe support this?\n                return false;\n            }\n            const field = getField(key);\n            processChange(field); // TODO(sufian): what to do here?\n            delete target[key];\n            return true;\n        },\n    }) as Collection<T>;\n\n    if (debugName) name(proxy, debugName);\n\n    return proxy;\n}\n", "import {\n    InvariantError,\n    TypeTag,\n    Model,\n    ModelEvent,\n    ModelObserver,\n    OwnKeysField,\n    Collection,\n    View,\n    ModelField,\n    ObserveKey,\n} from './types';\nimport { collection } from './collection';\nimport {\n    effect,\n    addManualDep,\n    addDepToCurrentCalculation,\n    processChange,\n} from './calc';\nimport { name, debugNameFor } from './debug';\n\nexport function model<T extends {}>(obj: T, debugName?: string): Model<T> {\n    if (typeof obj !== 'object' || !obj) {\n        throw new InvariantError('model must be provided an object');\n    }\n\n    const fields: Map<string | number | symbol, ModelField<T>> = new Map();\n    let observers: ModelObserver[] = [];\n\n    function notify(event: ModelEvent) {\n        observers.forEach((observer) => {\n            observer(event);\n        });\n    }\n\n    function getField(key: string | number | symbol): ModelField<T> {\n        let field = fields.get(key);\n        if (!field) {\n            field = {\n                model: proxy,\n                key,\n            };\n            if (debugName) name(field, debugName);\n            fields.set(key, field);\n        }\n        return field;\n    }\n\n    const knownFields: Set<string | number | symbol> = new Set(\n        Object.keys(obj)\n    );\n\n    function observe(observer: ModelObserver) {\n        observers.push(observer);\n        observer({\n            type: 'init',\n            keys: Object.keys(obj),\n        });\n        return () => {\n            observers = observers.filter((obs) => obs !== observer);\n        };\n    }\n\n    const methods = {\n        [ObserveKey]: observe,\n    };\n\n    const proxy = new Proxy(obj, {\n        get(target: any, key: string | symbol) {\n            if (key === TypeTag) {\n                return 'model';\n            }\n            if (key in methods) {\n                return (methods as any)[key];\n            }\n            const field = getField(key);\n            addDepToCurrentCalculation(field);\n            return target[key];\n        },\n\n        has(target: any, key: string | symbol) {\n            if (key === TypeTag) {\n                return true;\n            }\n            if (key in methods) {\n                return true;\n            }\n            const field = getField(key);\n            addDepToCurrentCalculation(field);\n            return knownFields.has(key);\n        },\n\n        set(target: any, key: string | number | symbol, value: any) {\n            const field = getField(key);\n            const changed = !knownFields.has(key) || target[key] !== value;\n            target[key] = value;\n            if (changed) {\n                processChange(field);\n                if (!knownFields.has(key)) {\n                    knownFields.add(key);\n                    notify({ type: 'add', key });\n                    if (typeof key !== 'symbol') {\n                        processChange(getField(OwnKeysField));\n                    }\n                }\n                notify({ type: 'set', key, value });\n            }\n            return true;\n        },\n\n        deleteProperty(target: any, key: string | number | symbol) {\n            const field = getField(key);\n            const changed = knownFields.has(key);\n            if (changed) {\n                processChange(field);\n                knownFields.delete(key);\n                if (typeof key !== 'symbol') {\n                    processChange(getField(OwnKeysField));\n                }\n                notify({ type: 'delete', key });\n            }\n            delete target[key];\n            return true;\n        },\n    }) as Model<T>;\n\n    if (debugName) name(proxy, debugName);\n\n    return proxy;\n}\nmodel.keys = function keys<T>(target: Model<T>): View<string> {\n    const view: Collection<string> = collection([]);\n    name(view, `keys(${debugNameFor(target)})`);\n\n    const keysSet = new Set<string>();\n\n    function addKey(key: string | number | symbol) {\n        if (typeof key === 'number' || typeof key === 'string') {\n            const stringKey = key.toString();\n            if (!keysSet.has(stringKey)) {\n                keysSet.add(stringKey);\n                view.push(stringKey);\n            }\n        }\n    }\n\n    function delKey(key: string | number | symbol) {\n        if (typeof key === 'number' || typeof key === 'string') {\n            const stringKey = key.toString();\n            if (keysSet.has(stringKey)) {\n                keysSet.delete(stringKey);\n                view.reject((k) => k !== stringKey);\n            }\n        }\n    }\n\n    const events: ModelEvent[] = [];\n\n    // TODO: should this use the same \"deferred\" mechanism of collections?\n    const updateEffect = effect(() => {\n        target[OwnKeysField]; // Access the Object.keys pesudo-field to ensure this effect tracks key changes\n        let event;\n        while ((event = events.shift())) {\n            if (event.type === 'init') {\n                event.keys.forEach((key) => {\n                    addKey(key);\n                });\n            }\n            if (event.type === 'add') {\n                addKey(event.key);\n            }\n            if (event.type === 'delete') {\n                delKey(event.key);\n            }\n        }\n    });\n    addManualDep(updateEffect, view);\n    updateEffect();\n\n    target[ObserveKey]((event) => {\n        events.push(event);\n    });\n\n    return view;\n};\n", "export { setLogLevel } from './log';\nimport { createElement } from './view';\nexport { Fragment, mount } from './view';\nexport { Component } from './jsx';\nexport { model } from './model';\nexport { collection } from './collection';\nexport {\n    calc,\n    effect,\n    reset,\n    subscribe,\n    flush,\n    retain,\n    release,\n    debug,\n} from './calc';\n\nexport {\n    ref,\n    Ref,\n    InvariantError,\n    Calculation,\n    Collection,\n    Model,\n    OnCollectionRelease,\n} from './types';\n\nexport default createElement;\n\nexport const VERSION = 'development';\n", "export interface InitMessageTest {\n    id: number;\n    name: string;\n    only: boolean;\n}\n\nexport function isInitMessageTest(test: any): test is InitMessageTest {\n    return !!(\n        typeof test === 'object' &&\n        test &&\n        typeof test.id === 'number' &&\n        typeof test.name === 'string' &&\n        typeof test.only === 'boolean'\n    );\n}\n\nexport interface InitMessageSuite {\n    id: number;\n    name: string;\n    parentSuiteId: number | undefined;\n    only: boolean;\n    tests: InitMessageTest[];\n}\n\nexport function isInitMessageSuite(suite: any): suite is InitMessageSuite {\n    return !!(\n        typeof suite === 'object' &&\n        suite &&\n        typeof suite.id === 'number' &&\n        typeof suite.name === 'string' &&\n        (typeof suite.parentSuiteId === 'number' ||\n            suite.parentSuiteId === undefined) &&\n        typeof suite.only === 'boolean' &&\n        Array.isArray(suite.tests) &&\n        suite.tests.every((test: any) => isInitMessageTest(test))\n    );\n}\n\nexport interface InitMessage {\n    url: string;\n    type: 'init';\n    suites: InitMessageSuite[];\n}\n\nexport function isInitMessage(msg: any): msg is InitMessage {\n    return !!(\n        typeof msg === 'object' &&\n        msg &&\n        typeof msg.url === 'string' &&\n        msg.type === 'init' &&\n        Array.isArray(msg.suites) &&\n        msg.suites.every((suite: any) => isInitMessageSuite(suite))\n    );\n}\n\nexport interface Response<T> {\n    id: number;\n    type: 'response';\n    response: T;\n    isPartial: boolean;\n}\n\nexport function makeResponse<T>(id: number, item: T): Response<T> {\n    return {\n        id,\n        type: 'response',\n        response: item,\n        isPartial: false,\n    };\n}\n\nexport function makePartialResponse<T>(id: number, item: T): Response<T> {\n    return {\n        id,\n        type: 'response',\n        response: item,\n        isPartial: true,\n    };\n}\n\nexport interface Request<T> {\n    id: number;\n    type: 'request';\n    request: T;\n}\n\nexport interface InitRequest {\n    type: 'init';\n}\n\nexport function makeRequest<T>(id: number, item: T): Request<T> {\n    return {\n        id,\n        type: 'request',\n        request: item,\n    };\n}\n\nexport interface RunTestRequest {\n    type: 'runtest';\n    suiteId: number;\n    testId: number;\n}\n\nexport function isRequest(msg: any): msg is Request<unknown> {\n    return (\n        typeof msg.id === 'number' && msg.type === 'request' && 'request' in msg\n    );\n}\n\nexport function isInitRequest(msg: any): msg is Request<InitRequest> {\n    if (!isRequest(msg)) return false;\n    const request: any = msg.request;\n    return !!(request && request.type === 'init');\n}\n\nexport function isResponse(msg: any): msg is Response<unknown> {\n    return (\n        typeof msg.id === 'number' &&\n        msg.type === 'response' &&\n        typeof msg.response === 'object' &&\n        typeof msg.isPartial === 'boolean'\n    );\n}\n\nexport function makeRunTestRequest({\n    suiteId,\n    testId,\n}: {\n    suiteId: number;\n    testId: number;\n}): RunTestRequest {\n    return {\n        type: 'runtest',\n        suiteId,\n        testId,\n    };\n}\n\nexport function isRunTestRequest(msg: any): msg is Request<RunTestRequest> {\n    if (!isRequest(msg)) return false;\n    const request: any = msg.request;\n    return !!(\n        request &&\n        request.type === 'runtest' &&\n        typeof request.suiteId === 'number' &&\n        typeof request.testId === 'number'\n    );\n}\n\nexport type RunResponse =\n    | { type: 'runtest'; result: 'done' }\n    | { type: 'runtest'; result: 'error'; error: string };\n\nexport function isRunResponse(msg: any): msg is RunResponse {\n    return (\n        msg.type === 'runtest' &&\n        (msg.result === 'done' ||\n            (msg.result === 'error' && typeof msg.error === 'string'))\n    );\n}\n\nexport type RunUpdate =\n    | { type: 'internal'; error: string }\n    | {\n          type: 'test';\n          suiteId: number;\n          testId: number;\n          result: 'fail';\n          error: string;\n      }\n    | {\n          type: 'test';\n          suiteId: number;\n          testId: number;\n          result: 'pass';\n          duration: number;\n          selfDuration: number;\n      }\n    | {\n          type: 'test';\n          suiteId: number;\n          testId: number;\n          result: 'run';\n      };\n\nexport function isRunUpdate(msg: any): msg is RunUpdate {\n    if (msg && msg.type === 'internal' && typeof msg.error === 'string') {\n        return true;\n    }\n    if (\n        msg &&\n        msg.type === 'test' &&\n        typeof msg.testId === 'number' &&\n        typeof msg.suiteId === 'number' &&\n        msg.result === 'pass' &&\n        typeof msg.duration === 'number' &&\n        typeof msg.selfDuration === 'number'\n    ) {\n        return true;\n    }\n    if (\n        msg &&\n        msg.type === 'test' &&\n        typeof msg.testId === 'number' &&\n        typeof msg.suiteId === 'number' &&\n        msg.result === 'run'\n    ) {\n        return true;\n    }\n    if (\n        msg &&\n        msg.type === 'test' &&\n        typeof msg.testId === 'number' &&\n        typeof msg.suiteId === 'number' &&\n        msg.result === 'fail' &&\n        typeof msg.error === 'string'\n    ) {\n        return true;\n    }\n    return false;\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n", "import { isResponse, makeRequest } from './types';\nimport { makePromise } from '../util';\n\nconst makeId = (() => {\n    let maxId = 0;\n    return () => maxId++;\n})();\n\nconst requests: Record<\n    number,\n    (response: unknown, isPartial: boolean) => void\n> = {};\nexport function request<T>(\n    targetWindow: Window,\n    request: any,\n    validator: (response: any) => response is T\n): Promise<T> {\n    const id = makeId();\n    const promise = new Promise<T>((resolve, reject) => {\n        requests[id] = (response: unknown, isPartial: boolean) => {\n            if (isPartial) {\n                console.error(\n                    'Got partial response when full response expected',\n                    response\n                );\n                reject(\n                    new Error(\n                        'Got partial response when full response expected'\n                    )\n                );\n            }\n            if (validator(response)) {\n                resolve(response);\n            } else {\n                reject(new Error('Failed validation'));\n            }\n            delete requests[id];\n        };\n    });\n    const msg = makeRequest(id, request);\n    targetWindow.postMessage(msg);\n    return promise;\n}\n\nexport async function* requestStream(\n    targetWindow: Window,\n    request: any\n): AsyncGenerator<unknown, void> {\n    const id = makeId();\n\n    const messages: {\n        response: unknown;\n        isPartial: boolean;\n    }[] = [];\n\n    let notify = makePromise<void>().resolve;\n    requests[id] = (response: unknown, isPartial: boolean) => {\n        messages.push({ response, isPartial });\n        notify();\n    };\n    const msg = makeRequest(id, request);\n    targetWindow.postMessage(msg);\n\n    while (true) {\n        if (messages.length === 0) {\n            const { promise, resolve } = makePromise();\n            notify = resolve;\n            await promise;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const { response, isPartial } = messages.shift()!;\n        yield response;\n        if (!isPartial) {\n            delete requests[id];\n            return;\n        }\n    }\n}\n\nwindow.addEventListener(\n    'message',\n    (event) => {\n        if (event.origin !== window.location.origin) {\n            return;\n        }\n        const source = event.source;\n        if (!source) {\n            return;\n        }\n        const msg = event.data;\n        if (!isResponse(msg)) {\n            console.error(\n                'Received malformed message, message not response',\n                event\n            );\n            return;\n        }\n        if (!requests[msg.id]) {\n            console.log(\n                'Received unexpected message, message id not expected',\n                event\n            );\n            return;\n        }\n        requests[msg.id](msg.response, msg.isPartial);\n    },\n    false\n);\n", "import Revise, {\n    Fragment,\n    Component,\n    Collection,\n    Model,\n    collection,\n    calc,\n    model,\n    mount,\n} from './index';\nimport {\n    isInitMessage,\n    isRunUpdate,\n    isRunResponse,\n    makeRunTestRequest,\n} from './test/types';\nimport { request, requestStream } from './test/rpc';\nimport { groupBy2 } from './util';\nimport testManifest from '../test-manifest.json'; // Generated from s/test\n\nfunction classes(...args: (string | boolean | null | undefined)[]) {\n    return args.filter((x) => !!x).join(' ');\n}\n\nconst millis = (ms?: number) => `${(ms || 0).toFixed(3)}ms`;\n\n/**\n * Record types\n */\ntype TestFileRecord = Model<{\n    src: string;\n    buildTarget: string;\n    iframe: HTMLIFrameElement;\n    suites: Collection<SuiteRecord>;\n    active: boolean;\n    initialized: boolean;\n}>;\n\ntype SuiteRecord = Model<{\n    id: number;\n    name: string;\n    only: boolean;\n    tests: Collection<TestRecord>;\n    parentSuiteId: number | undefined;\n    status?: 'fail' | 'pass' | 'run';\n    error?: string;\n}>;\n\ntype TestRecord = Model<{\n    id: number;\n    name: string;\n    only: boolean;\n    status?: 'fail' | 'pass' | 'run';\n    error?: string;\n    selfDuration?: number;\n    duration?: number;\n}>;\n\n/**\n * State\n */\nconst testFiles: Model<Record<string, TestFileRecord>> = model({});\nconst uiState = model({\n    stopOnFailure: true,\n});\n\nfunction initializeTestSandbox(\n    testFile: { src: string; buildTarget: string },\n    iframeElement: HTMLIFrameElement\n) {\n    iframeElement.addEventListener('load', () => {\n        const contentWindow = iframeElement.contentWindow;\n        const contentDocument = iframeElement.contentDocument;\n        if (!contentWindow) throw new Error('iframe missing contentWindow');\n        if (!contentDocument) throw new Error('iframe missing contentDocument');\n\n        const suites = collection<SuiteRecord>([]);\n\n        testFiles[testFile.buildTarget] = model({\n            src: testFile.src,\n            buildTarget: testFile.buildTarget,\n            iframe: iframeElement,\n            suites,\n            active: false,\n            initialized: false,\n        });\n\n        const script = contentDocument.createElement('script');\n        script.src = testFile.buildTarget;\n        script.onload = () => {\n            request(\n                contentWindow,\n                {\n                    type: 'init',\n                },\n                isInitMessage\n            )\n                .then((initMessage) => {\n                    initMessage.suites.forEach((suite) => {\n                        const tests = collection<TestRecord>([]);\n                        suite.tests.forEach((test) => {\n                            const testModel = model({\n                                id: test.id,\n                                name: test.name,\n                                only: test.only,\n                            });\n                            tests.push(testModel);\n                        });\n                        const suiteModel = model({\n                            id: suite.id,\n                            name: suite.name,\n                            tests,\n                            only: suite.only,\n                            parentSuiteId: suite.parentSuiteId,\n                        });\n                        suites.push(suiteModel);\n                    });\n                    testFiles[testFile.buildTarget].initialized = true;\n                })\n                .catch((e) => {\n                    console.error('Failed to initialize', testFile, e);\n                });\n        };\n        contentDocument.body.appendChild(script);\n    });\n}\n\n/**\n * Actions\n */\nfunction resetAllTestState() {\n    for (const testFile of Object.values(testFiles)) {\n        resetTestFileState(testFile);\n    }\n}\n\nfunction resetTestFileState(testFile: TestFileRecord) {\n    for (const suite of testFile.suites) {\n        suite.status = undefined;\n        suite.error = undefined;\n        suite.only = false;\n        for (const test of suite.tests) {\n            test.status = undefined;\n            test.only = false;\n        }\n    }\n}\n\nasync function runTests() {\n    const allSuites: [TestFileRecord, SuiteRecord, TestRecord][] = [];\n    let toRun: [TestFileRecord, SuiteRecord, TestRecord][] = [];\n\n    // Determine tests to run; clear out prior results\n    for (const testFile of Object.values(testFiles)) {\n        for (const suite of testFile.suites) {\n            suite.status = undefined;\n            suite.error = undefined;\n            if (suite.only) {\n                suite.tests.forEach((test) => {\n                    allSuites.push([testFile, suite, test]);\n                    toRun.push([testFile, suite, test]);\n                });\n            } else {\n                for (const test of suite.tests) {\n                    test.status = undefined;\n                    test.error = undefined;\n                    test.duration = undefined;\n                    test.selfDuration = undefined;\n\n                    allSuites.push([testFile, suite, test]);\n                    if (test.only) {\n                        toRun.push([testFile, suite, test]);\n                    }\n                }\n            }\n        }\n    }\n    if (toRun.length === 0) {\n        toRun = allSuites;\n    }\n\n    const groupedTests = groupBy2(toRun, (item) => [item[0], item[1], item[2]]);\n\n    // Run selected tests\n    for (const [testFile, suites] of groupedTests) {\n        const contentWindow = testFile.iframe.contentWindow;\n        if (!contentWindow) {\n            console.error('No content window!?');\n            continue;\n        }\n\n        testFile.active = true;\n        try {\n            for (const [suite, tests] of suites) {\n                let numFailures = 0;\n                suite.status = 'run';\n                for (const test of tests) {\n                    const stream = requestStream(\n                        contentWindow,\n                        makeRunTestRequest({\n                            suiteId: suite.id,\n                            testId: test.id,\n                        })\n                    );\n                    for await (const msg of stream) {\n                        if (isRunUpdate(msg)) {\n                            switch (msg.type) {\n                                case 'internal':\n                                    suite.status = 'fail';\n                                    test.status = 'fail';\n                                    test.error = msg.error;\n                                    throw new Error(\n                                        'Internal error: ' + msg.error\n                                    );\n                                    break;\n                                case 'test': {\n                                    if (msg.suiteId !== suite.id) {\n                                        throw new Error(\n                                            'Malformed message; suite mismatch'\n                                        );\n                                    }\n                                    test.status = msg.result;\n                                    if (msg.result === 'fail') {\n                                        suite.status = 'fail';\n                                        test.error = msg.error;\n                                        numFailures += 1;\n                                        continue;\n                                    }\n                                    if (msg.result === 'pass') {\n                                        test.duration = msg.duration;\n                                        test.selfDuration = msg.selfDuration;\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        if (isRunResponse(msg)) {\n                            switch (msg.type) {\n                                case 'runtest':\n                                    break;\n                            }\n                        }\n                    }\n                    if (numFailures > 0 && uiState.stopOnFailure) {\n                        return;\n                    }\n                }\n                suite.status = numFailures > 0 ? 'fail' : 'pass';\n            }\n        } finally {\n            testFile.active = false;\n        }\n    }\n}\n\n/**\n * Views\n */\nconst TestView: Component<{ test: TestRecord }> = ({ test }) => {\n    const onClick = (e: MouseEvent) => {\n        e.preventDefault();\n        if (!e.shiftKey) {\n            resetAllTestState();\n        }\n        test.only = !test.only;\n        runTests();\n    };\n    const statusText = {\n        run: 'RUN:',\n        pass: 'PASS',\n        fail: 'FAIL',\n    } as const;\n    return (\n        <div\n            class={calc(() =>\n                classes(\n                    'test',\n                    test.only && 'test--only',\n                    test.status === 'run' && 'test--running',\n                    test.status === 'pass' && 'test--pass',\n                    test.status === 'fail' && 'test--fail'\n                )\n            )}\n        >\n            <a class=\"test__link\" href=\"#\" on:click={onClick}>\n                {calc(() => (test.status ? statusText[test.status] : ''))}{' '}\n                {calc(() => test.name)}\n                {calc(\n                    () =>\n                        test.duration !== undefined &&\n                        test.selfDuration !== undefined && (\n                            <>\n                                : ({millis(test.selfDuration)};{' '}\n                                {millis(test.duration)} including setup)\n                            </>\n                        )\n                )}\n            </a>\n            {calc(\n                () =>\n                    test.status === 'fail' &&\n                    test.error && <pre>{test.error}</pre>\n            )}\n        </div>\n    );\n};\n\nconst SuiteView: Component<{ suite: SuiteRecord }> = ({ suite }) =>\n    suite.tests.length > 0 && (\n        <details\n            class={calc(() =>\n                classes(\n                    'suite',\n                    suite.status === 'run' && 'suite--running',\n                    suite.status === 'pass' && 'suite--pass',\n                    suite.status === 'fail' && 'suite--fail'\n                )\n            )}\n            open={calc(\n                () =>\n                    !(\n                        suite.status === 'pass' &&\n                        suite.tests.every((test) => test.status === 'pass')\n                    )\n            )}\n        >\n            <summary class=\"suite__top\">\n                <div class=\"suite__name\">\n                    {calc(() => suite.name || '<root>')}\n                </div>\n                {calc(\n                    () =>\n                        suite.status && (\n                            <div class=\"suite__info\">{suite.status}</div>\n                        )\n                )}\n                {calc(\n                    () =>\n                        suite.tests.length > 0 &&\n                        suite.status === 'pass' && (\n                            <div class=\"suite__info\">\n                                {\n                                    suite.tests.filter(\n                                        (test) => test.status === 'pass'\n                                    ).length\n                                }{' '}\n                                / {suite.tests.length}\n                            </div>\n                        )\n                )}\n                {calc(\n                    () =>\n                        suite.tests.length > 0 &&\n                        (suite.status === 'pass' ||\n                            suite.status === 'fail') && (\n                            <div class=\"suite__info\">\n                                in{' '}\n                                {millis(\n                                    suite.tests.reduce(\n                                        (acc, test) =>\n                                            acc + (test?.duration ?? 0),\n                                        0\n                                    )\n                                )}\n                            </div>\n                        )\n                )}\n            </summary>\n            {suite.tests.mapView((test) => (\n                <TestView test={test} />\n            ))}\n        </details>\n    );\n\nconst TestFileView: Component<{ testFile: TestFileRecord }> = ({\n    testFile,\n}) => (\n    <details class=\"testfile\" open>\n        <summary class=\"testfile__status\">{calc(() => testFile.src)}</summary>\n        {calc(() =>\n            testFile.suites.mapView((suite) =>\n                calc(() => <SuiteView suite={suite} />)\n            )\n        )}\n    </details>\n);\n\nconst TestRunner: Component<{}> = (props, { onMount, onEffect }) => {\n    const testFileKeys = model.keys(testFiles);\n\n    // Kick off tests once everything is initialized\n    onEffect(() => {\n        if (\n            testFileKeys.length === testManifest.length &&\n            testFileKeys.every(\n                (testFileKey) => testFiles[testFileKey].initialized\n            )\n        ) {\n            runTests();\n        }\n    });\n\n    const onClickRunAll = () => {\n        resetAllTestState();\n        runTests();\n    };\n    const onClickRerun = () => {\n        runTests();\n    };\n\n    const hasEmptyTests = calc(() => {\n        return testFileKeys.every((testFileKey) => {\n            return testFiles[testFileKey].suites.every((suite) => {\n                return suite.tests.length === 0;\n            });\n        });\n    });\n\n    const hasAnyOnlyItems = calc(() => {\n        return !testFileKeys.some((testFileKey) => {\n            return testFiles[testFileKey].suites.some((suite) => {\n                return suite.only || suite.tests.some((test) => test.only);\n            });\n        });\n    });\n\n    const onStopToggle = (e: UIEvent) => {\n        uiState.stopOnFailure = !!(e.target as HTMLInputElement)?.checked;\n    };\n\n    return (\n        <div class=\"testrunner\">\n            <div class=\"test-ui\">\n                <button disabled={hasEmptyTests} on:click={onClickRunAll}>\n                    Run all tests\n                </button>\n                <button disabled={hasAnyOnlyItems} on:click={onClickRerun}>\n                    Rerun selected tests\n                </button>\n                <label>\n                    <input\n                        type=\"checkbox\"\n                        checked={calc(() => uiState.stopOnFailure)}\n                        on:change={onStopToggle}\n                    />{' '}\n                    Stop on failure\n                </label>\n                {testFileKeys.mapView((testFile) => (\n                    <TestFileView testFile={testFiles[testFile]} />\n                ))}\n            </div>\n            <div class=\"test-sandboxes\">\n                {testManifest.map((testFile) => (\n                    <iframe\n                        class={calc(() =>\n                            classes(\n                                testFiles[testFile.buildTarget]?.active &&\n                                    'active'\n                            )\n                        )}\n                        ref={(iframeElement: HTMLIFrameElement | null) => {\n                            if (!iframeElement) {\n                                return;\n                            }\n                            initializeTestSandbox(testFile, iframeElement);\n                        }}\n                        src=\"testsandbox.html\"\n                    />\n                ))}\n            </div>\n        </div>\n    );\n};\n\nmount(document.body, <TestRunner />);\n"],
  "mappings": "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",
  "names": []
}
