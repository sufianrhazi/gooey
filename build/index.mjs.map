{
  "version": 3,
  "sources": ["../src/common/types.ts", "../src/common/log.ts", "../src/common/util.ts", "../src/common/arrayevent.ts", "../src/viewcontroller/commit.ts", "../src/common/sumarray.ts", "../src/common/slotsizes.ts", "../src/viewcontroller/rendernode/rendernode.ts", "../src/modelview/collectionrendernode.ts", "../src/model/rangeassociation.ts", "../src/model/dirtyarray.ts", "../src/model/trackedarray.ts", "../src/model/arraysub.ts", "../src/model/collection.ts", "../src/model/trackeddata.ts", "../src/model/dict.ts", "../src/model/field.ts", "../src/model/tarjan.ts", "../src/model/graph.ts", "../src/model/model.ts", "../src/model/engine.ts", "../src/model/calc.ts", "../src/viewcontroller/jsx.ts", "../src/viewcontroller/rendernode/arrayrendernode.ts", "../src/viewcontroller/rendernode/dynamicrendernode.ts", "../src/viewcontroller/rendernode/foreignrendernode.ts", "../src/viewcontroller/rendernode/textrendernode.ts", "../src/viewcontroller/renderjsx.ts", "../src/viewcontroller/rendernode/componentrendernode.ts", "../src/common/dyn.ts", "../src/viewcontroller/webcomponents.ts", "../src/viewcontroller/xmlnamespace.ts", "../src/viewcontroller/ref.ts", "../src/viewcontroller/rendernode/portalrendernode.ts", "../src/viewcontroller/rendernode/intrinsicrendernode.ts", "../src/viewcontroller/createelement.ts", "../src/components/fragment.ts", "../src/viewcontroller/rendernode/intrinsicobserverrendernode.ts", "../src/components/intrinsicobserver.ts", "../src/viewcontroller/rendernode/webcomponentrendernode.ts", "../src/viewcontroller/definecustomelement.ts", "../src/viewcontroller/mount.ts", "../src/index.ts"],
  "sourcesContent": ["export class InvariantError extends Error {\n    detail?: any;\n    constructor(msg: string, detail?: any) {\n        super(msg);\n        this.detail = detail;\n    }\n}\n", "import { InvariantError } from './types';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function getLogLevel(): LogLevel {\n    if (currentLevel >= levels.info) return 'info';\n    if (currentLevel >= levels.warn) return 'warn';\n    if (currentLevel >= levels.debug) return 'debug';\n    return 'error';\n}\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function isAtLogLevel(logLevel: LogLevel) {\n    return currentLevel >= levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function group(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.group(...items);\n    }\n}\n\nexport function groupEnd() {\n    if (currentLevel >= levels.debug) {\n        console.groupEnd();\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function fail(msg: string, ...items: any[]): never {\n    error('Invariant error', msg, ...items);\n    throw new InvariantError(`Invariant error: ${msg}`, items);\n}\n\nexport function assert(\n    check: any,\n    msg: string,\n    ...items: any[]\n): asserts check {\n    if (!check) {\n        error(\n            'Assertion failure',\n            check === undefined\n                ? 'undefined'\n                : check === null\n                  ? 'null'\n                  : check.toString(),\n            'is not truthy',\n            msg,\n            ...items\n        );\n        throw new InvariantError(`Assertion failure: ${msg}`, items);\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new InvariantError('Assertion failure', { context, items });\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function* noopGenerator() {}\n\nexport const dead = (): any => {\n    throw new Error('Cannot call dead function');\n};\n\nexport const uniqueid = (() => {\n    let id = 1;\n    return () => id++;\n})();\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy<TItem, TKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TKey, TVal]\n): Map<TKey, TVal[]> {\n    const grouped: Map<TKey, TVal[]> = new Map();\n    items.forEach((item) => {\n        const [key, val] = grouper(item);\n        let inner = grouped.get(key);\n        if (!inner) {\n            inner = [];\n            grouped.set(key, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function alwaysFalse(): false {\n    return false;\n}\n\nexport function strictEqual<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low)) + low;\n}\n\nexport function median(numbers: number[]): number {\n    const sorted = numbers.slice().sort((a, b) => a - b);\n    return (\n        (sorted[Math.floor((numbers.length - 1) / 2)] +\n            sorted[Math.ceil((numbers.length - 1) / 2)]) /\n        2\n    );\n}\n\nexport function wrapError(e: unknown, msg?: string): Error {\n    if (e instanceof Error) return e;\n    // @ts-ignore -- 2nd error cause param harmless to add\n    const err = new Error(msg ?? 'Unknown error', { cause: e });\n    return err;\n}\n", "import * as log from './log';\n\nexport enum ArrayEventType {\n    SPLICE = 'splice',\n    MOVE = 'move',\n    SORT = 'sort',\n}\n\nexport interface ArrayEventSplice<T> {\n    type: ArrayEventType.SPLICE;\n    index: number;\n    count: number;\n    items?: T[] | undefined;\n}\nexport interface ArrayEventMove {\n    type: ArrayEventType.MOVE;\n    from: number;\n    count: number;\n    to: number;\n}\nexport interface ArrayEventSort {\n    type: ArrayEventType.SORT;\n    from: number;\n    indexes: number[];\n}\n\nexport type ArrayEvent<T> =\n    | ArrayEventSplice<T>\n    | ArrayEventMove\n    | ArrayEventSort;\n\nconst EMPTY_ARRAY: readonly [] = [];\n\nexport function applySort<T>(target: T[], from: number, indexes: number[]) {\n    const duped = target.slice(from, from + indexes.length);\n    for (let i = 0; i < indexes.length; ++i) {\n        target[i + from] = duped[indexes[i] - from];\n    }\n}\n\nexport function applyMove<T>(\n    target: T[],\n    from: number,\n    count: number,\n    to: number\n) {\n    const slice = target.splice(from, count);\n    target.splice(to, 0, ...slice);\n}\n\nexport function applyArrayEvent<T>(\n    target: T[],\n    event: ArrayEvent<T>\n): readonly T[] {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            if (event.items) {\n                return target.splice(event.index, event.count, ...event.items);\n            } else {\n                return target.splice(event.index, event.count);\n            }\n        }\n        case ArrayEventType.SORT: {\n            applySort(target, event.from, event.indexes);\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            applyMove(target, event.from, event.count, event.to);\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n    return EMPTY_ARRAY;\n}\n\n/**\n * Merge array events into a stream of more optimized events.\n *\n * i.e. join splice events that can be joined\n */\nexport function* mergeArrayEvents<T>(events: Iterable<ArrayEvent<T>>) {\n    const iterator = events[Symbol.iterator]();\n    const firstItem = iterator.next();\n    if (firstItem.done) {\n        return;\n    }\n    let lastEvent = firstItem.value;\n    let mergedItems: T[] | undefined;\n    while (true) {\n        const nextItem = iterator.next();\n        if (nextItem.done) {\n            break;\n        }\n        const event = nextItem.value;\n\n        // Case 1: the insertion point of a splice is at the end of the change of the prior splice\n        // These can be merged by using the 1st event's index, summing the count, and concatenating the items\n        if (\n            event.type === ArrayEventType.SPLICE &&\n            lastEvent.type === ArrayEventType.SPLICE &&\n            lastEvent.index + (lastEvent.items?.length ?? 0) === event.index\n        ) {\n            // Start:\n            //     0123456789\n            //\n            // Splice index 1, count 3, items [a,b]\n            //      v         <- insertion point\n            //     0123456789\n            //      ^^^       <- removal\n            //     0ab456789  <- result\n            //\n            // Splice index 3, count 4, items [c,d]\n            //        v       <- insertion point\n            //     0ab456789\n            //        ^^^^    <- removal\n            //     0abcd89    <- result\n            //\n            // Equivalent to:\n            // Splice index 1, count 3+4, items [a,b,c,d]\n            //      v         <- insertion point\n            //     0123456789\n            //      ^^^^^^^   <- removal\n            //     0abcd89    <- result\n\n            if (!mergedItems) {\n                mergedItems = lastEvent.items?.slice() ?? [];\n            }\n            if (event.items) {\n                mergedItems.push(...event.items);\n            }\n            if (mergedItems.length) {\n                lastEvent = {\n                    type: ArrayEventType.SPLICE,\n                    index: lastEvent.index,\n                    count: lastEvent.count + event.count,\n                    items: mergedItems,\n                };\n            } else {\n                lastEvent = {\n                    type: ArrayEventType.SPLICE,\n                    index: lastEvent.index,\n                    count: lastEvent.count + event.count,\n                };\n            }\n        } else {\n            yield lastEvent;\n            lastEvent = event;\n            mergedItems = undefined;\n        }\n    }\n    yield lastEvent;\n}\n", "import { noop } from '../common/util';\nimport { RenderNodeCommitPhase } from './rendernode/constants';\nimport type { RenderNode } from './rendernode/rendernode';\n\n/**\n * Global state\n */\nconst COMMIT_SEQUENCE = [\n    RenderNodeCommitPhase.COMMIT_UNMOUNT,\n    RenderNodeCommitPhase.COMMIT_EMIT,\n    RenderNodeCommitPhase.COMMIT_UPDATE,\n    RenderNodeCommitPhase.COMMIT_MOUNT,\n];\nlet commitPhases = {\n    [RenderNodeCommitPhase.COMMIT_UNMOUNT]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_EMIT]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_UPDATE]: new Set<RenderNode>(),\n    [RenderNodeCommitPhase.COMMIT_MOUNT]: new Set<RenderNode>(),\n};\nlet commitHandle: undefined | (() => void);\nlet commitScheduler = defaultScheduler;\n\nfunction defaultScheduler(callback: () => void) {\n    if ((window as any).queueMicrotask) {\n        let cancelled = false;\n        queueMicrotask(() => {\n            if (cancelled) return;\n            callback();\n        });\n        return () => {\n            cancelled = true;\n        };\n    }\n    const handle = setTimeout(callback, 0);\n    return () => clearTimeout(handle);\n}\n\nfunction noopScheduler(callback: () => void) {\n    return noop;\n}\n\nexport function reset() {\n    commitPhases = {\n        [RenderNodeCommitPhase.COMMIT_UNMOUNT]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_EMIT]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_UPDATE]: new Set<RenderNode>(),\n        [RenderNodeCommitPhase.COMMIT_MOUNT]: new Set<RenderNode>(),\n    };\n    commitHandle = undefined;\n    commitScheduler = defaultScheduler;\n}\n\nexport function commit() {\n    while (commitHandle !== undefined) {\n        commitHandle = undefined;\n        performCommit();\n    }\n}\n\nexport function subscribe(scheduler?: (callback: () => void) => () => void) {\n    commitScheduler = scheduler ?? noopScheduler;\n}\n\n// Committing has a few phases:\n// - 1: notify \"onUnmount\"\n// - 2: emit ArrayEvent<Node> elements\n// - 2.5: record document.activeElement\n// - 3: commit emitted elements to the DOM\n// - 3.5: restore document.activeElement if it was moved\n// - 4: notify \"onMount\"\nfunction performCommit() {\n    let activeElement: Element | null = null;\n    for (const phase of COMMIT_SEQUENCE) {\n        if (phase === RenderNodeCommitPhase.COMMIT_UPDATE) {\n            activeElement = document.activeElement;\n        }\n        const toCommit = Array.from(commitPhases[phase]).sort(\n            (a, b) => b.getDepth() - a.getDepth()\n        );\n        commitPhases[phase] = new Set();\n        for (const renderNode of toCommit) {\n            renderNode.commit(phase);\n        }\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_UPDATE &&\n            activeElement &&\n            document.documentElement.contains(activeElement)\n        ) {\n            (activeElement as HTMLElement).focus();\n        }\n    }\n}\n\nexport function requestCommit(\n    target: RenderNode,\n    phase: RenderNodeCommitPhase\n) {\n    commitPhases[phase].add(target);\n    if (!commitHandle) {\n        commitHandle = commitScheduler(commit);\n    }\n}\n", "import { applyMove, applySort } from './arrayevent';\n\nexport class SumArray {\n    bucketBits: number;\n    bucketSize: number;\n    slots: number[];\n    buckets: number[];\n\n    constructor(bucketBits: number, items: number[]) {\n        this.bucketBits = bucketBits;\n        this.bucketSize = 1 << bucketBits;\n        this.slots = items;\n        this.buckets = this.recreate(this.slots);\n    }\n\n    private recreate(items: number[]) {\n        const buckets: number[] = [];\n        for (let i = 0; i < items.length; i += this.bucketSize) {\n            let bucket = 0;\n            for (let j = 0; j < this.bucketSize && i + j < items.length; ++j) {\n                bucket += items[i + j];\n            }\n            buckets.push(bucket);\n        }\n        return buckets;\n    }\n\n    private updateBuckets(from: number, to: number) {\n        const startBucket = from >> this.bucketBits;\n        const endBucket = to >> this.bucketBits;\n\n        // If the array has grown, we may need to resize the buckets\n        for (let i = this.buckets.length; i < endBucket; ++i) {\n            this.buckets.push(0);\n        }\n\n        for (let i = startBucket; i <= endBucket; ++i) {\n            let bucket = 0;\n            const shift = i << this.bucketBits;\n            for (\n                let j = 0;\n                j < this.bucketSize && shift + j < this.slots.length;\n                ++j\n            ) {\n                bucket += this.slots[shift + j];\n            }\n            this.buckets[i] = bucket;\n        }\n    }\n\n    splice(index: number, count: number, items: number[]) {\n        this.slots.splice(index, count, ...items);\n        this.updateBuckets(\n            index,\n            count === items.length ? index + count : this.slots.length\n        );\n        if (count - items.length > 0) {\n            // If the array has shrunk, we may need to resize the buckets\n            const bucketSize = this.slots.length >> this.bucketBits;\n            if (this.buckets.length > bucketSize) {\n                this.buckets.length = bucketSize;\n            }\n        }\n    }\n\n    move(fromIndex: number, count: number, toIndex: number) {\n        applyMove(this.slots, fromIndex, count, toIndex);\n        this.updateBuckets(\n            Math.min(fromIndex, toIndex),\n            Math.max(fromIndex, toIndex) + count\n        );\n    }\n\n    sort(fromIndex: number, indices: number[]) {\n        applySort(this.slots, fromIndex, indices);\n        this.updateBuckets(fromIndex, fromIndex + indices.length);\n    }\n\n    getSum(index: number) {\n        if (index === 0) {\n            return 0;\n        }\n        let sum = 0;\n        for (\n            let bucketIndex = 0, i = this.bucketSize;\n            bucketIndex < this.buckets.length && i <= index;\n            ++bucketIndex, i += this.bucketSize\n        ) {\n            sum += this.buckets[bucketIndex];\n        }\n        const start = index & ~(this.bucketSize - 1);\n        for (let j = start; j < index && j < this.slots.length; ++j) {\n            sum += this.slots[j];\n        }\n        return sum;\n    }\n\n    get(index: number) {\n        return this.slots[index];\n    }\n\n    set(index: number, value: number) {\n        const diff = value - this.slots[index];\n        this.slots[index] = value;\n        const bucketIndex = index >> this.bucketBits;\n        this.buckets[bucketIndex] += diff;\n    }\n}\n", "import { applyMove, applySort, ArrayEventType } from './arrayevent';\nimport type {\n    ArrayEvent,\n    ArrayEventMove,\n    ArrayEventSort,\n    ArrayEventSplice,\n} from './arrayevent';\nimport * as log from './log';\nimport { SumArray } from './sumarray';\n\n// 5 bit (32-sized bucket) size was chosen due to balancing practical sizes\n// Most elements have fewer than 32 items, so this will have no effect on those elements\n// However, if elements grow beyond 32 items, they tend to have many more (likely in the dozens to hundreds)\n// This seems like a \"right\" number to balance things out\nconst SUMARRAY_BITS = 5;\n\nexport class SlotSizes<TEventSource> {\n    items: TEventSource[];\n    private slots: SumArray;\n    private indexes: Map<TEventSource, number>;\n\n    constructor(items: TEventSource[]) {\n        this.slots = new SumArray(\n            SUMARRAY_BITS,\n            items.map(() => 0)\n        );\n        this.items = items;\n        this.indexes = new Map();\n        this.updateIndexes(0, items.length);\n    }\n\n    clearSlots() {\n        this.slots = new SumArray(\n            SUMARRAY_BITS,\n            this.items.map(() => 0)\n        );\n    }\n\n    updateIndexes(lo: number, hi: number) {\n        for (let i = lo; i < hi; ++i) {\n            this.indexes.set(this.items[i], i);\n        }\n    }\n\n    get(index: number): TEventSource | undefined {\n        return this.items[index];\n    }\n\n    move(from: number, count: number, to: number): ArrayEventMove {\n        const fromShift = this.slots.getSum(from);\n        const countShift = this.slots.getSum(from + count) - fromShift;\n\n        this.slots.move(from, count, to);\n        applyMove(this.items, from, count, to);\n\n        const toShift = this.slots.getSum(to);\n\n        this.updateIndexes(Math.min(from, to), Math.max(from, to) + count);\n\n        return {\n            type: ArrayEventType.MOVE,\n            from: fromShift,\n            count: countShift,\n            to: toShift,\n        };\n    }\n\n    sort(from: number, indexes: number[]): ArrayEventSort {\n        // We need to both apply a sort operation and return a projected sort\n        // event that is formed from the full array.\n        //\n        // Imagine slots:\n        // - [0, 3, 1, 0, 2]\n        // - [[], [a,b,c], [d], [], [e,f]]\n        //\n        // Where we sort from index 1 so that it goes: 0, 1, 3:\n        // - [[], [], [d], [a,b,c], [e,f]]\n        //\n        // Original event: from: 1, indexes: [3,2,1]\n        //\n        // Shifted event: from: 0, indexes: [3,0,1,2]\n        //\n        // We get here by building nested indexes:\n        // - [[], [0,1,2], [3], [], [4,5]]\n        //\n        // Applying the array event:\n        // - [[], [], [3], [0,1,2], [4,5]]\n        //\n        // And slicing/flattening the result with a shifted from:\n        // - [3,0,1,2]\n\n        let fromShift = 0;\n        let totalIndex = 0;\n        const indexedSlots: number[][] = [];\n        for (let i = 0; i < from + indexes.length; ++i) {\n            const slotSize = this.slots.get(i);\n            const indexedSlot: number[] = [];\n            for (let j = 0; j < slotSize; ++j) {\n                indexedSlot.push(totalIndex++);\n            }\n            indexedSlots.push(indexedSlot);\n            if (i < from) {\n                fromShift += this.slots.get(i);\n            }\n        }\n        applySort(indexedSlots, from, indexes);\n        const newIndexes = indexedSlots.slice(from).flat();\n        this.slots.sort(from, indexes);\n        applySort(this.items, from, indexes);\n        this.updateIndexes(from, from + indexes.length);\n        return {\n            type: ArrayEventType.SORT,\n            from: fromShift,\n            indexes: newIndexes,\n        };\n    }\n\n    splice<T>(\n        index: number,\n        count: number,\n        items: TEventSource[]\n    ): { removed: TEventSource[]; event: ArrayEventSplice<T> } {\n        const shiftIndex = this.slots.getSum(index);\n        const shiftCount = this.slots.getSum(index + count) - shiftIndex;\n        this.slots.splice(\n            index,\n            count,\n            items.map(() => 0)\n        );\n        const removedItems = this.items.splice(index, count, ...items);\n        for (const removedItem of removedItems) {\n            this.indexes.delete(removedItem);\n        }\n        if (this.items.length === count) {\n            this.updateIndexes(index, index + count);\n        } else {\n            this.updateIndexes(index, this.items.length);\n        }\n        return {\n            removed: removedItems,\n            event: {\n                type: ArrayEventType.SPLICE,\n                index: shiftIndex,\n                count: shiftCount,\n                items: [], // Note: added items are _always_ treated as if they are empty\n            },\n        };\n    }\n\n    applyEvent<TEvent>(\n        source: TEventSource,\n        event: ArrayEvent<TEvent>\n    ): ArrayEvent<TEvent> {\n        const sourceIndex = this.indexes.get(source);\n        log.assert(\n            sourceIndex !== undefined,\n            'event from unknown SlotSizes source',\n            source\n        );\n        const shift = this.slots.getSum(sourceIndex);\n        switch (event.type) {\n            case ArrayEventType.SPLICE: {\n                this.slots.set(\n                    sourceIndex,\n                    this.slots.get(sourceIndex) +\n                        (event.items?.length ?? 0) -\n                        event.count\n                );\n                return {\n                    type: ArrayEventType.SPLICE,\n                    index: event.index + shift,\n                    count: event.count,\n                    items: event.items,\n                };\n            }\n            case ArrayEventType.SORT: {\n                return {\n                    type: ArrayEventType.SORT,\n                    from: event.from + shift,\n                    indexes: event.indexes.map((index) => index + shift),\n                };\n            }\n            case ArrayEventType.MOVE: {\n                return {\n                    type: ArrayEventType.MOVE,\n                    from: event.from + shift,\n                    count: event.count,\n                    to: event.to + shift,\n                };\n            }\n            default:\n                log.assertExhausted(event, 'unknown ArrayEvent type');\n        }\n    }\n}\n", "import type { ArrayEvent } from '../../common/arrayevent';\nimport { ArrayEventType } from '../../common/arrayevent';\nimport * as log from '../../common/log';\nimport { SlotSizes } from '../../common/slotsizes';\nimport type { Retainable } from '../../model/engine';\nimport { release, retain } from '../../model/engine';\nimport { requestCommit } from '../commit';\nimport type { RenderNodeCommitPhase } from './constants';\n\nexport type NodeEmitter = (event: ArrayEvent<Node>) => void;\n\nexport type ErrorEmitter = (error: Error) => void;\n\nexport interface ParentContext {\n    /**\n     * RenderNode instances send a stream of ArrayEvent<Node> to their parents,\n     * which take responsibility for placing them into the DOM.\n     */\n    nodeEmitter: NodeEmitter;\n    /**\n     * RenderNode instances may emit Error events to their parents in case of\n     * an unrecoverable error in the RenderNode. The parents take\n     * responsibility for handling those Errors.\n     */\n    errorEmitter: ErrorEmitter;\n    xmlNamespace: string;\n}\n\nexport interface RenderNode extends Retainable {\n    clone(\n        props?: {} | undefined,\n        children?: JSX.Node[] | undefined\n    ): RenderNode;\n\n    onMount(): void;\n\n    onUnmount(): void;\n\n    attach(parentContext: ParentContext): void;\n\n    commit(phase: RenderNodeCommitPhase): void;\n\n    detach(): void;\n\n    retain(): void;\n\n    release(): void;\n\n    getDepth(): number;\n\n    setDepth(depth: number): void;\n}\n\ninterface RenderNodeHandlers {\n    /**\n     * Called when the RenderNode is created, before it is attached and mounted\n     */\n    onAlive?: () => void;\n    /**\n     * Called before the RenderNode is destroyed; it may still be attached\n     */\n    onDestroy?: () => void;\n    /**\n     * Called just after the RenderNode is attached to a parent RenderNode -- it may start emitting ArrayEvent<Node> | Error events\n     */\n    onAttach?: (parentContext: ParentContext) => void;\n    /**\n     * Called after the RenderNode has been detached from a parent RenderNode. Any nodes it has emitted have been already removed.\n     */\n    onDetach?: () => void;\n    /**\n     * Called just after the RenderNode is mounted to the DOM (specifically has been attached transitively to a mount() point)\n     */\n    onMount?: () => void;\n    /**\n     * Called just before the RenderNode is mounted to the DOM (specifically has been attached transitively to a mount() point)\n     */\n    onUnmount?: () => void;\n    /**\n     * Called when the RenderNode has received an error event from any child; return true to not pass the event to its parent\n     */\n    onError?: (error: Error) => boolean | void;\n    /**\n     * Called when the RenderNode has received an ArrayEvent<Node> event from any child; return true to not pass the event to its parent\n     */\n    onEvent?: (event: ArrayEvent<Node>) => boolean | void;\n    /**\n     * Called when the RenderNode is committed (all children have already been committed)\n     */\n    onCommit?: (phase: RenderNodeCommitPhase) => void;\n    /**\n     * Called when the RenderNode has received an ArrayEvent<Node> event from a specific child; return true to not pass the event to its parent\n     */\n    onChildEvent?: (\n        child: RenderNode,\n        event: ArrayEvent<Node>\n    ) => boolean | void;\n    /**\n     * Called when the RenderNode is cloned; callers should clone the provided children (if passed to the cloned node) and return a new RenderNode\n     *\n     * If omitted, an exception is thrown if the RenderNode is attempted to be cloned.\n     */\n    clone?: (props?: {}, children?: RenderNode[]) => RenderNode;\n}\n\n/**\n * SingleChildRenderNode: a virtual node in the tree that has exactly one child\n */\nexport class SingleChildRenderNode implements RenderNode, Retainable {\n    private declare handlers: RenderNodeHandlers;\n    private declare parentContext: ParentContext | undefined;\n    private declare _isMounted: boolean;\n    private declare child: RenderNode;\n    private declare liveNodes: number;\n    private declare depth: number;\n\n    constructor(\n        handlers: RenderNodeHandlers,\n        child: RenderNode,\n        debugName?: string\n    ) {\n        this.handlers = handlers;\n        this.child = child;\n        this._isMounted = false;\n        this.parentContext = undefined;\n        this.liveNodes = 0;\n        this.depth = 0;\n\n        this.__debugName = debugName ?? `custom`;\n        this.__refcount = 0;\n    }\n\n    isAttached() {\n        return !!this.parentContext;\n    }\n\n    isMounted() {\n        return this._isMounted;\n    }\n\n    emitEvent(event: ArrayEvent<Node>) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit event when detached'\n        );\n        this.parentContext.nodeEmitter(event);\n    }\n\n    emitError(error: Error) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit error when detached'\n        );\n        this.parentContext.errorEmitter(error);\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        this.handlers.onCommit?.(phase);\n    }\n\n    requestCommit(phase: RenderNodeCommitPhase) {\n        requestCommit(this, phase);\n    }\n\n    clone(props?: {}, children?: RenderNode[]): RenderNode {\n        if (this.handlers.clone) {\n            return this.handlers.clone(props, children);\n        }\n        const clonedChild = this.child.clone();\n        return new SingleChildRenderNode(this.handlers, clonedChild);\n    }\n\n    setChild(child: RenderNode) {\n        const toRemove = this.child;\n        this.child = child;\n        if (this._isMounted) {\n            toRemove.onUnmount();\n        }\n        if (this.parentContext) {\n            if (this.liveNodes > 0) {\n                this.parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: this.liveNodes,\n                });\n            }\n            toRemove.detach();\n        }\n        this.liveNodes = 0;\n        this.disown(toRemove);\n        this.own(this.child);\n        if (this.parentContext) {\n            this.child.attach({\n                nodeEmitter: this.handleEvent,\n                errorEmitter: this.handleError,\n                xmlNamespace: this.parentContext.xmlNamespace,\n            });\n        }\n        if (this._isMounted) {\n            this.child.onMount();\n        }\n    }\n\n    private handleEvent = (event: ArrayEvent<Node>) => {\n        if (event.type === ArrayEventType.SPLICE) {\n            this.liveNodes += (event.items?.length ?? 0) - event.count;\n        }\n        if (!this.handlers.onEvent?.(event)) {\n            log.assert(\n                this.parentContext,\n                'Unexpected event on detached RenderNode'\n            );\n            this.parentContext.nodeEmitter(event);\n        }\n    };\n\n    private handleError = (event: Error) => {\n        if (!this.handlers.onError?.(event)) {\n            if (this.parentContext) {\n                this.parentContext.errorEmitter(event);\n            } else {\n                log.warn('Unhandled error on detached RenderNode', event);\n            }\n        }\n    };\n\n    detach() {\n        log.assert(this.parentContext, 'double detached');\n        this.child.detach();\n        this.parentContext = undefined;\n        this.handlers.onDetach?.();\n    }\n\n    attach(parentContext: ParentContext) {\n        log.assert(!this.parentContext, 'Invariant: double attached');\n        this.parentContext = parentContext;\n        this.child.attach({\n            nodeEmitter: this.handleEvent,\n            errorEmitter: this.handleError,\n            xmlNamespace: this.parentContext.xmlNamespace,\n        });\n        this.handlers.onAttach?.(parentContext);\n    }\n\n    onMount() {\n        this._isMounted = true;\n        this.child.onMount();\n        this.handlers.onMount?.();\n    }\n\n    onUnmount() {\n        this._isMounted = false;\n        this.child.onUnmount();\n        this.handlers.onUnmount?.();\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        this.own(this.child);\n        this.handlers.onAlive?.();\n    }\n    __dead() {\n        this.handlers.onDestroy?.();\n        this.disown(this.child);\n        this.parentContext = undefined;\n    }\n\n    own(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.setDepth(this.depth + 1);\n        child.retain();\n    }\n\n    disown(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.release();\n        child.setDepth(0);\n    }\n\n    getDepth() {\n        return this.depth;\n    }\n\n    setDepth(depth: number) {\n        this.depth = depth;\n    }\n}\n\n/**\n * MultiChildRenderNode: a virtual node in the tree that can have a variable number of children\n */\nexport class MultiChildRenderNode implements RenderNode, Retainable {\n    private declare handlers: RenderNodeHandlers;\n    private declare parentContext: ParentContext | undefined;\n    private declare _isMounted: boolean;\n    private declare slotSizes: SlotSizes<RenderNode>;\n    private declare depth: number;\n    private declare pendingCommit: undefined | Map<RenderNode, number>;\n\n    constructor(\n        handlers: RenderNodeHandlers,\n        children: RenderNode[],\n        debugName?: string\n    ) {\n        this.depth = 0;\n        this.handlers = handlers;\n        this._isMounted = false;\n        this.slotSizes = new SlotSizes(children);\n        this.parentContext = undefined;\n        this.pendingCommit = undefined;\n\n        this.__debugName = debugName ?? `custom`;\n        this.__refcount = 0;\n    }\n\n    isAttached() {\n        return !!this.parentContext;\n    }\n\n    isMounted() {\n        return this._isMounted;\n    }\n\n    emitEvent(event: ArrayEvent<Node>) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit event when detached'\n        );\n        this.parentContext.nodeEmitter(event);\n    }\n\n    emitError(error: Error) {\n        log.assert(\n            this.parentContext,\n            'RenderNode attempted to emit error when detached'\n        );\n        this.parentContext.errorEmitter(error);\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        this.handlers.onCommit?.(phase);\n    }\n\n    requestCommit(phase: RenderNodeCommitPhase) {\n        requestCommit(this, phase);\n    }\n\n    clone(props?: {}, children?: RenderNode[]): RenderNode {\n        if (this.handlers.clone) {\n            return this.handlers.clone(props, children);\n        }\n        const clonedChildren = this.slotSizes.items.map((child) =>\n            child.clone()\n        );\n        return new MultiChildRenderNode(this.handlers, clonedChildren);\n    }\n\n    sortChildren(from: number, indexes: number[]) {\n        const event = this.slotSizes.sort(from, indexes);\n        this.parentContext?.nodeEmitter(event);\n    }\n\n    moveChildren(from: number, count: number, to: number) {\n        const event = this.slotSizes.move(from, count, to);\n        this.parentContext?.nodeEmitter(event);\n    }\n\n    spliceChildren(index: number, count: number, children: RenderNode[]) {\n        // unmount & detach children before removing from slots (so they may emit their cleanup events)\n        for (let i = index; i < index + count; ++i) {\n            const child = this.slotSizes.items[i];\n            if (this._isMounted) {\n                child.onUnmount();\n            }\n        }\n        const { removed, event } = this.slotSizes.splice(\n            index,\n            count,\n            children\n        );\n        if (this.parentContext && event.count > 0) {\n            this.parentContext.nodeEmitter({\n                type: ArrayEventType.SPLICE,\n                index: event.index,\n                count: event.count,\n                // Note: we do *not* take the responsibility of emitting the new nodes -- the children do that on attach\n            });\n        }\n        for (const child of removed) {\n            if (this.parentContext) {\n                child.detach();\n            }\n            this.disown(child);\n        }\n        for (const child of children) {\n            this.own(child);\n            if (this.parentContext) {\n                child.attach({\n                    nodeEmitter: (event: ArrayEvent<Node>) =>\n                        this.handleChildEvent(child, event),\n                    errorEmitter: this.handleError,\n                    xmlNamespace: this.parentContext.xmlNamespace,\n                });\n            }\n            if (this._isMounted) {\n                child.onMount();\n            }\n        }\n    }\n\n    private handleChildEvent(child: RenderNode, event: ArrayEvent<Node>) {\n        if (!this.handlers.onChildEvent?.(child, event)) {\n            const shifted = this.slotSizes.applyEvent(child, event);\n            this.handleEvent(shifted);\n        }\n    }\n\n    private handleEvent(event: ArrayEvent<Node>) {\n        if (!this.handlers.onEvent?.(event)) {\n            log.assert(\n                this.parentContext,\n                'Unexpected event on detached RenderNode'\n            );\n            this.parentContext.nodeEmitter(event);\n        }\n    }\n\n    private handleError = (event: Error) => {\n        if (!this.handlers.onError?.(event)) {\n            if (this.parentContext) {\n                this.parentContext.errorEmitter(event);\n            } else {\n                log.warn('Unhandled error on detached RenderNode', event);\n            }\n        }\n    };\n\n    detach() {\n        log.assert(this.parentContext, 'double detached');\n        this.slotSizes.clearSlots();\n        for (const child of this.slotSizes.items) {\n            child.detach();\n        }\n        this.parentContext = undefined;\n        this.handlers.onDetach?.();\n    }\n\n    attach(parentContext: ParentContext) {\n        log.assert(!this.parentContext, 'Invariant: double attached');\n        this.parentContext = parentContext;\n        for (const child of this.slotSizes.items) {\n            child.attach({\n                nodeEmitter: (event) => {\n                    this.handleChildEvent(child, event);\n                },\n                errorEmitter: this.handleError,\n                xmlNamespace: this.parentContext.xmlNamespace,\n            });\n        }\n        this.handlers.onAttach?.(parentContext);\n    }\n\n    onMount() {\n        this._isMounted = true;\n        for (const child of this.slotSizes.items) {\n            child.onMount();\n        }\n        this.handlers.onMount?.();\n    }\n\n    onUnmount() {\n        this._isMounted = false;\n        for (const child of this.slotSizes.items) {\n            child.onUnmount();\n        }\n        this.handlers.onUnmount?.();\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        for (const child of this.slotSizes.items) {\n            this.own(child);\n        }\n        this.handlers.onAlive?.();\n    }\n    __dead() {\n        this.handlers.onDestroy?.();\n        for (const child of this.slotSizes.items) {\n            this.disown(child);\n        }\n        this.parentContext = undefined;\n    }\n\n    own(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.setDepth(this.depth + 1);\n        child.retain();\n    }\n\n    disown(child: RenderNode) {\n        if (child === emptyRenderNode) return;\n        child.release();\n        child.setDepth(0);\n    }\n\n    getDepth() {\n        return this.depth;\n    }\n\n    setDepth(depth: number) {\n        this.depth = depth;\n    }\n}\n\n/**\n * Renders nothing\n */\nexport class EmptyRenderNode implements RenderNode {\n    __debugName: string;\n    __refcount: number;\n    constructor() {\n        this.__debugName = '<empty>';\n        this.__refcount = 1; // Intentional: always alive, never dead\n    }\n\n    detach() {}\n    attach() {}\n    onMount() {}\n    onUnmount() {}\n    retain() {}\n    release() {}\n    commit() {}\n    getDepth() {\n        return 0;\n    }\n    setDepth() {}\n    clone(): RenderNode {\n        return emptyRenderNode;\n    }\n    __alive() {}\n    __dead() {}\n}\n\n/**\n * Only need one of nothing\n */\nexport const emptyRenderNode = new EmptyRenderNode();\n\nexport function isRenderNode(obj: any): obj is RenderNode {\n    return (\n        obj &&\n        (obj instanceof SingleChildRenderNode ||\n            obj instanceof MultiChildRenderNode ||\n            obj instanceof EmptyRenderNode)\n    );\n}\n", "import type { ArrayEvent } from '../common/arrayevent';\nimport { ArrayEventType } from '../common/arrayevent';\nimport type { Collection, View } from '../model/collection';\nimport { untrackReads } from '../model/engine';\nimport type { RenderNode } from '../viewcontroller/rendernode/rendernode';\nimport { MultiChildRenderNode } from '../viewcontroller/rendernode/rendernode';\n\nexport function CollectionRenderNode(\n    renderJSXNode: (jsxNode: JSX.Node) => RenderNode,\n    collection: Collection<any> | View<any>,\n    debugName?: string\n): RenderNode {\n    let unsubscribe: undefined | (() => void);\n    function handleEvent(events: Iterable<ArrayEvent<any>>) {\n        for (const event of events) {\n            switch (event.type) {\n                case ArrayEventType.SPLICE:\n                    renderNode.spliceChildren(\n                        event.index,\n                        event.count,\n                        event.items?.map((item) => renderJSXNode(item)) ?? []\n                    );\n                    break;\n                case ArrayEventType.MOVE:\n                    renderNode.moveChildren(event.from, event.count, event.to);\n                    break;\n                case ArrayEventType.SORT:\n                    renderNode.sortChildren(event.from, event.indexes);\n                    break;\n            }\n        }\n    }\n    const renderNode = new MultiChildRenderNode(\n        {\n            onAlive: () => {\n                unsubscribe = collection.subscribe(handleEvent);\n            },\n            onDestroy: () => {\n                unsubscribe?.();\n                untrackReads(() => {\n                    renderNode.spliceChildren(0, collection.length, []);\n                });\n            },\n        },\n        [],\n        debugName ?? `CollectionRenderNode(${collection.__debugName})`\n    );\n\n    return renderNode;\n}\n", "type Interval<T> = {\n    start: number;\n    end: number;\n    value: T;\n};\n\nexport class RangeAssociation<T> {\n    private intervals: Interval<T>[] = [];\n\n    setAssociation(start: number, end: number, value: T): void {\n        if (start >= end) return;\n\n        const result: Interval<T>[] = [];\n\n        // Find left boundary (first interval whose end > start)\n        const left = this.findFirstOverlap(start);\n        let i = left;\n\n        // Skip overlapping intervals, building up new ones if needed\n        while (i < this.intervals.length && this.intervals[i].start < end) {\n            const current = this.intervals[i];\n\n            // Add gaps before current\n            if (start < current.start) {\n                result.push({\n                    start,\n                    end: Math.min(current.start, end),\n                    value,\n                });\n            }\n\n            // Skip overlapping part\n            start = Math.max(start, current.end);\n            result.push(current);\n            i++;\n        }\n\n        // Add tail if any remaining uncovered part\n        if (start < end) {\n            result.push({ start, end, value });\n        }\n\n        // Replace in-place: splice out [left, i), insert result\n        this.intervals.splice(left, i - left, ...result);\n    }\n\n    getAssociation(index: number): T | null {\n        if (isNaN(index)) {\n            return null;\n        }\n        if (this.intervals.length === 0) {\n            return null;\n        }\n        if (index < 0) {\n            return null;\n        }\n        const highestIndex = this.intervals[this.intervals.length - 1];\n        if (index >= highestIndex.end) {\n            return null;\n        }\n        let lo = 0,\n            hi = this.intervals.length - 1;\n\n        while (lo <= hi) {\n            const mid = (lo + hi) >>> 1;\n            const { start, end, value } = this.intervals[mid];\n            if (index < start) hi = mid - 1;\n            else if (index >= end) lo = mid + 1;\n            else return value;\n        }\n\n        return null;\n    }\n\n    private findFirstOverlap(pos: number): number {\n        // Binary search: first interval whose `end > pos`\n        let lo = 0,\n            hi = this.intervals.length;\n\n        while (lo < hi) {\n            const mid = (lo + hi) >>> 1;\n            if (this.intervals[mid].end <= pos) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n\n        return lo;\n    }\n\n    clear() {\n        this.intervals = [];\n    }\n}\n", "// Dirtiness tracking for dictionaries (exact keys)\nimport { RangeAssociation } from './rangeassociation';\n\nexport class DirtyArray {\n    private declare rangeAssociation: RangeAssociation<number>;\n    private declare dirtyLength: number | null;\n    private declare clock: number;\n\n    constructor() {\n        this.rangeAssociation = new RangeAssociation<number>();\n        this.dirtyLength = null;\n        this.clock = 0;\n    }\n\n    markDirty(key: 'length' | { start: number; end: number }) {\n        if (key === 'length') {\n            if (this.dirtyLength === null) {\n                this.dirtyLength = this.clock;\n            }\n            return;\n        }\n        this.rangeAssociation.setAssociation(key.start, key.end, this.clock);\n    }\n\n    tickClock() {\n        this.clock += 1;\n    }\n\n    clear() {\n        this.dirtyLength = null;\n        this.rangeAssociation.clear();\n    }\n\n    resetClock() {\n        this.clock = 0;\n    }\n\n    getClock() {\n        return this.clock;\n    }\n\n    get(key: 'length' | number) {\n        if (key === 'length') {\n            return this.dirtyLength;\n        }\n        return this.rangeAssociation.getAssociation(key);\n    }\n}\n", "import * as log from '../common/log';\nimport { DirtyArray } from './dirtyarray';\nimport {\n    addVertex,\n    markDirty,\n    notifyRead,\n    release,\n    removeVertex,\n    retain,\n} from './engine';\nimport type { Processable, Retainable } from './engine';\n\ntype TrackedDataSubscription<TEvent> = {\n    handler: (events: Iterable<TEvent>) => void;\n    events: TEvent[];\n};\n\nexport class TrackedArray<TEvent> implements Processable, Retainable {\n    private declare itemSubscriptions: Map<\n        Retainable & Processable,\n        Map<'length' | number, number>\n    >;\n    private declare eventSubscriptions: TrackedDataSubscription<TEvent>[];\n    private declare dirtyArray: DirtyArray;\n    private declare onAlive?: (() => void) | undefined;\n    private declare onDead?: (() => void) | undefined;\n    private declare mergeEvents: (events: TEvent[]) => Iterable<TEvent>;\n    private declare isDirty: boolean;\n\n    declare __processable: true;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(\n        mergeEvents: (events: TEvent[]) => Iterable<TEvent>,\n        lifecycle?: { onAlive?: () => void; onDead?: () => void },\n        debugName?: string\n    ) {\n        this.mergeEvents = mergeEvents;\n        this.itemSubscriptions = new Map();\n        this.eventSubscriptions = [];\n        this.dirtyArray = new DirtyArray();\n        this.onAlive = lifecycle?.onAlive;\n        this.onDead = lifecycle?.onDead;\n        this.isDirty = false;\n\n        this.__processable = true;\n        this.__refcount = 0;\n        this.__debugName = debugName ?? 'arraysub';\n    }\n\n    tickClock() {\n        this.dirtyArray.tickClock();\n    }\n\n    notifyRead(key: 'length' | number) {\n        const reader = notifyRead(this);\n        if (reader && reader.__refcount > 0) {\n            let subscriptions = this.itemSubscriptions.get(reader);\n            if (!subscriptions) {\n                subscriptions = new Map();\n                this.itemSubscriptions.set(reader, subscriptions);\n            }\n            if (!subscriptions.has(key)) {\n                subscriptions.set(key, this.dirtyArray.getClock());\n            }\n        }\n    }\n\n    markDirty(key: 'length' | { start: number; end: number }) {\n        if (this.__refcount === 0) {\n            return;\n        }\n        this.dirtyArray.markDirty(key);\n        if (!this.isDirty) {\n            markDirty(this);\n            this.isDirty = true;\n        }\n    }\n\n    addEvent(event: TEvent) {\n        if (this.__refcount === 0) {\n            return;\n        }\n        if (this.eventSubscriptions.length > 0) {\n            for (const subscription of this.eventSubscriptions) {\n                subscription.events.push(event);\n            }\n            if (!this.isDirty) {\n                markDirty(this);\n                this.isDirty = true;\n            }\n        }\n    }\n\n    subscribe(handler: (events: Iterable<TEvent>) => void) {\n        this.retain(); // yes, by virtue of subscribing to this, it is retained\n        const subscription = {\n            handler,\n            events: [],\n        };\n        this.eventSubscriptions.push(subscription);\n\n        return () => {\n            const index = this.eventSubscriptions.indexOf(subscription);\n            if (index >= 0) {\n                this.eventSubscriptions.splice(index, 1);\n                this.release();\n            }\n        };\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        addVertex(this);\n        this.onAlive?.();\n    }\n\n    __dead() {\n        this.onDead?.();\n        removeVertex(this);\n\n        this.itemSubscriptions.clear();\n        this.eventSubscriptions = [];\n        this.dirtyArray.clear();\n        this.dirtyArray.resetClock();\n    }\n\n    __recalculate(): Processable[] {\n        log.assert(this.__refcount > 0, 'cannot flush dead trackedarray');\n\n        const toPropagate = new Set<Retainable & Processable>();\n\n        // First propagate dirtiness for keys\n        for (const [\n            reader,\n            subscriptions,\n        ] of this.itemSubscriptions.entries()) {\n            if (reader.__refcount > 0) {\n                for (const [key, whenRead] of subscriptions.entries()) {\n                    const whenChanged = this.dirtyArray.get(key);\n                    if (whenChanged !== null && whenRead <= whenChanged) {\n                        toPropagate.add(reader);\n                    }\n                }\n            }\n        }\n\n        // For all the readers that have been dirtied, clear their subscriptions since they will re-evaluate\n        for (const reader of toPropagate) {\n            this.itemSubscriptions.delete(reader);\n        }\n\n        this.eventSubscriptions.forEach((subscription) => {\n            if (subscription.events.length) {\n                subscription.handler(this.mergeEvents(subscription.events));\n                subscription.events = [];\n            }\n        });\n\n        this.dirtyArray.clear();\n        this.isDirty = false;\n\n        // Propagate dirtiness\n        return [...toPropagate];\n    }\n}\n", "import {\n    applyArrayEvent,\n    ArrayEventType,\n    mergeArrayEvents,\n} from '../common/arrayevent';\nimport type { ArrayEvent } from '../common/arrayevent';\nimport * as log from '../common/log';\nimport { SlotSizes } from '../common/slotsizes';\nimport { TrackedArray } from './trackedarray';\n\nexport type DynamicArraySubscription<T> = {\n    handler: (events: Iterable<ArrayEvent<T>>) => void;\n    /**\n     * The thing called when users unsubscribe; note: this is *mutable*\n     */\n    onUnsubscribe: () => void;\n};\n\n// https://tc39.es/ecma262/multipage/indexed-collections.html#sec-sortcompare\nfunction defaultSort(x: any, y: any) {\n    if (x === undefined && y === undefined) return 0;\n    if (x === undefined) return 1;\n    if (y === undefined) return -1;\n    const xStr = '' + x;\n    const yStr = '' + y;\n    if (xStr < yStr) return -1;\n    if (xStr > yStr) return 1;\n    return 0;\n}\n\nexport interface DynamicArray<T> {\n    get(key: number): T;\n    getLength(): number;\n    getItemsUnsafe(): T[];\n    subscribe(handler: (event: Iterable<ArrayEvent<T>>) => void): () => void;\n    retain(): void;\n    release(): void;\n    takeSubscriptions(): DynamicArraySubscription<T>[];\n    getTrackedArray(): TrackedArray<ArrayEvent<T>>;\n}\n\nexport class ArraySub<T> implements DynamicArray<T> {\n    private declare items: T[];\n    private declare trackedArray: TrackedArray<ArrayEvent<T>>;\n    private declare subscriptions: DynamicArraySubscription<T>[];\n\n    declare __debugName: string;\n\n    constructor(\n        init?: T[] | undefined,\n        debugName?: string,\n        lifecycle?: { onAlive?: () => void; onDead?: () => void }\n    ) {\n        this.items = init ?? [];\n        this.trackedArray = new TrackedArray(\n            mergeArrayEvents,\n            lifecycle,\n            debugName\n        );\n        this.subscriptions = [];\n\n        this.__debugName = debugName ?? 'arraysub';\n    }\n\n    getItemsUnsafe() {\n        return this.items;\n    }\n\n    get(index: number) {\n        this.trackedArray.notifyRead(index);\n        return this.items[index];\n    }\n\n    set(index: number, value: T) {\n        if (index >= this.items.length) {\n            log.warn('Assigning to out-of-bounds index');\n            const items: T[] = [];\n            for (let i = this.items.length; i < index; ++i) {\n                items.push(undefined as T);\n            }\n            items.push(value);\n            this.splice(this.items.length, 0, items);\n            return;\n        }\n        if (this.items[index] === value) {\n            // Avoid doing anything if the write is a noop\n            return;\n        }\n        this.items[index] = value;\n        this.trackedArray.markDirty({ start: index, end: index + 1 });\n\n        this.trackedArray.addEvent({\n            type: ArrayEventType.SPLICE,\n            index,\n            count: 1,\n            items: [value],\n        });\n\n        this.trackedArray.tickClock();\n    }\n\n    setLength(newLength: number) {\n        if (newLength < this.items.length) {\n            this.splice(newLength, this.items.length - newLength, []);\n        } else if (newLength > this.items.length) {\n            const items: T[] = [];\n            for (let i = this.items.length; i < newLength; ++i) {\n                items.push(undefined as T);\n            }\n            this.splice(this.items.length, 0, items);\n        }\n    }\n\n    getLength() {\n        this.trackedArray.notifyRead('length');\n        return this.items.length;\n    }\n\n    /**\n     * Implement a splice, dirtying the affected fields, but do not queue a\n     * splice event\n     */\n    private spliceInner(index: number, count: number, items: T[]) {\n        const startLength = this.items.length;\n        const removed = Array.prototype.splice.call(\n            this.items,\n            index,\n            count,\n            ...items\n        );\n        const endLength = this.items.length;\n\n        if (startLength === endLength) {\n            // invalidate fields affected by splice\n            this.trackedArray.markDirty({\n                start: index,\n                end: index + items.length,\n            });\n        } else {\n            // invalidate fields affected by splice\n            this.trackedArray.markDirty({ start: index, end: endLength });\n\n            // destroy any dead fields\n            this.trackedArray.markDirty({ start: endLength, end: startLength });\n            this.trackedArray.markDirty('length');\n        }\n\n        return removed;\n    }\n\n    splice(index: number, count: number, items: T[]) {\n        if (count === 0 && items.length === 0) {\n            // no-op avoid incrementing clock\n            return [];\n        }\n        let fixedIndex: number;\n        if (index < -this.items.length) {\n            fixedIndex = 0;\n        } else if (index < 0) {\n            fixedIndex = this.items.length - index;\n        } else if (index > this.items.length) {\n            fixedIndex = this.items.length;\n        } else {\n            fixedIndex = index;\n        }\n\n        const removed = this.spliceInner(fixedIndex, count, items);\n\n        this.trackedArray.addEvent({\n            type: ArrayEventType.SPLICE,\n            index: fixedIndex,\n            count,\n            items,\n        });\n\n        this.trackedArray.tickClock();\n        return removed;\n    }\n\n    sort(sortFn: (a: T, b: T) => number = defaultSort) {\n        const indexes = this.items\n            .map((_unused: T, index: number) => index)\n            .sort((a, b) => sortFn(this.items[a], this.items[b]));\n        this.items.sort(sortFn);\n\n        this.trackedArray.addEvent({\n            type: ArrayEventType.SORT,\n            from: 0,\n            indexes,\n        });\n\n        // Invalidate sorted fields\n        this.trackedArray.markDirty({ start: 0, end: this.items.length });\n\n        this.trackedArray.tickClock();\n\n        return this;\n    }\n\n    reverse() {\n        const indexes: number[] = [];\n        for (let i = this.items.length - 1; i >= 0; --i) {\n            indexes.push(i);\n        }\n\n        // Perform the reverse\n        this.items.reverse();\n\n        // Notify of the (reversed) sort\n        this.trackedArray.addEvent({\n            type: ArrayEventType.SORT,\n            from: 0,\n            indexes,\n        });\n\n        // Invalidate all fields\n        this.trackedArray.markDirty({ start: 0, end: this.items.length });\n\n        this.trackedArray.tickClock();\n\n        return this;\n    }\n\n    moveSlice(fromIndex: number, count: number, toIndex: number) {\n        const removed = this.items.splice(fromIndex, count);\n        this.items.splice(toIndex, 0, ...removed);\n\n        // When you move a section, everything before & after the move is\n        // unchanged, but everything *between* the move is shifted:\n        //   abcdefghiJKLmnop\n        //            ^^^\n        //             |\n        //       +-----+\n        //       |\n        //      vvv\n        //   abcJKLdefghimnop\n        //\n        //   ...XXXYYYYYY....\n        //\n        // So everything between the lower & upper bounds of the move is dirty\n        const lowerBound = Math.min(fromIndex, toIndex);\n        const upperBound = Math.max(fromIndex, toIndex) + count;\n        this.trackedArray.markDirty({ start: lowerBound, end: upperBound });\n\n        this.trackedArray.addEvent({\n            type: ArrayEventType.MOVE,\n            from: fromIndex,\n            count,\n            to: toIndex,\n        });\n\n        this.trackedArray.tickClock();\n    }\n\n    subscribe(handler: (events: Iterable<ArrayEvent<T>>) => void) {\n        this.retain();\n        const trackedArrayUnsubscribe = this.trackedArray.subscribe(handler);\n        handler([\n            {\n                type: ArrayEventType.SPLICE,\n                index: 0,\n                count: 0,\n                items: this.items.slice(),\n            },\n        ]);\n        const onUnsubscribe = () => {\n            trackedArrayUnsubscribe();\n            this.release();\n            this.subscriptions = this.subscriptions.filter(\n                (sub) => sub !== subscription\n            );\n        };\n        const subscription = {\n            handler,\n            onUnsubscribe,\n        };\n        this.subscriptions.push(subscription);\n        return () => subscription.onUnsubscribe();\n    }\n\n    takeSubscriptions() {\n        const toReturn = this.subscriptions;\n        this.subscriptions = [];\n        return toReturn;\n    }\n\n    retain() {\n        this.trackedArray.retain();\n    }\n\n    release() {\n        this.trackedArray.release();\n    }\n\n    getTrackedArray() {\n        return this.trackedArray;\n    }\n}\n\nexport class DerivedArraySub<T, TSource> implements DynamicArray<T> {\n    private declare source: DynamicArray<TSource>;\n    private declare sourceUnsubscribe: (() => void) | undefined;\n    private declare eventTransform: (\n        events: Iterable<ArrayEvent<TSource>>\n    ) => Iterable<ArrayEvent<T>>;\n    private declare items: T[];\n    private declare trackedArray: TrackedArray<ArrayEvent<T>>;\n    private declare subscriptions: DynamicArraySubscription<T>[];\n\n    declare __debugName: string;\n\n    constructor(\n        source: DynamicArray<TSource>,\n        eventTransform: (\n            events: Iterable<ArrayEvent<TSource>>\n        ) => Iterable<ArrayEvent<T>>,\n        debugName?: string\n    ) {\n        this.source = source;\n        this.sourceUnsubscribe = undefined;\n        this.eventTransform = eventTransform;\n        this.items = [];\n        this.trackedArray = new TrackedArray(\n            mergeArrayEvents,\n            {\n                onAlive: () => {\n                    this.source.retain();\n                    this.sourceUnsubscribe = this.source.subscribe((events) => {\n                        this.ingestEvents(events);\n                    });\n                },\n                onDead: () => {\n                    this.sourceUnsubscribe?.();\n                    this.items = [];\n                    this.source.release();\n                },\n            },\n            debugName\n        );\n        this.subscriptions = [];\n\n        this.__debugName = debugName ?? 'arraysub';\n    }\n\n    replaceSource(source: DynamicArray<TSource>) {\n        this.sourceUnsubscribe?.();\n        if (this.items.length > 0) {\n            this.ingestEvents([\n                {\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: this.items.length,\n                },\n            ]);\n        }\n        this.items = [];\n        this.source.release();\n\n        this.source = source;\n        this.source.retain();\n        this.sourceUnsubscribe = this.source.subscribe((events) => {\n            this.ingestEvents(events);\n        });\n    }\n\n    get(index: number) {\n        // Note: notifyRead must happen before asserting index bounds\n        // Calculations may read values from an unalive view; as a result of\n        // reading the view's value, the calculation will cause the view to\n        // become alive, populating it from the source collection.\n        this.trackedArray.notifyRead(index);\n        log.assert(\n            index >= 0 && index < this.items.length,\n            'Out-of-bounds ArraySub read'\n        );\n        return this.items[index];\n    }\n\n    getItemsUnsafe() {\n        return this.items;\n    }\n\n    set(index: number, value: T) {\n        throw new Error('Read-only');\n    }\n\n    getLength() {\n        this.trackedArray.notifyRead('length');\n        return this.items.length;\n    }\n\n    subscribe(handler: (events: Iterable<ArrayEvent<T>>) => void) {\n        this.retain();\n        const trackedArrayUnsubscribe = this.trackedArray.subscribe(handler);\n        handler([\n            {\n                type: ArrayEventType.SPLICE,\n                index: 0,\n                count: 0,\n                items: this.items.slice(),\n            },\n        ]);\n        const onUnsubscribe = () => {\n            trackedArrayUnsubscribe();\n            this.release();\n            this.subscriptions = this.subscriptions.filter(\n                (sub) => sub !== subscription\n            );\n        };\n        const subscription = {\n            handler,\n            onUnsubscribe,\n        };\n        this.subscriptions.push(subscription);\n        return () => subscription.onUnsubscribe();\n    }\n\n    takeSubscriptions() {\n        const toReturn = this.subscriptions;\n        this.subscriptions = [];\n        return toReturn;\n    }\n\n    private ingestEvents(events: Iterable<ArrayEvent<TSource>>) {\n        const transformedEvents = mergeArrayEvents(this.eventTransform(events));\n        for (const transformed of transformedEvents) {\n            const lengthBefore = this.items.length;\n            applyArrayEvent(this.items, transformed);\n            const lengthAfter = this.items.length;\n            switch (transformed.type) {\n                case ArrayEventType.SPLICE: {\n                    this.trackedArray.markDirty({\n                        start: transformed.index,\n                        end: transformed.index + transformed.count,\n                    });\n                    if (lengthBefore !== lengthAfter) {\n                        const dirtyEnd = Math.max(lengthBefore, lengthAfter);\n                        this.trackedArray.markDirty({\n                            start: transformed.index + transformed.count,\n                            end: dirtyEnd,\n                        });\n                        this.trackedArray.markDirty('length');\n                    }\n                    break;\n                }\n                case ArrayEventType.MOVE: {\n                    const startIndex = Math.min(\n                        transformed.from,\n                        transformed.to\n                    );\n                    const endIndex =\n                        Math.max(transformed.from, transformed.to) +\n                        transformed.count;\n                    this.trackedArray.markDirty({\n                        start: startIndex,\n                        end: endIndex,\n                    });\n                    break;\n                }\n                case ArrayEventType.SORT: {\n                    this.trackedArray.markDirty({\n                        start: transformed.from,\n                        end: transformed.from + transformed.indexes.length,\n                    });\n                    break;\n                }\n            }\n            this.trackedArray.addEvent(transformed);\n        }\n        this.trackedArray.tickClock();\n    }\n\n    retain() {\n        this.trackedArray.retain();\n    }\n\n    release() {\n        this.trackedArray.release();\n    }\n\n    getTrackedArray() {\n        return this.trackedArray;\n    }\n}\n\nexport function mapView<TSource, TTarget>(\n    source: DynamicArray<TSource>,\n    mapFn: (val: TSource) => TTarget\n): DerivedArraySub<TTarget, TSource> {\n    return new DerivedArraySub(source, function* (events) {\n        for (const event of events) {\n            switch (event.type) {\n                case ArrayEventType.SPLICE:\n                    yield {\n                        type: event.type,\n                        index: event.index,\n                        count: event.count,\n                        items: event.items?.map((val) => mapFn(val)),\n                    };\n                    break;\n                default:\n                    yield event;\n            }\n        }\n    });\n}\n\nexport function flatMapView<TSource, TTarget>(\n    source: DynamicArray<TSource>,\n    mapFn: (val: TSource) => TTarget[]\n): DerivedArraySub<TTarget, TSource> {\n    const slotSizes = new SlotSizes<TTarget[]>([]);\n    return new DerivedArraySub(source, function* (events) {\n        for (const event of events) {\n            switch (event.type) {\n                case ArrayEventType.SPLICE: {\n                    const mappedItems =\n                        event.items?.map((item) => mapFn(item)) ?? [];\n                    yield slotSizes.splice<TTarget>(\n                        event.index,\n                        event.count,\n                        mappedItems\n                    ).event;\n                    for (const item of mappedItems) {\n                        yield slotSizes.applyEvent(item, {\n                            type: ArrayEventType.SPLICE,\n                            index: 0,\n                            count: 0,\n                            items: item,\n                        });\n                    }\n                    break;\n                }\n                case ArrayEventType.SORT: {\n                    yield slotSizes.sort(event.from, event.indexes);\n                    break;\n                }\n                case ArrayEventType.MOVE: {\n                    yield slotSizes.move(event.from, event.count, event.to);\n                    break;\n                }\n            }\n        }\n    });\n}\n\nexport function filterView<TSource>(\n    source: DynamicArray<TSource>,\n    mapFn: (val: TSource) => boolean\n): DerivedArraySub<TSource, TSource> {\n    return flatMapView(source, (item) => (mapFn(item) ? [item] : []));\n}\n", "import type { ArrayEvent } from '../common/arrayevent';\nimport * as log from '../common/log';\nimport { CollectionRenderNode } from '../modelview/collectionrendernode';\nimport type { JSXNode } from '../viewcontroller/jsx';\nimport type { RenderNode } from '../viewcontroller/rendernode/rendernode';\nimport type { DerivedArraySub, DynamicArray } from './arraysub';\nimport { ArraySub, filterView, flatMapView, mapView } from './arraysub';\n\nconst collectionSymbol = Symbol('collection');\nconst dynamicArraySymbol = Symbol('dynamicArray');\n\ninterface CollectionViewSharedInterface<T> {\n    //\n    // Misc\n    //\n    /** Destroy the collection */\n    dispose(): void;\n\n    /** Retain the collection */\n    retain(): void;\n\n    /** Release the collection */\n    release(): void;\n\n    __debugName: string;\n\n    //\n    // View transformation\n    //\n    mapView<V>(mapFn: (value: T) => V, debugName?: string): View<V>;\n    filterView(filterFn: (value: T) => boolean, debugName?: string): View<T>;\n    flatMapView<V>(flatMapFn: (value: T) => V[], debugName?: string): View<V>;\n\n    //\n    // Subscription\n    //\n    subscribe: (\n        handler: (events: Iterable<ArrayEvent<T>>) => void\n    ) => () => void;\n\n    //\n    // Internal access\n    //\n    [dynamicArraySymbol]: () => DynamicArray<T>;\n}\n\nexport interface Collection<T>\n    extends Array<T>,\n        CollectionViewSharedInterface<T> {\n    //\n    // Helper functions\n    //\n    /** Mutate the collection, rejecting items that pass the predicate fn */\n    reject(predicate: (value: T) => boolean): T[];\n\n    /** Move portion of the collection to another index */\n    moveSlice(from: number, count: number, to: number): void;\n\n    asView(): View<T>;\n\n    //\n    // RenderNode\n    //\n    __renderNode(renderJsxNode: (jsxNode: JSXNode) => RenderNode): RenderNode;\n}\n\nexport interface View<T>\n    extends ReadonlyArray<T>,\n        CollectionViewSharedInterface<T> {\n    //\n    // RenderNode\n    //\n    __renderNode(renderJsxNode: (jsxNode: JSXNode) => RenderNode): RenderNode;\n}\n\nfunction makeCollectionOrView<T, I extends { __debugName: string }>(\n    dynamicArray: DynamicArray<T>,\n    additionalPrototypeProps: I,\n    isWritable: boolean,\n    setFn: (\n        ...args: [prop: 'length', value: number] | [prop: number, value: T]\n    ) => boolean\n) {\n    const values = dynamicArray.getItemsUnsafe();\n    const pseudoPrototype: CollectionViewSharedInterface<T> & I = {\n        dispose: () => {\n            revoke();\n        },\n        retain: () => {\n            dynamicArray.retain();\n        },\n        release: () => {\n            dynamicArray.release();\n        },\n        mapView: <V>(fn: (val: T) => V, debugName?: string) =>\n            view(mapView(dynamicArray, fn), debugName),\n        filterView: (fn: (val: T) => boolean, debugName?: string) =>\n            view(filterView(dynamicArray, fn), debugName),\n        flatMapView: <V>(fn: (val: T) => V[], debugName?: string) =>\n            view(flatMapView(dynamicArray, fn), debugName),\n\n        subscribe: (handler: (event: Iterable<ArrayEvent<T>>) => void) =>\n            dynamicArray.subscribe(handler),\n\n        [dynamicArraySymbol]: () => dynamicArray,\n\n        ...additionalPrototypeProps,\n    };\n\n    const getPropertyDescriptor = (prop: string | symbol) => {\n        if (prop === collectionSymbol) {\n            return {\n                value: true,\n                writable: false,\n                enumerable: false,\n                configurable: false,\n            };\n        }\n        if (prop in pseudoPrototype) {\n            return {\n                value: pseudoPrototype[prop as keyof typeof pseudoPrototype],\n                writable: false,\n                enumerable: false,\n                configurable: false,\n            };\n        }\n        if (prop === 'length') {\n            return {\n                value: dynamicArray.getLength(),\n                writable: false,\n                enumerable: true,\n                configurable: false,\n            };\n        }\n        const numericProp = typeof prop === 'string' ? parseInt(prop) : null;\n        if (numericProp !== null && numericProp.toString() === prop) {\n            return {\n                value: dynamicArray.get(numericProp),\n                writable: isWritable,\n                enumerable: true,\n                configurable: true,\n            };\n        }\n        return undefined;\n    };\n\n    const { proxy, revoke } = Proxy.revocable(values, {\n        get: (target, prop, receiver) => {\n            const descriptor = getPropertyDescriptor(prop);\n            if (!descriptor) {\n                return target[prop as any];\n            }\n            return descriptor.value;\n        },\n        set: (target, prop, value, receiver) => {\n            if (prop === collectionSymbol) {\n                return false;\n            }\n            if (prop in pseudoPrototype) {\n                log.warn(\n                    'Reassigning built-in methods not supported on collections/views'\n                );\n                return false;\n            }\n            if (prop === 'length') {\n                return setFn(prop, value);\n            }\n            const numericProp =\n                typeof prop === 'string' ? parseInt(prop) : null;\n            if (numericProp !== null && numericProp.toString() === prop) {\n                return setFn(numericProp, value);\n            }\n            log.warn(\n                'Cannot assign to unsupported values on collections/views',\n                { prop }\n            );\n            return false;\n        },\n        has: (target, prop) => {\n            return getPropertyDescriptor(prop) !== undefined;\n        },\n        ownKeys: (target) => {\n            const keys: string[] = [];\n            const length = dynamicArray.getLength();\n            for (let i = 0; i < length; ++i) {\n                keys.push(i.toString());\n            }\n            keys.push('length');\n            return keys;\n        },\n        defineProperty: () => {\n            log.warn('defineProperty not supported on collections');\n            return false;\n        },\n        deleteProperty: () => {\n            log.warn('delete not supported on collections');\n            return false;\n        },\n        getOwnPropertyDescriptor: (target, prop) => {\n            return getPropertyDescriptor(prop);\n        },\n        setPrototypeOf: () => {\n            log.warn('setPrototypeOf not supported on collections');\n            return false;\n        },\n    });\n    return proxy;\n}\n\nexport function collection<T>(\n    values: T[] = [],\n    debugName: string = 'collection'\n): Collection<T> {\n    const arraySub = new ArraySub(values, debugName);\n    const coll = makeCollectionOrView(\n        arraySub,\n        {\n            reject(predicate: (value: T) => boolean): T[] {\n                const removed: T[] = [];\n                for (let i = arraySub.getLength() - 1; i >= 0; --i) {\n                    if (predicate(arraySub.get(i))) {\n                        removed.push(arraySub.splice(i, 1, [])![0]);\n                    }\n                }\n                return removed.reverse();\n            },\n            moveSlice(from: number, count: number, to: number) {\n                arraySub.moveSlice(from, count, to);\n            },\n            splice(index: number, count: number, ...items: T[]) {\n                return arraySub.splice(index, count, items);\n            },\n            sort(fn?: (a: T, b: T) => number) {\n                arraySub.sort(fn);\n                return this;\n            },\n            reverse() {\n                arraySub.reverse();\n                return this;\n            },\n            pop() {\n                const length = arraySub.getItemsUnsafe().length;\n                if (length === 0) {\n                    return undefined;\n                }\n                return arraySub.splice(length - 1, 1, [])![0];\n            },\n            shift() {\n                const length = arraySub.getItemsUnsafe().length;\n                if (length === 0) {\n                    return undefined;\n                }\n                return arraySub.splice(0, 1, [])![0];\n            },\n            unshift(...items: T[]) {\n                arraySub.splice(0, 0, items);\n                return arraySub.getItemsUnsafe().length;\n            },\n            push(...items: T[]) {\n                arraySub.splice(Infinity, 0, items);\n                return arraySub.getItemsUnsafe().length;\n            },\n            asView() {\n                return view(arraySub);\n            },\n            __renderNode: (\n                renderJsxNode: (jsxNode: JSXNode) => RenderNode\n            ): RenderNode => {\n                return CollectionRenderNode(renderJsxNode, coll, debugName);\n            },\n            __debugName: debugName,\n        },\n        true,\n        (prop, value) => {\n            if (prop === 'length') {\n                arraySub.setLength(value);\n            } else {\n                arraySub.set(prop, value);\n            }\n            return true;\n        }\n    ) as Collection<T>;\n    return coll;\n}\n\nexport function view<T>(\n    arraySub: ArraySub<T> | DerivedArraySub<T, any>,\n    debugName: string = `view(${arraySub.__debugName})`\n): View<T> {\n    function unsupported(): boolean {\n        throw new Error('Cannot mutate readonly view');\n    }\n    const v = makeCollectionOrView(\n        arraySub,\n        {\n            push: unsupported,\n            unshift: unsupported,\n            pop: unsupported,\n            shift: unsupported,\n            __renderNode: (\n                renderJsxNode: (jsxNode: JSXNode) => RenderNode\n            ): RenderNode => {\n                return CollectionRenderNode(renderJsxNode, v, debugName);\n            },\n            __debugName: debugName,\n        },\n        false,\n        unsupported\n    ) as unknown as View<T>;\n    return v;\n}\n\nexport function getDynamicArray(item: Collection<unknown> | View<unknown>) {\n    return item[dynamicArraySymbol]();\n}\n\nexport function isCollectionOrView(\n    value: unknown\n): value is Collection<any> | View<any> {\n    return !!(\n        value &&\n        typeof value === 'object' &&\n        collectionSymbol in value &&\n        value[collectionSymbol] === true\n    );\n}\n", "import * as log from '../common/log';\nimport {\n    addVertex,\n    markDirty,\n    notifyRead,\n    release,\n    removeVertex,\n    retain,\n} from './engine';\nimport type { Processable, Retainable } from './engine';\n\nexport type TrackedDataSubscription<TEvent> = {\n    onUnsubscribe: () => void;\n    handler: (events: Iterable<TEvent>) => void;\n    events: TEvent[];\n};\n\nexport class TrackedData<TKey, TEvent> implements Processable, Retainable {\n    private declare itemSubscriptions: Map<\n        Retainable & Processable,\n        Map<TKey, number>\n    >;\n    private declare eventSubscriptions: TrackedDataSubscription<TEvent>[];\n    private declare dirtyKeys: Map<TKey, number>;\n    private declare clock: number;\n    private declare onAlive?: (() => void) | undefined;\n    private declare onDead?: (() => void) | undefined;\n    private declare mergeEvents: (events: TEvent[]) => Iterable<TEvent>;\n    private declare isDirty: boolean;\n\n    declare __processable: true;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(\n        mergeEvents: (events: TEvent[]) => Iterable<TEvent>,\n        lifecycle?: { onAlive?: () => void; onDead?: () => void },\n        debugName?: string\n    ) {\n        this.mergeEvents = mergeEvents;\n        this.itemSubscriptions = new Map();\n        this.eventSubscriptions = [];\n        this.dirtyKeys = new Map();\n        this.clock = 0;\n        this.onAlive = lifecycle?.onAlive;\n        this.onDead = lifecycle?.onDead;\n        this.isDirty = false;\n\n        this.__processable = true;\n        this.__refcount = 0;\n        this.__debugName = debugName ?? 'arraysub';\n    }\n\n    tickClock() {\n        this.clock += 1;\n    }\n\n    notifyRead(key: TKey) {\n        const reader = notifyRead(this);\n        if (reader && reader.__refcount > 0) {\n            let subscriptions = this.itemSubscriptions.get(reader);\n            if (!subscriptions) {\n                subscriptions = new Map();\n                this.itemSubscriptions.set(reader, subscriptions);\n            }\n            if (!subscriptions.has(key)) {\n                subscriptions.set(key, this.clock);\n            }\n        }\n    }\n\n    markDirty(key: TKey) {\n        if (this.__refcount === 0) {\n            return;\n        }\n        if (!this.dirtyKeys.has(key)) {\n            this.dirtyKeys.set(key, this.clock);\n        }\n        if (!this.isDirty) {\n            markDirty(this);\n            this.isDirty = true;\n        }\n    }\n\n    addEvent(event: TEvent) {\n        if (this.__refcount === 0) {\n            return;\n        }\n        if (this.eventSubscriptions.length > 0) {\n            for (const subscription of this.eventSubscriptions) {\n                subscription.events.push(event);\n            }\n            if (!this.isDirty) {\n                markDirty(this);\n                this.isDirty = true;\n            }\n        }\n    }\n\n    subscribe(handler: (events: Iterable<TEvent>) => void) {\n        this.retain(); // yes, by virtue of subscribing to this, it is retained\n        const subscription = {\n            onUnsubscribe: () => {\n                const index = this.eventSubscriptions.indexOf(subscription);\n                if (index >= 0) {\n                    this.eventSubscriptions.splice(index, 1);\n                    this.release();\n                }\n            },\n            handler,\n            events: [],\n        };\n        this.eventSubscriptions.push(subscription);\n\n        return () => subscription.onUnsubscribe();\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        addVertex(this);\n        this.onAlive?.();\n    }\n\n    __dead() {\n        this.onDead?.();\n        removeVertex(this);\n\n        this.itemSubscriptions.clear();\n        this.eventSubscriptions = [];\n        this.dirtyKeys.clear();\n        this.clock = 0;\n    }\n\n    __recalculate(): Processable[] {\n        log.assert(this.__refcount > 0, 'cannot flush dead trackeddata');\n\n        const toPropagate = new Set<Retainable & Processable>();\n\n        // First propagate dirtiness for keys\n        for (const [\n            reader,\n            subscriptions,\n        ] of this.itemSubscriptions.entries()) {\n            if (reader.__refcount > 0) {\n                for (const [key, whenRead] of subscriptions.entries()) {\n                    const whenChanged = this.dirtyKeys.get(key);\n                    if (whenChanged !== undefined && whenRead <= whenChanged) {\n                        toPropagate.add(reader);\n                    }\n                }\n            }\n        }\n\n        // For all the readers that have been dirtied, clear their subscriptions since they will re-evaluate\n        for (const reader of toPropagate) {\n            this.itemSubscriptions.delete(reader);\n        }\n\n        this.eventSubscriptions.forEach((subscription) => {\n            if (subscription.events.length) {\n                subscription.handler(this.mergeEvents(subscription.events));\n                subscription.events = [];\n            }\n        });\n\n        this.dirtyKeys.clear();\n        this.isDirty = false;\n\n        // Propagate dirtiness\n        return [...toPropagate];\n    }\n\n    takeSubscriptions() {\n        const toReturn = this.eventSubscriptions;\n        this.eventSubscriptions = [];\n        return toReturn;\n    }\n}\n", "import { ArraySub } from './arraysub';\nimport { view } from './collection';\nimport type { View } from './collection';\nimport { release, retain } from './engine';\nimport type { Retainable } from './engine';\nimport { TrackedData } from './trackeddata';\n\nexport enum DictEventType {\n    ADD = 'add',\n    SET = 'set',\n    DEL = 'del',\n}\nexport type DictEvent<K, V> =\n    | { type: DictEventType.ADD; prop: K; value: V }\n    | { type: DictEventType.SET; prop: K; value: V }\n    | { type: DictEventType.DEL; prop: K; value?: V };\n\nexport type Model<T extends {}> = T;\n\nfunction* mergeDictEvents<K, V>(events: DictEvent<K, V>[]) {\n    if (events.length === 0) {\n        return;\n    }\n    let lastEvent: DictEvent<K, V> | undefined = events[0];\n    for (let i = 1; i < events.length; ++i) {\n        const event = events[i];\n        if (lastEvent?.prop === event.prop) {\n            switch (lastEvent.type) {\n                case DictEventType.ADD:\n                case DictEventType.SET:\n                    if (event.type === DictEventType.SET) {\n                        lastEvent = {\n                            type: lastEvent.type, // ADD/SET followed by SET overwrites with the new value\n                            prop: event.prop,\n                            value: event.value, // Use overridden value\n                        };\n                        return;\n                    }\n                    if (event.type === DictEventType.DEL) {\n                        lastEvent = undefined; // ADD/SET followed by DEL is a no-op, so *both* can be omitted\n                        return;\n                    }\n                    break;\n                case DictEventType.DEL:\n                    if (event.type === DictEventType.ADD) {\n                        lastEvent = {\n                            type: DictEventType.SET, // DEL followed by ADD is a SET\n                            prop: event.prop,\n                            value: event.value,\n                        };\n                    }\n                    break;\n            }\n        } else {\n            if (lastEvent) {\n                yield lastEvent;\n            }\n            lastEvent = event;\n        }\n    }\n    if (lastEvent) {\n        yield lastEvent;\n    }\n}\n\nconst sizeSymbol = Symbol('dictSize');\nconst keysSymbol = Symbol('dictKeys');\nconst trackedDataSymbol = Symbol('trackedData');\n\nexport class Dict<K, V> implements Retainable {\n    private declare items: Map<K, V>;\n    declare [trackedDataSymbol]: TrackedData<\n        K | typeof sizeSymbol | typeof keysSymbol,\n        DictEvent<K, V>\n    >;\n\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(init?: [key: K, value: V][] | undefined, debugName?: string) {\n        this.items = new Map(init ?? []);\n        this[trackedDataSymbol] = new TrackedData(\n            mergeDictEvents,\n            {},\n            debugName\n        );\n\n        this.__refcount = 0;\n        this.__debugName = debugName ?? 'arraysub';\n    }\n\n    getItemsUnsafe() {\n        return this.items;\n    }\n\n    get(key: K): V | undefined {\n        this[trackedDataSymbol].notifyRead(key);\n        return this.items.get(key);\n    }\n\n    has(key: K): boolean {\n        this[trackedDataSymbol].notifyRead(key);\n        return this.items.has(key);\n    }\n\n    set(key: K, value: V) {\n        if (this.items.get(key) === value) {\n            // Avoid doing anything if the write is a noop\n            return;\n        }\n        const hasKey = this.items.has(key);\n        this.items.set(key, value);\n        this[trackedDataSymbol].markDirty(key);\n\n        if (!hasKey) {\n            this[trackedDataSymbol].markDirty(sizeSymbol);\n            this[trackedDataSymbol].markDirty(keysSymbol);\n        }\n\n        this[trackedDataSymbol].addEvent({\n            type: hasKey ? DictEventType.SET : DictEventType.ADD,\n            prop: key,\n            value,\n        });\n\n        this[trackedDataSymbol].tickClock();\n    }\n\n    delete(key: K) {\n        if (!this.items.has(key)) {\n            // Avoid doing anything if the delete is a noop\n            return;\n        }\n        this.items.delete(key);\n        this[trackedDataSymbol].markDirty(key);\n        this[trackedDataSymbol].markDirty(sizeSymbol);\n        this[trackedDataSymbol].markDirty(keysSymbol);\n\n        this[trackedDataSymbol].addEvent({\n            type: DictEventType.DEL,\n            prop: key,\n        });\n\n        this[trackedDataSymbol].tickClock();\n    }\n\n    clear() {\n        if (this.items.size === 0) {\n            // Avoid doing anything if clear is noop\n            return;\n        }\n        const keys = Array.from(this.items.keys());\n        this.items.clear();\n        for (const key of keys) {\n            this[trackedDataSymbol].markDirty(key);\n            this[trackedDataSymbol].addEvent({\n                type: DictEventType.DEL,\n                prop: key,\n            });\n        }\n        this[trackedDataSymbol].markDirty(sizeSymbol);\n\n        this[trackedDataSymbol].tickClock();\n    }\n\n    forEach(fn: (value: V, key: K) => void) {\n        for (const [key, value] of this.entries()) {\n            fn(value, key);\n        }\n    }\n\n    keysView(debugName?: string): View<K> {\n        let subscription: undefined | (() => void);\n        const arrSub = new ArraySub<K>([], debugName, {\n            onAlive: () => {\n                subscription = this.subscribe((events) => {\n                    for (const event of events) {\n                        switch (event.type) {\n                            case DictEventType.ADD:\n                                arrSub.splice(Infinity, 0, [event.prop]);\n                                break;\n                            case DictEventType.SET:\n                                break;\n                            case DictEventType.DEL: {\n                                const items = arrSub.getItemsUnsafe();\n                                const index = items.indexOf(event.prop);\n                                if (index !== -1) {\n                                    arrSub.splice(index, 1, []);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                });\n            },\n            onDead: () => {\n                subscription?.();\n                subscription = undefined;\n            },\n        });\n        const keysView = view(arrSub, debugName);\n        return keysView;\n    }\n\n    *keys() {\n        this[trackedDataSymbol].notifyRead(keysSymbol);\n        const keys = Array.from(this.items.keys());\n        for (const key of keys) {\n            yield key;\n        }\n    }\n\n    *values() {\n        this[trackedDataSymbol].notifyRead(keysSymbol);\n        const keys = Array.from(this.items.keys());\n        const values: V[] = [];\n        for (const key of keys) {\n            this[trackedDataSymbol].notifyRead(key);\n            values.push(this.items.get(key)!);\n        }\n        for (const value of values) {\n            yield value;\n        }\n    }\n\n    *entries() {\n        this[trackedDataSymbol].notifyRead(keysSymbol);\n        const keys = Array.from(this.items.keys());\n        const entries: [K, V][] = [];\n        for (const key of keys) {\n            this[trackedDataSymbol].notifyRead(key);\n            entries.push([key, this.items.get(key)!]);\n        }\n        for (const entry of entries) {\n            yield entry;\n        }\n    }\n\n    get size() {\n        this[trackedDataSymbol].notifyRead(sizeSymbol);\n        return this.items.size;\n    }\n\n    subscribe(handler: (events: Iterable<DictEvent<K, V>>) => void) {\n        this.retain();\n\n        const initialEvents: Iterable<DictEvent<K, V>> = mergeDictEvents(\n            Array.from(this.items.entries()).map(([key, value]) => ({\n                type: DictEventType.ADD,\n                prop: key,\n                value,\n            }))\n        );\n        handler(initialEvents);\n\n        const unsubscribe = this[trackedDataSymbol].subscribe(handler);\n        return () => {\n            unsubscribe();\n            this.release();\n        };\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        this[trackedDataSymbol].retain();\n    }\n\n    __dead() {\n        this[trackedDataSymbol].release();\n    }\n}\n\nexport function getDictTrackedData<K, V>(\n    dict: Dict<K, V>\n): TrackedData<K | typeof sizeSymbol | typeof keysSymbol, DictEvent<K, V>> {\n    return dict[trackedDataSymbol];\n}\n\nexport function dict<K, V>(entries: [K, V][] = [], debugName?: string) {\n    return new Dict<K, V>(entries, debugName);\n}\n\nexport function isDict(value: unknown): value is Dict<unknown, unknown> {\n    return value instanceof Dict;\n}\n", "import type {\n    DynamicInternalSubscription,\n    DynamicMut,\n    DynamicNonErrorSubscriptionHandler,\n    DynamicSubscriptionHandler,\n} from '../common/dyn';\nimport * as log from '../common/log';\nimport type { Calculation } from './calc';\nimport { calc } from './calc';\nimport type { Processable, Retainable } from './engine';\nimport {\n    addVertex,\n    getForwardDependencies,\n    markDirty,\n    notifyRead,\n    release,\n    removeVertex,\n    retain,\n} from './engine';\n\nconst takeFieldSubscriptionsSymbol = Symbol('takeFieldSubscriptions');\n\nexport class Field<T> implements Processable, Retainable, DynamicMut<T> {\n    private declare _val: T;\n    // Map of subscriber to the clock time\n    private declare _subscribers?: Map<\n        DynamicNonErrorSubscriptionHandler<T>,\n        number\n    >;\n    private declare _subscriptions: DynamicInternalSubscription<T>[];\n    private declare _changeClock: number;\n\n    declare __processable: true;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(val: T, debugName?: string) {\n        this._val = val;\n        this._changeClock = 0;\n        this._subscriptions = [];\n\n        this.__processable = true;\n        this.__refcount = 0;\n\n        this.__debugName = debugName ?? 'field';\n    }\n\n    get(): T {\n        notifyRead(this);\n        return this._val;\n    }\n\n    set(newVal: T) {\n        if (newVal !== this._val) {\n            if (this._subscribers) {\n                this._changeClock += 1;\n            }\n            this._val = newVal;\n            if (this.__refcount > 0) {\n                markDirty(this);\n            }\n        }\n    }\n\n    subscribe(handler: DynamicNonErrorSubscriptionHandler<T>): () => void {\n        this.retain();\n        if (!this._subscribers) this._subscribers = new Map();\n        const subscription: DynamicInternalSubscription<T> = {\n            onUnsubscribe: () => {\n                if (this._subscribers?.has(handler)) {\n                    this._subscribers?.delete(handler);\n                    this.release();\n                }\n                this._subscriptions = this._subscriptions.filter(\n                    (sub) => sub !== subscription\n                );\n            },\n            // Yes, this is type incompatible. If a field is replaced by a\n            // calc; it's possible the subscription will be passed errors and\n            // the caller is not expecting that. This can only occur during hot\n            // swapping, and the type error will surface if it is incompatible,\n            // so this is \"safe\"\n            handler: handler as DynamicSubscriptionHandler<T>,\n        };\n        this._subscriptions.push(subscription);\n        this._subscribers.set(handler, this._changeClock);\n        handler(undefined, this._val);\n        return () => subscription.onUnsubscribe();\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        addVertex(this);\n    }\n\n    __dead() {\n        removeVertex(this);\n        this._subscribers = undefined;\n        this._subscriptions = [];\n    }\n\n    __recalculate(): Processable[] {\n        log.assert(this.__refcount > 0, 'cannot flush dead field');\n        if (this._subscribers) {\n            for (const [subscriber, observeClock] of this._subscribers) {\n                if (observeClock < this._changeClock) {\n                    subscriber(undefined, this._val);\n                }\n                this._subscribers.set(subscriber, 0);\n            }\n            this._changeClock = 0;\n        }\n        return [...getForwardDependencies(this)];\n    }\n\n    map<V>(fn: (val: T) => V): Calculation<V> {\n        return calc(() => fn(this.get()));\n    }\n\n    [takeFieldSubscriptionsSymbol]() {\n        const toReturn = this._subscriptions;\n        this._subscriptions = [];\n        return toReturn;\n    }\n}\n\nexport function field<T>(val: T, debugName?: string): Field<T> {\n    return new Field(val, debugName);\n}\n\nexport function takeFieldSubscriptions<T>(field: Field<T>) {\n    return field[takeFieldSubscriptionsSymbol]();\n}\n", "type Vertex = {\n    nodeId: number;\n    index?: number;\n    lowlink?: number;\n    onStack?: boolean;\n};\n\nexport function tarjanStronglyConnected(\n    reverseAdjacency: readonly (readonly number[])[],\n    topologicalIndexById: readonly (number | undefined)[],\n    lowerBound: number,\n    upperBound: number,\n    fromNodes: Iterable<number>\n): number[][] {\n    let index = 0;\n    const nodeVertex: Record<number, Vertex> = {};\n    const stack: Vertex[] = [];\n    const reverseTopoSort: number[][] = [];\n\n    function* getDepenencies(nodeId: number) {\n        for (const toId of reverseAdjacency[nodeId]) {\n            const toIndex = topologicalIndexById[toId];\n            if (\n                toIndex !== undefined &&\n                lowerBound <= toIndex &&\n                toIndex <= upperBound\n            ) {\n                yield toId;\n            }\n        }\n    }\n\n    const strongconnect = (vertex: Vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index = index + 1;\n        stack.push(vertex);\n        vertex.onStack = true;\n\n        // Consider successors of v\n        for (const toId of getDepenencies(vertex.nodeId)) {\n            if (!nodeVertex[toId]) {\n                nodeVertex[toId] = {\n                    nodeId: toId,\n                };\n            }\n            const toVertex = nodeVertex[toId];\n            if (toVertex.index === undefined) {\n                // Successor toVertex has not yet been visited; recurse on it\n                strongconnect(toVertex);\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    toVertex.lowlink!\n                );\n            } else if (toVertex.onStack) {\n                // Successor toVertex is in stack S and hence in the current SCC\n                // If toVertex is not on stack, then (vertex, toVertex) is an edge pointing to an SCC already found and must be ignored\n                // Note: The next line may look odd - but is correct.\n                // It says toVertex.index not toVertex.lowlink; that is deliberate and from the original paper\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    toVertex.index\n                );\n            }\n        }\n\n        // If vertex is a root node, pop the stack and generate an SCC\n        if (vertex.lowlink === vertex.index) {\n            // start a new strongly connected component\n            const component: number[] = [];\n            for (;;) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const toVertex = stack.pop()!;\n                toVertex.onStack = false;\n                // add toVertex to current strongly connected component\n                component.push(toVertex.nodeId);\n                if (toVertex === vertex) {\n                    break;\n                }\n            }\n            // output the current strongly connected component\n            reverseTopoSort.push(component);\n        }\n    };\n\n    for (const nodeId of fromNodes) {\n        if (!nodeVertex[nodeId]) {\n            nodeVertex[nodeId] = {\n                nodeId,\n            };\n            strongconnect(nodeVertex[nodeId]);\n        }\n    }\n\n    return reverseTopoSort;\n}\n", "/*\n * The Directed Graph\n * ==================\n *\n * The directed graph is a fully dynamic directed graph: vertices and edges may be added and removed at any time.\n *\n * Main challenge: maintain the topological ordering after each batch of vertex/edge additions/removals.\n *\n * Each vertex has a set of flags which may be set/cleared:\n * - \"dirty\": which is set when the vertex\u2019s underlying data is modified/invalidated.\n * - \"cycle\": set when the vertex is part of a cycle (more correctly: a strongly connected component with >1 vertex)\n * - \"self cycle\": set when the vertex has an edge pointing to itself (completely separate from \"cycle\")\n * - \"cycle informed\": set when the vertex has been processed as a cycle\n *\n * When a dirty vertex is processed, its dirtiness is cleared. Depending on the result of processing the vertex,\n * dirtiness may be propagated to destination vertices, which have their dirty bit set.\n *\n *\n * Topological Ordering\n * --------------------\n *\n * Our primary goal is to process the dirty vertices in this graph in topological order. One hitch is that during the\n * processing of dirty vertices, edges may be added and vertices may be marked as dirty.\n *\n * Since a topological ordering means arrows go from left to right, the only thing that could possibly break a\n * topological ordering is the addition of an edge that goes in the opposite direction.\n *\n * When we add an edge that goes in the opposite direction, we add the vertices to a set that need to be reordered.\n *\n * It's important to note that if topological order is maintained, a cycle can only occur if an edge is added in the\n * incorrect order (or to itself).\n *\n * This graph uses a variation on the Pearce Kelly algorithm to maintain the topological ordering in this case\n * (https://whileydave.com/publications/pk07_jea/) while supporting cycles.\n *\n * The general structure of this variation is:\n * - Get the lower and upper index bounds of the set of out of order vertices\n * - Instead of using DFS to determine the correct order of the subgraph within the upper/lower bounds, use Tarjan's\n *   strongly connected component algorithm to both determine the order and obtain strongly connected components\n *\n *\n * Handling Cycles\n * ---------------\n *\n * One edge case not explicitly handled by the Pearce Kelly algorithm is how to handle cycles/strongly connected\n * components. This directed graph allows for cycles in the directed graph to exist.\n *\n * Note: The term cycle to mean a set of vertices that can all reach each other. This set may have a size of one.\n *\n * In this case, for the purposes of the graph, all nodes in a cycle are treated as a single unit:\n * - If any of the cycle vertices are marked as \u201Cdirty\u201D they all are marked as \u201Cdirty\u201D\n * - If any of the cycle vertices are processed, they are all processed (in arbitrary order) and dirtiness is propagated\n *   only to vertices that are not members of the cycle.\n *\n * When an edge is added that introduces a cycle, that edge will go from right to left. We will identify these cycles\n * when reordering. In every cycle there is at least one edge that goes in the wrong direction.\n *\n * If an edge that connects two vertices in a cycle is removed there are two cases to consider:\n *\n * Case 1) If the removed edge goes in the correct direction, the cycle may be broken. If broken, there exists at least\n * one edge in the cycle that goes in the wrong direction. In this case, the topological order of the subgraph\n * reachable/that reaches the vertices needs to be reordered. Tarjan\u2019s strongly connected components algorithm is used\n * to reorder the reachable subgraph in this case: identify the subgraph via a DFS traversal forward and backward, then\n * perform the algorithm on the subgraph.\n *\n * Case 2) If the edge goes in the wrong direction, no adjustments to the topological ordering need to be performed.\n * (This is a bold statement. Can a proof be demonstrated? Does this apply if edges are added to vertices in the middle\n * of a cycle?)\n *\n * **Open question**: when sorting and assigning vertices in a cycle, do we ever put anything in the middle of a cycle? We\n * should not.\n *\n * Given:\n * - a b c d e\n * - a->b->d->e->a\n * - And an addition: c->d\n * - We should place c before a as in: c a b d e\n * - This is since the component really \u201Clives\u201D at the first index of a cycle.\n *\n *\n * Graph Processing\n * ----------------\n *\n * The goal of graph processing is to visit all of the vertices marked as dirty and get them marked as not dirty.\n * Processing the graph is a coroutine operation, where a set of actions is produced and in response a Boolean is returned,\n * which indicates whether or not dirtiness should be propagated.\n *\n * When visiting a dirty node, one of three things happens:\n * - If the vertex is part of a cycle, it emits a cycle action.\n * - Otherwise, a recalculate action is emitted.\n *\n * While the graph doesn't concern itself with what these actions perform, in practice:\n * - Invalidation events clear cached data associated with the vertex. These always propagate dirtiness.\n * - Cycle events raise an error. These propagate dirtiness if the error is caught and the value produced is equal to the\n *   prior value.\n * - Recalculation events cause the calculation associated with the vertex to be re-executed. Propagation occurs if the\n *   value produced is equal to the prior value.\n *\n * The naive procedure of processing the graph is to iterate through the dirty vertices in topological order of the graph.\n * Upon discovering a dirty vertex:\n * - If it is part of a cycle, and is not cycle informed, emit a cycle, mark as informed, and conditionally propagate dirtiness\n * - If it ((is not part of a cycle) or (is part of a cycle and is cycle informed)), emit a recalculation and conditionally propagate dirtiness\n *\n * After processing a dirty vertex, perform any pending vertex/edge additions and removals caused by processing while\n * maintaining topological order. Proceed to the dirty vertex with lowest priority order. This ordering of dirty vertices\n * can be maintained with a priority queue that supports reassigning weights.\n *\n * Once all dirty vertices are processed, the operation is complete.\n *\n * It is possible for this algorithm to loop indefinitely. To avoid this, a process limit can be imposed (either per-vertex\n * or globally).\n *\n */\nimport * as log from '../common/log';\nimport { dead } from '../common/util';\nimport { tarjanStronglyConnected } from './tarjan';\n\ninterface CycleInfo {\n    lowerBound: number;\n    upperBound: number;\n    vertexIds: Set<number>;\n}\n\nexport enum ProcessAction {\n    INVALIDATE,\n    RECALCULATE,\n    CYCLE,\n}\n\nconst VERTEX_BIT_DIRTY /* ********** */ = 0b0001;\nconst VERTEX_BIT_CYCLE /* ********** */ = 0b0010;\nconst VERTEX_BIT_SELF_CYCLE /* ***** */ = 0b0100;\nconst VERTEX_BIT_CYCLE_INFORMED /* * */ = 0b1000;\n\ninterface DebugAttributes {\n    isActive: boolean;\n    name: string;\n}\n\ntype DebugFormatter<TVertex> = (vertex: TVertex) => DebugAttributes;\ntype DebugSubscription = (graphviz: string, label: string) => void;\n\nexport class Graph<TVertex> {\n    /** identifiers available for reuse */\n    protected declare availableIds: number[];\n    protected declare availableIndices: number[];\n    protected declare nextId: number;\n\n    /** Mapping of id -> vertex */\n    protected declare vertexToId: Map<TVertex, number>;\n    protected declare vertexById: (TVertex | undefined)[];\n\n    /** Mapping of id -> bits */\n    protected declare vertexBitsById: number[];\n\n    /** Mapping of id -> CycleInfo */\n    protected declare cycleInfoById: Record<number, CycleInfo | undefined>;\n\n    /** Mapping of id -> edges in the forward direction */\n    protected declare forwardAdjacency: number[][];\n\n    /** Mapping of id -> edges in the reverse direction */\n    protected declare reverseAdjacency: number[][];\n\n    /** Mapping of id -> index into topologicalOrdering */\n    protected declare topologicalIndexById: (number | undefined)[];\n\n    /** Ordered list of vertex ids */\n    protected declare topologicalOrdering: (number | undefined)[];\n\n    /** The start index of process(), moves forward in each step, may move back as a result of dirty vertices being added / reordered */\n    protected declare startVertexIndex: number;\n\n    /** Set of vertex ids that need reordering */\n    protected declare toReorderIds: Set<number>;\n\n    private declare debugSubscriptions: Set<{\n        formatter: DebugFormatter<TVertex>;\n        subscription: DebugSubscription;\n    }>;\n\n    private declare _processHandler: (\n        vertexGroup: Set<TVertex>,\n        action: ProcessAction\n    ) => void;\n\n    constructor(\n        processHandler: (\n            vertexGroup: Set<TVertex>,\n            action: ProcessAction\n        ) => void\n    ) {\n        this._processHandler = processHandler;\n\n        this.nextId = 1;\n        this.availableIds = [];\n        this.availableIndices = [];\n\n        this.vertexById = [];\n        this.vertexToId = new Map();\n\n        this.vertexBitsById = [];\n        this.cycleInfoById = {};\n        this.topologicalIndexById = [];\n        this.topologicalOrdering = [];\n\n        this.forwardAdjacency = [];\n        this.reverseAdjacency = [];\n\n        this.startVertexIndex = 0;\n        this.toReorderIds = new Set();\n\n        this.debugSubscriptions = new Set();\n    }\n\n    /**\n     * Vertex ids can be reused.\n     *\n     * If a vertex is added, it gets a new id\n     * If a vertex is deleted, its id is removed\n     * If a\n     */\n    addVertex(vertex: TVertex) {\n        log.assert(!this.vertexToId.has(vertex), 'double vertex addition');\n\n        let id: number;\n        if (this.availableIds.length > 0) {\n            id = this.availableIds.pop() as number;\n        } else {\n            id = this.nextId++;\n        }\n\n        this.vertexToId.set(vertex, id);\n        this.vertexById[id] = vertex;\n        this.vertexBitsById[id] = 0;\n\n        let index: number;\n        if (this.availableIndices.length > 0) {\n            index = this.availableIndices.pop() as number;\n        } else {\n            index = this.topologicalOrdering.length;\n            this.topologicalOrdering.length += 1;\n        }\n\n        this.topologicalIndexById[id] = index;\n        this.topologicalOrdering[index] = id;\n\n        this.forwardAdjacency[id] = [];\n        this.reverseAdjacency[id] = [];\n    }\n\n    removeVertex(vertex: TVertex) {\n        const id = this.vertexToId.get(vertex);\n        log.assert(id, 'double vertex removal');\n        const index = this.topologicalIndexById[id];\n        log.assert(index !== undefined, 'malformed graph');\n\n        // Note: no need to clear edges as you can only remove vertices with no edges\n        log.assert(\n            this.forwardAdjacency[id].length === 0,\n            'cannot remove vertex with forward edges'\n        );\n        log.assert(\n            this.reverseAdjacency[id].length === 0,\n            'cannot remove vertex with reverse edges'\n        );\n\n        this.topologicalIndexById[id] = undefined;\n        this.topologicalOrdering[index] = undefined;\n\n        this.clearVertexDirtyInner(id);\n        this.vertexBitsById[id] = 0;\n        delete this.cycleInfoById[id];\n        this.vertexToId.delete(vertex);\n        this.vertexById[id] = undefined;\n        this.toReorderIds.delete(id);\n\n        // Mark vertices as available for reuse\n        this.availableIds.push(id);\n        this.availableIndices.push(index);\n    }\n\n    hasVertex(vertex: TVertex) {\n        return this.vertexToId.has(vertex);\n    }\n\n    markVertexDirty(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexDirty on nonexistent vertex');\n        this.markVertexDirtyInner(vertexId);\n    }\n\n    private markVertexDirtyInner(vertexId: number) {\n        const vertex = this.vertexById[vertexId];\n        if (vertex && !(this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY)) {\n            this.vertexBitsById[vertexId] |= VERTEX_BIT_DIRTY;\n            this.vertexBitsById[vertexId] &= ~VERTEX_BIT_CYCLE_INFORMED;\n            this.processVertexIdAction(vertexId, ProcessAction.INVALIDATE);\n\n            const index = this.topologicalIndexById[vertexId];\n            if (index !== undefined && index < this.startVertexIndex) {\n                this.startVertexIndex = index;\n            }\n        }\n    }\n\n    clearVertexDirty(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexDirty on nonexistent vertex');\n        this.clearVertexDirtyInner(vertexId);\n    }\n\n    private clearVertexDirtyInner(vertexId: number) {\n        if (this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY) {\n            this.vertexBitsById[vertexId] &= ~VERTEX_BIT_DIRTY;\n        }\n    }\n\n    markVertexCycleInformed(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexCycleInformed on nonexistent vertex');\n        this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE_INFORMED;\n    }\n\n    private *cycleAwareAdjacency(\n        vertexId: number,\n        cycleInfo: CycleInfo | undefined,\n        adjacencyList: number[][]\n    ) {\n        if (cycleInfo) {\n            const yielded = new Set<number>();\n            for (const cycleId of cycleInfo.vertexIds) {\n                for (const toId of adjacencyList[cycleId]) {\n                    if (!cycleInfo.vertexIds.has(toId) && !yielded.has(toId)) {\n                        yielded.add(toId);\n                        yield toId;\n                    }\n                }\n            }\n            return;\n        }\n        for (const toId of adjacencyList[vertexId]) {\n            if (toId !== vertexId) yield toId;\n        }\n    }\n\n    addEdge(fromVertex: TVertex, toVertex: TVertex) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'addEdge from vertex not found', { fromVertex });\n        log.assert(toId, 'addEdge to vertex not found', { toVertex });\n\n        DEBUG &&\n            log.assert(\n                !this.forwardAdjacency[fromId].includes(toId),\n                'addEdge duplicate'\n            );\n        this.forwardAdjacency[fromId].push(toId);\n        this.reverseAdjacency[toId].push(fromId);\n\n        if (\n            fromId === toId &&\n            (this.vertexBitsById[fromId] & VERTEX_BIT_SELF_CYCLE) === 0\n        ) {\n            const isInformed =\n                this.vertexBitsById[fromId] & VERTEX_BIT_CYCLE_INFORMED;\n            if (!isInformed) {\n                const vertex = this.vertexById[fromId];\n                log.assert(vertex, 'missing vertex in self-cycle');\n                this.processVertexIdAction(fromId, ProcessAction.CYCLE);\n                this.vertexBitsById[fromId] |=\n                    VERTEX_BIT_CYCLE_INFORMED | VERTEX_BIT_SELF_CYCLE;\n            } else {\n                this.vertexBitsById[fromId] |= VERTEX_BIT_SELF_CYCLE;\n            }\n        }\n\n        const fromIndex = this.topologicalIndexById[fromId];\n        const toIndex = this.topologicalIndexById[toId];\n        log.assert(toIndex !== undefined, 'malformed graph');\n        log.assert(fromIndex !== undefined, 'malformed graph');\n\n        DEBUG &&\n            log.info(\n                `Add edge ${fromId} (idx=${fromIndex}) -> ${toId} (idx=${toIndex})`\n            );\n        // Check for out-of-order edge insertion and add to resort batch\n        const badOrder = fromIndex > toIndex; // Note: equal is ok: you can't reorder a self-edge\n        if (badOrder) {\n            DEBUG &&\n                log.info(\n                    `- Out-of-order detected, reordering ${fromId} and ${toId}`\n                );\n            this.toReorderIds.add(fromId);\n            this.toReorderIds.add(toId);\n        }\n    }\n\n    hasEdge(fromVertex: TVertex, toVertex: TVertex) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'addEdge from vertex not found');\n        log.assert(toId, 'addEdge to vertex not found');\n\n        return this.forwardAdjacency[fromId].includes(toId);\n    }\n\n    removeEdge(fromVertex: TVertex, toVertex: TVertex) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'removeEdge from vertex not found');\n        log.assert(toId, 'removeEdge to vertex not found');\n\n        DEBUG &&\n            log.assert(\n                this.forwardAdjacency[fromId].includes(toId),\n                'removeEdge on edge that does not exist'\n            );\n\n        removeUnordered(this.forwardAdjacency[fromId], toId);\n        removeUnordered(this.reverseAdjacency[toId], fromId);\n\n        // If we are removing a self-cycle, clear the self cycle bit\n        if (fromId === toId) {\n            this.vertexBitsById[fromId] =\n                this.vertexBitsById[fromId] & ~VERTEX_BIT_SELF_CYCLE;\n        }\n\n        DEBUG && log.info(`Remove edge ${fromId} -> ${toId}`);\n        // If the removed edge is between two nodes in a cycle, it _may_ break the cycle\n        const fromCycleInfo = this.cycleInfoById[fromId];\n        const toCycleInfo = this.cycleInfoById[toId];\n        if (fromCycleInfo && toCycleInfo && fromCycleInfo === toCycleInfo) {\n            DEBUG &&\n                log.info(\n                    `- Edge removal possibly broke cycle, reordering ${fromId} and ${toId}`\n                );\n            this.toReorderIds.add(fromId);\n            this.toReorderIds.add(toId);\n        }\n    }\n\n    private visitDfsForwardRecurse(\n        vertexId: number,\n        lowerBound: number,\n        upperBound: number,\n        visited: Set<number>\n    ) {\n        if (visited.has(vertexId)) return;\n        visited.add(vertexId);\n        for (const toId of this.forwardAdjacency[vertexId]) {\n            const toIndex = this.topologicalIndexById[toId];\n            log.assert(toIndex !== undefined, 'malformed graph');\n            if (lowerBound <= toIndex && toIndex <= upperBound) {\n                this.visitDfsForwardRecurse(\n                    toId,\n                    lowerBound,\n                    upperBound,\n                    visited\n                );\n            }\n        }\n    }\n\n    private visitDfsForward(\n        startVertices: Iterable<number>,\n        lowerBound: number,\n        upperBound: number\n    ) {\n        const visited = new Set<number>();\n        for (const vertexId of startVertices) {\n            this.visitDfsForwardRecurse(\n                vertexId,\n                lowerBound,\n                upperBound,\n                visited\n            );\n        }\n        return visited;\n    }\n\n    private resort(toReorder: Set<number>) {\n        DEBUG && log.info('Resort from', [...toReorder]);\n        // Determine the bounds of the subgraph to reorder\n        let lowerBound = Infinity;\n        let upperBound = -Infinity;\n        for (const vertexId of toReorder) {\n            const cycleInfo = this.cycleInfoById[vertexId];\n            if (cycleInfo) {\n                DEBUG &&\n                    log.info(\n                        `- ${vertexId} is cycle with lower bound ${cycleInfo.lowerBound} & upper bound ${cycleInfo.upperBound}`\n                    );\n                if (cycleInfo.lowerBound < lowerBound)\n                    lowerBound = cycleInfo.lowerBound;\n                if (cycleInfo.upperBound > upperBound)\n                    upperBound = cycleInfo.upperBound;\n            } else {\n                const index = this.topologicalIndexById[vertexId];\n                DEBUG &&\n                    log.info(`- ${vertexId} is vertex with index ${index}`);\n                log.assert(index !== undefined, 'malformed graph');\n                if (index < lowerBound) lowerBound = index;\n                if (index > upperBound) upperBound = index;\n            }\n        }\n\n        DEBUG && log.info(`- lower bound: ${lowerBound}`);\n        DEBUG && log.info(`- upper bound: ${upperBound}`);\n\n        // Determine \"seed\" vertices for Tarjan's algorithm (those that are reachable in reverse from the ones that need reordering, within bounds)\n        const seedVertices = this.visitDfsForward(\n            toReorder,\n            lowerBound,\n            upperBound\n        );\n\n        DEBUG && log.info(`- seed vertices: ${[...seedVertices].join(',')}`);\n\n        // Use Tarjan's strongly connected algorithm (limited by the bound subgraph, sourced solely from the nodes we\n        // want to reorder) to get topological order & strongly connected components\n        const components = tarjanStronglyConnected(\n            this.reverseAdjacency,\n            this.topologicalIndexById,\n            lowerBound,\n            upperBound,\n            seedVertices\n        );\n\n        DEBUG && log.info(`- components:`, components);\n\n        // Grab the list of current indexes that we will reorder\n        const allocatedIndexes: number[] = [];\n        for (const component of components) {\n            for (const vertexId of component) {\n                const index = this.topologicalIndexById[vertexId];\n                log.assert(index !== undefined, 'malformed graph');\n                allocatedIndexes.push(index);\n            }\n        }\n\n        DEBUG && log.info('Resort');\n        DEBUG && this.debugLogTopology('before sort');\n\n        // Sort the allocated indexes so we can incrementally assign vertices to these indexes\n        allocatedIndexes.sort((a, b) => a - b);\n\n        // Place the new topology ordering in order per the allocatedIndexes\n        let i = 0;\n        for (const component of components) {\n            for (const vertexId of component) {\n                const index = allocatedIndexes[i];\n                this.topologicalOrdering[index] = vertexId;\n                this.topologicalIndexById[vertexId] = index;\n                i += 1;\n            }\n        }\n\n        // Update cycleInfo and inform cycles / clear cycles in two passes\n        //\n        // 1. First to assign all the cycleInfoById pieces (and update the lower/upper bounds)\n        // 2. Then to do the CYCLE informing / dirtying of cleared cycles\n        //\n        // This must be decoupled so that when a CYCLE is informed, it may react via invalidating / propagating with the full information of the graph\n        for (const component of components) {\n            let cycle: CycleInfo | undefined;\n            if (component.length > 1) {\n                cycle = {\n                    upperBound: -Infinity,\n                    lowerBound: Infinity,\n                    vertexIds: new Set(component),\n                };\n            }\n\n            for (const vertexId of component) {\n                if (cycle) {\n                    this.cycleInfoById[vertexId] = cycle;\n                    const index = this.topologicalIndexById[vertexId];\n                    log.assert(index !== undefined, 'malformed graph');\n                    if (index < cycle.lowerBound) cycle.lowerBound = index;\n                    if (index > cycle.upperBound) cycle.upperBound = index;\n                }\n            }\n        }\n\n        for (const component of components) {\n            for (const vertexId of component) {\n                if (component.length > 1) {\n                    if (!(this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE)) {\n                        this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE;\n                    }\n                    if (\n                        !(\n                            this.vertexBitsById[vertexId] &\n                            VERTEX_BIT_CYCLE_INFORMED\n                        )\n                    ) {\n                        // A vertex is discovered to be part of a cycle, inform it\n                        const vertex = this.vertexById[vertexId];\n                        log.assert(vertex, 'uninformed vertex missing');\n                        this.processVertexIdAction(\n                            vertexId,\n                            ProcessAction.CYCLE\n                        );\n                        this.vertexBitsById[vertexId] |=\n                            VERTEX_BIT_CYCLE_INFORMED;\n                    }\n                } else if (this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE) {\n                    // Vertex no longer part of a cycle, clear the cycle bits and mark as dirty\n                    this.vertexBitsById[vertexId] =\n                        this.vertexBitsById[vertexId] &\n                        ~(VERTEX_BIT_CYCLE | VERTEX_BIT_CYCLE_INFORMED);\n                    delete this.cycleInfoById[vertexId];\n                    this.markVertexDirtyInner(vertexId);\n                }\n            }\n        }\n\n        DEBUG && this.debugLogTopology('after sort');\n\n        return lowerBound;\n    }\n\n    private debugLogTopology(msg: string, vertexIndex?: number) {\n        log.assert(DEBUG, 'Do not call debugLogTopology when DEBUG not true');\n        if (log.isAtLogLevel('info')) {\n            DEBUG && log.info('Topology', msg);\n            for (let i = 0; i < this.topologicalOrdering.length; ++i) {\n                const vId = this.topologicalOrdering[i];\n                const prefix = vertexIndex === i ? '->' : '--';\n                if (vId === undefined) {\n                    log.info(`${prefix} [idx=${i}] (empty)`);\n                } else {\n                    const v = this.vertexById[vId];\n                    if (!v) {\n                        log.info(\n                            `${prefix} [idx=${i}] id=${vId} (no vertex?!)`\n                        );\n                    } else {\n                        const isDirty = !!(\n                            this.vertexBitsById[vId] & VERTEX_BIT_DIRTY\n                        );\n                        const cycleInfo = this.cycleInfoById[vId];\n                        if (cycleInfo) {\n                            log.info(\n                                `${prefix} [idx=${i}] id=${vId} ${(v as any).__debugName}; out=${this.forwardAdjacency[vId]?.join(',')}; cycle=${[...cycleInfo.vertexIds].join(',')}; cycleRange=[${cycleInfo.lowerBound}, ${cycleInfo.upperBound}] ${isDirty ? 'dirty' : 'clean'}`\n                            );\n                        } else {\n                            log.info(\n                                `${prefix} [idx=${i}] id=${vId} ${(v as any).__debugName}; out=${this.forwardAdjacency[vId]?.join(',')} ${isDirty ? 'dirty' : 'clean'}`\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private processHandler(vertexGroup: Set<TVertex>, action: ProcessAction) {\n        return this._processHandler(vertexGroup, action);\n    }\n\n    private processVertexIdAction(vertexId: number, action: ProcessAction) {\n        const cycleInfo = this.cycleInfoById[vertexId];\n\n        const vertexIds: number[] = [];\n        const vertexGroup = new Set<TVertex>();\n        if (cycleInfo) {\n            for (const cycleVertexId of cycleInfo.vertexIds) {\n                vertexIds.push(cycleVertexId);\n                const vertex = this.vertexById[cycleVertexId];\n                log.assert(vertex, 'malformed graph');\n                vertexGroup.add(vertex);\n            }\n        } else {\n            vertexIds.push(vertexId);\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'malformed graph');\n            vertexGroup.add(vertex);\n        }\n\n        DEBUG &&\n            log.debug(\n                `Processing vertex group action=${ProcessAction[action]}`,\n                Object.fromEntries(\n                    [...vertexGroup].map((vertex) => [\n                        (vertex as any).__debugName,\n                        vertex,\n                    ])\n                )\n            );\n\n        if (action === ProcessAction.CYCLE) {\n            const anyDirty = vertexIds.some(\n                (vertexId) => this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY\n            );\n            for (const vertexId of vertexIds) {\n                const isInformed =\n                    this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE_INFORMED;\n                if (!isInformed) {\n                    if (anyDirty) {\n                        this.vertexBitsById[vertexId] |= VERTEX_BIT_DIRTY;\n                    }\n                    const index = this.topologicalIndexById[vertexId];\n                    if (index !== undefined && index < this.startVertexIndex) {\n                        this.startVertexIndex = index;\n                    }\n                    this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE_INFORMED;\n                }\n            }\n        }\n\n        this._processHandler(vertexGroup, action);\n\n        // Note: it's possible that vertices within a group are **removed**\n        const aliveVertices: TVertex[] = [];\n        for (const vertex of vertexGroup) {\n            if (this.vertexToId.get(vertex) !== undefined) {\n                aliveVertices.push(vertex);\n            }\n        }\n\n        return aliveVertices;\n    }\n\n    process() {\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const label = `Process start`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n        if (this.toReorderIds.size > 0) {\n            this.resort(this.toReorderIds);\n            this.toReorderIds.clear();\n        }\n\n        for (;;) {\n            const vertexIndex = this.startVertexIndex;\n            if (vertexIndex >= this.vertexById.length) {\n                this.startVertexIndex = 0;\n                break;\n            }\n            this.startVertexIndex++;\n\n            const vertexId = this.topologicalOrdering[vertexIndex];\n            if (vertexId === undefined) {\n                continue;\n            }\n\n            const isDirty = this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY;\n            if (!isDirty) {\n                continue;\n            }\n\n            DEBUG && this.debugLogTopology('Process step', vertexIndex);\n\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'nonexistent vertex dirtied');\n\n            const beforeCycleInfo = this.cycleInfoById[vertexId];\n\n            // Process the vertex\n            const vertexGroup = this.processVertexIdAction(\n                vertexId,\n                ProcessAction.RECALCULATE\n            );\n            // After recalculating, clear all of the vertices dirty bits\n            for (const vertex of vertexGroup) {\n                this.clearVertexDirty(vertex);\n            }\n\n            // Processing may cause changes in edges, which may cause changes\n            // in cycles, so we must reorder and check for cycles\n            if (this.toReorderIds.size > 0) {\n                const lowerBound = this.resort(this.toReorderIds);\n                if (lowerBound < this.startVertexIndex) {\n                    this.startVertexIndex = lowerBound;\n                }\n                this.toReorderIds.clear();\n            }\n\n            // Now that we've reordered, we may have a different cycle\n            const newCycleInfo = this.cycleInfoById[vertexId];\n\n            // Handle cases where cycles have changed:\n            if (!beforeCycleInfo && newCycleInfo) {\n                // This vertex is part of a new cycle, notify the vertex of the cycle\n                this.processVertexIdAction(vertexId, ProcessAction.CYCLE);\n            } else if (beforeCycleInfo && !newCycleInfo) {\n                // This vertex is no longer part of a new cycle\n                // Do we need to do anything?\n            } else if (newCycleInfo) {\n                // This vertex is still part of a cycle; notify again\n                this.processVertexIdAction(vertexId, ProcessAction.CYCLE);\n            } else if (this.vertexBitsById[vertexId] & VERTEX_BIT_SELF_CYCLE) {\n                // This vertex is still part of a self-cycle; must notify again\n                this.processVertexIdAction(vertexId, ProcessAction.CYCLE);\n            }\n        }\n\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const label = `Process end`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n    }\n\n    getOrderedDirty() {\n        if (this.toReorderIds.size > 0) {\n            this.resort(this.toReorderIds);\n            this.toReorderIds.clear();\n        }\n\n        const vertices: TVertex[] = [];\n        for (\n            let vertexIndex = 0;\n            vertexIndex < this.topologicalOrdering.length;\n            ++vertexIndex\n        ) {\n            const vertexId = this.topologicalOrdering[vertexIndex];\n            if (vertexId === undefined) {\n                continue;\n            }\n\n            const isDirty = this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY;\n            if (!isDirty) {\n                continue;\n            }\n\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'nonexistent vertex dirtied');\n            vertices.push(vertex);\n        }\n        return vertices;\n    }\n\n    private propagateDirty(\n        vertexId: number,\n        cycleVertexIds: null | Set<number>\n    ) {\n        this.clearVertexDirtyInner(vertexId);\n        for (const toId of this.forwardAdjacency[vertexId]) {\n            const toCycleInfo = this.cycleInfoById[toId];\n            if (toCycleInfo) {\n                for (const toCycleId of toCycleInfo.vertexIds) {\n                    if (!cycleVertexIds || !cycleVertexIds.has(toCycleId)) {\n                        this.markVertexDirtyInner(toCycleId);\n                    }\n                }\n            } else {\n                if (!cycleVertexIds || !cycleVertexIds.has(toId)) {\n                    this.markVertexDirtyInner(toId);\n                }\n            }\n        }\n    }\n\n    // TODO: rename get forward non-cycle dependencies\n    *getForwardDependencies(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(\n            vertexId !== undefined,\n            'attempted to get forward dependencies on nonexistent vertex',\n            { vertex }\n        );\n        const cycleInfo = this.cycleInfoById[vertexId];\n        for (const toId of this.forwardAdjacency[vertexId]) {\n            const toVertex = this.vertexById[toId];\n            log.assert(toVertex !== undefined, 'malformed graph');\n            if (!cycleInfo || !cycleInfo.vertexIds.has(toId)) {\n                yield toVertex;\n            }\n        }\n    }\n\n    debug(getAttrs: DebugFormatter<TVertex>, label?: string) {\n        const lines = [];\n        lines.push('digraph dependencies {');\n        lines.push(`  graph [];`);\n        lines.push(`  edge [penwidth=2.0];`);\n        lines.push(`  node [penwidth=2.0];`);\n        if (label) {\n            lines.push(`  graph [label=${JSON.stringify(label)};]`);\n        }\n\n        const emitVertex = (id: number) => {\n            const vertex = this.vertexById[id];\n            if (!vertex) return;\n            const customAttrs = getAttrs(vertex);\n            const attrs: Record<string, string | number> = {\n                style: 'filled',\n                label: `${id}\\n${customAttrs.name}`,\n            };\n\n            // Shapes:\n            attrs.shape = 'ellipse';\n\n            // Fill colors:\n            // - dirty: black / #F9C784\n            // - clean: black / white\n            if (this.vertexBitsById[id] & VERTEX_BIT_DIRTY) {\n                attrs.style = 'filled';\n                attrs.fontcolor = '#FFFFFF';\n                attrs.fillcolor = '#FC7A1E';\n            } else {\n                attrs.style = 'filled';\n                attrs.fontcolor = '#000000';\n                attrs.fillcolor = '#FFFFFF';\n            }\n\n            // Border:\n            // - active: #485696\n            if (customAttrs.isActive) {\n                attrs.penwidth = 4.0;\n                attrs.pencolor = '#485696';\n            }\n\n            const labelItems: string[] = [];\n            for (const [attrName, attrVal] of Object.entries(attrs)) {\n                labelItems.push(`${attrName}=${JSON.stringify(attrVal)}`);\n            }\n\n            lines.push(`  v_${id} [${labelItems.join(',')}]`);\n        };\n\n        const cycles = new Set<CycleInfo>();\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const cycleInfo = this.cycleInfoById[id];\n            if (cycleInfo) {\n                cycles.add(cycleInfo);\n            }\n        }\n        for (const cycle of cycles) {\n            lines.push('  subgraph cluster_cycle {');\n            lines.push(`  graph [label=\"cycle\";]`);\n            for (const cycleId of cycle.vertexIds) {\n                emitVertex(cycleId);\n            }\n            lines.push('  }');\n        }\n\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const cycleInfo = this.cycleInfoById[id];\n            if (cycleInfo) continue;\n            emitVertex(id);\n        }\n\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            if (this.forwardAdjacency[id]) {\n                for (const toId of this.forwardAdjacency[id]) {\n                    lines.push(`  v_${id} -> v_${toId};`);\n                }\n            }\n        }\n        lines.push('}');\n        return lines.join('\\n');\n    }\n\n    debugSubscribe(\n        formatter: DebugFormatter<TVertex>,\n        subscription: (graphviz: string, label: string) => void\n    ) {\n        const entry = {\n            formatter,\n            subscription,\n        };\n        this.debugSubscriptions.add(entry);\n        return () => {\n            this.debugSubscriptions.delete(entry);\n        };\n    }\n\n    debugGetGraph() {\n        const vertices: TVertex[] = [];\n        for (let i = 0; i < this.vertexById.length; ++i) {\n            const vertex = this.vertexById[i];\n            if (vertex) {\n                vertices.push(vertex);\n            }\n        }\n        const edges: [TVertex, TVertex][] = [];\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            if (this.forwardAdjacency[id]) {\n                for (const toId of this.forwardAdjacency[id]) {\n                    const source = this.vertexById[id];\n                    const target = this.vertexById[toId];\n                    if (source && target) {\n                        edges.push([source, target]);\n                    }\n                }\n            }\n        }\n        return { vertices, edges };\n    }\n\n    /**\n     * Test-only interfaces; omitted in standard build\n     */\n    _test_getVertices(): TVertex[] {\n        return dead();\n    }\n    _test_getDependencies(vertex: TVertex): TVertex[] {\n        return dead();\n    }\n    _test_getVertexInfo(\n        vertex: TVertex\n    ): undefined | { id: number; index: number; bits: number } {\n        return dead();\n    }\n}\n\n/**\n * Inject test-only interfaces if we are in a test environment\n */\nif (TEST) {\n    Graph.prototype._test_getVertices = function _test_getVertices<TVertex>(\n        this: Graph<TVertex>\n    ) {\n        return this.vertexById.filter((vertex) => !!vertex);\n    };\n    Graph.prototype._test_getDependencies = function _test_getDependencies<\n        TVertex,\n    >(this: Graph<TVertex>, vertex: TVertex) {\n        const id = this.vertexToId.get(vertex);\n        log.assert(id, 'getDependencies on nonexistent vertex');\n        return this.forwardAdjacency[id].map((toId) => this.vertexById[toId]);\n    };\n\n    Graph.prototype._test_getVertexInfo = function _test_getVertexInfo<TVertex>(\n        this: Graph<TVertex>,\n        vertex: TVertex\n    ) {\n        const id = this.vertexToId.get(vertex);\n        if (id === undefined) return undefined;\n        const index = this.topologicalIndexById[id];\n        log.assert(index !== undefined, 'malformed graph');\n        const bits = this.vertexBitsById[id];\n        return {\n            id,\n            index,\n            bits,\n        };\n    };\n}\n\nfunction removeUnordered(array: number[], value: number) {\n    if (value === array[array.length - 1]) {\n        array.pop();\n        return;\n    }\n    const index = array.indexOf(value);\n    array[index] = array[array.length - 1];\n    array.pop();\n}\n", "import type { DynamicMut } from '../common/dyn';\nimport * as log from '../common/log';\nimport { dict, DictEventType } from './dict';\nimport type { Dict } from './dict';\n\nexport enum ModelEventType {\n    SET = 'set',\n}\n\nexport type ModelEvent<T extends {}, K extends keyof T> = {\n    type: ModelEventType;\n    prop: K;\n    value: T[K];\n};\n\nconst modelDictSymbol = Symbol('modelDict');\n\nexport type Model<T extends {}> = T;\n\nexport function getModelDict<T extends {}>(\n    model: Model<T>\n): Dict<keyof T, any> {\n    const dict = (model as any)[modelDictSymbol];\n    log.assert(dict, 'Unable to retrieve internal model dict');\n    return dict;\n}\n\nexport function isModel(value: unknown): value is Model<object> {\n    return !!(value && typeof value === 'object' && modelDictSymbol in value);\n}\n\nexport function model<T extends {}>(target: T, debugName?: string): Model<T> {\n    const modelDict = dict(Object.entries(target), debugName);\n    const modelObj: Model<T> = {} as Model<T>;\n    Object.keys(target).forEach((key) => {\n        Object.defineProperty(modelObj, key, {\n            get: () => {\n                return modelDict.get(key);\n            },\n            set: (newValue) => {\n                modelDict.set(key, newValue);\n            },\n            enumerable: true,\n        });\n    });\n    Object.defineProperty(modelObj, modelDictSymbol, {\n        get: () => modelDict,\n        enumerable: false,\n    });\n    return modelObj;\n}\n\nmodel.subscribe = function modelSubscribe<T extends {}, K extends keyof T>(\n    sourceModel: Model<T>,\n    handler: (event: ModelEvent<T, K>[]) => void,\n    debugName?: string\n): () => void {\n    const modelDict = getModelDict(sourceModel);\n    return modelDict.subscribe((events) => {\n        const transformed: ModelEvent<T, K>[] = [];\n        for (const event of events) {\n            if (\n                event.type === DictEventType.SET ||\n                event.type === DictEventType.ADD\n            ) {\n                transformed.push({\n                    type: ModelEventType.SET,\n                    prop: event.prop as K,\n                    value: event.value,\n                });\n            }\n        }\n        if (transformed.length) {\n            handler(transformed);\n        }\n    });\n};\n\nmodel.field = function modelField<T extends {}, K extends keyof T>(\n    sourceModel: Model<T>,\n    field: K\n): DynamicMut<T[K]> {\n    return {\n        get: () => sourceModel[field],\n        set: (newValue: T[K]) => {\n            sourceModel[field] = newValue;\n        },\n        subscribe: (handler) => {\n            return model.subscribe(sourceModel, (events) => {\n                for (const event of events) {\n                    if (event.prop === field) {\n                        handler(undefined, event.value as T[K]);\n                    }\n                }\n            });\n        },\n    };\n};\n", "import { ArrayEventType } from '../common/arrayevent';\nimport type { DynamicInternalSubscription } from '../common/dyn';\nimport * as log from '../common/log';\nimport { noop } from '../common/util';\nimport { commit } from '../viewcontroller/commit';\nimport { isClassComponent } from '../viewcontroller/createelement';\nimport type { Component } from '../viewcontroller/rendernode/componentrendernode';\nimport type { DynamicArraySubscription } from './arraysub';\nimport { Calculation, takeCalcSubscriptions } from './calc';\nimport type { Collection, View } from './collection';\nimport { getDynamicArray, isCollectionOrView } from './collection';\nimport { DictEventType, getDictTrackedData, isDict } from './dict';\nimport type { DictEvent } from './dict';\nimport { Field, takeFieldSubscriptions } from './field';\nimport { Graph, ProcessAction } from './graph';\nimport { getModelDict, isModel, model } from './model';\nimport type { ModelEvent } from './model';\nimport type { TrackedDataSubscription } from './trackeddata';\n\nexport interface Retainable {\n    __debugName: string;\n    __refcount: number;\n    __alive: () => void;\n    __dead: () => void;\n}\n\nexport interface Processable {\n    __processable: true;\n    __debugName: string;\n    __recalculate?: (vertexSet: Set<Processable>) => Processable[];\n    __cycle?: () => void;\n    __invalidate?: () => void;\n}\n\nexport function isProcessable(val: any): val is Processable {\n    return val && val.__processable === true;\n}\n\n/**\n * When reader R reads data D, data D calls `const reader = notifyRead(data)`\n *\n *   An edge is added between data D -> reader R\n *   Data D should be retained if it is a new dependency (by reader R, responsibility to do this is on the reader R)\n *   Data D gets a reference back to Reader R so it may markDirty(reader) when D is processed and needs to propagate change\n */\ntype OnReadCallback = (\n    vertex: Retainable & Processable\n) => Retainable & Processable;\n\nexport type MountSubscription = () => void;\n\nlet globalDependencyGraph = new Graph<Processable>(processHandler);\nlet trackReadCallbackStack: (OnReadCallback | null)[] = [];\nlet isFlushing = false;\nlet needsFlush = false;\nlet flushHandle: (() => void) | null = null;\nlet flushScheduler = defaultScheduler;\nlet componentToReplaceSet: Map<\n    Component<any>,\n    Set<(newComponent: Component<any>) => void>\n> = new Map();\nlet collectionToReplaceSet: Map<\n    Collection<any> | View<any>,\n    Set<(newCollection: Collection<any> | View<any>) => void>\n> = new Map();\nlet mountPoints: Map<Element | ShadowRoot, MountSubscription> = new Map();\n\nfunction noopScheduler(callback: () => void) {\n    return noop;\n}\n\nfunction defaultScheduler(callback: () => void) {\n    if ((window as any).queueMicrotask) {\n        let cancelled = false;\n        queueMicrotask(() => {\n            if (cancelled) return;\n            callback();\n        });\n        return () => {\n            cancelled = true;\n        };\n    }\n    const handle = setTimeout(callback, 0);\n    return () => clearTimeout(handle);\n}\n\nexport function reset() {\n    globalDependencyGraph = new Graph<Processable>(processHandler);\n    trackReadCallbackStack = [];\n    isFlushing = false;\n    needsFlush = false;\n    if (flushHandle) flushHandle();\n    flushHandle = null;\n    flushScheduler = defaultScheduler;\n    componentToReplaceSet = new Map();\n    collectionToReplaceSet = new Map();\n    mountPoints = new Map();\n}\n\nexport function registerMountPoint(\n    target: Element | ShadowRoot,\n    mountSubscription: MountSubscription\n) {\n    mountPoints.set(target, mountSubscription);\n}\n\nexport function takeMountPoint(target: Element | ShadowRoot) {\n    const sub = mountPoints.get(target);\n    if (sub) {\n        mountPoints.delete(target);\n    }\n    return sub;\n}\n\nexport function registerComponentReload<T>(\n    component: Component<T>,\n    reload: (newComponent: typeof component) => void\n) {\n    let reloads = componentToReplaceSet.get(component);\n    if (!reloads) {\n        reloads = new Set();\n        componentToReplaceSet.set(component, reloads);\n    }\n    reloads.add(reload);\n}\n\nexport function unregisterComponentReload<T>(\n    component: Component<T>,\n    reload: (newComponent: typeof component) => void\n) {\n    const reloads = componentToReplaceSet.get(component);\n    if (reloads) {\n        reloads.delete(reload);\n    }\n}\n\nexport function registerCollectionViewReload<T>(\n    coll: Collection<T> | View<T>,\n    reload: (newComponent: typeof coll) => void\n) {\n    let reloads = collectionToReplaceSet.get(coll);\n    if (!reloads) {\n        reloads = new Set();\n        collectionToReplaceSet.set(coll, reloads);\n    }\n    reloads.add(reload);\n}\n\nexport function unregisterCollectionViewReload<T>(\n    coll: Collection<T> | View<T>,\n    reload: (newComponent: typeof coll) => void\n) {\n    const reloads = collectionToReplaceSet.get(coll);\n    log.assert(\n        reloads,\n        'Internal error: unexpected unregisterComponentRenderNode, previously unseen',\n        { coll, reload }\n    );\n    reloads.delete(reload);\n}\n\nexport function hotSwap(beforeExport: unknown, afterExport: unknown) {\n    let beforeVertex: Processable | undefined;\n    let beforeArraySubscriptions:\n        | { length: number; subscriptions: DynamicArraySubscription<unknown>[] }\n        | undefined;\n    let beforeValueSubscriptions:\n        | DynamicInternalSubscription<unknown>[]\n        | undefined;\n    let beforeDictSubscriptions:\n        | {\n              keys: unknown[];\n              subscriptions: TrackedDataSubscription<\n                  DictEvent<unknown, unknown>\n              >[];\n          }\n        | undefined;\n    let beforeModelSubscriptions:\n        | {\n              keys: unknown[];\n              subscriptions: TrackedDataSubscription<\n                  ModelEvent<any, string | number | symbol>\n              >[];\n          }\n        | undefined;\n    let beforeComponent: Component<unknown> | undefined;\n    if (beforeExport instanceof Field) {\n        beforeVertex = beforeExport;\n        beforeValueSubscriptions = takeFieldSubscriptions(beforeExport);\n    } else if (beforeExport instanceof Calculation) {\n        beforeVertex = beforeExport;\n        beforeValueSubscriptions = takeCalcSubscriptions(beforeExport);\n    } else if (isModel(beforeExport)) {\n        const dict = getModelDict(beforeExport);\n        const trackedData = getDictTrackedData(dict);\n        // TODO: this is unsound!\n        beforeVertex = trackedData;\n        beforeModelSubscriptions = {\n            keys: [],\n            subscriptions:\n                trackedData.takeSubscriptions() as unknown as TrackedDataSubscription<\n                    ModelEvent<any, any>\n                >[],\n        };\n    } else if (isCollectionOrView(beforeExport)) {\n        const dynamicArray = getDynamicArray(beforeExport);\n        beforeVertex = dynamicArray.getTrackedArray();\n        beforeArraySubscriptions = {\n            length: beforeExport.length,\n            subscriptions: dynamicArray.takeSubscriptions(),\n        };\n    } else if (isDict(beforeExport)) {\n        const trackedData = getDictTrackedData(beforeExport);\n        if (globalDependencyGraph.hasVertex(trackedData)) {\n            for (const dep of globalDependencyGraph.getForwardDependencies(\n                trackedData\n            )) {\n                globalDependencyGraph.markVertexDirty(dep);\n            }\n        }\n        beforeDictSubscriptions = {\n            keys: Array.from(beforeExport.keys()),\n            subscriptions: trackedData.takeSubscriptions(),\n        };\n    } else if (\n        typeof beforeExport === 'function' ||\n        isClassComponent(beforeExport)\n    ) {\n        beforeComponent = beforeExport as Component<any>;\n    }\n\n    // If the export was a vertex, downstream dependencies must be dirtied\n    if (beforeVertex) {\n        if (globalDependencyGraph.hasVertex(beforeVertex)) {\n            for (const dep of globalDependencyGraph.getForwardDependencies(\n                beforeVertex\n            )) {\n                globalDependencyGraph.markVertexDirty(dep);\n            }\n        }\n    }\n\n    // If the old export had value subscriptions, hand them to the new export\n    if (beforeValueSubscriptions) {\n        for (const subscription of beforeValueSubscriptions) {\n            subscription.onUnsubscribe();\n            if (\n                afterExport instanceof Calculation ||\n                afterExport instanceof Field\n            ) {\n                subscription.onUnsubscribe = afterExport.subscribe(\n                    subscription.handler\n                );\n            } else {\n                subscription.onUnsubscribe = noop;\n                subscription.handler(\n                    new Error(\n                        'Hot swapping replaced Field/Calculation with non-Field/Calculation value'\n                    ),\n                    undefined\n                );\n            }\n        }\n    }\n    // If the old export had array subscriptions, hand them to the new export\n    if (beforeArraySubscriptions) {\n        for (const subscription of beforeArraySubscriptions.subscriptions) {\n            subscription.handler([\n                {\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: beforeArraySubscriptions.length,\n                },\n            ]);\n            subscription.onUnsubscribe();\n\n            if (isCollectionOrView(afterExport)) {\n                subscription.onUnsubscribe = afterExport.subscribe(\n                    subscription.handler\n                );\n            }\n        }\n    }\n\n    // If the old export had dict subscriptions, hand them to the new export\n    if (beforeDictSubscriptions) {\n        for (const subscription of beforeDictSubscriptions.subscriptions) {\n            subscription.handler(\n                beforeDictSubscriptions.keys.map((key) => ({\n                    type: DictEventType.DEL,\n                    prop: key,\n                }))\n            );\n            subscription.onUnsubscribe();\n\n            if (isDict(afterExport)) {\n                subscription.onUnsubscribe = afterExport.subscribe(\n                    subscription.handler\n                );\n            }\n        }\n    }\n\n    // If the old export had model subscriptions, hand them to the new export\n    if (beforeModelSubscriptions) {\n        for (const subscription of beforeModelSubscriptions.subscriptions) {\n            subscription.onUnsubscribe();\n\n            if (isModel(afterExport)) {\n                subscription.onUnsubscribe = model.subscribe(\n                    afterExport,\n                    subscription.handler\n                );\n            }\n        }\n    }\n\n    // If the old export is a component, replace with new export\n    if (beforeComponent) {\n        const replaceFunctions = componentToReplaceSet.get(beforeComponent);\n        if (replaceFunctions) {\n            // Note: if there is no after export, we swap it with a dead component\n            const afterComponent: Component<unknown> =\n                typeof afterExport === 'function' ||\n                isClassComponent(afterExport)\n                    ? (afterExport as Component<unknown>)\n                    : () => {\n                          log.warn(\n                              'Hot swapping replaced component with non-component value; the old component will now render to nothing'\n                          );\n                          return null;\n                      };\n            replaceFunctions.forEach((replaceFn) => {\n                replaceFn(afterComponent);\n                registerComponentReload(afterComponent, replaceFn);\n            });\n        }\n        componentToReplaceSet.delete(beforeComponent);\n    }\n}\n\nfunction scheduleFlush() {\n    if (needsFlush) return;\n    needsFlush = true;\n    flushHandle = flushScheduler(() => {\n        needsFlush = false;\n        flushHandle = null;\n        flushInner();\n    });\n}\n\nexport function flush() {\n    if (isFlushing) {\n        return;\n    }\n    if (flushHandle) {\n        flushHandle();\n        flushHandle = null;\n    }\n    needsFlush = false;\n    flushInner();\n}\n\nexport function subscribe(scheduler?: (callback: () => void) => () => void) {\n    flushScheduler = scheduler ?? noopScheduler;\n}\n\nexport function retain(retainable: Retainable) {\n    DEBUG &&\n        log.debug(\n            'retain',\n            retainable.__debugName,\n            'was',\n            retainable.__refcount\n        );\n    retainable.__refcount += 1;\n    if (retainable.__refcount === 1) {\n        retainable.__alive();\n    }\n}\n\nexport function release(retainable: Retainable) {\n    DEBUG &&\n        log.debug(\n            'release',\n            retainable.__debugName,\n            'was',\n            retainable.__refcount\n        );\n    log.assert(retainable.__refcount > 0, 'double release');\n    if (retainable.__refcount === 1) {\n        retainable.__dead();\n    }\n    retainable.__refcount -= 1;\n}\n\nfunction processHandler(vertexGroup: Set<Processable>, action: ProcessAction) {\n    const toInvalidate = new Set<Processable>();\n    for (const vertex of vertexGroup) {\n        DEBUG &&\n            log.debug(\n                'process',\n                ProcessAction[action],\n                vertex.__debugName,\n                vertex\n            );\n        switch (action) {\n            case ProcessAction.INVALIDATE:\n                vertex.__invalidate?.();\n                break;\n            case ProcessAction.RECALCULATE:\n                vertex\n                    .__recalculate?.(vertexGroup)\n                    .forEach((v) => toInvalidate.add(v));\n                break;\n            case ProcessAction.CYCLE:\n                vertex.__cycle?.();\n                // TODO: This is awkward! We need to propagate when a cycle _first occurs_\n                for (const toVertex of getForwardDependencies(\n                    vertex as Processable & Retainable\n                )) {\n                    toInvalidate.add(toVertex);\n                }\n                break;\n            default:\n                log.assertExhausted(action, 'unknown action');\n        }\n    }\n    for (const vertex of vertexGroup) {\n        toInvalidate.delete(vertex);\n    }\n    for (const vertex of toInvalidate) {\n        DEBUG &&\n            log.debug('post-process invalidate', vertex.__debugName, vertex);\n        markDirty(vertex);\n    }\n    return false;\n}\n\nfunction flushInner() {\n    isFlushing = true;\n    globalDependencyGraph.process();\n    commit();\n    isFlushing = false;\n    if (needsFlush) {\n        // This can happen when a flush or commit causes nodes in the dependency graph to be dirtied\n        // Ideally this shouldn't happen in a normal application, probably should measure if that's true in an idiomatic one\n        flush();\n    }\n}\n\nexport function addVertex(vertex: Processable) {\n    DEBUG && log.debug('addVertex', vertex.__debugName);\n    globalDependencyGraph.addVertex(vertex);\n}\n\nexport function removeVertex(vertex: Processable) {\n    DEBUG && log.debug('removeVertex', vertex.__debugName);\n    globalDependencyGraph.removeVertex(vertex);\n}\n\nexport function addEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'add edge',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.addEdge(fromVertex, toVertex);\n}\n\nexport function removeEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'del edge',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.removeEdge(fromVertex, toVertex);\n}\n\nexport function markDirty(vertex: Processable) {\n    DEBUG && log.debug('Vertex manually marked dirty', vertex.__debugName);\n    globalDependencyGraph.markVertexDirty(vertex);\n    scheduleFlush();\n}\n\nexport function unmarkDirty(vertex: Processable) {\n    DEBUG && log.debug('Vertex manually unmarked dirty', vertex.__debugName);\n    globalDependencyGraph.clearVertexDirty(vertex);\n}\n\nexport function markCycleInformed(vertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'Vertex manually marked as cycle informed',\n            vertex.__debugName\n        );\n    globalDependencyGraph.markVertexCycleInformed(vertex);\n}\n\nexport function trackReads<T>(\n    onRead: OnReadCallback,\n    fn: () => T,\n    debugName?: string\n): T {\n    DEBUG && log.group('trackReads', debugName ?? 'call');\n    trackReadCallbackStack.push(onRead);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            onRead === trackReadCallbackStack.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function untrackReads<T>(fn: () => T, debugName?: string): T {\n    DEBUG && log.group('untrackReads', debugName ?? 'call');\n    trackReadCallbackStack.push(null);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            null === trackReadCallbackStack.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function notifyRead(\n    dependency: Retainable & Processable\n): undefined | (Retainable & Processable) {\n    if (trackReadCallbackStack.length === 0) return undefined;\n    const onRead = trackReadCallbackStack[trackReadCallbackStack.length - 1];\n    if (onRead) {\n        DEBUG &&\n            log.debug(\n                'adding dependency',\n                dependency.__debugName,\n                'to active calculation'\n            );\n        return onRead(dependency);\n    }\n    return undefined;\n}\n\nexport function* getForwardDependencies(dependency: Retainable & Processable) {\n    yield* globalDependencyGraph.getForwardDependencies(dependency);\n}\n\nexport function debug(activeVertex?: Processable, label?: string) {\n    return globalDependencyGraph.debug((vertex) => {\n        return {\n            isActive: vertex === activeVertex,\n            name: `${vertex.__debugName} (rc=${(vertex as any).__refcount})`,\n        };\n    }, label);\n}\n\nexport function debugSubscribe(fn: (label: string, graphviz: string) => void) {\n    return globalDependencyGraph.debugSubscribe((vertex) => {\n        return {\n            isActive: false,\n            name: vertex.__debugName,\n        };\n    }, fn);\n}\n\nexport function debugGetGraph() {\n    const { vertices, edges } = globalDependencyGraph.debugGetGraph();\n    const labels = new Map<Processable, string>();\n    vertices.forEach((vertex) => {\n        labels.set(vertex, vertex.__debugName);\n    });\n    return { vertices, edges, labels };\n}\n", "/*\n * ### Calculations\n *\n * A calculation exists on the directed graph as a single vertex. They only get dirtied via propagation.\n *\n * The calculation abstraction represents a \u201Cpure\u201D function which takes no arguments and should produce the same value\n * if the data it reads is unchanged. Calculations have the following state:\n * - An optional error handler, which provides an alternative value in case of a cycle/error in calculation/processing\n * - An optional equality function, which determines whether or not subsequent results are the same value\n * - The cached value of its result\n * - The items it owns with respect to retaining\n *\n * A calculation may be in an error state, in which any calls to it raise an exception.\n *\n *\n * #### Calculation Caching\n *\n * All calculations have their results cached. A calculation may be invalidated, which discards the cached result if it\n * exists.\n *\n * Additionally, calculations have an equality comparator. By default this comparator is strict reference equality.\n *\n * If a cached calculation is recalculated, if the recalculated result compares equal to the cached result, the newly\n * produced result is discarded and the cached result is kept.\n *\n * When a calculation is called, the calculation is treated as an access with respect to tracking, even if the\n * calculation is in an error state or its result is cached. If the calculation is cached, the cached value is returned.\n * If the calculation is uncached, the underlying function is executed, its result cached, and that value is returned.\n *\n *\n * #### Calculation Error Handling\n *\n * Calculations have an error state, which is initially clear, and an optional error handler which is not set.\n *\n * The optional error handler is a function that takes one parameter, a value which indicates the error was due to a cycle\n * or due to an exception.\n *\n * The error handler is always executed in an \u201Cuntracked\u201D context.\n *\n * When a calculation\u2019s function is executed, all exceptions are caught. If an error handler is present, it is called\n * with a value that indicates the error was due to an exception and the return value of the error handler is used as if\n * it was the return value of the function (including equality comparison of the cached value). On completion of an\n * error handler, the calculation is popped off the global tracking stack, and inbound edge replacement proceeds as\n * normal. This means that only accesses that occur during the execution of the function (not during the execution of\n * the error handler) are tracked in the directed graph.\n *\n * If an exception is caught and there is no error handler present, the error state is set on the calculation so that\n * further calls raise an exception, the calculation is popped off the global tracking stack, inbound edge replacement\n * proceeds as normal, and the caught exception is re-thrown. This means that access that occur during the execution of the\n * function prior to the exception are tracked in the directed graph.\n *\n * The error state is cleared when the calculation is recalculated or when the calculation is invalidated.\n *\n * A calculation in a non-error state may be informed that it participates in a cycle. In this case if there is no error\n * handler the calculation\u2019s cache is cleared and is set to an error state. If there is an error handler, it is called with\n * a value that indicates the error is due to a cycle and the returned value is set to the cache if unequal to the value in\n * cache.\n *\n *\n * #### Calculation Execution\n *\n * When a calculation\u2019s function is being executed, all calls to other calculations (cached or uncached) or fields are\n * tracked. These tracked accesses are added to the directed graph as inbound edges: from the item being\n * accessed (either a calculation or a field) and to the calculation performing the access. Each execution replaces all\n * inbound edges.\n *\n * This tracking of access is shallow. That is to say:\n * * There is a stack of active calculations\n * * When a calculation starts execution it is added pushed on the top of the stack\n * * When a calculation finishes execution (either naturally or via exception) it is popped off the top of the stack\n * * Tracking only impacts the calculation on the top of the stack\n *\n * For example, if a calculation\u2019s function (A) is called, which calls another calculation\u2019s function (B), which accesses a\n * field (C), the resulting edges added are:\n * * C -> B\n * * B -> A\n *\n * Sometimes it is desirable to avoid this tracking. In this case a sentinel untracked value can be pushed to the stack of\n * calculations, call a function, and then pop the sentinel off the stack. When accesses occur while this sentinel value is\n * on top of the stack, no tracking is necessary. This is called executing a function in an \u201Cuntracked\u201D context.\n *\n *\n * #### Calculation Behavior\n *\n * This strict set of behaviors around caching, data tracking, and error handling are specifically chosen so that the\n * maintained topological ordering of the directed graph holds the quality that data accesses are placed before all things\n * doing the access. This allows us to intelligently recalculate functions only when their data dependencies have changed.\n * In other words, caching should be \u201Cperfect\u201D with no need to choose specific cache keys that need to be invalidated for\n * classes of calculations, or no need to manually invalidate cached calculations.\n *\n * For example, let\u2019s look at the following function that we\u2019ll call X:\n *\n * ```\n * calc(() => {\n *   if (A()) return B();\n *   if (C()) return D();\n *   return E();\n * })\n * ```\n *\n * There are three possible variations of the directed graph when calling X:\n * 1. If `A()` returns true, then `X` depends on `A` and `B`.\n * 2. If `A()` returns false and `C()` returns true, then `X` depends on `A` and `C` and `D`.\n * 3. If `A()` returns false and `C()` returns false, then `X` depends on `A` and `C` and `E`.\n *\n * This is to say that in case 2, we know for a fact that the return value does not and cannot depend on `B`, so we do not\n * need to recalculate/invalidate `X` if `B` were to change.\n *\n * Similarly in case 2, if `C` were to throw an exception, the effect of this exception depends on the fact that `A` was\n * called and returned a value that was true. If `A` were to change, even though the calculation is in an error state, it\n * could be that `A` now returns a value such that `C` is never called\u2014so we should recalculate `X` if `A` were to change\n * even if `X` is in the error state.\n *\n * In other words, we always know what values depend on the result of calculating `X`, so we know exactly when to\n * recalculate/invalidate `X`.\n *\n * If you are familiar with React hooks, you may recognize that the list of dependencies that React hooks forces you to\n * list explicitly when using `useMemo()` is the set of all possible data accesses, not the set of data accesses that\n * matter for each invocation. This is strikingly different than gooey, which performs the work of automatically tracking\n * only the values that the function uses.\n *\n *\n * #### Calculation Processing\n *\n * While the directed graph is processing, it emits one of three actions: invalidation, recalculation, and cycle.\n * * On an invalidation event, the calculation\u2019s cache is discarded and the error state is cleared. Propagation occurs if\n *   the calculation was cached.\n * * On a recalculation event, the calculation\u2019s underlying function is executed. Propagation occurs if the calculation is\n *   uncached.\n * * On a cycle event\n *     * If there is no error handler for the calculation, the calculation is invalidated and placed in an error state.\n *       Propagation occurs if the calculation was not in an error state.\n *     * If there is an error handler, it is called and the result is handled in the same manner as if it was the result of\n *       a recalculation event. Propagation occurs if the calculation was not cached or the error handler\u2019s return value\n *       does not equal the prior cached value.\n */\n\nimport type {\n    Dynamic,\n    DynamicInternalSubscription,\n    DynamicSubscriptionHandler,\n} from '../common/dyn';\nimport * as log from '../common/log';\nimport { wrapError } from '../common/util';\nimport {\n    addEdge,\n    addVertex,\n    getForwardDependencies,\n    isProcessable,\n    markCycleInformed,\n    notifyRead,\n    release,\n    removeEdge,\n    removeVertex,\n    retain,\n    trackReads,\n} from './engine';\nimport type { Processable, Retainable } from './engine';\n\ntype CalcUnsubscribe = () => void;\n\ntype CalcErrorHandler<T> = (error: Error) => T;\n\ntype CalculationResult<T> =\n    | { ok: false; error: Error }\n    | { ok: true; stale: boolean; value: T };\n\nfunction strictEqual<T>(a: T, b: T) {\n    return a === b;\n}\n\nconst takeCalcSubscriptionsSymbol = Symbol('takeCalcSubscriptions');\n\nexport class Calculation<T> implements Retainable, Processable, Dynamic<T> {\n    declare __processable: true;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    private declare _fn: () => T;\n    private declare _errorHandler: undefined | ((err: Error) => T);\n    private declare _result: CalculationResult<T> | undefined;\n    private declare _calculating: boolean;\n    private declare _eq: (a: T, b: T) => boolean;\n    private declare _dependencies: Set<Processable & Retainable>;\n    private declare _subscriptions: DynamicInternalSubscription<T>[];\n\n    private ensureResult(): {\n        propagate: boolean;\n        result: CalculationResult<T>;\n    } {\n        const result = this._result;\n        if (result && !result.ok) {\n            return { propagate: false, result };\n        }\n        if (result?.ok && !result.stale) {\n            DEBUG && log.debug(`Reuse calc ${this.__debugName}`);\n            return { propagate: false, result };\n        }\n        if (result?.ok && result.stale) {\n            DEBUG &&\n                log.debug(`Recalculating calc (stale) ${this.__debugName}`);\n            const lastValue = result.value;\n            const newResult = this.recalc();\n            if (newResult.ok && this._eq(lastValue, newResult.value)) {\n                DEBUG &&\n                    log.debug(`Stale recalculation reused ${this.__debugName}`);\n                return {\n                    propagate: false,\n                    result: {\n                        ok: true,\n                        stale: false,\n                        value: lastValue,\n                    },\n                };\n            }\n            return { propagate: true, result: newResult };\n        }\n        DEBUG && log.debug(`Recalculating calc ${this.__debugName}`);\n        return { propagate: true, result: this.recalc() };\n    }\n\n    get(): T {\n        notifyRead(this);\n        const { result } = this.ensureResult();\n        if (!result.ok) {\n            throw result.error;\n        }\n        return result.value;\n    }\n\n    recalc() {\n        if (this._calculating) {\n            throw new SynchronousCycleError(\n                'Cycle error: calculation cycle reached itself',\n                this\n            );\n        }\n\n        // Call the calc implementation\n        this._calculating = true;\n        let result: CalculationResult<T>;\n        const newDependencies = new Set<Processable & Retainable>();\n        try {\n            result = {\n                ok: true,\n                stale: false,\n                value: trackReads(\n                    (dependency) => {\n                        if (!newDependencies.has(dependency)) {\n                            newDependencies.add(dependency);\n                            retain(dependency);\n                            if (\n                                !this._dependencies.has(dependency) &&\n                                isProcessable(dependency) &&\n                                this.__refcount > 0\n                            ) {\n                                addEdge(dependency, this);\n                            }\n                        }\n                        return this;\n                    },\n                    () => this._fn(),\n                    this.__debugName\n                ),\n            };\n        } catch (e) {\n            result = {\n                ok: false,\n                error: wrapError(e),\n            };\n        }\n        this._calculating = false;\n\n        // Inform the graph of new dependencies\n        for (const prevDependency of this._dependencies) {\n            if (\n                !newDependencies.has(prevDependency) &&\n                isProcessable(prevDependency) &&\n                this.__refcount > 0\n            ) {\n                // We lost a dependency\n                removeEdge(prevDependency, this);\n            }\n            release(prevDependency); // We **always** release previous dependencies, since we **always** retain new ones\n        }\n        this._dependencies = newDependencies;\n\n        const synchronousError =\n            !result.ok && result.error instanceof SynchronousCycleError\n                ? result.error\n                : null;\n\n        if (synchronousError) {\n            // This calculation has learned it is part of a cycle, let the engine know so we are not informed by it of\n            // the cycle.\n            if (this.__refcount > 0) {\n                markCycleInformed(this);\n            }\n\n            if (synchronousError.sourceCalculation !== this) {\n                // The discovery of the cycle is passing upward, synchronously\n                synchronousError.passthruCalculations.add(this);\n            } else {\n                // We're at the source of the cycle, so all of the nodes in the cycle (aside from this one) should be in\n                //   result.error.passthruCalculations\n                //\n                // So we do the same thing that the engine does:\n\n                // 1. Tell the nodes to discard their cache\n                for (const calculation of synchronousError.passthruCalculations) {\n                    calculation.__invalidate();\n                }\n\n                // 2. Tell the nodes they're part of a cycle\n                const cycleDependencies = new Set<Processable>(\n                    this._dependencies\n                );\n                for (const calculation of synchronousError.passthruCalculations) {\n                    for (const dependency of calculation.__cycle()) {\n                        cycleDependencies.add(dependency);\n                    }\n                }\n                for (const calculation of synchronousError.passthruCalculations) {\n                    cycleDependencies.delete(calculation);\n                }\n                cycleDependencies.delete(this);\n            }\n        }\n\n        if (!result.ok) {\n            let error: Error;\n            if (\n                result.error instanceof SynchronousCycleError &&\n                result.error.sourceCalculation === this\n            ) {\n                // TODO: fragile error message & tests. Rewrite tests that fail when this error message is reworded\n                // TODO: also check to see if passthruCalculations is needed at all\n                error = new CycleError(\n                    'Cycle error: calculation cycle reached itself'\n                );\n            } else {\n                error = result.error;\n            }\n            if (this._errorHandler) {\n                try {\n                    result = {\n                        ok: true,\n                        stale: false,\n                        value: this._errorHandler(error),\n                    };\n                } catch (innerError) {\n                    // The error handler threw, nothing we can do but have the calculation error\n                    result = {\n                        ok: false,\n                        error: wrapError(innerError),\n                    };\n                }\n            } else {\n                result = {\n                    ok: false,\n                    error,\n                };\n            }\n        }\n\n        if (this.__refcount > 0) {\n            this._result = result;\n        }\n\n        if (synchronousError && synchronousError.sourceCalculation !== this) {\n            // Instead of returning, we throw the error until we've reached sourceCalculation again\n            throw synchronousError;\n        }\n\n        return result;\n    }\n\n    constructor(fn: () => T, debugName?: string) {\n        this.__refcount = 0;\n        this.__debugName = debugName ?? `calc:(${fn.name})`;\n        this.__processable = true;\n        this._result = undefined;\n        this._fn = fn;\n        this._errorHandler = undefined;\n        this._calculating = false;\n        this._eq = strictEqual;\n        this._dependencies = new Set();\n        this._subscriptions = [];\n    }\n\n    onError(handler: CalcErrorHandler<T>): this {\n        this._errorHandler = handler;\n        return this;\n    }\n\n    setCmp(eq: (a: T, b: T) => boolean): this {\n        this._eq = eq;\n        return this;\n    }\n\n    subscribe(handler: DynamicSubscriptionHandler<T>): CalcUnsubscribe {\n        retain(this);\n        let args: [Error, undefined] | [undefined, T];\n        try {\n            args = [undefined, this.get()];\n        } catch (e) {\n            args = [wrapError(e), undefined];\n        }\n        if (!this._subscriptions) {\n            this._subscriptions = [];\n        }\n        const subscription: DynamicInternalSubscription<T> = {\n            onUnsubscribe: () => {\n                this._subscriptions = this._subscriptions.filter(\n                    (sub) => sub !== subscription\n                );\n                release(this);\n            },\n            handler,\n        };\n        this._subscriptions.push(subscription);\n        handler(...args);\n        return () => subscription.onUnsubscribe();\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    __alive() {\n        addVertex(this);\n        this._dependencies.clear();\n    }\n\n    __dead() {\n        this._result = undefined;\n\n        for (const dependency of this._dependencies) {\n            if (isProcessable(dependency)) {\n                removeEdge(dependency, this);\n            }\n            release(dependency);\n        }\n        this._dependencies.clear();\n        removeVertex(this);\n    }\n\n    __recalculate(vertexGroup: Set<Processable>): Processable[] {\n        const { propagate, result } = this.ensureResult();\n        DEBUG &&\n            log.debug(\n                `Recalculated ${this.__debugName} (propagate=${propagate}) {result=${JSON.stringify(result)}}`\n            );\n        this.notifySubscriptions(result);\n        // Since each vertex is responsible for its own propagation, we need to\n        // take downstream dependencies that are _not_ part of the\n        // vertexGroup.\n        // The vertexGroup can be greater than one if an entire cycle is being\n        // recalculated. This is how we can avoid having a cycle propagate to\n        // itself.\n        const toPropagate: Processable[] = [];\n        if (propagate) {\n            for (const dependency of getForwardDependencies(this)) {\n                toPropagate.push(dependency);\n            }\n        }\n        return toPropagate;\n    }\n\n    __invalidate(): void {\n        if (this._result?.ok) {\n            this._result = { ...this._result, stale: true };\n        } else {\n            this._result = undefined;\n        }\n    }\n\n    __cycle(): Processable[] {\n        const error = new MarkedCycleError(\n            'Cycle error: calculation cycle reached itself'\n        );\n        if (this._errorHandler) {\n            try {\n                this._result = {\n                    ok: true,\n                    stale: false,\n                    value: this._errorHandler(error),\n                };\n            } catch (e) {\n                this._result = { ok: false, error: wrapError(e) };\n            }\n        } else {\n            this._result = {\n                ok: false,\n                error,\n            };\n        }\n        this.notifySubscriptions(this._result);\n        return [...getForwardDependencies(this)];\n    }\n\n    private notifySubscriptions(result: CalculationResult<T>) {\n        for (const subscription of this._subscriptions) {\n            if (result.ok) {\n                subscription.handler(undefined, result.value);\n            } else {\n                subscription.handler(result.error, undefined);\n            }\n        }\n    }\n\n    map<V>(fn: (val: T) => V): Calculation<V> {\n        return calc(() => fn(this.get()));\n    }\n\n    [takeCalcSubscriptionsSymbol]() {\n        const toReturn = this._subscriptions;\n        this._subscriptions = [];\n        return toReturn;\n    }\n}\n\nexport class CycleError extends Error {}\n\nclass MarkedCycleError extends CycleError {}\n\nexport class SynchronousCycleError extends CycleError {\n    declare sourceCalculation: Calculation<any>;\n    passthruCalculations: Set<Calculation<any>>;\n\n    constructor(msg: string, sourceCalculation: Calculation<any>) {\n        super(msg);\n        this.sourceCalculation = sourceCalculation;\n        this.passthruCalculations = new Set();\n    }\n}\n\nexport function calc<T>(fn: () => T, debugName?: string) {\n    return new Calculation(fn, debugName);\n}\n\nexport function takeCalcSubscriptions<T>(calc: Calculation<T>) {\n    return calc[takeCalcSubscriptionsSymbol]();\n}\n", "import type { Dyn, Dynamic } from '../common/dyn';\nimport type { RefObjectOrCallback } from './ref';\nimport type {\n    ClassComponentInterface,\n    Component,\n} from './rendernode/componentrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\n\nexport interface JSXRenderable {\n    __renderNode<T>(\n        this: T,\n        renderJsxNode: (jsxNode: JSXNode) => RenderNode\n    ): RenderNode;\n}\n\nexport function isCustomJSXNode(node: JSXNode): node is JSXRenderable {\n    return !!(\n        node &&\n        typeof node === 'object' &&\n        '__renderNode' in node &&\n        typeof node.__renderNode === 'function'\n    );\n}\n\n/**\n * The core type that can be used as a child or root of a JSX expression\n */\nexport type JSXNode =\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    | bigint\n    | symbol\n    | Function\n    | Node\n    | RenderNode\n    | JSXNodeArray\n    | Dynamic<JSXNode>\n    | Promise<JSXNode>\n    | JSXRenderable;\n\n// The following interfaces are to allow for a recursive type alias: JSXNode\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSXNodeArray extends Array<JSXNode> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface CustomElements {}\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        /**\n         * The core type produced by a JSX expression\n         */\n        type Element = RenderNode;\n\n        /**\n         * The element type\n         */\n        type ElementType =\n            | Component<any>\n            | Promise<RenderNode>\n            | keyof KnownElements\n            | keyof CustomElements\n            | string;\n\n        /**\n         * The core type allowable as a child node in a JSX expression\n         *\n         * Note: this is not used by TypeScript internally and exported for convenience so you may type a component like:\n         *\n         *   const TakesExactlyOneChild: Component<{ children: JSX.Node }> = ({ children }) => (<div>{children}</div>);\n         *\n         */\n        type Node = JSXNode;\n\n        /**\n         * The mapping of element name to intrinsic element path\n         */\n        type IntrinsicElements = KnownElements &\n            CustomElements &\n            Record<string, any>;\n\n        /**\n         * The object property of children\n         */\n        interface ElementChildrenAttribute {\n            children: {};\n        }\n\n        /**\n         * The class property of props\n         */\n        interface ElementAttributesProperty {\n            props: {};\n        }\n\n        /**\n         * The class component interface\n         */\n        type ElementClass = ClassComponentInterface;\n    }\n}\n\nfunction attrBooleanToEmptyString(\n    val: boolean | undefined\n): string | undefined {\n    if (!val) return undefined;\n    return '';\n}\n\nfunction attrStringOrNumberToNumber(\n    val: string | number | undefined\n): number | undefined {\n    if (val === undefined) return undefined;\n    return typeof val === 'number' ? val : parseInt(val);\n}\n\nfunction attrYesNo(val: '' | 'yes' | 'no' | undefined): boolean | undefined {\n    if (val === undefined) return undefined;\n    return val === 'no' ? false : true;\n}\n\n// All attributes (except for value) share similar behavior. This map holds:\n// - Mapping of html attribute name to idl property name\n// - Formatter of jsx property value to idl property value\n// - A flag to omit setting an html attribute (only used for indeterminate)\nconst attrBehavior: Record<\n    string,\n    {\n        // idl name\n        idn?: string | null;\n        // idl value formatter\n        idv?: (jsxAttr: any) => any;\n        // no attribute (do not call setAttribute)\n        noa?: true;\n    }\n> = {\n    'accept-charset': { idn: 'acceptCharset' },\n    'aria-atomic': { idn: 'ariaAtomic' },\n    'aria-autocomplete': { idn: 'ariaAutoComplete' },\n    'aria-busy': { idn: 'ariaBusy' },\n    'aria-checked': { idn: 'ariaChecked' },\n    'aria-colcount': { idn: 'ariaColCount' },\n    'aria-colindex': { idn: 'ariaColIndex' },\n    'aria-colindextext': { idn: 'ariaColIndexText' },\n    'aria-colspan': { idn: 'ariaColSpan' },\n    'aria-current': { idn: 'ariaCurrent' },\n    'aria-disabled': { idn: 'ariaDisabled' },\n    'aria-expanded': { idn: 'ariaExpanded' },\n    'aria-haspopup': { idn: 'ariaHasPopup' },\n    'aria-hidden': { idn: 'ariaHidden' },\n    'aria-invalid': { idn: 'ariaInvalid' },\n    'aria-keyshortcuts': { idn: 'ariaKeyShortcuts' },\n    'aria-label': { idn: 'ariaLabel' },\n    'aria-level': { idn: 'ariaLevel' },\n    'aria-live': { idn: 'ariaLive' },\n    'aria-modal': { idn: 'ariaModal' },\n    'aria-multiline': { idn: 'ariaMultiLine' },\n    'aria-multiselectable': { idn: 'ariaMultiSelectable' },\n    'aria-orientation': { idn: 'ariaOrientation' },\n    'aria-placeholder': { idn: 'ariaPlaceholder' },\n    'aria-posinset': { idn: 'ariaPosInSet' },\n    'aria-pressed': { idn: 'ariaPressed' },\n    'aria-readonly': { idn: 'ariaReadOnly' },\n    'aria-required': { idn: 'ariaRequired' },\n    'aria-roledescription': { idn: 'ariaRoleDescription' },\n    'aria-rowcount': { idn: 'ariaRowCount' },\n    'aria-rowindex': { idn: 'ariaRowIndex' },\n    'aria-rowindextext': { idn: 'ariaRowIndexText' },\n    'aria-rowspan': { idn: 'ariaRowSpan' },\n    'aria-selected': { idn: 'ariaSelected' },\n    'aria-setsize': { idn: 'ariaSetSize' },\n    'aria-sort': { idn: 'ariaSort' },\n    'aria-valuemax': { idn: 'ariaValueMax' },\n    'aria-valuemin': { idn: 'ariaValueMin' },\n    'aria-valuenow': { idn: 'ariaValueNow' },\n    'aria-valuetext': { idn: 'ariaValueText' },\n    'http-equiv': { idn: 'httpEquiv' },\n    abbr: {},\n    accept: {},\n    accesskey: { idn: 'accessKey' },\n    action: {},\n    allow: {},\n    allowfullscreen: { idn: 'allowFullscreen' },\n    alt: {},\n    as: {},\n    async: {},\n    autocapitalize: {},\n    autocomplete: {},\n    autofocus: {},\n    autoplay: { idn: null, idv: attrBooleanToEmptyString },\n    charset: { idn: null },\n    checked: {},\n    cite: {},\n    class: { idn: 'className' },\n    color: { idn: null },\n    cols: { idv: attrStringOrNumberToNumber },\n    colspan: { idn: 'colSpan', idv: attrStringOrNumberToNumber },\n    content: {},\n    contenteditable: { idn: 'contentEditable' },\n    controls: {},\n    coords: {},\n    crossorigin: { idn: 'crossOrigin' },\n    data: {},\n    datetime: { idn: 'dateTime' },\n    decoding: {},\n    default: {},\n    defer: {},\n    dir: {},\n    dirname: { idn: 'dirName' },\n    disabled: {},\n    download: {},\n    draggable: {},\n    enctype: {},\n    enterkeyhint: { idn: 'enterKeyHint' },\n    for: { idn: 'htmlFor' },\n    form: { idn: null },\n    formaction: { idn: 'formAction' },\n    formenctype: { idn: 'formEnctype' },\n    formmethod: { idn: 'formMethod' },\n    formnovalidate: { idn: 'formNoValidate' },\n    formtarget: { idn: 'formTarget' },\n    headers: {},\n    height: { idv: attrStringOrNumberToNumber },\n    hidden: {},\n    high: { idv: attrStringOrNumberToNumber },\n    href: {},\n    hreflang: {},\n    id: {},\n    imagesizes: { idn: 'imageSizes' },\n    imagesrcset: { idn: 'imageSrcset' },\n    indeterminate: { noa: true },\n    inputmode: { idn: 'inputMode' },\n    integrity: {},\n    is: { idn: null },\n    ismap: { idn: 'isMap' },\n    itemid: { idn: null },\n    itemprop: { idn: null },\n    itemref: { idn: null },\n    itemscope: { idn: null },\n    itemtype: { idn: null },\n    kind: {},\n    label: {},\n    lang: {},\n    list: {},\n    loading: {},\n    loop: { idv: attrBooleanToEmptyString },\n    low: { idv: attrStringOrNumberToNumber },\n    max: { idv: attrStringOrNumberToNumber },\n    maxlength: {\n        idn: 'maxLength',\n        idv: attrStringOrNumberToNumber,\n    },\n    media: {},\n    method: {},\n    min: { idv: attrStringOrNumberToNumber },\n    minlength: {\n        idn: 'minLength',\n        idv: attrStringOrNumberToNumber,\n    },\n    multiple: {},\n    muted: { idn: null, idv: attrBooleanToEmptyString },\n    name: {},\n    nomodule: { idn: 'noModule' },\n    nonce: {},\n    novalidate: { idn: 'noValidate' },\n    open: {},\n    optimum: { idv: attrStringOrNumberToNumber },\n    pattern: {},\n    ping: {},\n    placeholder: {},\n    playsinline: { idn: 'playsInline' },\n    popover: {\n        idv: (val) => {\n            if (val === true) return 'auto';\n            if (val === false) return undefined;\n            return val;\n        },\n    },\n    poster: {},\n    preload: {},\n    readonly: { idn: 'readOnly' },\n    referrerpolicy: { idn: 'referrerPolicy' },\n    rel: {},\n    required: {},\n    reversed: {},\n    role: {},\n    rows: { idv: attrStringOrNumberToNumber },\n    rowspan: { idn: 'rowSpan', idv: attrStringOrNumberToNumber },\n    sandbox: {},\n    scope: {},\n    selected: {},\n    shape: {},\n    size: { idv: attrStringOrNumberToNumber },\n    sizes: {},\n    slot: {},\n    span: { idv: attrStringOrNumberToNumber },\n    spellcheck: {},\n    src: {},\n    srcdoc: {},\n    srclang: {},\n    srcset: {},\n    start: { idv: attrStringOrNumberToNumber },\n    step: { idv: attrStringOrNumberToNumber },\n    style: {},\n    tabindex: { idn: 'tabIndex', idv: attrStringOrNumberToNumber },\n    target: {},\n    title: {},\n    translate: { idv: attrYesNo },\n    type: {},\n    usemap: { idn: 'useMap' },\n    // value: {}, // NOTE: value is special and depends on the element\n    width: { idv: attrStringOrNumberToNumber },\n    wrap: {},\n};\n\nexport function setAttribute(\n    element: Element,\n    attributeName: string,\n    val: unknown\n) {\n    if (val === undefined || val === null || val === false) {\n        element.removeAttribute(attributeName);\n    } else if (val === true) {\n        element.setAttribute(attributeName, '');\n    } else if (typeof val === 'string') {\n        element.setAttribute(attributeName, val);\n    } else if (typeof val === 'number' || typeof val === 'bigint') {\n        element.setAttribute(attributeName, val.toString());\n    }\n}\n\nexport function assignProp(element: Element, attribute: string, value: any) {\n    // Note: SVG elements (and probably other kinds) do not have the same\n    // shared IDL behaviors. For example, it's an error to set the .width\n    // property of an SVGSVGElement\n    if (!(element instanceof HTMLElement)) {\n        setAttribute(element, attribute, value);\n        return;\n    }\n    if (attribute === 'value') {\n        // Note: value is special and treated differently, depending on the element\n        switch (element.tagName) {\n            case 'PROGRESS':\n            case 'METER':\n                // Passthru attribue\n                // Numeric idl value\n                setAttribute(element, attribute, value);\n                (element as any).value = attrStringOrNumberToNumber(value);\n                break;\n\n            case 'SELECT':\n                // No attribue\n                // Passthru idl value; provided for convenience as writing to select.value assigns the corresponding option as the selected value\n                (element as any).value = value;\n                break;\n\n            case 'BUTTON':\n            case 'DATA':\n            case 'INPUT':\n            case 'LI':\n            case 'OPTION':\n            case 'PARAM':\n            case 'TEXTAREA':\n                // Passthru attribute\n                // Passthru idl\n                setAttribute(element, attribute, value);\n                (element as any).value = value;\n                break;\n            default:\n                // Passthru attribute\n                setAttribute(element, attribute, value);\n        }\n        return;\n    }\n    const behavior = attrBehavior[attribute];\n    if (behavior) {\n        if (!behavior.noa) {\n            const attributeValue = value;\n            setAttribute(element, attribute, attributeValue);\n        }\n        if (behavior.idn !== null) {\n            const idlValue = behavior.idv ? behavior.idv(value) : value;\n            (element as any)[behavior.idn ?? attribute] = idlValue;\n        }\n        return;\n    }\n    setAttribute(element, attribute, value);\n}\n\n/*\n * Interfaces adopted from HTML Living Standard Last Updated 30 November 2021: https://html.spec.whatwg.org/\n */\n\n// Note: abstract roles are **not** in this list, as \"Authors MUST NOT use abstract roles in content\"\ntype AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'associationlist'\n    | 'associationlistitemkey'\n    | 'associationlistitemvalue'\n    | 'banner'\n    | 'blockquote'\n    | 'button'\n    | 'caption'\n    | 'cell'\n    | 'checkbox'\n    | 'code'\n    | 'columnheader'\n    | 'combobox'\n    | 'comment'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'deletion'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'emphasis'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'generic'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'insertion'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'mark'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'meter'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'paragraph'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'strong'\n    | 'subscript'\n    | 'suggestion'\n    | 'superscript'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'time'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | string;\n\ntype DirValue = 'ltr' | 'rtl' | 'auto' | string;\n\ntype BrowsingContextValue = '_blank' | '_self' | '_parent' | '_top' | string;\n\ntype ReferrerPolicyValue =\n    | ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'same-origin'\n    | 'origin'\n    | 'strict-origin'\n    | 'origin-when-cross-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url'\n    | string;\n\ntype CrossOriginValue = 'anonymous' | '' | 'use-credentials';\n\ntype LazyLoadingValue = 'lazy' | 'eager' | string;\n\ntype ImageDecodingHintValue = 'sync' | 'async' | 'auto' | string;\n\ntype SandboxValue =\n    | 'allow-forms'\n    | 'allow-modals'\n    | 'allow-orientation-lock'\n    | 'allow-pointer-lock'\n    | 'allow-popups'\n    | 'allow-popups-to-escape-sandbox'\n    | 'allow-presentation'\n    | 'allow-same-origin'\n    | 'allow-scripts'\n    | 'allow-top-navigation'\n    | 'allow-top-navigation-by-user-activation'\n    | 'allow-downloads'\n    | string;\n\ntype EncTypeValue =\n    | 'application/x-www-form-urlencoded'\n    | 'multipart/form-data'\n    | 'text/plain'\n    | string;\n\ntype FormMethodValue = 'get' | 'post' | 'dialog' | string;\n\ntype AutocompleteValue = 'on' | 'off' | string;\n\ninterface JSXElementInterface {\n    /** a guide for creating a keyboard shortcut that activates or focuses the element */\n    accesskey?: string | undefined;\n    'aria-atomic'?: string | undefined; //  ariaAtomic\n    'aria-autocomplete'?: string | undefined; //  ariaAutoComplete\n    'aria-busy'?: string | undefined; //  ariaBusy\n    'aria-checked'?: string | undefined; //  ariaChecked\n    'aria-colcount'?: string | undefined; //  ariaColCount\n    'aria-colindex'?: string | undefined; //  ariaColIndex\n    'aria-colindextext'?: string | undefined; //  ariaColIndexText\n    'aria-colspan'?: string | undefined; //  ariaColSpan\n    'aria-current'?: string | undefined; //  ariaCurrent\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description'?: string | undefined; //  ariaDescription\n    */\n    'aria-disabled'?: string | undefined; //  ariaDisabled\n    'aria-expanded'?: string | undefined; //  ariaExpanded\n    'aria-haspopup'?: string | undefined; //  ariaHasPopup\n    'aria-hidden'?: string | undefined; //  ariaHidden\n    'aria-invalid'?: string | undefined; //  ariaInvalid\n    'aria-keyshortcuts'?: string | undefined; //  ariaKeyShortcuts\n    'aria-label'?: string | undefined; //  ariaLabel\n    'aria-level'?: string | undefined; //  ariaLevel\n    'aria-live'?: string | undefined; //  ariaLive\n    'aria-modal'?: string | undefined; //  ariaModal\n    'aria-multiline'?: string | undefined; //  ariaMultiLine\n    'aria-multiselectable'?: string | undefined; //  ariaMultiSelectable\n    'aria-orientation'?: string | undefined; //  ariaOrientation\n    'aria-placeholder'?: string | undefined; //  ariaPlaceholder\n    'aria-posinset'?: string | undefined; //  ariaPosInSet\n    'aria-pressed'?: string | undefined; //  ariaPressed\n    'aria-readonly'?: string | undefined; //  ariaReadOnly\n    'aria-required'?: string | undefined; //  ariaRequired\n    'aria-roledescription'?: string | undefined; //  ariaRoleDescription\n    'aria-rowcount'?: string | undefined; //  ariaRowCount\n    'aria-rowindex'?: string | undefined; //  ariaRowIndex\n    'aria-rowindextext'?: string | undefined; //  ariaRowIndexText\n    'aria-rowspan'?: string | undefined; //  ariaRowSpan\n    'aria-selected'?: string | undefined; //  ariaSelected\n    'aria-setsize'?: string | undefined; //  ariaSetSize\n    'aria-sort'?: string | undefined; //  ariaSort\n    'aria-valuemax'?: string | undefined; //  ariaValueMax\n    'aria-valuemin'?: string | undefined; //  ariaValueMin\n    'aria-valuenow'?: string | undefined; //  ariaValueNow\n    'aria-valuetext'?: string | undefined; //  ariaValueText\n    /** autocapitalization hint */\n    autocapitalize?:\n        | 'off'\n        | 'none'\n        | 'on'\n        | 'sentences'\n        | 'words'\n        | 'characters'\n        | string\n        | undefined;\n    /** focus as soon as the page is loaded or as soon as the dialog within which it finds itself is shown */\n    autofocus?: boolean | undefined;\n    /** the various classes that the element belongs to */\n    class?: string | undefined;\n    /** indicates if the element is editable */\n    contenteditable?: '' | 'true' | 'false' | string | undefined;\n    /** specifies the element's text directionality */\n    dir?: DirValue | undefined;\n    /** specifies the element's drag behavior */\n    draggable?: boolean | undefined;\n    /** specifies what action label (or icon) to present for the enter key on virtual keyboards */\n    enterkeyhint?:\n        | 'enter'\n        | 'done'\n        | 'go'\n        | 'next'\n        | 'previous'\n        | 'search'\n        | 'send'\n        | string\n        | undefined;\n    /** indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user */\n    hidden?: boolean | undefined;\n    /** the unique id of the element */\n    id?: string | undefined;\n    inputmode?:\n        | 'none'\n        | 'text'\n        | 'tel'\n        | 'url'\n        | 'email'\n        | 'numeric'\n        | 'decimal'\n        | 'search'\n        | string\n        | undefined;\n    is?: string | undefined;\n    itemid?: string | undefined;\n    itemprop?: string | undefined;\n    itemref?: string | undefined;\n    itemscope?: boolean | undefined;\n    itemtype?: string | undefined;\n    lang?: string | undefined;\n    nonce?: string | undefined;\n    // Convenience: true => 'auto'; false => undefined\n    popover?: 'auto' | 'manual' | true | false | undefined;\n    role?: AriaRole | undefined;\n    slot?: string | undefined;\n    spellcheck?: boolean | undefined;\n    style?: string | undefined;\n    tabindex?: -1 | 0 | '-1' | '0' | string | number | undefined; // \"-1\" and \"0\" used as convenience\n    title?: string | undefined;\n    translate?: '' | 'yes' | 'no' | undefined;\n}\n\ninterface JSXAnchorElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** Browsing context for hyperlink navigation */\n    target?: BrowsingContextValue | undefined;\n    /** Whether to download the resource instead of navigating to it, and its filename if so */\n    download?: string | undefined;\n    /** URLs to ping */\n    ping?: string | undefined;\n    /** Relationship between the location in the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXAreaElementInterface extends JSXElementInterface {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    shape?:\n        | 'circle'\n        | 'circ'\n        | 'default'\n        | 'poly'\n        | 'polygon'\n        | 'rect'\n        | 'rectangle'\n        | string\n        | undefined;\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n    download?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXMediaElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Hints how much buffering the media resource will likely need */\n    preload?: 'none' | 'metadata' | 'auto' | undefined;\n    /** Hint that the media resource can be started automatically when the page is loaded */\n    autoplay?: boolean | undefined;\n    /** Whether to loop the media resource */\n    loop?: boolean | undefined;\n    /** Whether to mute the media resource by default */\n    muted?: boolean | undefined;\n    /** Show user agent controls */\n    controls?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXAudioElementInterface extends JSXMediaElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBRElementInterface extends JSXElementInterface {}\n\ninterface JSXBaseElementInterface extends JSXElementInterface {\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBodyElementInterface extends JSXElementInterface {}\n\ninterface JSXButtonElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formaction?: string | undefined;\n    formenctype?: EncTypeValue | undefined;\n    formmethod?: FormMethodValue | undefined;\n    formnovalidate?: boolean | undefined;\n    formtarget?: BrowsingContextValue | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | string | undefined;\n    value?: string | undefined;\n}\n\ninterface JSXCanvasElementInterface extends JSXElementInterface {\n    width?: string | number | undefined;\n    height?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDListElementInterface extends JSXElementInterface {}\n\ninterface JSXDataElementInterface extends JSXElementInterface {\n    value?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDataListElementInterface extends JSXElementInterface {}\n\ninterface JSXDetailsElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\ninterface JSXDialogElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDivElementInterface extends JSXElementInterface {}\n\ninterface JSXEmbedElementInterface extends JSXElementInterface {\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: string | number | undefined;\n    height?: string | number | undefined;\n}\n\ninterface JSXFieldSetElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\ninterface JSXFormElementInterface extends JSXElementInterface {\n    'accept-charset'?: 'UTF-8' | string | undefined;\n    action?: string | undefined;\n    autocomplete?: AutocompleteValue | undefined;\n    enctype?: EncTypeValue | undefined;\n    method?: FormMethodValue | undefined;\n    name?: string | undefined;\n    novalidate?: boolean | undefined;\n    target?: BrowsingContextValue | undefined;\n    rel?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadingElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHRElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHtmlElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXIFrameElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** A document to render in the iframe */\n    srcdoc?: string | undefined;\n    /** Name of nested browsing context */\n    name?: string | undefined;\n    /** Security rules for nested content */\n    sandbox?: SandboxValue | undefined; // TODO: This _could_ be a SandboxValue[], but feels awkward\n    /** Permissions policy to be applied to the iframe's contents */\n    allow?: string | undefined;\n    /** Whether to allow the iframe's contents to use requestFullscreen() */\n    allowfullscreen?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\ninterface JSXImageElementInterface extends JSXElementInterface {\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Name of image map to use */\n    usemap?: string | undefined;\n    /** Whether the image is a server-side image map */\n    ismap?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Decoding hint to use when processing this image for presentation */\n    decoding?: ImageDecodingHintValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\ntype FormInputTypeValues =\n    | 'button'\n    | 'checkbox'\n    | 'color'\n    | 'date'\n    | 'datetime-local'\n    | 'email'\n    | 'file'\n    | 'hidden'\n    | 'image'\n    | 'month'\n    | 'number'\n    | 'password'\n    | 'radio'\n    | 'range'\n    | 'reset'\n    | 'search'\n    | 'submit'\n    | 'tel'\n    | 'text'\n    | 'time'\n    | 'url'\n    | 'week'\n    | string;\n\ninterface JSXInputElementInterface extends JSXElementInterface {\n    /** Hint for expected file type in file upload controls */\n    accept?: string | undefined;\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the control is checked */\n    checked?: boolean | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: string | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** URL to use for form submission */\n    formaction?: string | undefined;\n    /** Entry list encoding type to use for form submission */\n    formenctype?: EncTypeValue | undefined;\n    /** Variant to use for form submission */\n    formmethod?: FormMethodValue | undefined;\n    /** Bypass form control validation for form submission */\n    formnovalidate?: boolean | undefined;\n    /** Browsing context for form submission */\n    formtarget?: BrowsingContextValue | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Third, indeterminate state for checkboxes */\n    indeterminate?: boolean | undefined;\n    /** List of autocomplete options */\n    list?: string | undefined;\n    /** Maximum value */\n    max?: string | number | undefined;\n    /** Maximum length of value */\n    maxlength?: string | number | undefined;\n    /** Minimum value */\n    min?: string | number | undefined;\n    /** Minimum length of value */\n    minlength?: string | number | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Pattern to be matched by the form control's value */\n    pattern?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: string | number | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Granularity to be matched by the form control's value */\n    step?: string | number | undefined;\n    /** Type of form control */\n    type?: FormInputTypeValues | undefined;\n    /** Value of the form control */\n    value?: string | number | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n}\n\ninterface JSXModElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n    /** Date and (optionally) time of the change */\n    datetime?: string | undefined;\n}\n\ninterface JSXLabelElementInterface extends JSXElementInterface {\n    /** Associate the label with form control */\n    for?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLegendElementInterface extends JSXElementInterface {}\n\ninterface JSXLIElementInterface extends JSXElementInterface {\n    /** Ordinal value of the list item */\n    value?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLinkElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Relationship between the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Sizes of the icons (for rel=\"icon\") */\n    sizes?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel=\"preload\") */\n    imagesrcset?: string | undefined;\n    /** Image sizes for different page layouts (for rel=\"preload\") */\n    imagesizes?: string | undefined;\n    /** Potential destination for a preload request (for rel=\"preload\" and rel=\"modulepreload\") */\n    as?: string | undefined;\n    /** Color to use when customizing a site's icon (for rel=\"mask-icon\") */\n    color?: string | undefined;\n    /** Whether the link is disabled */\n    disabled?: boolean | undefined;\n}\n\ninterface JSXMapElementInterface extends JSXElementInterface {\n    /** Name of image map to reference from the usemap attribute */\n    name?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXMenuElementInterface extends JSXElementInterface {}\n\ninterface JSXMetaElementInterface extends JSXElementInterface {\n    /** Metadata name */\n    name?:\n        | 'application-name'\n        | 'author'\n        | 'description'\n        | 'generator'\n        | 'keywords'\n        | 'referrer'\n        | 'theme-color'\n        | 'color-scheme'\n        | string\n        | undefined;\n    /** Pragma directive */\n    'http-equiv'?: string | undefined;\n    /** Value of the element */\n    content?: string | undefined;\n    /** Character encoding declaration */\n    charset?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** OpenGraph Property */\n    property?: string | undefined;\n}\n\ninterface JSXMeterElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: string | number | undefined;\n    /** Lower bound of range */\n    min?: string | number | undefined;\n    /** Upper bound of range */\n    max?: string | number | undefined;\n    /** High limit of low range */\n    low?: string | number | undefined;\n    /** Low limit of high range */\n    high?: string | number | undefined;\n    /** Optimum value in gauge */\n    optimum?: string | number | undefined;\n}\n\ninterface JSXObjectElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    data?: string | undefined;\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** Name of nested browsing context */\n    name?: BrowsingContextValue | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | undefined;\n    /** Vertical dimension */\n    height?: string | undefined;\n}\n\ninterface JSXOListElementInterface extends JSXElementInterface {\n    /** Number the list backwards */\n    reversed?: boolean | undefined;\n    /** Starting value of the list */\n    start?: string | number | undefined;\n    /** Kind of list marker */\n    type?:\n        | 'decimal'\n        | 'lower-alpha'\n        | 'upper-alpha'\n        | 'lower-roman'\n        | 'upper-roman'\n        | string\n        | undefined;\n}\n\ninterface JSXOptGroupElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n}\n\ninterface JSXOptionElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Whether the option is selected by default */\n    selected?: boolean | undefined;\n    /** Value to be used for form submission */\n    value?: string | undefined;\n}\n\ninterface JSXOutputElementInterface extends JSXElementInterface {\n    /** Specifies controls from which the output was calculated */\n    for?: string | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Name of the element to use in the form.elements API. */\n    name?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXParagraphElementInterface extends JSXElementInterface {}\n\ninterface JSXParamElementInterface extends JSXElementInterface {\n    /** Name of parameter */\n    name?: string | undefined;\n    /** Value of parameter */\n    value?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPictureElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPreElementInterface extends JSXElementInterface {}\n\ninterface JSXProgressElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: string | number | undefined;\n    /** Upper bound of range */\n    max?: string | number | undefined;\n}\n\ninterface JSXQuoteElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n}\n\ninterface JSXScriptElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Type of script */\n    type?: 'application/json' | 'text/json' | 'module' | string | undefined;\n    /** Prevents execution in user agents that support module scripts */\n    nomodule?: boolean | undefined;\n    /** Execute script when available, without blocking while fetching */\n    async?: boolean | undefined;\n    /** Defer script execution */\n    defer?: boolean | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXSelectElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: string | number | undefined;\n    /** Value of the element */\n    value?: string | undefined;\n}\n\ninterface JSXSlotElementInterface extends JSXElementInterface {\n    /** Name of shadow tree slot */\n    name?: string | undefined;\n}\n\ninterface JSXSourceElementInterface extends JSXElementInterface {\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** (in video or audio) \u2014 Address of the resource */\n    src?: string | undefined;\n    /** (in picture) \u2014 Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** (in picture) \u2014 Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** (in picture) \u2014 Applicable media */\n    media?: string | undefined;\n    /** (in picture) \u2014 Horizontal dimension */\n    width?: string | number | undefined;\n    /** (in picture) \u2014 Vertical dimension */\n    height?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXSpanElementInterface extends JSXElementInterface {}\n\ninterface JSXStyleElementInterface extends JSXElementInterface {\n    /** Applicable media */\n    media?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableCaptionElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableSectionElementInterface extends JSXElementInterface {}\n\ninterface JSXTableCellElementInterface extends JSXElementInterface {\n    /** Number of columns that the cell is to span */\n    colspan?: string | number | undefined;\n    /** Number of rows that the cell is to span */\n    rowspan?: string | number | undefined;\n    /** The header cells for this cell */\n    headers?: string | undefined;\n}\n\ninterface JSXTableHeaderElementInterface extends JSXTableCellElementInterface {\n    /** Specifies which cells the header cell applies to */\n    scope?: string | undefined;\n\n    /** Alternative label to use for the header cell when referencing the cell in other contexts */\n    abbr?: string | undefined;\n}\n\ninterface JSXTableColElementInterface extends JSXElementInterface {\n    /** Number of columns spanned by the element */\n    span?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTemplateElementInterface extends JSXElementInterface {}\n\ninterface JSXTextAreaElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Maximum number of characters per line */\n    cols?: string | number | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: DirValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Maximum length of value */\n    maxlength?: string | number | undefined;\n    /** Minimum length of value */\n    minlength?: string | number | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Number of lines to show */\n    rows?: string | number | undefined;\n    /** How the value of the form control is to be wrapped for form submission */\n    wrap?: 'soft' | 'hard' | string | undefined;\n    /** The value of the textarea element */\n    value?: string | undefined;\n}\n\ninterface JSXTimeElementInterface extends JSXElementInterface {\n    /** Machine-readable value */\n    datetime?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTitleElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableRowElementInterface extends JSXElementInterface {}\n\ninterface JSXTrackElementInterface extends JSXElementInterface {\n    /** The type of text track */\n    kind?:\n        | 'subtitles'\n        | 'captions'\n        | 'descriptions'\n        | 'chapters'\n        | 'metadata'\n        | string\n        | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Language of the text track */\n    srclang?: string | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Enable the track if no other text track is more suitable */\n    default?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXUListElementInterface extends JSXElementInterface {}\n\ninterface JSXVideoElementInterface extends JSXMediaElementInterface {\n    /** Poster frame to show prior to video playback */\n    poster?: string | undefined;\n    /** Encourage the user agent to display video content within the element's playback area */\n    playsinline?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n}\n\n/**\n * Good old bivarianceHack to allow assignability of specific event handlers to more generic event handlers :facepalm:\n */\ntype EventHandler<TEvent extends Event, TElement extends Element> =\n    | undefined\n    | {\n          bivarianceHack(event: TEvent, target: TElement): void;\n      }['bivarianceHack'];\n\ninterface JSXRefProps<TElement extends Element> {\n    ref?: undefined | RefObjectOrCallback<TElement | undefined>;\n}\n\ntype DynamicPropValue<T> = Dyn<T>;\n\ninterface JSXAttrProps {\n    [key: `attr:${string}`]: DynamicPropValue<\n        string | number | boolean | undefined\n    >;\n    [key: `prop:${string}`]: DynamicPropValue<\n        string | number | boolean | undefined\n    >;\n}\n\ntype JSXEventPrefix = 'on' | 'onpassive' | 'oncapture';\ntype JSXEventTypes = {\n    // Element events\n    animationcancel: AnimationEvent;\n    animationend: AnimationEvent;\n    animationiteration: AnimationEvent;\n    animationstart: AnimationEvent;\n    auxclick: PointerEvent;\n    beforeinput: InputEvent;\n    blur: FocusEvent;\n    click: PointerEvent;\n    compositionend: CompositionEvent;\n    compositionstart: CompositionEvent;\n    compositionupdate: CompositionEvent;\n    contextmenu: PointerEvent;\n    copy: ClipboardEvent;\n    cut: ClipboardEvent;\n    dblclick: MouseEvent;\n    focus: FocusEvent;\n    focusin: FocusEvent;\n    focusout: FocusEvent;\n    fullscreenchange: Event;\n    fullscreenerror: Event;\n    gotpointercapture: PointerEvent;\n    input: InputEvent;\n    keydown: KeyboardEvent;\n    keyup: KeyboardEvent;\n    lostpointercapture: PointerEvent;\n    mousedown: MouseEvent;\n    mouseenter: MouseEvent;\n    mouseleave: MouseEvent;\n    mousemove: MouseEvent;\n    mouseout: MouseEvent;\n    mouseover: MouseEvent;\n    mouseup: MouseEvent;\n    paste: ClipboardEvent;\n    pointercancel: PointerEvent;\n    pointerdown: PointerEvent;\n    pointerenter: PointerEvent;\n    pointerleave: PointerEvent;\n    pointermove: PointerEvent;\n    pointerout: PointerEvent;\n    pointerover: PointerEvent;\n    pointerup: PointerEvent;\n    scroll: Event;\n    scrollend: Event;\n    securitypolicyviolation: SecurityPolicyViolationEvent;\n    touchcancel: TouchEvent;\n    touchend: TouchEvent;\n    touchmove: TouchEvent;\n    touchstart: TouchEvent;\n    transitioncancel: TransitionEvent;\n    transitionend: TransitionEvent;\n    transitionrun: TransitionEvent;\n    transitionstart: TransitionEvent;\n    wheel: WheelEvent;\n\n    // Specific element events\n    beforetoggle: Event; // Incorrect: should be ToggleEvent\n    change: Event;\n    close: Event;\n    drag: DragEvent;\n    dragend: DragEvent;\n    dragenter: DragEvent;\n    dragleave: DragEvent;\n    dragover: DragEvent;\n    dragstart: DragEvent;\n    drop: DragEvent;\n    error: Event;\n    load: Event;\n    toggle: Event; // Incorrect: should be ToggleEvent\n\n    // Media elements: probably should be limited to HTMLMediaElement? (most/all don't bubble)\n    abort: Event;\n    canplay: Event;\n    canplaythrough: Event;\n    durationchange: Event;\n    emptied: Event;\n    encrypted: MediaEncryptedEvent;\n    ended: Event;\n    loadeddata: Event;\n    loadedmetadata: Event;\n    loadstart: Event;\n    pause: Event;\n    play: Event;\n    playing: Event;\n    progress: Event;\n    ratechange: Event;\n    seeked: Event;\n    seeking: Event;\n    stalled: Event;\n    suspend: Event;\n    timeupdate: Event;\n    volumechange: Event;\n    waiting: Event;\n    waitingforkey: Event;\n\n    // Dialog & Input events\n    cancel: Event;\n\n    // Canvas events\n    contextlost: Event;\n    contextrestored: Event;\n    webglcontextcreationerror: WebGLContextEvent;\n    webglcontextlost: WebGLContextEvent;\n    webglcontextrestored: WebGLContextEvent;\n\n    // Form events\n    formdata: FormDataEvent;\n    reset: Event;\n    submit: SubmitEvent;\n\n    // Input events\n    invalid: Event;\n    select: Event;\n\n    // Slot events\n    slotchange: Event;\n\n    // Window events... these probably should not be here?\n    hashchange: HashChangeEvent;\n    languagechange: Event;\n    message: MessageEvent;\n    messageerror: MessageEvent;\n    offline: Event;\n    online: Event;\n    pagehide: PageTransitionEvent;\n    pageshow: PageTransitionEvent;\n    popstate: PopStateEvent;\n    rejectionhandled: PromiseRejectionEvent;\n    storage: StorageEvent;\n    unhandledrejection: PromiseRejectionEvent;\n\n    // Document events... these probably should not be here?\n    readystatechange: Event;\n    visibilitychange: Event;\n\n    // Unknown... where did these come from?\n    connect: MessageEvent;\n    open: Event;\n};\n\ntype JSXEventPropsNamed<TElement extends Element> = {\n    [TKey in `${JSXEventPrefix}:${keyof JSXEventTypes}`]?: TKey extends `${JSXEventPrefix}:${infer TValue}`\n        ? TValue extends keyof JSXEventTypes\n            ? EventHandler<JSXEventTypes[TValue], TElement>\n            : never\n        : never;\n};\n\ninterface JSXEventProps<TElement extends Element>\n    extends JSXEventPropsNamed<TElement> {\n    [key: `on:${string}`]: EventHandler<Event, TElement>;\n    [key: `onpassive:${string}`]: EventHandler<Event, TElement>;\n    [key: `oncapture:${string}`]: EventHandler<Event, TElement>;\n}\n\ninterface CSSProps {\n    [key: `style:${string}`]: DynamicPropValue<string | number | undefined>;\n    [key: `cssprop:${string}`]: DynamicPropValue<string | number | undefined>;\n}\n\ninterface JSXDataProps {\n    [key: `data-${string}`]: DynamicPropValue<\n        string | number | boolean | undefined\n    >;\n}\n\ntype JSXElementInterfaceProps<TJSXType extends JSXElementInterface> = {\n    [Key in keyof TJSXType]: Key extends 'is'\n        ? string | undefined\n        : DynamicPropValue<TJSXType[Key]>;\n};\n\ntype JSXChildrenProps<HasChildren extends boolean> = HasChildren extends true\n    ? { children?: JSX.Node | JSX.Node[] }\n    : { children?: never };\n\ntype WithCalculationsAndRef<\n    TJSXType extends JSXElementInterface,\n    TElement extends Element,\n    HasChildren extends boolean,\n> = JSXRefProps<TElement> &\n    JSXAttrProps &\n    JSXEventProps<TElement> &\n    JSXDataProps &\n    CSSProps &\n    JSXElementInterfaceProps<TJSXType> &\n    JSXChildrenProps<HasChildren>;\n\nexport interface KnownElements {\n    a: WithCalculationsAndRef<\n        JSXAnchorElementInterface,\n        HTMLAnchorElement,\n        true\n    >;\n    abbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    address: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    area: WithCalculationsAndRef<\n        JSXAreaElementInterface,\n        HTMLAreaElement,\n        false\n    >;\n    article: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    aside: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    audio: WithCalculationsAndRef<\n        JSXAudioElementInterface,\n        HTMLAudioElement,\n        true\n    >;\n    b: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    base: WithCalculationsAndRef<\n        JSXBaseElementInterface,\n        HTMLBaseElement,\n        false\n    >;\n    bdi: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    bdo: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    blockquote: WithCalculationsAndRef<\n        JSXQuoteElementInterface,\n        HTMLQuoteElement,\n        true\n    >;\n    body: WithCalculationsAndRef<\n        JSXBodyElementInterface,\n        HTMLBodyElement,\n        true\n    >;\n    br: WithCalculationsAndRef<JSXBRElementInterface, HTMLBRElement, false>;\n    button: WithCalculationsAndRef<\n        JSXButtonElementInterface,\n        HTMLButtonElement,\n        true\n    >;\n    canvas: WithCalculationsAndRef<\n        JSXCanvasElementInterface,\n        HTMLCanvasElement,\n        true\n    >;\n    caption: WithCalculationsAndRef<\n        JSXTableCaptionElementInterface,\n        HTMLTableCaptionElement,\n        true\n    >;\n    cite: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    code: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    col: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        false\n    >;\n    colgroup: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        true\n    >;\n    data: WithCalculationsAndRef<\n        JSXDataElementInterface,\n        HTMLDataElement,\n        true\n    >;\n    datalist: WithCalculationsAndRef<\n        JSXDataListElementInterface,\n        HTMLDataListElement,\n        true\n    >;\n    dd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    del: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    details: WithCalculationsAndRef<\n        JSXDetailsElementInterface,\n        HTMLDetailsElement,\n        true\n    >;\n    dfn: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    dialog: WithCalculationsAndRef<\n        JSXDialogElementInterface,\n        HTMLDialogElement,\n        true\n    >;\n    div: WithCalculationsAndRef<JSXDivElementInterface, HTMLDivElement, true>;\n    dl: WithCalculationsAndRef<\n        JSXDListElementInterface,\n        HTMLDListElement,\n        true\n    >;\n    dt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    em: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    embed: WithCalculationsAndRef<\n        JSXEmbedElementInterface,\n        HTMLEmbedElement,\n        false\n    >;\n    fieldset: WithCalculationsAndRef<\n        JSXFieldSetElementInterface,\n        HTMLFieldSetElement,\n        true\n    >;\n    figcaption: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    figure: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    footer: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    form: WithCalculationsAndRef<\n        JSXFormElementInterface,\n        HTMLFormElement,\n        true\n    >;\n    h1: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h2: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h3: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h4: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h5: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h6: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    head: WithCalculationsAndRef<\n        JSXHeadElementInterface,\n        HTMLHeadElement,\n        true\n    >;\n    header: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hgroup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hr: WithCalculationsAndRef<JSXHRElementInterface, HTMLHRElement, false>;\n    html: WithCalculationsAndRef<\n        JSXHtmlElementInterface,\n        HTMLHtmlElement,\n        true\n    >;\n    i: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    iframe: WithCalculationsAndRef<\n        JSXIFrameElementInterface,\n        HTMLIFrameElement,\n        true\n    >;\n    img: WithCalculationsAndRef<\n        JSXImageElementInterface,\n        HTMLImageElement,\n        false\n    >;\n    input: WithCalculationsAndRef<\n        JSXInputElementInterface,\n        HTMLInputElement,\n        false\n    >;\n    ins: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    kbd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    label: WithCalculationsAndRef<\n        JSXLabelElementInterface,\n        HTMLLabelElement,\n        true\n    >;\n    legend: WithCalculationsAndRef<\n        JSXLegendElementInterface,\n        HTMLLegendElement,\n        true\n    >;\n    li: WithCalculationsAndRef<JSXLIElementInterface, HTMLLIElement, true>;\n    link: WithCalculationsAndRef<\n        JSXLinkElementInterface,\n        HTMLLinkElement,\n        false\n    >;\n    main: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    map: WithCalculationsAndRef<JSXMapElementInterface, HTMLMapElement, true>;\n    mark: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    menu: WithCalculationsAndRef<\n        JSXMenuElementInterface,\n        HTMLMenuElement,\n        true\n    >;\n    meta: WithCalculationsAndRef<\n        JSXMetaElementInterface,\n        HTMLMetaElement,\n        false\n    >;\n    meter: WithCalculationsAndRef<\n        JSXMeterElementInterface,\n        HTMLMeterElement,\n        true\n    >;\n    nav: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    noscript: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    object: WithCalculationsAndRef<\n        JSXObjectElementInterface,\n        HTMLObjectElement,\n        true\n    >;\n    ol: WithCalculationsAndRef<\n        JSXOListElementInterface,\n        HTMLOListElement,\n        true\n    >;\n    optgroup: WithCalculationsAndRef<\n        JSXOptGroupElementInterface,\n        HTMLOptGroupElement,\n        true\n    >;\n    option: WithCalculationsAndRef<\n        JSXOptionElementInterface,\n        HTMLOptionElement,\n        true\n    >;\n    output: WithCalculationsAndRef<\n        JSXOutputElementInterface,\n        HTMLOutputElement,\n        true\n    >;\n    p: WithCalculationsAndRef<\n        JSXParagraphElementInterface,\n        HTMLParagraphElement,\n        true\n    >;\n    param: WithCalculationsAndRef<\n        JSXParamElementInterface,\n        HTMLParamElement,\n        false\n    >;\n    picture: WithCalculationsAndRef<\n        JSXPictureElementInterface,\n        HTMLPictureElement,\n        true\n    >;\n    pre: WithCalculationsAndRef<JSXPreElementInterface, HTMLPreElement, true>;\n    progress: WithCalculationsAndRef<\n        JSXProgressElementInterface,\n        HTMLProgressElement,\n        true\n    >;\n    q: WithCalculationsAndRef<JSXQuoteElementInterface, HTMLQuoteElement, true>;\n    rp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    rt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ruby: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    s: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    samp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    script: WithCalculationsAndRef<\n        JSXScriptElementInterface,\n        HTMLScriptElement,\n        true\n    >;\n    section: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    select: WithCalculationsAndRef<\n        JSXSelectElementInterface,\n        HTMLSelectElement,\n        true\n    >;\n    slot: WithCalculationsAndRef<\n        JSXSlotElementInterface,\n        HTMLSlotElement,\n        true\n    >;\n    small: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    source: WithCalculationsAndRef<\n        JSXSourceElementInterface,\n        HTMLSourceElement,\n        false\n    >;\n    span: WithCalculationsAndRef<\n        JSXSpanElementInterface,\n        HTMLSpanElement,\n        true\n    >;\n    strong: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    style: WithCalculationsAndRef<\n        JSXStyleElementInterface,\n        HTMLStyleElement,\n        true\n    >;\n    sub: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    summary: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    sup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    table: WithCalculationsAndRef<\n        JSXTableElementInterface,\n        HTMLTableElement,\n        true\n    >;\n    tbody: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    td: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    template: WithCalculationsAndRef<\n        JSXTemplateElementInterface,\n        HTMLTemplateElement,\n        true\n    >;\n    textarea: WithCalculationsAndRef<\n        JSXTextAreaElementInterface,\n        HTMLTextAreaElement,\n        true\n    >;\n    tfoot: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    th: WithCalculationsAndRef<\n        JSXTableHeaderElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    thead: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    time: WithCalculationsAndRef<\n        JSXTimeElementInterface,\n        HTMLTimeElement,\n        true\n    >;\n    title: WithCalculationsAndRef<\n        JSXTitleElementInterface,\n        HTMLTitleElement,\n        true\n    >;\n    tr: WithCalculationsAndRef<\n        JSXTableRowElementInterface,\n        HTMLTableRowElement,\n        true\n    >;\n    track: WithCalculationsAndRef<\n        JSXTrackElementInterface,\n        HTMLTrackElement,\n        false\n    >;\n    u: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ul: WithCalculationsAndRef<\n        JSXUListElementInterface,\n        HTMLUListElement,\n        true\n    >;\n    var: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    video: WithCalculationsAndRef<\n        JSXVideoElementInterface,\n        HTMLVideoElement,\n        true\n    >;\n    wbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, false>;\n}\n", "import type { RenderNode } from './rendernode';\nimport { emptyRenderNode, MultiChildRenderNode } from './rendernode';\n\n/**\n * Renders an array of render nodes\n */\nexport function ArrayRenderNode(\n    children: RenderNode[],\n    debugName?: string\n): RenderNode {\n    if (children.length === 0) {\n        return emptyRenderNode;\n    }\n    if (children.length === 1) {\n        return children[0];\n    }\n    return new MultiChildRenderNode({}, children, debugName);\n}\n", "import type { Dynamic, DynamicSubscriptionHandler } from '../../common/dyn';\nimport * as log from '../../common/log';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\n/**\n * Renders the result of a dynamic value\n */\nexport function DynamicRenderNode(\n    renderJSXNode: (jsxNode: JSX.Node) => RenderNode,\n    dynamic: Dynamic<any>,\n    debugName?: string\n): RenderNode {\n    let dynamicError: Error | undefined;\n    let dynamicSubscription: (() => void) | undefined;\n    let renderValue: JSX.Node | undefined;\n    let syncSubscription = false;\n\n    const subscribe: DynamicSubscriptionHandler<JSX.Node> = (error, val) => {\n        if (error) {\n            renderNode.setChild(emptyRenderNode);\n            dynamicError = error;\n            if (renderNode.isAttached()) {\n                renderNode.emitError(error);\n            } else {\n                log.warn('Unhandled error on detached DynamicRenderNode', val);\n            }\n        } else if (syncSubscription) {\n            renderNode.setChild(renderJSXNode(val));\n        } else {\n            renderNode.setChild(emptyRenderNode);\n            renderValue = val;\n            renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_EMIT);\n        }\n    };\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                if (dynamicError) {\n                    parentContext.errorEmitter(dynamicError);\n                }\n            },\n            onCommit: (phase) => {\n                if (phase === RenderNodeCommitPhase.COMMIT_EMIT) {\n                    renderNode.setChild(renderJSXNode(renderValue));\n                }\n            },\n            clone: () => {\n                return DynamicRenderNode(renderJSXNode, dynamic, debugName);\n            },\n            onAlive: () => {\n                syncSubscription = true;\n                dynamicSubscription = dynamic.subscribe(subscribe);\n                syncSubscription = false;\n            },\n            onDestroy: () => {\n                dynamicError = undefined;\n                dynamicSubscription?.();\n                dynamicSubscription = undefined;\n            },\n        },\n        emptyRenderNode,\n        debugName ? `DynamicRenderNode(${debugName})` : `DynamicRenderNode`\n    );\n    return renderNode;\n}\n", "import { ArrayEventType } from '../../common/arrayevent';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\n/**\n * Renders a foreign managed DOM node\n */\nexport function ForeignRenderNode(node: Node, debugName?: string): RenderNode {\n    return new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: 0,\n                    items: [node],\n                });\n            },\n            clone: () => {\n                return ForeignRenderNode(node, debugName);\n            },\n        },\n        emptyRenderNode,\n        debugName ?? 'foreign'\n    );\n}\n", "import { ArrayEventType } from '../../common/arrayevent';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\n/**\n * Renders a Text DOM node\n */\nexport function TextRenderNode(str: string, debugName?: string): RenderNode {\n    const textNode = document.createTextNode(str);\n    return new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: 0,\n                    items: [textNode],\n                });\n            },\n            clone: () => {\n                return TextRenderNode(str, debugName);\n            },\n        },\n        emptyRenderNode,\n        DEBUG\n            ? debugName ?? `text(${JSON.stringify(str)})`\n            : debugName ?? 'text'\n    );\n}\n", "import * as log from '../common/log';\nimport { wrapError } from '../common/util';\nimport { calc } from '../model/calc';\nimport { field } from '../model/field';\nimport { isCustomJSXNode } from './jsx';\nimport { ArrayRenderNode } from './rendernode/arrayrendernode';\nimport { DynamicRenderNode } from './rendernode/dynamicrendernode';\nimport { ForeignRenderNode } from './rendernode/foreignrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\nimport { emptyRenderNode, isRenderNode } from './rendernode/rendernode';\nimport { TextRenderNode } from './rendernode/textrendernode';\n\nexport function renderJSXNode(jsxNode: JSX.Node): RenderNode {\n    if (isRenderNode(jsxNode)) {\n        return jsxNode;\n    }\n    if (isCustomJSXNode(jsxNode)) {\n        return jsxNode.__renderNode(renderJSXNode);\n    }\n    if (jsxNode instanceof Node) {\n        return ForeignRenderNode(jsxNode);\n    }\n    if (Array.isArray(jsxNode)) {\n        return ArrayRenderNode(jsxNode.map((item) => renderJSXNode(item)));\n    }\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        typeof jsxNode === 'boolean'\n    ) {\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'function') {\n        log.warn('Rendering a function as JSX renders to nothing');\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'symbol') {\n        log.warn('Rendering a symbol as JSX renders to nothing');\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'string') {\n        return TextRenderNode(jsxNode);\n    }\n    if (typeof jsxNode === 'number' || typeof jsxNode === 'bigint') {\n        return TextRenderNode(jsxNode.toString());\n    }\n    if (\n        typeof jsxNode === 'object' &&\n        'get' in jsxNode &&\n        typeof jsxNode.get === 'function' &&\n        typeof jsxNode.subscribe === 'function'\n    ) {\n        return DynamicRenderNode(renderJSXNode, jsxNode);\n    }\n    if (\n        typeof jsxNode === 'object' &&\n        'then' in jsxNode &&\n        typeof jsxNode.then === 'function'\n    ) {\n        const promiseResult = field<\n            | { type: 'error'; error: Error }\n            | { type: 'resolved'; value: any }\n            | null\n        >(null);\n        const renderedValue = calc(() => {\n            const result = promiseResult.get();\n            if (!result) {\n                return null;\n            }\n            if (result.type === 'resolved') {\n                return result.value;\n            }\n            throw result.error;\n        });\n        jsxNode.then(\n            (val: any) => {\n                promiseResult.set({ type: 'resolved', value: val });\n            },\n            (err: any) => {\n                promiseResult.set({ type: 'error', error: wrapError(err) });\n            }\n        );\n        return DynamicRenderNode(renderJSXNode, renderedValue);\n    }\n    log.warn('Unexpected JSX node type, rendering nothing', jsxNode);\n    return emptyRenderNode;\n}\n\nexport function renderJSXChildren(\n    children?: JSX.Node | JSX.Node[]\n): RenderNode[] {\n    const childRenderNodes: RenderNode[] = [];\n    if (children) {\n        if (Array.isArray(children) && !isCustomJSXNode(children)) {\n            for (const child of children) {\n                childRenderNodes.push(renderJSXNode(child));\n            }\n        } else {\n            childRenderNodes.push(renderJSXNode(children));\n        }\n    }\n    return childRenderNodes;\n}\n", "import * as log from '../../common/log';\nimport { wrapError } from '../../common/util';\nimport type { Retainable } from '../../model/engine';\nimport {\n    registerComponentReload,\n    release,\n    retain,\n    unregisterComponentReload,\n} from '../../model/engine';\nimport {\n    classComponentToFunctionComponent,\n    isClassComponent,\n} from '../createelement';\nimport { renderJSXNode } from '../renderjsx';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\nexport interface ComponentLifecycle {\n    onMount: (callback: () => void) => (() => void) | void;\n    onUnmount: (callback: () => void) => void;\n    onDestroy: (callback: () => void) => void;\n    onError: (handler: (e: Error) => JSX.Element | null) => void;\n}\n\nexport type Component<TProps = {}> =\n    | FunctionComponent<TProps>\n    | ClassComponentConstructor<TProps>;\n\n// NOTE: UnusedSymbolForChildrenOmission is present solely for the typechecker to not allow assignment of { children?: JSXNode | JSXNode[] } to TProps if TProps is {}\n// Which allows components to flag type errors when they do not specify a `children` prop, but children are given\ndeclare const UnusedSymbolForChildrenOmission: unique symbol;\nexport type EmptyProps = { [UnusedSymbolForChildrenOmission]?: boolean };\n\nexport type FunctionComponent<TProps = {}> = (\n    props: TProps & EmptyProps,\n    lifecycle: ComponentLifecycle\n) => JSX.Element | null;\n\nexport interface ClassComponentConstructor<TProps> {\n    new (props: TProps): ClassComponent<TProps>;\n}\n\nexport interface ClassComponentInterface {\n    render?(): JSX.Element | null;\n    onMount?(): (() => void) | void;\n    onUnmount?(): void;\n    onDestroy?(): void;\n    onError?(e: Error): JSX.Element | null;\n}\n\nexport class ClassComponent<TProps = EmptyProps>\n    implements ClassComponentInterface\n{\n    declare props: TProps;\n    constructor(props: TProps) {\n        this.props = props;\n    }\n\n    render?(): JSX.Element | null;\n    onMount?(): (() => void) | void;\n    onUnmount?(): void;\n    onDestroy?(): void;\n    onError?(e: Error): JSX.Element | null;\n}\n\nexport function ComponentRenderNode<TProps>(\n    Component: Component<TProps>,\n    props: TProps | null | undefined,\n    children: JSX.Node[],\n    debugName?: string\n): RenderNode {\n    let result: undefined | Error | RenderNode;\n    let onMountCallbacks: undefined | (() => (() => void) | void)[];\n    let onUnmountCallbacks: undefined | (() => void)[];\n    let onDestroyCallbacks: undefined | (() => void)[];\n    let owned: Set<Retainable> = new Set();\n    let errorHandler: undefined | ((e: Error) => JSX.Element | null);\n    // Note: may be replaced live as a result of Hot Module Reloading\n    let ActiveComponent = isClassComponent(Component)\n        ? classComponentToFunctionComponent(Component)\n        : (Component as FunctionComponent<TProps>);\n\n    function ensureResult() {\n        if (!result) {\n            let callbacksAllowed = true;\n            const lifecycle: ComponentLifecycle = {\n                onMount: (handler: () => (() => void) | void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onMount must be called in component body'\n                    );\n                    if (!onMountCallbacks) onMountCallbacks = [];\n                    onMountCallbacks.push(handler);\n                },\n                onUnmount: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onUnmount must be called in component body'\n                    );\n                    if (!onUnmountCallbacks) onUnmountCallbacks = [];\n                    onUnmountCallbacks.push(handler);\n                },\n                onDestroy: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onDestroy must be called in component body'\n                    );\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(handler);\n                },\n                onError: (handler: (e: Error) => JSX.Element | null) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onError must be called in component body'\n                    );\n                    log.assert(!errorHandler, 'onError called multiple times');\n                    errorHandler = handler;\n                },\n            };\n\n            let componentProps: any;\n            if (children.length === 0) {\n                componentProps = props || {};\n            } else if (children.length === 1) {\n                componentProps = props\n                    ? { ...props, children: children[0] }\n                    : { children: children[0] };\n            } else {\n                componentProps = props ? { ...props, children } : { children };\n            }\n            let jsxResult: JSX.Element | Error;\n            try {\n                jsxResult =\n                    ActiveComponent(componentProps, lifecycle) ||\n                    emptyRenderNode;\n            } catch (e) {\n                const error = wrapError(e, 'Unknown error rendering component');\n                if (errorHandler) {\n                    jsxResult = errorHandler(error) ?? emptyRenderNode;\n                } else {\n                    jsxResult = error;\n                }\n            }\n            callbacksAllowed = false;\n            for (const item of owned) {\n                retain(item);\n            }\n            if (!(jsxResult instanceof Error)) {\n                result = renderJSXNode(jsxResult);\n            } else {\n                result = jsxResult;\n            }\n        }\n        return result;\n    }\n\n    const cleanup = () => {\n        if (result && !(result instanceof Error)) {\n            renderNode.disown(result);\n        }\n        if (onDestroyCallbacks) {\n            for (const callback of onDestroyCallbacks) {\n                callback();\n            }\n        }\n\n        for (const item of owned) {\n            release(item);\n        }\n\n        owned = new Set();\n        onMountCallbacks = undefined;\n        onUnmountCallbacks = undefined;\n        onDestroyCallbacks = undefined;\n        result = undefined;\n        errorHandler = undefined;\n    };\n\n    const initialize = () => {\n        const componentResult = ensureResult();\n        if (componentResult instanceof Error) {\n            log.warn('Unhandled exception on detached component', {\n                error: componentResult,\n                renderNode: renderNode,\n            });\n        } else {\n            renderNode.own(componentResult);\n        }\n        return componentResult;\n    };\n\n    const replaceComponent = (newComponent: Component<TProps>) => {\n        if (renderNode.isMounted() && onUnmountCallbacks) {\n            for (const cb of onUnmountCallbacks) {\n                cb();\n            }\n        }\n        onUnmountCallbacks = undefined;\n        renderNode.setChild(emptyRenderNode);\n        cleanup();\n        if (isClassComponent(newComponent)) {\n            ActiveComponent = classComponentToFunctionComponent(newComponent);\n        } else {\n            ActiveComponent = newComponent as FunctionComponent<TProps>;\n        }\n        const componentResult = initialize();\n        if (renderNode.isAttached()) {\n            if (componentResult instanceof Error) {\n                renderNode.emitError(componentResult);\n            } else {\n                renderNode.setChild(componentResult);\n            }\n        }\n        if (renderNode.isMounted() && onMountCallbacks) {\n            // NOTE: is this needed?\n            renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_MOUNT);\n        }\n    };\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAlive: () => {\n                initialize();\n                registerComponentReload(Component, replaceComponent);\n            },\n            onDestroy: () => {\n                unregisterComponentReload(Component, replaceComponent);\n                cleanup();\n            },\n            onAttach: (parentContext) => {\n                if (result instanceof Error) {\n                    parentContext.errorEmitter(result);\n                } else if (result) {\n                    renderNode.setChild(result);\n                }\n            },\n            onDetach: () => {\n                renderNode.setChild(emptyRenderNode);\n            },\n            onError: (error: Error) => {\n                if (errorHandler) {\n                    const handledResult = errorHandler(error);\n                    result = handledResult\n                        ? renderJSXNode(handledResult)\n                        : emptyRenderNode;\n                    renderNode.setChild(result);\n                    return true;\n                }\n            },\n            onMount: () => {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_MOUNT);\n            },\n            onUnmount: () => {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                if (onUnmountCallbacks) {\n                    for (const callback of onUnmountCallbacks) {\n                        callback();\n                    }\n                }\n            },\n            onCommit: (phase) => {\n                if (\n                    phase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n                    onMountCallbacks\n                ) {\n                    for (const callback of onMountCallbacks) {\n                        const maybeOnUnmount = callback();\n                        if (typeof maybeOnUnmount === 'function') {\n                            if (!onUnmountCallbacks) {\n                                onUnmountCallbacks = [];\n                            }\n                            const onUnmount = () => {\n                                maybeOnUnmount();\n                                if (onUnmountCallbacks) {\n                                    const index =\n                                        onUnmountCallbacks.indexOf(onUnmount);\n                                    if (index >= 0) {\n                                        onUnmountCallbacks.splice(index, 1);\n                                    }\n                                }\n                            };\n                            onUnmountCallbacks.push(onUnmount);\n                        }\n                    }\n                }\n            },\n            clone(newProps, newChildren) {\n                return ComponentRenderNode(\n                    Component,\n                    props && newProps\n                        ? { ...props, ...newProps }\n                        : ((newProps || props) as TProps),\n                    newChildren ?? children\n                );\n            },\n        },\n        emptyRenderNode,\n        debugName ?? `component(${Component.name})`\n    );\n    return renderNode;\n}\n", "import { calc } from '../model/calc';\nimport type { Calculation } from '../model/calc';\nimport { noop } from './util';\n\nexport interface DynamicNonErrorSubscriptionHandler<T> {\n    (error: undefined, val: T): void;\n}\n\nexport interface DynamicSubscriptionHandler<T> {\n    (\n        ...args: [error: Error, val: undefined] | [error: undefined, val: T]\n    ): void;\n}\n\nexport interface DynamicInternalSubscription<T> {\n    onUnsubscribe: () => void;\n    handler: DynamicSubscriptionHandler<T>;\n}\n\nexport interface Dynamic<out T> {\n    get: () => T;\n    subscribe: (fn: DynamicSubscriptionHandler<T>) => () => void;\n}\n\nexport interface DynamicMut<in out T> extends Dynamic<T> {\n    set: (val: T) => void;\n}\n\nexport type Dyn<T> = T | Dynamic<T>;\n\nexport type DynMut<T> = T | DynamicMut<T>;\n\nexport function dynGet<TVal>(wrapper: Dyn<TVal>): TVal {\n    if (isDynamic(wrapper)) {\n        return wrapper.get();\n    }\n    return wrapper;\n}\n\nexport function dynSet<TVal>(\n    wrapper: Dyn<TVal> | DynMut<TVal>,\n    value: TVal\n): boolean {\n    if (isDynamicMut(wrapper)) {\n        wrapper.set(value);\n        return true;\n    }\n    return false;\n}\n\nexport function dynSubscribe<TVal>(\n    wrapper: Dyn<TVal>,\n    callback: DynamicSubscriptionHandler<TVal>\n): () => void {\n    if (isDynamic(wrapper)) {\n        return wrapper.subscribe(callback);\n    }\n    callback(undefined, wrapper);\n    return noop;\n}\n\nexport function isDynamic<TVal>(val: Dyn<TVal>): val is Dynamic<TVal> {\n    return !!(\n        val &&\n        typeof val === 'object' &&\n        'get' in val &&\n        'subscribe' in val &&\n        typeof val.get === 'function' &&\n        typeof val.subscribe === 'function'\n    );\n}\n\nexport function isDynamicMut<TVal>(val: DynMut<TVal>): val is DynamicMut<TVal> {\n    return isDynamic(val) && 'set' in val && typeof val.set === 'function';\n}\n\nexport function dynMap<T, V>(val: Dyn<T>, fn: (val: T) => V): Calculation<V> {\n    return calc(() => fn(dynGet(val)));\n}\n\nexport function dyn<T>(val: Dyn<T>): {\n    get: () => T;\n    subscribe: (handler: DynamicSubscriptionHandler<T>) => () => void;\n    map: <V>(fn: (val: T) => V) => Calculation<V>;\n} {\n    return {\n        get: () => dynGet(val),\n        subscribe: (handler) => dynSubscribe(val, handler),\n        map: <V>(fn: (val: T) => V): Calculation<V> => dynMap<T, V>(val, fn),\n    };\n}\n", "export const getWebComponentTagConstructors = () =>\n    ({\n        a: HTMLAnchorElement,\n        abbr: HTMLElement,\n        address: HTMLElement,\n        area: HTMLAreaElement,\n        article: HTMLElement,\n        aside: HTMLElement,\n        audio: HTMLAudioElement,\n        b: HTMLElement,\n        base: HTMLBaseElement,\n        bdi: HTMLElement,\n        bdo: HTMLElement,\n        blockquote: HTMLQuoteElement,\n        body: HTMLBodyElement,\n        br: HTMLBRElement,\n        button: HTMLButtonElement,\n        canvas: HTMLCanvasElement,\n        caption: HTMLTableCaptionElement,\n        cite: HTMLElement,\n        code: HTMLElement,\n        col: HTMLTableColElement,\n        colgroup: HTMLTableColElement,\n        data: HTMLDataElement,\n        datalist: HTMLDataListElement,\n        dd: HTMLElement,\n        del: HTMLModElement,\n        details: HTMLDetailsElement,\n        dfn: HTMLElement,\n        dialog: HTMLDialogElement,\n        div: HTMLDivElement,\n        dl: HTMLDListElement,\n        dt: HTMLElement,\n        em: HTMLElement,\n        embed: HTMLEmbedElement,\n        fieldset: HTMLFieldSetElement,\n        figcaption: HTMLElement,\n        figure: HTMLElement,\n        footer: HTMLElement,\n        form: HTMLFormElement,\n        h1: HTMLHeadingElement,\n        h2: HTMLHeadingElement,\n        h3: HTMLHeadingElement,\n        h4: HTMLHeadingElement,\n        h5: HTMLHeadingElement,\n        h6: HTMLHeadingElement,\n        head: HTMLHeadElement,\n        header: HTMLElement,\n        hgroup: HTMLElement,\n        hr: HTMLHRElement,\n        html: HTMLHtmlElement,\n        i: HTMLElement,\n        iframe: HTMLIFrameElement,\n        img: HTMLImageElement,\n        input: HTMLInputElement,\n        ins: HTMLModElement,\n        kbd: HTMLElement,\n        label: HTMLLabelElement,\n        legend: HTMLLegendElement,\n        li: HTMLLIElement,\n        link: HTMLLinkElement,\n        main: HTMLElement,\n        map: HTMLMapElement,\n        mark: HTMLElement,\n        menu: HTMLMenuElement,\n        meta: HTMLMetaElement,\n        meter: HTMLMeterElement,\n        nav: HTMLElement,\n        noscript: HTMLElement,\n        object: HTMLObjectElement,\n        ol: HTMLOListElement,\n        optgroup: HTMLOptGroupElement,\n        option: HTMLOptionElement,\n        output: HTMLOutputElement,\n        p: HTMLParagraphElement,\n        picture: HTMLPictureElement,\n        pre: HTMLPreElement,\n        progress: HTMLProgressElement,\n        q: HTMLQuoteElement,\n        rp: HTMLElement,\n        rt: HTMLElement,\n        ruby: HTMLElement,\n        s: HTMLElement,\n        samp: HTMLElement,\n        script: HTMLScriptElement,\n        section: HTMLElement,\n        select: HTMLSelectElement,\n        slot: HTMLSlotElement,\n        small: HTMLElement,\n        source: HTMLSourceElement,\n        span: HTMLSpanElement,\n        strong: HTMLElement,\n        style: HTMLStyleElement,\n        sub: HTMLElement,\n        summary: HTMLElement,\n        sup: HTMLElement,\n        table: HTMLTableElement,\n        tbody: HTMLTableSectionElement,\n        td: HTMLTableCellElement,\n        template: HTMLTemplateElement,\n        textarea: HTMLTextAreaElement,\n        tfoot: HTMLTableSectionElement,\n        th: HTMLTableCellElement,\n        thead: HTMLTableSectionElement,\n        time: HTMLTimeElement,\n        title: HTMLTitleElement,\n        tr: HTMLTableRowElement,\n        track: HTMLTrackElement,\n        u: HTMLElement,\n        ul: HTMLUListElement,\n        var: HTMLElement,\n        video: HTMLVideoElement,\n        wbr: HTMLElement,\n    }) as const;\n\nexport type WebComponentShadowSupportedExtends =\n    | undefined\n    | 'article'\n    | 'aside'\n    | 'blockquote'\n    | 'body'\n    | 'div'\n    | 'footer'\n    | 'h1'\n    | 'h2'\n    | 'h3'\n    | 'h4'\n    | 'h5'\n    | 'h6'\n    | 'header'\n    | 'main'\n    | 'nav'\n    | 'p'\n    | 'section'\n    | 'span';\n\n// List per https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals\nexport type WebComponentInternalsKey =\n    | 'ariaAtomic'\n    | 'ariaAutoComplete'\n    | 'ariaBusy'\n    | 'ariaChecked'\n    | 'ariaColCount'\n    | 'ariaColIndex'\n    | 'ariaColSpan'\n    | 'ariaCurrent'\n    | 'ariaDescription'\n    | 'ariaDisabled'\n    | 'ariaExpanded'\n    | 'ariaHasPopup'\n    | 'ariaHidden'\n    | 'ariaKeyShortcuts'\n    | 'ariaLabel'\n    | 'ariaLevel'\n    | 'ariaLive'\n    | 'ariaModal'\n    | 'ariaMultiLine'\n    | 'ariaMultiSelectable'\n    | 'ariaOrientation'\n    | 'ariaPlaceholder'\n    | 'ariaPosInSet'\n    | 'ariaPressed'\n    | 'ariaReadOnly'\n    | 'ariaRequired'\n    | 'ariaRoleDescription'\n    | 'ariaRowCount'\n    | 'ariaRowIndex'\n    | 'ariaRowSpan'\n    | 'ariaSelected'\n    | 'ariaSetSize'\n    | 'ariaSort'\n    | 'ariaValueMax'\n    | 'ariaValueMin'\n    | 'ariaValueNow'\n    | 'ariaValueText'\n    | 'role'\n    // Non-standard properties\n    | 'ariaRelevant'\n    // Experimental properties\n    | 'ariaRowIndexText'\n    | 'ariaColIndexText';\n", "export const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const ELEMENT_NAMESPACE_GUESS: Record<string, string | undefined> = {\n    // SVG Elements per https://developer.mozilla.org/en-US/docs/Web/SVG/Element\n    //'a': SVG_NAMESPACE,\n    animate: SVG_NAMESPACE,\n    animateMotion: SVG_NAMESPACE,\n    animateTransform: SVG_NAMESPACE,\n    circle: SVG_NAMESPACE,\n    clipPath: SVG_NAMESPACE,\n    defs: SVG_NAMESPACE,\n    desc: SVG_NAMESPACE,\n    discard: SVG_NAMESPACE,\n    ellipse: SVG_NAMESPACE,\n    feBlend: SVG_NAMESPACE,\n    feColorMatrix: SVG_NAMESPACE,\n    feComponentTransfer: SVG_NAMESPACE,\n    feComposite: SVG_NAMESPACE,\n    feConvolveMatrix: SVG_NAMESPACE,\n    feDiffuseLighting: SVG_NAMESPACE,\n    feDisplacementMap: SVG_NAMESPACE,\n    feDistantLight: SVG_NAMESPACE,\n    feDropShadow: SVG_NAMESPACE,\n    feFlood: SVG_NAMESPACE,\n    feFuncA: SVG_NAMESPACE,\n    feFuncB: SVG_NAMESPACE,\n    feFuncG: SVG_NAMESPACE,\n    feFuncR: SVG_NAMESPACE,\n    feGaussianBlur: SVG_NAMESPACE,\n    feImage: SVG_NAMESPACE,\n    feMerge: SVG_NAMESPACE,\n    feMergeNode: SVG_NAMESPACE,\n    feMorphology: SVG_NAMESPACE,\n    feOffset: SVG_NAMESPACE,\n    fePointLight: SVG_NAMESPACE,\n    feSpecularLighting: SVG_NAMESPACE,\n    feSpotLight: SVG_NAMESPACE,\n    feTile: SVG_NAMESPACE,\n    feTurbulence: SVG_NAMESPACE,\n    filter: SVG_NAMESPACE,\n    foreignObject: SVG_NAMESPACE,\n    g: SVG_NAMESPACE,\n    hatch: SVG_NAMESPACE,\n    hatchpath: SVG_NAMESPACE,\n    image: SVG_NAMESPACE,\n    line: SVG_NAMESPACE,\n    linearGradient: SVG_NAMESPACE,\n    marker: SVG_NAMESPACE,\n    mask: SVG_NAMESPACE,\n    metadata: SVG_NAMESPACE,\n    mpath: SVG_NAMESPACE,\n    path: SVG_NAMESPACE,\n    pattern: SVG_NAMESPACE,\n    polygon: SVG_NAMESPACE,\n    polyline: SVG_NAMESPACE,\n    radialGradient: SVG_NAMESPACE,\n    rect: SVG_NAMESPACE,\n    //'script': SVG_NAMESPACE,\n    set: SVG_NAMESPACE,\n    stop: SVG_NAMESPACE,\n    //'style': SVG_NAMESPACE,\n    svg: SVG_NAMESPACE,\n    switch: SVG_NAMESPACE,\n    symbol: SVG_NAMESPACE,\n    text: SVG_NAMESPACE,\n    textPath: SVG_NAMESPACE,\n    //'title': SVG_NAMESPACE,\n    tspan: SVG_NAMESPACE,\n    use: SVG_NAMESPACE,\n    view: SVG_NAMESPACE,\n\n    // MATHML Elements per https://developer.mozilla.org/en-US/docs/Web/MathML/Element\n    math: MATHML_NAMESPACE,\n    maction: MATHML_NAMESPACE,\n    annotation: MATHML_NAMESPACE,\n    'annotation-xml': MATHML_NAMESPACE,\n    menclose: MATHML_NAMESPACE,\n    merror: MATHML_NAMESPACE,\n    mfenced: MATHML_NAMESPACE,\n    mfrac: MATHML_NAMESPACE,\n    mi: MATHML_NAMESPACE,\n    mmultiscripts: MATHML_NAMESPACE,\n    mn: MATHML_NAMESPACE,\n    none: MATHML_NAMESPACE,\n    mo: MATHML_NAMESPACE,\n    mover: MATHML_NAMESPACE,\n    mpadded: MATHML_NAMESPACE,\n    mphantom: MATHML_NAMESPACE,\n    mprescripts: MATHML_NAMESPACE,\n    mroot: MATHML_NAMESPACE,\n    mrow: MATHML_NAMESPACE,\n    ms: MATHML_NAMESPACE,\n    semantics: MATHML_NAMESPACE,\n    mspace: MATHML_NAMESPACE,\n    msqrt: MATHML_NAMESPACE,\n    mstyle: MATHML_NAMESPACE,\n    msub: MATHML_NAMESPACE,\n    msup: MATHML_NAMESPACE,\n    msubsup: MATHML_NAMESPACE,\n    mtable: MATHML_NAMESPACE,\n    mtd: MATHML_NAMESPACE,\n    mtext: MATHML_NAMESPACE,\n    mtr: MATHML_NAMESPACE,\n    munder: MATHML_NAMESPACE,\n    munderover: MATHML_NAMESPACE,\n};\n\nexport const elementNamespaceTransitionMap: Record<\n    string,\n    Record<string, { node: string; children: string } | undefined> | undefined\n> = {\n    [HTML_NAMESPACE]: {\n        svg: {\n            node: SVG_NAMESPACE,\n            children: SVG_NAMESPACE,\n        },\n        math: {\n            node: MATHML_NAMESPACE,\n            children: MATHML_NAMESPACE,\n        },\n    },\n    [SVG_NAMESPACE]: {\n        foreignObject: {\n            node: SVG_NAMESPACE,\n            children: HTML_NAMESPACE,\n        },\n    },\n} as const;\n", "/**\n * A ref object that can be passed to native elements.\n */\nexport class Ref<in out T> {\n    declare current: T;\n    constructor(current: T) {\n        this.current = current;\n    }\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val: T): Ref<T>;\nexport function ref<T>(val?: T): Ref<T | undefined>;\nexport function ref<T>(val?: T): Ref<T | undefined> {\n    return new Ref(val);\n}\n\n/**\n * A standard ref callback\n */\nexport type RefCallback<T> = (val: T | undefined) => void;\n\n/**\n * Ref types may be passed as the ref prop to intrinsic elements to obtain a\n * reference to the underlying Element\n */\nexport type RefObjectOrCallback<T> = Ref<T> | RefCallback<T>;\n", "import type { ArrayEvent } from '../../common/arrayevent';\nimport {\n    applyArrayEvent,\n    ArrayEventType,\n    mergeArrayEvents,\n} from '../../common/arrayevent';\nimport * as log from '../../common/log';\nimport type { RefObjectOrCallback } from '../ref';\nimport { Ref } from '../ref';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { SingleChildRenderNode } from './rendernode';\n\nconst moveOrInsertBeforeFunction =\n    'moveBefore' in Element.prototype\n        ? (Element.prototype\n              .moveBefore as typeof Element.prototype.insertBefore)\n        : Element.prototype.insertBefore;\n\nfunction moveOrInsertBefore(\n    element: Element | ShadowRoot,\n    node: Node,\n    target: Node | null\n) {\n    const destRoot = element.getRootNode();\n    const srcRoot = node.getRootNode();\n    if (destRoot === srcRoot) {\n        moveOrInsertBeforeFunction.call(element, node, target);\n    } else {\n        element.insertBefore(node, target);\n    }\n}\n\nexport function PortalRenderNode(\n    element: Element | ShadowRoot,\n    childrenRenderNode: RenderNode,\n    refProp:\n        | RefObjectOrCallback<Element | ShadowRoot | undefined>\n        | null\n        | undefined,\n    debugName?: string\n) {\n    let pendingEvents: ArrayEvent<Node>[] = [];\n    let committedNodes: (Node | undefined)[] = [];\n\n    function getReferenceNode(index: number): Node | null {\n        for (let i = index; i < committedNodes.length; ++i) {\n            const node = committedNodes[i];\n            if (node) {\n                return node;\n            }\n        }\n        return null;\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onEvent: (event: ArrayEvent<Node>) => {\n                pendingEvents.push(event);\n                renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_UPDATE);\n                return true;\n            },\n            onMount: () => {\n                if (refProp) {\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                }\n            },\n            onUnmount: () => {\n                if (refProp) {\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            onCommit: (phase: RenderNodeCommitPhase) => {\n                if (phase === RenderNodeCommitPhase.COMMIT_UNMOUNT && refProp) {\n                    if (refProp instanceof Ref) {\n                        refProp.current = undefined;\n                    } else if (typeof refProp === 'function') {\n                        refProp(undefined);\n                    }\n                }\n                if (phase === RenderNodeCommitPhase.COMMIT_UPDATE) {\n                    // It's possible that another RenderNode has committed first and inserted a Node which was a direct\n                    // child of this node. See the test case \"jsx relocation can occur in complex situations\"\n                    //\n                    // This will cause the inserted node to be removed from this RenderNode's element and placed as the\n                    // other RenderNode's child.\n                    //\n                    // We can detect if this stolen node has occurred if the actual sequence of children does not match\n                    // what is in our committedNodes array.\n                    //\n                    // In this case, we can assume the stolen node will be removed by this commit, and \"skip\" over it\n                    // when picking the reference node for insertions.\n                    for (\n                        let i = 0, childIndex = 0;\n                        i < committedNodes.length;\n                        ++i\n                    ) {\n                        const expectedNode = committedNodes[i];\n                        const realNode = element.childNodes[childIndex];\n                        if (expectedNode && expectedNode === realNode) {\n                            childIndex += 1;\n                        } else {\n                            // Assume the child was stolen, work around its absence\n                            committedNodes[i] = undefined;\n                        }\n                    }\n\n                    for (const event of mergeArrayEvents(pendingEvents)) {\n                        switch (event.type) {\n                            case ArrayEventType.SPLICE: {\n                                if (\n                                    event.index === 0 &&\n                                    event.count > 0 &&\n                                    event.count === committedNodes.length\n                                ) {\n                                    element.replaceChildren();\n                                    committedNodes = [];\n                                } else {\n                                    for (let i = event.count - 1; i >= 0; --i) {\n                                        const toRemove =\n                                            committedNodes[event.index + i];\n                                        if (toRemove) {\n                                            element.removeChild(toRemove);\n                                        }\n                                    }\n                                    committedNodes.splice(\n                                        event.index,\n                                        event.count\n                                    );\n                                }\n                                if (event.items) {\n                                    const referenceNode = getReferenceNode(\n                                        event.index\n                                    );\n                                    if (\n                                        event.items.length > 1 &&\n                                        event.items.every(\n                                            (node) => node.parentNode === null\n                                        )\n                                    ) {\n                                        // Performance optimization:\n                                        // If we're adding new nodes (not\n                                        // *moving* them), we can quickly batch\n                                        // add in one swoop via a document\n                                        // fragment\n                                        const fragment =\n                                            document.createDocumentFragment();\n                                        fragment.replaceChildren(\n                                            ...event.items\n                                        );\n                                        moveOrInsertBefore(\n                                            element,\n                                            fragment,\n                                            referenceNode\n                                        );\n                                    } else {\n                                        for (const node of event.items) {\n                                            moveOrInsertBefore(\n                                                element,\n                                                node,\n                                                referenceNode\n                                            );\n                                        }\n                                    }\n                                    committedNodes.splice(\n                                        event.index,\n                                        0,\n                                        ...event.items\n                                    );\n                                }\n                                break;\n                            }\n                            case ArrayEventType.SORT: {\n                                const toInsert: Node[] = [];\n                                for (let i = 0; i < event.indexes.length; ++i) {\n                                    const node =\n                                        committedNodes[event.indexes[i]];\n                                    if (node) {\n                                        toInsert.push(node);\n                                    }\n                                }\n                                const referenceNode = getReferenceNode(\n                                    event.from + event.indexes.length\n                                );\n                                for (const node of toInsert) {\n                                    moveOrInsertBefore(\n                                        element,\n                                        node,\n                                        referenceNode\n                                    );\n                                }\n                                applyArrayEvent(committedNodes, event);\n                                break;\n                            }\n                            case ArrayEventType.MOVE: {\n                                const toMove: Node[] = [];\n                                for (let i = 0; i < event.count; ++i) {\n                                    const node = committedNodes[event.from + i];\n                                    if (node) {\n                                        toMove.push(node);\n                                    }\n                                }\n                                const referenceIndex =\n                                    event.to > event.from\n                                        ? event.to + event.count\n                                        : event.to;\n                                const referenceNode =\n                                    getReferenceNode(referenceIndex);\n                                for (const node of toMove) {\n                                    moveOrInsertBefore(\n                                        element,\n                                        node,\n                                        referenceNode\n                                    );\n                                }\n                                applyArrayEvent(committedNodes, event);\n                                break;\n                            }\n                        }\n                    }\n                    pendingEvents = [];\n                }\n                if (phase === RenderNodeCommitPhase.COMMIT_MOUNT && refProp) {\n                    if (refProp instanceof Ref) {\n                        refProp.current = element;\n                    } else if (typeof refProp === 'function') {\n                        refProp(element);\n                    }\n                }\n            },\n            clone(): RenderNode {\n                log.assert(\n                    false,\n                    \"Attempted to clone a PortalRenderNode -- this operation doesn't make sense\"\n                );\n            },\n            onDestroy: () => {\n                pendingEvents = [];\n                committedNodes = [];\n            },\n        },\n        childrenRenderNode,\n        `mount(${\n            element instanceof Element\n                ? element.tagName\n                : `shadow(${element.host.tagName})`\n        })`\n    );\n    return renderNode;\n}\n", "import type { ArrayEvent } from '../../common/arrayevent';\nimport { ArrayEventType } from '../../common/arrayevent';\nimport type { Dyn } from '../../common/dyn';\nimport { dynGet, dynSubscribe, isDynamic } from '../../common/dyn';\nimport * as log from '../../common/log';\nimport { flush } from '../../model/engine';\nimport { assignProp, setAttribute } from '../jsx';\nimport { getWebComponentTagConstructors } from '../webcomponents';\nimport {\n    ELEMENT_NAMESPACE_GUESS,\n    elementNamespaceTransitionMap,\n    HTML_NAMESPACE,\n} from '../xmlnamespace';\nimport { ArrayRenderNode } from './arrayrendernode';\nimport { PortalRenderNode } from './portalrendernode';\nimport type { ParentContext, RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\nconst EventProps = [\n    { prefix: 'on:', param: false },\n    { prefix: 'oncapture:', param: true },\n    { prefix: 'onpassive:', param: { passive: true } },\n] as const;\n\n/**\n * Renders an intrinsic DOM node\n */\nexport function IntrinsicRenderNode(\n    tagName: string,\n    props: Record<string, any> | undefined,\n    childRenderNode: RenderNode,\n    debugName?: string\n): RenderNode {\n    let boundAttributes: undefined | Map<string, Dyn<unknown>>;\n    let subscriptions: undefined | Set<() => void>;\n    let element: undefined | Element;\n    let elementXmlNamespace: undefined | string;\n    let portalRenderNode: undefined | RenderNode;\n    let detachedError: undefined | Error;\n\n    function handleEvent(event: ArrayEvent<Node>) {\n        log.assert(\n            false,\n            'unexpected event in IntrinsicRenderNode from PortalRenderNode'\n        );\n    }\n\n    function handleError(error: Error) {\n        if (renderNode.isAttached()) {\n            // Pass up errors while attached\n            renderNode.emitError(error);\n        } else {\n            // We are capable of handling errors while detached\n            log.warn(\n                'Unhandled error on detached IntrinsicRenderNode',\n                debugName,\n                error\n            );\n            detachedError = error;\n            return true;\n        }\n    }\n\n    function ensureElement(\n        parentContext: ParentContext,\n        xmlNamespace: string,\n        childXmlNamespace: string\n    ) {\n        if (!element || xmlNamespace !== elementXmlNamespace) {\n            elementXmlNamespace = xmlNamespace;\n            element = createElement(xmlNamespace);\n\n            if (portalRenderNode) {\n                if (renderNode.isMounted()) {\n                    portalRenderNode.onUnmount();\n                }\n                portalRenderNode.detach();\n                renderNode.disown(portalRenderNode);\n            }\n            portalRenderNode = PortalRenderNode(\n                element,\n                childRenderNode,\n                props?.ref\n            );\n            renderNode.own(portalRenderNode);\n            portalRenderNode.attach({\n                nodeEmitter: handleEvent,\n                errorEmitter: handleError,\n                xmlNamespace: childXmlNamespace,\n            });\n            if (renderNode.isMounted()) {\n                portalRenderNode.onMount();\n            }\n        }\n        return element;\n    }\n\n    function createElement(xmlNamespace: string) {\n        let element: Element;\n        if (\n            typeof props?.is === 'string' &&\n            tagName in getWebComponentTagConstructors()\n        ) {\n            element = document.createElement(tagName, {\n                is: props.is,\n            });\n        } else {\n            element = document.createElementNS(xmlNamespace, tagName);\n        }\n        if (props) {\n            for (const [prop, val] of Object.entries(props)) {\n                if (prop === 'ref') continue; // specially handled by PortalRenderNode\n                if (prop === 'is') continue; // specially handled above\n                if (\n                    EventProps.some(({ prefix, param }) => {\n                        if (prop.startsWith(prefix)) {\n                            if (val) {\n                                element.addEventListener(\n                                    prop.slice(prefix.length),\n                                    (e) => {\n                                        val(e, element);\n                                        flush(); // TODO: this is probably not necessary, and may even lead to surprising behavior (read calc A, trigger event, read calc B -> both reads differ!). Consider not flushing after events are triggered.\n                                    },\n                                    param\n                                );\n                            }\n                            return true;\n                        }\n                        return false;\n                    })\n                ) {\n                    continue;\n                }\n                if (isDynamic(val)) {\n                    if (!boundAttributes) {\n                        boundAttributes = new Map();\n                    }\n                    boundAttributes.set(prop, val);\n                } else {\n                    setProp(element, prop, dynGet(val));\n                }\n            }\n            if (boundAttributes) {\n                if (!subscriptions) {\n                    subscriptions = new Set();\n                }\n                for (const [prop, boundAttr] of boundAttributes.entries()) {\n                    subscriptions.add(\n                        dynSubscribe(boundAttr, (error, updatedVal) => {\n                            if (error) {\n                                log.error('Unhandled error in bound prop', {\n                                    prop,\n                                    element,\n                                    error: updatedVal,\n                                });\n                            } else {\n                                setProp(element, prop, updatedVal);\n                            }\n                        })\n                    );\n                    const currentVal = dynGet(boundAttr);\n                    setProp(element, prop, currentVal);\n                }\n            }\n        }\n        return element;\n    }\n\n    function setProp(element: Element, prop: string, val: unknown) {\n        if (prop.startsWith('prop:')) {\n            const propName = prop.slice(5);\n            (element as any)[propName] = val;\n            return;\n        }\n\n        if (prop.startsWith('attr:')) {\n            const attrName = prop.slice(5);\n            setAttribute(element, attrName, val);\n            return;\n        }\n\n        if (\n            (element instanceof HTMLElement || element instanceof SVGElement) &&\n            (prop.startsWith('cssprop:') || prop.startsWith('style:'))\n        ) {\n            const attrName = prop.startsWith('cssprop:')\n                ? '--' + prop.slice(8)\n                : prop.slice(6);\n            if (val === undefined || val === null || val === false) {\n                element.style.removeProperty(attrName);\n            } else if (typeof val === 'string') {\n                element.style.setProperty(attrName, val);\n            } else if (typeof val === 'number' || typeof val === 'bigint') {\n                element.style.setProperty(attrName, val.toString());\n            }\n            return;\n        }\n\n        if (prop.startsWith('style:')) {\n            const attrName = prop.slice(6);\n            setAttribute(element, attrName, val);\n            return;\n        }\n\n        assignProp(element, prop, val);\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAttach: (parentContext) => {\n                if (detachedError) {\n                    parentContext.errorEmitter(detachedError);\n                    return;\n                }\n                const namespaceTransition =\n                    elementNamespaceTransitionMap[parentContext.xmlNamespace]?.[\n                        tagName\n                    ];\n                const xmlNamespace =\n                    namespaceTransition?.node ?? parentContext.xmlNamespace;\n                const childXmlNamespace =\n                    namespaceTransition?.children ?? parentContext.xmlNamespace;\n\n                element = ensureElement(\n                    parentContext,\n                    xmlNamespace,\n                    childXmlNamespace\n                );\n\n                parentContext.nodeEmitter({\n                    type: ArrayEventType.SPLICE,\n                    index: 0,\n                    count: 0,\n                    items: [element],\n                });\n            },\n            onDetach: () => {},\n            onMount: () => {\n                portalRenderNode?.onMount();\n            },\n            onUnmount: () => {\n                portalRenderNode?.onUnmount();\n            },\n            clone: (adjustedProps?: {}, newChildren?: RenderNode[]) => {\n                return IntrinsicRenderNode(\n                    tagName,\n                    adjustedProps ? { ...props, ...adjustedProps } : props,\n                    newChildren\n                        ? ArrayRenderNode(newChildren ?? [])\n                        : childRenderNode.clone()\n                );\n            },\n            onAlive: () => {\n                const xmlNamespaceGuess =\n                    ELEMENT_NAMESPACE_GUESS[tagName] ?? HTML_NAMESPACE;\n                const childXmlNamespaceGuess =\n                    elementNamespaceTransitionMap[xmlNamespaceGuess]?.[tagName]\n                        ?.children ?? xmlNamespaceGuess;\n                element = ensureElement(\n                    {\n                        nodeEmitter: (nodeEvent) => {\n                            log.fail(\n                                'IntrinsicRenderNode got unexpected node event',\n                                nodeEvent\n                            );\n                        },\n                        errorEmitter: (err) => {\n                            log.fail(\n                                'IntrinsicRenderNode got unexpected error event',\n                                err\n                            );\n                        },\n                        xmlNamespace: xmlNamespaceGuess,\n                    },\n                    xmlNamespaceGuess,\n                    childXmlNamespaceGuess\n                );\n            },\n            onDestroy: () => {\n                boundAttributes = undefined;\n                if (subscriptions) {\n                    for (const unsubscribe of subscriptions) {\n                        unsubscribe();\n                    }\n                    subscriptions = undefined;\n                }\n\n                element = undefined;\n                elementXmlNamespace = undefined;\n                if (portalRenderNode) {\n                    renderNode.disown(portalRenderNode);\n                    portalRenderNode = undefined;\n                }\n\n                detachedError = undefined;\n            },\n        },\n        emptyRenderNode,\n        debugName ?? `intrinsic(${tagName})`\n    );\n    return renderNode;\n}\n", "import { renderJSXChildren } from './renderjsx';\nimport { ArrayRenderNode } from './rendernode/arrayrendernode';\nimport type {\n    Component,\n    FunctionComponent,\n} from './rendernode/componentrendernode';\nimport {\n    ClassComponent,\n    ComponentRenderNode,\n} from './rendernode/componentrendernode';\nimport { IntrinsicRenderNode } from './rendernode/intrinsicrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\n\nexport const Fragment: Component<{ children?: JSX.Node | JSX.Node[] }> = ({\n    children,\n}) => ArrayRenderNode(renderJSXChildren(children));\n\nexport interface ClassComponentConstructor<TProps> {\n    new (props: TProps): ClassComponent<TProps>;\n}\n\nexport function isClassComponent(\n    val: any\n): val is ClassComponentConstructor<unknown> {\n    return val && val.prototype instanceof ClassComponent;\n}\n\nexport function classComponentToFunctionComponent<TProps>(\n    Component: ClassComponentConstructor<TProps>\n): FunctionComponent<TProps> {\n    return (props: TProps, lifecycle) => {\n        const instance = new Component(props);\n        if (instance.onDestroy)\n            lifecycle.onDestroy(instance.onDestroy.bind(instance));\n        if (instance.onMount)\n            lifecycle.onMount(instance.onMount.bind(instance));\n        if (instance.onError)\n            lifecycle.onError(instance.onError.bind(instance));\n        if (instance.onUnmount)\n            lifecycle.onUnmount(instance.onUnmount.bind(instance));\n        if (!instance.render) return null;\n        return instance.render();\n    };\n}\n\nexport function createElement<TProps extends {} | undefined>(\n    type: string | Component<TProps>,\n    props: TProps,\n    ...children: JSX.Node[]\n): RenderNode {\n    if (typeof type === 'string') {\n        return IntrinsicRenderNode(\n            type,\n            props,\n            ArrayRenderNode(renderJSXChildren(children))\n        );\n    }\n    return ComponentRenderNode<TProps>(type, props, children);\n}\ncreateElement.Fragment = Fragment;\n", "import { renderJSXChildren } from '../viewcontroller/renderjsx';\nimport { ArrayRenderNode } from '../viewcontroller/rendernode/arrayrendernode';\nimport type { Component } from '../viewcontroller/rendernode/componentrendernode';\n\nexport const Fragment: Component<{ children?: JSX.Node | JSX.Node[] }> = ({\n    children,\n}) => ArrayRenderNode(renderJSXChildren(children));\n", "import { applyArrayEvent, ArrayEventType } from '../../common/arrayevent';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { SingleChildRenderNode } from './rendernode';\n\nexport enum IntrinsicObserverEventType {\n    MOUNT = 'mount',\n    UNMOUNT = 'unmount',\n}\n\nexport type IntrinsicObserverNodeCallback = (\n    node: Node,\n    event: IntrinsicObserverEventType\n) => void;\n\nexport type IntrinsicObserverElementCallback = (\n    element: Element,\n    event: IntrinsicObserverEventType\n) => void;\n\nexport function IntrinsicObserverRenderNode(\n    nodeCallback: IntrinsicObserverNodeCallback | undefined,\n    elementCallback: IntrinsicObserverElementCallback | undefined,\n    child: RenderNode,\n    debugName?: string\n): RenderNode {\n    const nodes: Node[] = [];\n    const pendingEvent = new Map<Node, IntrinsicObserverEventType>();\n\n    function notify(node: Node, eventType: IntrinsicObserverEventType) {\n        nodeCallback?.(node, eventType);\n        if (node instanceof Element) {\n            elementCallback?.(node, eventType);\n        }\n    }\n    const renderNode = new SingleChildRenderNode(\n        {\n            onEvent: (event) => {\n                for (const removedNode of applyArrayEvent(nodes, event)) {\n                    pendingEvent.set(\n                        removedNode,\n                        IntrinsicObserverEventType.UNMOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n                if (event.type === ArrayEventType.SPLICE && event.items) {\n                    for (const addedNode of event.items) {\n                        pendingEvent.set(\n                            addedNode,\n                            IntrinsicObserverEventType.MOUNT\n                        );\n                    }\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            clone: () => {\n                return IntrinsicObserverRenderNode(\n                    nodeCallback,\n                    elementCallback,\n                    child.clone(),\n                    debugName\n                );\n            },\n            onMount: () => {\n                for (const node of nodes) {\n                    pendingEvent.set(node, IntrinsicObserverEventType.MOUNT);\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            onUnmount: () => {\n                for (const node of nodes) {\n                    pendingEvent.set(node, IntrinsicObserverEventType.UNMOUNT);\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_MOUNT\n                    );\n                    renderNode.requestCommit(\n                        RenderNodeCommitPhase.COMMIT_UNMOUNT\n                    );\n                }\n            },\n            onCommit: (phase) => {\n                switch (phase) {\n                    case RenderNodeCommitPhase.COMMIT_UNMOUNT:\n                        for (const [node, event] of pendingEvent.entries()) {\n                            if (event === IntrinsicObserverEventType.UNMOUNT) {\n                                notify(\n                                    node,\n                                    IntrinsicObserverEventType.UNMOUNT\n                                );\n                            }\n                        }\n                        break;\n                    case RenderNodeCommitPhase.COMMIT_MOUNT:\n                        for (const [node, event] of pendingEvent.entries()) {\n                            if (event === IntrinsicObserverEventType.MOUNT) {\n                                notify(node, IntrinsicObserverEventType.MOUNT);\n                            }\n                        }\n                        pendingEvent.clear();\n                        break;\n                }\n            },\n        },\n        child,\n        debugName ?? 'IntrinsicObserverRenderNode'\n    );\n    return renderNode;\n}\n", "import { renderJSXChildren } from '../viewcontroller/renderjsx';\nimport { ArrayRenderNode } from '../viewcontroller/rendernode/arrayrendernode';\nimport type { Component } from '../viewcontroller/rendernode/componentrendernode';\nimport type {\n    IntrinsicObserverElementCallback,\n    IntrinsicObserverNodeCallback,\n} from '../viewcontroller/rendernode/intrinsicobserverrendernode';\nimport { IntrinsicObserverRenderNode } from '../viewcontroller/rendernode/intrinsicobserverrendernode';\n\nexport const IntrinsicObserver: Component<{\n    nodeCallback?: IntrinsicObserverNodeCallback;\n    elementCallback?: IntrinsicObserverElementCallback;\n    children?: JSX.Node | JSX.Node[];\n}> = ({ nodeCallback, elementCallback, children }) => {\n    return IntrinsicObserverRenderNode(\n        nodeCallback,\n        elementCallback,\n        ArrayRenderNode(renderJSXChildren(children))\n    );\n};\n", "import type { Dyn } from '../../common/dyn';\nimport { dynGet, dynSubscribe } from '../../common/dyn';\nimport * as log from '../../common/log';\nimport { wrapError } from '../../common/util';\nimport type { Retainable } from '../../model/engine';\nimport { release, retain } from '../../model/engine';\nimport type { Field } from '../../model/field';\nimport type { JSXNode } from '../jsx';\nimport { renderJSXNode } from '../renderjsx';\nimport type {\n    getWebComponentTagConstructors,\n    WebComponentInternalsKey,\n    WebComponentShadowSupportedExtends,\n} from '../webcomponents';\nimport type { ComponentLifecycle } from './componentrendernode';\nimport { RenderNodeCommitPhase } from './constants';\nimport type { RenderNode } from './rendernode';\nimport { emptyRenderNode, SingleChildRenderNode } from './rendernode';\n\nexport type WebComponentProps<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n> = TShadowMode extends undefined\n    ? { [Key in TKeys]?: Dyn<string | undefined> } & { children: JSXNode }\n    : { [Key in TKeys]?: Dyn<string | undefined> };\n\nexport interface WebComponentLifecycle extends ComponentLifecycle {\n    host: HTMLElement;\n    shadowRoot: ShadowRoot | undefined;\n    elementInternals: ElementInternals | undefined;\n    addEventListener<K extends keyof HTMLElementEventMap>(\n        type: K,\n        listener: (\n            this: HTMLElement,\n            ev: HTMLElementEventMap[K],\n            el: HTMLElement // Added for convenience\n        ) => any,\n        options?: boolean | AddEventListenerOptions\n    ): () => void;\n    addEventListener(\n        type: string,\n        listener: (\n            this: HTMLElement,\n            ev: Event,\n            el: HTMLElement // Added for convenience\n        ) => any,\n        options?: boolean | AddEventListenerOptions\n    ): void;\n    bindElementInternalsAttribute: (\n        param: WebComponentInternalsKey,\n        value: Dyn<string | null>\n    ) => () => void;\n    bindFormValue: (formValue: Dyn<FormValue>) => () => void;\n    bindValidity: (validity: Dyn<Validity>) => () => void;\n    checkValidity: () => void;\n    reportValidity: () => void;\n}\n\nexport type WebFunctionComponent<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n> = (\n    props: WebComponentProps<TKeys, TShadowMode>,\n    lifecycle: WebComponentLifecycle\n) => JSX.Element | null;\n\nexport type WebComponent<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n> = WebFunctionComponent<TKeys, TShadowMode>;\n\nexport interface WebComponentOptions<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n    TExtends extends\n        | keyof ReturnType<typeof getWebComponentTagConstructors>\n        | undefined,\n> {\n    tagName: `${string}-${string}`;\n    Component: WebComponent<TKeys, TShadowMode>;\n    hydrateTemplateChild?: boolean | undefined;\n    observedAttributes?: TKeys[] | undefined;\n    formAssociated?: boolean | undefined;\n    shadowMode?: TExtends extends WebComponentShadowSupportedExtends\n        ? TShadowMode\n        : undefined;\n    delegatesFocus?: boolean | undefined;\n    extends?: TExtends;\n}\n\nexport interface Validity {\n    flags: {\n        valueMissing?: boolean;\n        typeMismatch?: boolean;\n        patternMismatch?: boolean;\n        tooLong?: boolean;\n        tooShort?: boolean;\n        rangeUnderflow?: boolean;\n        rangeOverflow?: boolean;\n        stepMismatch?: boolean;\n        badInput?: boolean;\n        customError?: boolean;\n    };\n    message?: string | undefined;\n    anchor?: HTMLElement | undefined;\n}\n\nexport type FormValue =\n    | string\n    | File\n    | FormData\n    | {\n          value: string | File | FormData;\n          state?: string | File | FormData | undefined;\n      };\n\nexport function WebComponentRenderNode<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined,\n    TExtends extends\n        | keyof ReturnType<typeof getWebComponentTagConstructors>\n        | undefined,\n>(\n    host: HTMLElement,\n    shadowRoot: ShadowRoot | undefined,\n    elementInternals: ElementInternals | undefined,\n    options: WebComponentOptions<TKeys, TShadowMode, TExtends>,\n    childrenField: Field<Node[] | undefined>,\n    fields: Record<TKeys, Field<string | undefined>>,\n    debugName?: string\n): RenderNode {\n    let result: RenderNode | Error | undefined;\n    let onMountCallbacks: undefined | (() => (() => void) | void)[];\n    let onUnmountCallbacks: undefined | (() => void)[];\n    let onDestroyCallbacks: undefined | (() => void)[];\n    const owned: Set<Retainable> = new Set();\n    let errorHandler: ((e: Error) => JSX.Element | null) | undefined;\n\n    function ensureResult() {\n        if (!result) {\n            let callbacksAllowed = true;\n            const lifecycle: WebComponentLifecycle = {\n                onMount: (handler: () => (() => void) | void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onMount must be called in component body'\n                    );\n                    if (!onMountCallbacks) onMountCallbacks = [];\n                    onMountCallbacks.push(handler);\n                },\n                onUnmount: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onUnmount must be called in component body'\n                    );\n                    if (!onUnmountCallbacks) onUnmountCallbacks = [];\n                    onUnmountCallbacks.push(handler);\n                },\n                onDestroy: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onDestroy must be called in component body'\n                    );\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(handler);\n                },\n                onError: (handler: (e: Error) => JSX.Element | null) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onError must be called in component body'\n                    );\n                    log.assert(!errorHandler, 'onError called multiple times');\n                    errorHandler = handler;\n                },\n                host,\n                elementInternals,\n                shadowRoot,\n                addEventListener: (\n                    name: string,\n                    handler: (\n                        this: HTMLElement,\n                        event: Event,\n                        el: HTMLElement\n                    ) => void,\n                    options?: boolean | AddEventListenerOptions\n                ) => {\n                    const listener = (event: Event) => {\n                        handler.call(host, event, host);\n                    };\n                    host.addEventListener(name, listener, options);\n                    const unsubscribe = () => {\n                        host.removeEventListener(name, listener, options);\n                    };\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                bindElementInternalsAttribute: (param, value) => {\n                    // @ts-expect-error // for some reason, ariaDescription is missing from the ARIAMixin definition. Probably need to update type dependencies\n                    elementInternals[param] = dynGet(value);\n                    const unsubscribe = dynSubscribe(value, (err, newValue) => {\n                        if (err === undefined) {\n                            // @ts-expect-error // for some reason, ariaDescription is missing from the ARIAMixin definition. Probably need to update type dependencies\n                            elementInternals[param] = newValue;\n                        } else {\n                            // TODO: what to do on errors?\n                        }\n                    });\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                bindFormValue: (formValue) => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    const update = (formValue: FormValue) => {\n                        if (\n                            typeof formValue === 'string' ||\n                            formValue instanceof File ||\n                            formValue instanceof FormData\n                        ) {\n                            elementInternals?.setFormValue(formValue);\n                        } else {\n                            const { value, state } = formValue;\n                            if (state === undefined) {\n                                elementInternals?.setFormValue(value);\n                            } else {\n                                elementInternals?.setFormValue(value, state);\n                            }\n                        }\n                    };\n                    update(dynGet(formValue));\n                    const unsubscribe = dynSubscribe(\n                        formValue,\n                        (err, newVal) => {\n                            if (err === undefined) {\n                                update(newVal);\n                            } else {\n                                // TODO: what to do on error?\n                            }\n                        }\n                    );\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                bindValidity: (validity) => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    const update = (validity: Validity) => {\n                        const { flags, message, anchor } = validity;\n                        elementInternals?.setValidity(flags, message, anchor);\n                    };\n                    const val = dynGet(validity);\n                    update(val);\n                    const unsubscribe = dynSubscribe(validity, (err, val) => {\n                        if (err === undefined) {\n                            update(val);\n                        } else {\n                            // TODO: what to do on error?\n                        }\n                    });\n                    if (!onDestroyCallbacks) onDestroyCallbacks = [];\n                    onDestroyCallbacks.push(unsubscribe);\n                    return unsubscribe;\n                },\n                checkValidity: () => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    elementInternals?.checkValidity();\n                },\n                reportValidity: () => {\n                    if (!elementInternals) {\n                        throw new Error(\n                            `ElementInternals not available on custom element ${options.tagName}`\n                        );\n                    }\n                    elementInternals?.reportValidity();\n                },\n            };\n\n            const componentProps: any =\n                options.shadowMode === undefined\n                    ? {\n                          ...fields,\n                          children: renderJSXNode(childrenField),\n                      }\n                    : {\n                          ...fields,\n                      };\n            const Component = options.Component;\n            let jsxResult: JSX.Element | Error;\n            try {\n                jsxResult =\n                    Component(componentProps, lifecycle) || emptyRenderNode;\n            } catch (e) {\n                const error = wrapError(e, 'Unknown error rendering component');\n                if (errorHandler) {\n                    jsxResult = errorHandler(error) ?? emptyRenderNode;\n                } else {\n                    jsxResult = error;\n                }\n            }\n            callbacksAllowed = false;\n            for (const item of owned) {\n                retain(item);\n            }\n            if (!(jsxResult instanceof Error)) {\n                result = renderJSXNode(jsxResult);\n            } else {\n                result = jsxResult;\n            }\n        }\n        return result;\n    }\n\n    const renderNode = new SingleChildRenderNode(\n        {\n            onAlive: () => {\n                const result = ensureResult();\n                if (result instanceof Error) {\n                    log.warn('Unhandled exception on detached component', {\n                        error: result,\n                        renderNode: renderNode,\n                    });\n                } else {\n                    renderNode.setChild(result);\n                }\n            },\n            onDestroy: () => {\n                if (onDestroyCallbacks) {\n                    for (const callback of onDestroyCallbacks) {\n                        callback();\n                    }\n                }\n\n                result = undefined;\n                onMountCallbacks = undefined;\n                onUnmountCallbacks = undefined;\n                onDestroyCallbacks = undefined;\n                errorHandler = undefined;\n\n                for (const item of owned) {\n                    release(item);\n                }\n                owned.clear();\n            },\n            onAttach: (parentContext) => {\n                if (result instanceof Error) {\n                    parentContext.errorEmitter(result);\n                }\n            },\n            onError: (error: Error) => {\n                if (errorHandler) {\n                    const handledResult = errorHandler(error);\n                    result = handledResult\n                        ? renderJSXNode(handledResult)\n                        : emptyRenderNode;\n                    renderNode.setChild(result);\n                    return true;\n                }\n            },\n            onMount() {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                renderNode.requestCommit(RenderNodeCommitPhase.COMMIT_MOUNT);\n            },\n            onUnmount() {\n                log.assert(result, 'Invariant: missing result');\n                if (result instanceof Error) {\n                    return;\n                }\n                if (onUnmountCallbacks) {\n                    for (const callback of onUnmountCallbacks) {\n                        callback();\n                    }\n                }\n            },\n            onCommit(phase: RenderNodeCommitPhase) {\n                if (\n                    phase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n                    onMountCallbacks\n                ) {\n                    for (const callback of onMountCallbacks) {\n                        const maybeOnUnmount = callback();\n                        if (typeof maybeOnUnmount === 'function') {\n                            if (!onUnmountCallbacks) {\n                                onUnmountCallbacks = [];\n                            }\n                            const onUnmount = () => {\n                                maybeOnUnmount();\n                                if (onUnmountCallbacks) {\n                                    const index =\n                                        onUnmountCallbacks.indexOf(onUnmount);\n                                    if (index >= 0) {\n                                        onUnmountCallbacks.splice(index, 1);\n                                    }\n                                }\n                            };\n                            onUnmountCallbacks.push(onUnmount);\n                        }\n                    }\n                }\n            },\n            clone() {\n                log.assert(\n                    false,\n                    \"Attempted to clone a WebComponentRenderNode -- this operation doesn't make sense\"\n                );\n            },\n        },\n        emptyRenderNode,\n        debugName ?? `web-component(${options.tagName})`\n    );\n    return renderNode;\n}\n", "import * as log from '../common/log';\nimport type { Retainable } from '../model/engine';\nimport { release, retain } from '../model/engine';\nimport type { Field } from '../model/field';\nimport { field } from '../model/field';\nimport { PortalRenderNode } from './rendernode/portalrendernode';\nimport type { RenderNode } from './rendernode/rendernode';\nimport type { WebComponentOptions } from './rendernode/webcomponentrendernode';\nimport { WebComponentRenderNode } from './rendernode/webcomponentrendernode';\nimport { getWebComponentTagConstructors } from './webcomponents';\nimport { HTML_NAMESPACE } from './xmlnamespace';\n\nexport function defineCustomElement<\n    TKeys extends string,\n    TShadowMode extends 'open' | 'closed' | undefined = undefined,\n    TExtends extends\n        | keyof ReturnType<typeof getWebComponentTagConstructors>\n        | undefined = undefined,\n>(options: WebComponentOptions<TKeys, TShadowMode, TExtends>) {\n    const Superclass = options.extends\n        ? getWebComponentTagConstructors()[options.extends]\n        : HTMLElement;\n    class GooeyCustomElement extends Superclass implements Retainable {\n        __debugName: string;\n        __refcount: number;\n        _originalChildren: Node[] | null;\n        _unmount: (() => void) | undefined;\n        _portalRenderNode: RenderNode | null;\n        _renderNode: RenderNode | null;\n        _childrenField: Field<Node[] | undefined>;\n        _fields: Record<TKeys, Field<string | undefined>>;\n        static formAssociated = options.formAssociated || false;\n        static observedAttributes = options.observedAttributes ?? [];\n\n        constructor() {\n            super();\n            const shadowRoot = options.shadowMode\n                ? this.attachShadow({\n                      delegatesFocus: options.delegatesFocus,\n                      mode: options.shadowMode,\n                  })\n                : undefined;\n\n            const elementInternals = options.extends\n                ? undefined\n                : this.attachInternals();\n\n            this._childrenField = field<Node[] | undefined>(undefined);\n            this._fields = {} as Record<TKeys, Field<string | undefined>>;\n            options.observedAttributes?.forEach((attr) => {\n                this._fields[attr] = field<string | undefined>(undefined);\n            });\n\n            this._renderNode = WebComponentRenderNode(\n                this,\n                shadowRoot,\n                elementInternals,\n                options,\n                this._childrenField,\n                this._fields\n            );\n            this._portalRenderNode = PortalRenderNode(\n                shadowRoot || this,\n                this._renderNode,\n                undefined\n            );\n            this._originalChildren = null;\n            this.__debugName = `custom:${options.tagName}`;\n            this.__refcount = 0;\n        }\n\n        __dead() {\n            this._portalRenderNode?.release();\n            if (this._originalChildren) {\n                this.replaceChildren(...this._originalChildren);\n            }\n        }\n\n        __alive() {\n            if (\n                options.hydrateTemplateChild !== false &&\n                this.children.length === 1 &&\n                this.children[0] instanceof HTMLTemplateElement\n            ) {\n                this._originalChildren = Array.from(this.childNodes);\n                this.replaceChildren(\n                    ...this._originalChildren.map((node) =>\n                        node instanceof HTMLTemplateElement\n                            ? node.content\n                            : node\n                    )\n                );\n            }\n            let children: Node[] = [];\n            if (!options.shadowMode) {\n                children = Array.from(this.childNodes);\n                this.replaceChildren();\n                this._childrenField.set(children);\n            }\n            this._portalRenderNode?.retain();\n            this._portalRenderNode?.attach({\n                nodeEmitter: (event) => {\n                    log.assert(false, 'Unexpected event from Portal', event);\n                },\n                errorEmitter: (error) => {\n                    log.error('Unhandled web component mount error', error);\n                },\n                xmlNamespace: this.namespaceURI ?? HTML_NAMESPACE,\n            });\n        }\n\n        retain() {\n            retain(this);\n        }\n\n        release() {\n            release(this);\n        }\n\n        connectedCallback() {\n            this.retain();\n            this._portalRenderNode?.onMount();\n        }\n\n        disconnectedCallback() {\n            this._portalRenderNode?.onUnmount();\n            this.release();\n        }\n\n        adoptedCallback() {\n            // TODO: what should be done here?\n        }\n\n        attributeChangedCallback(\n            name: string,\n            oldValue: string,\n            newValue: string\n        ) {\n            this._fields[name as TKeys].set(newValue);\n        }\n    }\n    if (options.extends) {\n        customElements.define(options.tagName, GooeyCustomElement, {\n            extends: options.extends,\n        });\n    } else {\n        customElements.define(options.tagName, GooeyCustomElement);\n    }\n}\n", "import * as log from '../common/log';\nimport { flush, registerMountPoint, takeMountPoint } from '../model/engine';\nimport { renderJSXNode } from './renderjsx';\nimport { PortalRenderNode } from './rendernode/portalrendernode';\nimport { HTML_NAMESPACE } from './xmlnamespace';\n\nexport function mount(\n    target: Element | ShadowRoot,\n    node: JSX.Node\n): () => void {\n    const priorMount = takeMountPoint(target);\n    if (priorMount) {\n        log.warn(\n            'Multiple mount() calls to the same target, resetting the old mount'\n        );\n        priorMount();\n    }\n    log.assert(\n        target.childNodes.length === 0,\n        'mount() called on non-empty target',\n        { target }\n    );\n    const root = PortalRenderNode(target, renderJSXNode(node), null, 'root');\n    root.retain();\n\n    let syncError: undefined | Error;\n    root.attach({\n        nodeEmitter: (event) => {\n            log.assert(false, 'Unexpected event emitted by Portal', event);\n        },\n        errorEmitter: (error) => {\n            syncError = error;\n            log.error('Unhandled mount error', error);\n        },\n        xmlNamespace:\n            (target instanceof Element\n                ? target.namespaceURI\n                : target.host.namespaceURI) ?? HTML_NAMESPACE,\n    });\n    if (syncError) {\n        root.release();\n        throw syncError;\n    }\n\n    // WE HAVE A CONUNDRUM!\n    // - When onMount() is called _before_ flushing, IntrinsicObserver callbacks work as expected; but component onMount notifications fail\n    // - When onMount() is called _after_ flushing, IntrinsicObserver callbacks fail; but component onMount notifications work as expected\n    // This is probably because the interaction between mounting and commit is very awkward when dealing with DOM nodes\n    // - For onMount lifecycles to be able to observe nodes in the DOM, onMount needs to happen __after__ commit\n    // - ref={} callbacks should be equivalent to onMount\n    // - refRaw={} callbacks should be equivalent to retain() (NEEDS BETTER NAME)\n    // Overall, it really sucks that we have to flush at all here.\n    root.onMount();\n\n    let unsubscribed = false;\n    const unsubscribe = () => {\n        if (unsubscribed) {\n            log.warn('mount() unmount function called multiple times');\n            return;\n        }\n        takeMountPoint(target);\n        unsubscribed = true;\n        root.onUnmount();\n        flush();\n        target.replaceChildren(); // TODO: Woah nellie, this is weird\n        root.detach();\n        root.release();\n    };\n    registerMountPoint(target, unsubscribe);\n\n    flush();\n\n    return unsubscribe;\n}\n", "import { createElement } from './viewcontroller/createelement';\n\nexport type { ArrayEvent } from './common/arrayevent';\nexport { ArrayEventType, applyArrayEvent } from './common/arrayevent';\nexport type {\n    Dyn,\n    DynMut,\n    Dynamic,\n    DynamicMut,\n    DynamicSubscriptionHandler,\n    DynamicNonErrorSubscriptionHandler,\n} from './common/dyn';\nexport {\n    dyn,\n    dynGet,\n    dynSet,\n    dynMap,\n    dynSubscribe,\n    isDynamic,\n    isDynamicMut,\n} from './common/dyn';\nexport type { LogLevel } from './common/log';\nexport { getLogLevel, setLogLevel } from './common/log';\nexport { InvariantError } from './common/types';\n\nexport { Fragment } from './components/fragment';\nexport { IntrinsicObserver } from './components/intrinsicobserver';\n\nexport { calc, CycleError } from './model/calc';\nexport type { Calculation } from './model/calc';\nexport type { Collection, View } from './model/collection';\nexport { collection } from './model/collection';\nexport type { DictEvent } from './model/dict';\nexport { dict, Dict, DictEventType } from './model/dict';\nexport type { Field } from './model/field';\nexport { field } from './model/field';\nexport {\n    reset,\n    subscribe,\n    flush,\n    debug,\n    debugSubscribe,\n    debugGetGraph,\n    hotSwap,\n} from './model/engine';\nexport type { Model, ModelEvent } from './model/model';\nexport { model, ModelEventType } from './model/model';\n\nexport { createElement } from './viewcontroller/createelement';\nexport { defineCustomElement } from './viewcontroller/definecustomelement';\nexport type { CustomElements } from './viewcontroller/jsx';\nexport { mount } from './viewcontroller/mount';\nexport type {\n    RefObjectOrCallback,\n    Ref,\n    RefCallback,\n} from './viewcontroller/ref';\nexport { ref } from './viewcontroller/ref';\nexport type {\n    Component,\n    EmptyProps,\n    ComponentLifecycle,\n} from './viewcontroller/rendernode/componentrendernode';\nexport { ClassComponent } from './viewcontroller/rendernode/componentrendernode';\nexport type {\n    WebComponent,\n    WebComponentLifecycle,\n} from './viewcontroller/rendernode/webcomponentrendernode';\nexport type {\n    IntrinsicObserverNodeCallback,\n    IntrinsicObserverElementCallback,\n} from './viewcontroller/rendernode/intrinsicobserverrendernode';\nexport { IntrinsicObserverEventType } from './viewcontroller/rendernode/intrinsicobserverrendernode';\n\nexport default createElement;\n\nexport const VERSION =\n    typeof LIB_VERSION === 'string' ? LIB_VERSION : 'development';\n"],
  "mappings": ";AAAO,IAAM,iBAAN,cAA6B,MAAM;AAAA,EAEtC,YAAY,KAAa,QAAc;AACnC,UAAM,GAAG;AACT,SAAK,SAAS;AAAA,EAClB;AACJ;;;ACHA,IAAM,SAAmC;AAAA,EACrC,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AACX;AACA,IAAI,eAAuB,OAAO;AAE3B,SAAS,cAAwB;AACpC,MAAI,gBAAgB,OAAO;AAAM,WAAO;AACxC,MAAI,gBAAgB,OAAO;AAAM,WAAO;AACxC,MAAI,gBAAgB,OAAO;AAAO,WAAO;AACzC,SAAO;AACX;AACO,SAAS,YAAY,UAAoB;AAC5C,YAAU,MAAM,YAAY,QAAQ,QAAQ;AAC5C,iBAAe,OAAO,QAAQ;AAClC;AAEO,SAAS,aAAa,UAAoB;AAC7C,SAAO,gBAAgB,OAAO,QAAQ;AAC1C;AAQO,SAAS,QAAQ,OAAc;AAClC,MAAI,gBAAgB,OAAO,MAAM;AAC7B,YAAQ,IAAI,GAAG,KAAK;AAAA,EACxB;AACJ;AAEO,SAAS,QAAQ,OAAc;AAClC,MAAI,gBAAgB,OAAO,MAAM;AAC7B,YAAQ,KAAK,GAAG,KAAK;AAAA,EACzB;AACJ;AAEO,SAAS,SAAS,OAAc;AACnC,MAAI,gBAAgB,OAAO,OAAO;AAC9B,YAAQ,MAAM,GAAG,KAAK;AAAA,EAC1B;AACJ;AAuBO,SAAS,UAAU,UAAqB,OAAc;AACzD,MAAI,CAAC,MAAM,GAAG;AACV,UAAM,mBAAmB,MAAM,SAAS,GAAG,iBAAiB,GAAG,KAAK;AAAA,EACxE;AACJ;AAEO,SAAS,KAAK,QAAgB,OAAqB;AACtD,QAAM,mBAAmB,KAAK,GAAG,KAAK;AACtC,QAAM,IAAI,eAAe,oBAAoB,OAAO,KAAK;AAC7D;AAEO,SAAS,OACZ,OACA,QACG,OACU;AACb,MAAI,CAAC,OAAO;AACR;AAAA,MACI;AAAA,MACA,UAAU,SACJ,cACA,UAAU,OACR,SACA,MAAM,SAAS;AAAA,MACvB;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACP;AACA,UAAM,IAAI,eAAe,sBAAsB,OAAO,KAAK;AAAA,EAC/D;AACJ;AAEO,SAAS,gBAAgB,YAAmB,OAAqB;AACpE,QAAM,qBAAqB,SAAS,oBAAoB,GAAG,KAAK;AAChE,QAAM,IAAI,eAAe,qBAAqB,EAAE,SAAS,MAAM,CAAC;AACpE;;;ACzGO,IAAM,OAAO,MAAM;AAAC;AAKpB,IAAM,OAAO,MAAW;AAC3B,QAAM,IAAI,MAAM,2BAA2B;AAC/C;AAEO,IAAM,YAAY,MAAM;AAC3B,MAAI,KAAK;AACT,SAAO,MAAM;AACjB,GAAG;AAmFI,SAAS,UAAU,GAAY,KAAqB;AACvD,MAAI,aAAa;AAAO,WAAO;AAE/B,QAAM,MAAM,IAAI,MAAM,OAAO,iBAAiB,EAAE,OAAO,EAAE,CAAC;AAC1D,SAAO;AACX;;;ACnGO,IAAK,iBAAL,kBAAKA,oBAAL;AACH,EAAAA,gBAAA,YAAS;AACT,EAAAA,gBAAA,UAAO;AACP,EAAAA,gBAAA,UAAO;AAHC,SAAAA;AAAA,GAAA;AA6BZ,IAAM,cAA2B,CAAC;AAE3B,SAAS,UAAa,QAAa,MAAc,SAAmB;AACvE,QAAM,QAAQ,OAAO,MAAM,MAAM,OAAO,QAAQ,MAAM;AACtD,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,EAAE,GAAG;AACrC,WAAO,IAAI,IAAI,IAAI,MAAM,QAAQ,CAAC,IAAI,IAAI;AAAA,EAC9C;AACJ;AAEO,SAAS,UACZ,QACA,MACA,OACA,IACF;AACE,QAAM,QAAQ,OAAO,OAAO,MAAM,KAAK;AACvC,SAAO,OAAO,IAAI,GAAG,GAAG,KAAK;AACjC;AAEO,SAAS,gBACZ,QACA,OACY;AACZ,UAAQ,MAAM,MAAM;AAAA,IAChB,KAAK,uBAAuB;AACxB,UAAI,MAAM,OAAO;AACb,eAAO,OAAO,OAAO,MAAM,OAAO,MAAM,OAAO,GAAG,MAAM,KAAK;AAAA,MACjE,OAAO;AACH,eAAO,OAAO,OAAO,MAAM,OAAO,MAAM,KAAK;AAAA,MACjD;AAAA,IACJ;AAAA,IACA,KAAK,mBAAqB;AACtB,gBAAU,QAAQ,MAAM,MAAM,MAAM,OAAO;AAC3C;AAAA,IACJ;AAAA,IACA,KAAK,mBAAqB;AACtB,gBAAU,QAAQ,MAAM,MAAM,MAAM,OAAO,MAAM,EAAE;AACnD;AAAA,IACJ;AAAA,IACA;AACI,MAAI,gBAAgB,KAAK;AAAA,EACjC;AACA,SAAO;AACX;AAOO,UAAU,iBAAoB,QAAiC;AAClE,QAAM,WAAW,OAAO,OAAO,QAAQ,EAAE;AACzC,QAAM,YAAY,SAAS,KAAK;AAChC,MAAI,UAAU,MAAM;AAChB;AAAA,EACJ;AACA,MAAI,YAAY,UAAU;AAC1B,MAAI;AACJ,SAAO,MAAM;AACT,UAAM,WAAW,SAAS,KAAK;AAC/B,QAAI,SAAS,MAAM;AACf;AAAA,IACJ;AACA,UAAM,QAAQ,SAAS;AAIvB,QACI,MAAM,SAAS,yBACf,UAAU,SAAS,yBACnB,UAAU,SAAS,UAAU,OAAO,UAAU,OAAO,MAAM,OAC7D;AAuBE,UAAI,CAAC,aAAa;AACd,sBAAc,UAAU,OAAO,MAAM,KAAK,CAAC;AAAA,MAC/C;AACA,UAAI,MAAM,OAAO;AACb,oBAAY,KAAK,GAAG,MAAM,KAAK;AAAA,MACnC;AACA,UAAI,YAAY,QAAQ;AACpB,oBAAY;AAAA,UACR,MAAM;AAAA,UACN,OAAO,UAAU;AAAA,UACjB,OAAO,UAAU,QAAQ,MAAM;AAAA,UAC/B,OAAO;AAAA,QACX;AAAA,MACJ,OAAO;AACH,oBAAY;AAAA,UACR,MAAM;AAAA,UACN,OAAO,UAAU;AAAA,UACjB,OAAO,UAAU,QAAQ,MAAM;AAAA,QACnC;AAAA,MACJ;AAAA,IACJ,OAAO;AACH,YAAM;AACN,kBAAY;AACZ,oBAAc;AAAA,IAClB;AAAA,EACJ;AACA,QAAM;AACV;;;ACjJA,IAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAKxB;AACA,IAAI,eAAe;AAAA,EACf,uBAAqC,GAAG,oBAAI,IAAgB;AAAA,EAC5D,oBAAkC,GAAG,oBAAI,IAAgB;AAAA,EACzD,sBAAoC,GAAG,oBAAI,IAAgB;AAAA,EAC3D,qBAAmC,GAAG,oBAAI,IAAgB;AAC9D;AACA,IAAI;AACJ,IAAI,kBAAkB;AAEtB,SAAS,iBAAiB,UAAsB;AAC5C,MAAK,OAAe,gBAAgB;AAChC,QAAI,YAAY;AAChB,mBAAe,MAAM;AACjB,UAAI;AAAW;AACf,eAAS;AAAA,IACb,CAAC;AACD,WAAO,MAAM;AACT,kBAAY;AAAA,IAChB;AAAA,EACJ;AACA,QAAM,SAAS,WAAW,UAAU,CAAC;AACrC,SAAO,MAAM,aAAa,MAAM;AACpC;AAiBO,SAAS,SAAS;AACrB,SAAO,iBAAiB,QAAW;AAC/B,mBAAe;AACf,kBAAc;AAAA,EAClB;AACJ;AAaA,SAAS,gBAAgB;AACrB,MAAI,gBAAgC;AACpC,aAAW,SAAS,iBAAiB;AACjC,QAAI,iCAA+C;AAC/C,sBAAgB,SAAS;AAAA,IAC7B;AACA,UAAM,WAAW,MAAM,KAAK,aAAa,KAAK,CAAC,EAAE;AAAA,MAC7C,CAAC,GAAG,MAAM,EAAE,SAAS,IAAI,EAAE,SAAS;AAAA,IACxC;AACA,iBAAa,KAAK,IAAI,oBAAI,IAAI;AAC9B,eAAW,cAAc,UAAU;AAC/B,iBAAW,OAAO,KAAK;AAAA,IAC3B;AACA,QACI,mCACA,iBACA,SAAS,gBAAgB,SAAS,aAAa,GACjD;AACE,MAAC,cAA8B,MAAM;AAAA,IACzC;AAAA,EACJ;AACJ;AAEO,SAAS,cACZ,QACA,OACF;AACE,eAAa,KAAK,EAAE,IAAI,MAAM;AAC9B,MAAI,CAAC,cAAc;AACf,mBAAe,gBAAgB,MAAM;AAAA,EACzC;AACJ;;;ACnGO,IAAM,WAAN,MAAe;AAAA,EAMlB,YAAY,YAAoB,OAAiB;AAC7C,SAAK,aAAa;AAClB,SAAK,aAAa,KAAK;AACvB,SAAK,QAAQ;AACb,SAAK,UAAU,KAAK,SAAS,KAAK,KAAK;AAAA,EAC3C;AAAA,EAEQ,SAAS,OAAiB;AAC9B,UAAM,UAAoB,CAAC;AAC3B,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK,KAAK,YAAY;AACpD,UAAI,SAAS;AACb,eAAS,IAAI,GAAG,IAAI,KAAK,cAAc,IAAI,IAAI,MAAM,QAAQ,EAAE,GAAG;AAC9D,kBAAU,MAAM,IAAI,CAAC;AAAA,MACzB;AACA,cAAQ,KAAK,MAAM;AAAA,IACvB;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,cAAc,MAAc,IAAY;AAC5C,UAAM,cAAc,QAAQ,KAAK;AACjC,UAAM,YAAY,MAAM,KAAK;AAG7B,aAAS,IAAI,KAAK,QAAQ,QAAQ,IAAI,WAAW,EAAE,GAAG;AAClD,WAAK,QAAQ,KAAK,CAAC;AAAA,IACvB;AAEA,aAAS,IAAI,aAAa,KAAK,WAAW,EAAE,GAAG;AAC3C,UAAI,SAAS;AACb,YAAM,QAAQ,KAAK,KAAK;AACxB,eACQ,IAAI,GACR,IAAI,KAAK,cAAc,QAAQ,IAAI,KAAK,MAAM,QAC9C,EAAE,GACJ;AACE,kBAAU,KAAK,MAAM,QAAQ,CAAC;AAAA,MAClC;AACA,WAAK,QAAQ,CAAC,IAAI;AAAA,IACtB;AAAA,EACJ;AAAA,EAEA,OAAO,OAAe,OAAe,OAAiB;AAClD,SAAK,MAAM,OAAO,OAAO,OAAO,GAAG,KAAK;AACxC,SAAK;AAAA,MACD;AAAA,MACA,UAAU,MAAM,SAAS,QAAQ,QAAQ,KAAK,MAAM;AAAA,IACxD;AACA,QAAI,QAAQ,MAAM,SAAS,GAAG;AAE1B,YAAM,aAAa,KAAK,MAAM,UAAU,KAAK;AAC7C,UAAI,KAAK,QAAQ,SAAS,YAAY;AAClC,aAAK,QAAQ,SAAS;AAAA,MAC1B;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,KAAK,WAAmB,OAAe,SAAiB;AACpD,cAAU,KAAK,OAAO,WAAW,OAAO,OAAO;AAC/C,SAAK;AAAA,MACD,KAAK,IAAI,WAAW,OAAO;AAAA,MAC3B,KAAK,IAAI,WAAW,OAAO,IAAI;AAAA,IACnC;AAAA,EACJ;AAAA,EAEA,KAAK,WAAmB,SAAmB;AACvC,cAAU,KAAK,OAAO,WAAW,OAAO;AACxC,SAAK,cAAc,WAAW,YAAY,QAAQ,MAAM;AAAA,EAC5D;AAAA,EAEA,OAAO,OAAe;AAClB,QAAI,UAAU,GAAG;AACb,aAAO;AAAA,IACX;AACA,QAAI,MAAM;AACV,aACQ,cAAc,GAAG,IAAI,KAAK,YAC9B,cAAc,KAAK,QAAQ,UAAU,KAAK,OAC1C,EAAE,aAAa,KAAK,KAAK,YAC3B;AACE,aAAO,KAAK,QAAQ,WAAW;AAAA,IACnC;AACA,UAAM,QAAQ,QAAQ,EAAE,KAAK,aAAa;AAC1C,aAAS,IAAI,OAAO,IAAI,SAAS,IAAI,KAAK,MAAM,QAAQ,EAAE,GAAG;AACzD,aAAO,KAAK,MAAM,CAAC;AAAA,IACvB;AACA,WAAO;AAAA,EACX;AAAA,EAEA,IAAI,OAAe;AACf,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EAEA,IAAI,OAAe,OAAe;AAC9B,UAAM,OAAO,QAAQ,KAAK,MAAM,KAAK;AACrC,SAAK,MAAM,KAAK,IAAI;AACpB,UAAM,cAAc,SAAS,KAAK;AAClC,SAAK,QAAQ,WAAW,KAAK;AAAA,EACjC;AACJ;;;AC7FA,IAAM,gBAAgB;AAEf,IAAM,YAAN,MAA8B;AAAA,EAKjC,YAAY,OAAuB;AAC/B,SAAK,QAAQ,IAAI;AAAA,MACb;AAAA,MACA,MAAM,IAAI,MAAM,CAAC;AAAA,IACrB;AACA,SAAK,QAAQ;AACb,SAAK,UAAU,oBAAI,IAAI;AACvB,SAAK,cAAc,GAAG,MAAM,MAAM;AAAA,EACtC;AAAA,EAEA,aAAa;AACT,SAAK,QAAQ,IAAI;AAAA,MACb;AAAA,MACA,KAAK,MAAM,IAAI,MAAM,CAAC;AAAA,IAC1B;AAAA,EACJ;AAAA,EAEA,cAAc,IAAY,IAAY;AAClC,aAAS,IAAI,IAAI,IAAI,IAAI,EAAE,GAAG;AAC1B,WAAK,QAAQ,IAAI,KAAK,MAAM,CAAC,GAAG,CAAC;AAAA,IACrC;AAAA,EACJ;AAAA,EAEA,IAAI,OAAyC;AACzC,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EAEA,KAAK,MAAc,OAAe,IAA4B;AAC1D,UAAM,YAAY,KAAK,MAAM,OAAO,IAAI;AACxC,UAAM,aAAa,KAAK,MAAM,OAAO,OAAO,KAAK,IAAI;AAErD,SAAK,MAAM,KAAK,MAAM,OAAO,EAAE;AAC/B,cAAU,KAAK,OAAO,MAAM,OAAO,EAAE;AAErC,UAAM,UAAU,KAAK,MAAM,OAAO,EAAE;AAEpC,SAAK,cAAc,KAAK,IAAI,MAAM,EAAE,GAAG,KAAK,IAAI,MAAM,EAAE,IAAI,KAAK;AAEjE,WAAO;AAAA,MACH;AAAA,MACA,MAAM;AAAA,MACN,OAAO;AAAA,MACP,IAAI;AAAA,IACR;AAAA,EACJ;AAAA,EAEA,KAAK,MAAc,SAAmC;AAwBlD,QAAI,YAAY;AAChB,QAAI,aAAa;AACjB,UAAM,eAA2B,CAAC;AAClC,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,QAAQ,EAAE,GAAG;AAC5C,YAAM,WAAW,KAAK,MAAM,IAAI,CAAC;AACjC,YAAM,cAAwB,CAAC;AAC/B,eAAS,IAAI,GAAG,IAAI,UAAU,EAAE,GAAG;AAC/B,oBAAY,KAAK,YAAY;AAAA,MACjC;AACA,mBAAa,KAAK,WAAW;AAC7B,UAAI,IAAI,MAAM;AACV,qBAAa,KAAK,MAAM,IAAI,CAAC;AAAA,MACjC;AAAA,IACJ;AACA,cAAU,cAAc,MAAM,OAAO;AACrC,UAAM,aAAa,aAAa,MAAM,IAAI,EAAE,KAAK;AACjD,SAAK,MAAM,KAAK,MAAM,OAAO;AAC7B,cAAU,KAAK,OAAO,MAAM,OAAO;AACnC,SAAK,cAAc,MAAM,OAAO,QAAQ,MAAM;AAC9C,WAAO;AAAA,MACH;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,EACJ;AAAA,EAEA,OACI,OACA,OACA,OACuD;AACvD,UAAM,aAAa,KAAK,MAAM,OAAO,KAAK;AAC1C,UAAM,aAAa,KAAK,MAAM,OAAO,QAAQ,KAAK,IAAI;AACtD,SAAK,MAAM;AAAA,MACP;AAAA,MACA;AAAA,MACA,MAAM,IAAI,MAAM,CAAC;AAAA,IACrB;AACA,UAAM,eAAe,KAAK,MAAM,OAAO,OAAO,OAAO,GAAG,KAAK;AAC7D,eAAW,eAAe,cAAc;AACpC,WAAK,QAAQ,OAAO,WAAW;AAAA,IACnC;AACA,QAAI,KAAK,MAAM,WAAW,OAAO;AAC7B,WAAK,cAAc,OAAO,QAAQ,KAAK;AAAA,IAC3C,OAAO;AACH,WAAK,cAAc,OAAO,KAAK,MAAM,MAAM;AAAA,IAC/C;AACA,WAAO;AAAA,MACH,SAAS;AAAA,MACT,OAAO;AAAA,QACH;AAAA,QACA,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO,CAAC;AAAA;AAAA,MACZ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,WACI,QACA,OACkB;AAClB,UAAM,cAAc,KAAK,QAAQ,IAAI,MAAM;AAC3C,IAAI;AAAA,MACA,gBAAgB;AAAA,MAChB;AAAA,MACA;AAAA,IACJ;AACA,UAAM,QAAQ,KAAK,MAAM,OAAO,WAAW;AAC3C,YAAQ,MAAM,MAAM;AAAA,MAChB,4BAA4B;AACxB,aAAK,MAAM;AAAA,UACP;AAAA,UACA,KAAK,MAAM,IAAI,WAAW,KACrB,MAAM,OAAO,UAAU,KACxB,MAAM;AAAA,QACd;AACA,eAAO;AAAA,UACH;AAAA,UACA,OAAO,MAAM,QAAQ;AAAA,UACrB,OAAO,MAAM;AAAA,UACb,OAAO,MAAM;AAAA,QACjB;AAAA,MACJ;AAAA,MACA,wBAA0B;AACtB,eAAO;AAAA,UACH;AAAA,UACA,MAAM,MAAM,OAAO;AAAA,UACnB,SAAS,MAAM,QAAQ,IAAI,CAAC,UAAU,QAAQ,KAAK;AAAA,QACvD;AAAA,MACJ;AAAA,MACA,wBAA0B;AACtB,eAAO;AAAA,UACH;AAAA,UACA,MAAM,MAAM,OAAO;AAAA,UACnB,OAAO,MAAM;AAAA,UACb,IAAI,MAAM,KAAK;AAAA,QACnB;AAAA,MACJ;AAAA,MACA;AACI,QAAI,gBAAgB,OAAO,yBAAyB;AAAA,IAC5D;AAAA,EACJ;AACJ;;;ACtFO,IAAM,wBAAN,MAA8D;AAAA,EAQjE,YACI,UACA,OACA,WACF;AAmFF,SAAQ,cAAc,CAAC,UAA4B;AAC/C,UAAI,MAAM,gCAAgC;AACtC,aAAK,cAAc,MAAM,OAAO,UAAU,KAAK,MAAM;AAAA,MACzD;AACA,UAAI,CAAC,KAAK,SAAS,UAAU,KAAK,GAAG;AACjC,QAAI;AAAA,UACA,KAAK;AAAA,UACL;AAAA,QACJ;AACA,aAAK,cAAc,YAAY,KAAK;AAAA,MACxC;AAAA,IACJ;AAEA,SAAQ,cAAc,CAAC,UAAiB;AACpC,UAAI,CAAC,KAAK,SAAS,UAAU,KAAK,GAAG;AACjC,YAAI,KAAK,eAAe;AACpB,eAAK,cAAc,aAAa,KAAK;AAAA,QACzC,OAAO;AACH,UAAI,KAAK,0CAA0C,KAAK;AAAA,QAC5D;AAAA,MACJ;AAAA,IACJ;AAvGI,SAAK,WAAW;AAChB,SAAK,QAAQ;AACb,SAAK,aAAa;AAClB,SAAK,gBAAgB;AACrB,SAAK,YAAY;AACjB,SAAK,QAAQ;AAEb,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA,EACtB;AAAA,EAEA,aAAa;AACT,WAAO,CAAC,CAAC,KAAK;AAAA,EAClB;AAAA,EAEA,YAAY;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,UAAU,OAAyB;AAC/B,IAAI;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACJ;AACA,SAAK,cAAc,YAAY,KAAK;AAAA,EACxC;AAAA,EAEA,UAAUC,QAAc;AACpB,IAAI;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACJ;AACA,SAAK,cAAc,aAAaA,MAAK;AAAA,EACzC;AAAA,EAEA,OAAO,OAA8B;AACjC,SAAK,SAAS,WAAW,KAAK;AAAA,EAClC;AAAA,EAEA,cAAc,OAA8B;AACxC,kBAAc,MAAM,KAAK;AAAA,EAC7B;AAAA,EAEA,MAAM,OAAY,UAAqC;AACnD,QAAI,KAAK,SAAS,OAAO;AACrB,aAAO,KAAK,SAAS,MAAM,OAAO,QAAQ;AAAA,IAC9C;AACA,UAAM,cAAc,KAAK,MAAM,MAAM;AACrC,WAAO,IAAI,sBAAsB,KAAK,UAAU,WAAW;AAAA,EAC/D;AAAA,EAEA,SAAS,OAAmB;AACxB,UAAM,WAAW,KAAK;AACtB,SAAK,QAAQ;AACb,QAAI,KAAK,YAAY;AACjB,eAAS,UAAU;AAAA,IACvB;AACA,QAAI,KAAK,eAAe;AACpB,UAAI,KAAK,YAAY,GAAG;AACpB,aAAK,cAAc,YAAY;AAAA,UAC3B;AAAA,UACA,OAAO;AAAA,UACP,OAAO,KAAK;AAAA,QAChB,CAAC;AAAA,MACL;AACA,eAAS,OAAO;AAAA,IACpB;AACA,SAAK,YAAY;AACjB,SAAK,OAAO,QAAQ;AACpB,SAAK,IAAI,KAAK,KAAK;AACnB,QAAI,KAAK,eAAe;AACpB,WAAK,MAAM,OAAO;AAAA,QACd,aAAa,KAAK;AAAA,QAClB,cAAc,KAAK;AAAA,QACnB,cAAc,KAAK,cAAc;AAAA,MACrC,CAAC;AAAA,IACL;AACA,QAAI,KAAK,YAAY;AACjB,WAAK,MAAM,QAAQ;AAAA,IACvB;AAAA,EACJ;AAAA,EAyBA,SAAS;AACL,IAAI,OAAO,KAAK,eAAe,iBAAiB;AAChD,SAAK,MAAM,OAAO;AAClB,SAAK,gBAAgB;AACrB,SAAK,SAAS,WAAW;AAAA,EAC7B;AAAA,EAEA,OAAO,eAA8B;AACjC,IAAI,OAAO,CAAC,KAAK,eAAe,4BAA4B;AAC5D,SAAK,gBAAgB;AACrB,SAAK,MAAM,OAAO;AAAA,MACd,aAAa,KAAK;AAAA,MAClB,cAAc,KAAK;AAAA,MACnB,cAAc,KAAK,cAAc;AAAA,IACrC,CAAC;AACD,SAAK,SAAS,WAAW,aAAa;AAAA,EAC1C;AAAA,EAEA,UAAU;AACN,SAAK,aAAa;AAClB,SAAK,MAAM,QAAQ;AACnB,SAAK,SAAS,UAAU;AAAA,EAC5B;AAAA,EAEA,YAAY;AACR,SAAK,aAAa;AAClB,SAAK,MAAM,UAAU;AACrB,SAAK,SAAS,YAAY;AAAA,EAC9B;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EACA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAKA,UAAU;AACN,SAAK,IAAI,KAAK,KAAK;AACnB,SAAK,SAAS,UAAU;AAAA,EAC5B;AAAA,EACA,SAAS;AACL,SAAK,SAAS,YAAY;AAC1B,SAAK,OAAO,KAAK,KAAK;AACtB,SAAK,gBAAgB;AAAA,EACzB;AAAA,EAEA,IAAI,OAAmB;AACnB,QAAI,UAAU;AAAiB;AAC/B,UAAM,SAAS,KAAK,QAAQ,CAAC;AAC7B,UAAM,OAAO;AAAA,EACjB;AAAA,EAEA,OAAO,OAAmB;AACtB,QAAI,UAAU;AAAiB;AAC/B,UAAM,QAAQ;AACd,UAAM,SAAS,CAAC;AAAA,EACpB;AAAA,EAEA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,SAAS,OAAe;AACpB,SAAK,QAAQ;AAAA,EACjB;AACJ;AAKO,IAAM,uBAAN,MAA6D;AAAA,EAQhE,YACI,UACA,UACA,WACF;AA4HF,SAAQ,cAAc,CAAC,UAAiB;AACpC,UAAI,CAAC,KAAK,SAAS,UAAU,KAAK,GAAG;AACjC,YAAI,KAAK,eAAe;AACpB,eAAK,cAAc,aAAa,KAAK;AAAA,QACzC,OAAO;AACH,UAAI,KAAK,0CAA0C,KAAK;AAAA,QAC5D;AAAA,MACJ;AAAA,IACJ;AAnII,SAAK,QAAQ;AACb,SAAK,WAAW;AAChB,SAAK,aAAa;AAClB,SAAK,YAAY,IAAI,UAAU,QAAQ;AACvC,SAAK,gBAAgB;AACrB,SAAK,gBAAgB;AAErB,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA,EACtB;AAAA,EAEA,aAAa;AACT,WAAO,CAAC,CAAC,KAAK;AAAA,EAClB;AAAA,EAEA,YAAY;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,UAAU,OAAyB;AAC/B,IAAI;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACJ;AACA,SAAK,cAAc,YAAY,KAAK;AAAA,EACxC;AAAA,EAEA,UAAUA,QAAc;AACpB,IAAI;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACJ;AACA,SAAK,cAAc,aAAaA,MAAK;AAAA,EACzC;AAAA,EAEA,OAAO,OAA8B;AACjC,SAAK,SAAS,WAAW,KAAK;AAAA,EAClC;AAAA,EAEA,cAAc,OAA8B;AACxC,kBAAc,MAAM,KAAK;AAAA,EAC7B;AAAA,EAEA,MAAM,OAAY,UAAqC;AACnD,QAAI,KAAK,SAAS,OAAO;AACrB,aAAO,KAAK,SAAS,MAAM,OAAO,QAAQ;AAAA,IAC9C;AACA,UAAM,iBAAiB,KAAK,UAAU,MAAM;AAAA,MAAI,CAAC,UAC7C,MAAM,MAAM;AAAA,IAChB;AACA,WAAO,IAAI,qBAAqB,KAAK,UAAU,cAAc;AAAA,EACjE;AAAA,EAEA,aAAa,MAAc,SAAmB;AAC1C,UAAM,QAAQ,KAAK,UAAU,KAAK,MAAM,OAAO;AAC/C,SAAK,eAAe,YAAY,KAAK;AAAA,EACzC;AAAA,EAEA,aAAa,MAAc,OAAe,IAAY;AAClD,UAAM,QAAQ,KAAK,UAAU,KAAK,MAAM,OAAO,EAAE;AACjD,SAAK,eAAe,YAAY,KAAK;AAAA,EACzC;AAAA,EAEA,eAAe,OAAe,OAAe,UAAwB;AAEjE,aAAS,IAAI,OAAO,IAAI,QAAQ,OAAO,EAAE,GAAG;AACxC,YAAM,QAAQ,KAAK,UAAU,MAAM,CAAC;AACpC,UAAI,KAAK,YAAY;AACjB,cAAM,UAAU;AAAA,MACpB;AAAA,IACJ;AACA,UAAM,EAAE,SAAS,MAAM,IAAI,KAAK,UAAU;AAAA,MACtC;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AACA,QAAI,KAAK,iBAAiB,MAAM,QAAQ,GAAG;AACvC,WAAK,cAAc,YAAY;AAAA,QAC3B;AAAA,QACA,OAAO,MAAM;AAAA,QACb,OAAO,MAAM;AAAA;AAAA,MAEjB,CAAC;AAAA,IACL;AACA,eAAW,SAAS,SAAS;AACzB,UAAI,KAAK,eAAe;AACpB,cAAM,OAAO;AAAA,MACjB;AACA,WAAK,OAAO,KAAK;AAAA,IACrB;AACA,eAAW,SAAS,UAAU;AAC1B,WAAK,IAAI,KAAK;AACd,UAAI,KAAK,eAAe;AACpB,cAAM,OAAO;AAAA,UACT,aAAa,CAACC,WACV,KAAK,iBAAiB,OAAOA,MAAK;AAAA,UACtC,cAAc,KAAK;AAAA,UACnB,cAAc,KAAK,cAAc;AAAA,QACrC,CAAC;AAAA,MACL;AACA,UAAI,KAAK,YAAY;AACjB,cAAM,QAAQ;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEQ,iBAAiB,OAAmB,OAAyB;AACjE,QAAI,CAAC,KAAK,SAAS,eAAe,OAAO,KAAK,GAAG;AAC7C,YAAM,UAAU,KAAK,UAAU,WAAW,OAAO,KAAK;AACtD,WAAK,YAAY,OAAO;AAAA,IAC5B;AAAA,EACJ;AAAA,EAEQ,YAAY,OAAyB;AACzC,QAAI,CAAC,KAAK,SAAS,UAAU,KAAK,GAAG;AACjC,MAAI;AAAA,QACA,KAAK;AAAA,QACL;AAAA,MACJ;AACA,WAAK,cAAc,YAAY,KAAK;AAAA,IACxC;AAAA,EACJ;AAAA,EAYA,SAAS;AACL,IAAI,OAAO,KAAK,eAAe,iBAAiB;AAChD,SAAK,UAAU,WAAW;AAC1B,eAAW,SAAS,KAAK,UAAU,OAAO;AACtC,YAAM,OAAO;AAAA,IACjB;AACA,SAAK,gBAAgB;AACrB,SAAK,SAAS,WAAW;AAAA,EAC7B;AAAA,EAEA,OAAO,eAA8B;AACjC,IAAI,OAAO,CAAC,KAAK,eAAe,4BAA4B;AAC5D,SAAK,gBAAgB;AACrB,eAAW,SAAS,KAAK,UAAU,OAAO;AACtC,YAAM,OAAO;AAAA,QACT,aAAa,CAAC,UAAU;AACpB,eAAK,iBAAiB,OAAO,KAAK;AAAA,QACtC;AAAA,QACA,cAAc,KAAK;AAAA,QACnB,cAAc,KAAK,cAAc;AAAA,MACrC,CAAC;AAAA,IACL;AACA,SAAK,SAAS,WAAW,aAAa;AAAA,EAC1C;AAAA,EAEA,UAAU;AACN,SAAK,aAAa;AAClB,eAAW,SAAS,KAAK,UAAU,OAAO;AACtC,YAAM,QAAQ;AAAA,IAClB;AACA,SAAK,SAAS,UAAU;AAAA,EAC5B;AAAA,EAEA,YAAY;AACR,SAAK,aAAa;AAClB,eAAW,SAAS,KAAK,UAAU,OAAO;AACtC,YAAM,UAAU;AAAA,IACpB;AACA,SAAK,SAAS,YAAY;AAAA,EAC9B;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EACA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAKA,UAAU;AACN,eAAW,SAAS,KAAK,UAAU,OAAO;AACtC,WAAK,IAAI,KAAK;AAAA,IAClB;AACA,SAAK,SAAS,UAAU;AAAA,EAC5B;AAAA,EACA,SAAS;AACL,SAAK,SAAS,YAAY;AAC1B,eAAW,SAAS,KAAK,UAAU,OAAO;AACtC,WAAK,OAAO,KAAK;AAAA,IACrB;AACA,SAAK,gBAAgB;AAAA,EACzB;AAAA,EAEA,IAAI,OAAmB;AACnB,QAAI,UAAU;AAAiB;AAC/B,UAAM,SAAS,KAAK,QAAQ,CAAC;AAC7B,UAAM,OAAO;AAAA,EACjB;AAAA,EAEA,OAAO,OAAmB;AACtB,QAAI,UAAU;AAAiB;AAC/B,UAAM,QAAQ;AACd,UAAM,SAAS,CAAC;AAAA,EACpB;AAAA,EAEA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,SAAS,OAAe;AACpB,SAAK,QAAQ;AAAA,EACjB;AACJ;AAKO,IAAM,kBAAN,MAA4C;AAAA,EAG/C,cAAc;AACV,SAAK,cAAc;AACnB,SAAK,aAAa;AAAA,EACtB;AAAA,EAEA,SAAS;AAAA,EAAC;AAAA,EACV,SAAS;AAAA,EAAC;AAAA,EACV,UAAU;AAAA,EAAC;AAAA,EACX,YAAY;AAAA,EAAC;AAAA,EACb,SAAS;AAAA,EAAC;AAAA,EACV,UAAU;AAAA,EAAC;AAAA,EACX,SAAS;AAAA,EAAC;AAAA,EACV,WAAW;AACP,WAAO;AAAA,EACX;AAAA,EACA,WAAW;AAAA,EAAC;AAAA,EACZ,QAAoB;AAChB,WAAO;AAAA,EACX;AAAA,EACA,UAAU;AAAA,EAAC;AAAA,EACX,SAAS;AAAA,EAAC;AACd;AAKO,IAAM,kBAAkB,IAAI,gBAAgB;AAE5C,SAAS,aAAa,KAA6B;AACtD,SACI,QACC,eAAe,yBACZ,eAAe,wBACf,eAAe;AAE3B;;;ACtjBO,SAAS,qBACZC,gBACAC,aACA,WACU;AACV,MAAI;AACJ,WAAS,YAAY,QAAmC;AACpD,eAAW,SAAS,QAAQ;AACxB,cAAQ,MAAM,MAAM;AAAA,QAChB;AACI,qBAAW;AAAA,YACP,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM,OAAO,IAAI,CAAC,SAASD,eAAc,IAAI,CAAC,KAAK,CAAC;AAAA,UACxD;AACA;AAAA,QACJ;AACI,qBAAW,aAAa,MAAM,MAAM,MAAM,OAAO,MAAM,EAAE;AACzD;AAAA,QACJ;AACI,qBAAW,aAAa,MAAM,MAAM,MAAM,OAAO;AACjD;AAAA,MACR;AAAA,IACJ;AAAA,EACJ;AACA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,SAAS,MAAM;AACX,sBAAcC,YAAW,UAAU,WAAW;AAAA,MAClD;AAAA,MACA,WAAW,MAAM;AACb,sBAAc;AACd,qBAAa,MAAM;AACf,qBAAW,eAAe,GAAGA,YAAW,QAAQ,CAAC,CAAC;AAAA,QACtD,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,IACA,CAAC;AAAA,IACD,aAAa,wBAAwBA,YAAW;AAAA,EACpD;AAEA,SAAO;AACX;;;AC3CO,IAAM,mBAAN,MAA0B;AAAA,EAA1B;AACH,SAAQ,YAA2B,CAAC;AAAA;AAAA,EAEpC,eAAe,OAAe,KAAa,OAAgB;AACvD,QAAI,SAAS;AAAK;AAElB,UAAM,SAAwB,CAAC;AAG/B,UAAM,OAAO,KAAK,iBAAiB,KAAK;AACxC,QAAI,IAAI;AAGR,WAAO,IAAI,KAAK,UAAU,UAAU,KAAK,UAAU,CAAC,EAAE,QAAQ,KAAK;AAC/D,YAAM,UAAU,KAAK,UAAU,CAAC;AAGhC,UAAI,QAAQ,QAAQ,OAAO;AACvB,eAAO,KAAK;AAAA,UACR;AAAA,UACA,KAAK,KAAK,IAAI,QAAQ,OAAO,GAAG;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AAGA,cAAQ,KAAK,IAAI,OAAO,QAAQ,GAAG;AACnC,aAAO,KAAK,OAAO;AACnB;AAAA,IACJ;AAGA,QAAI,QAAQ,KAAK;AACb,aAAO,KAAK,EAAE,OAAO,KAAK,MAAM,CAAC;AAAA,IACrC;AAGA,SAAK,UAAU,OAAO,MAAM,IAAI,MAAM,GAAG,MAAM;AAAA,EACnD;AAAA,EAEA,eAAe,OAAyB;AACpC,QAAI,MAAM,KAAK,GAAG;AACd,aAAO;AAAA,IACX;AACA,QAAI,KAAK,UAAU,WAAW,GAAG;AAC7B,aAAO;AAAA,IACX;AACA,QAAI,QAAQ,GAAG;AACX,aAAO;AAAA,IACX;AACA,UAAM,eAAe,KAAK,UAAU,KAAK,UAAU,SAAS,CAAC;AAC7D,QAAI,SAAS,aAAa,KAAK;AAC3B,aAAO;AAAA,IACX;AACA,QAAI,KAAK,GACL,KAAK,KAAK,UAAU,SAAS;AAEjC,WAAO,MAAM,IAAI;AACb,YAAM,MAAO,KAAK,OAAQ;AAC1B,YAAM,EAAE,OAAO,KAAK,MAAM,IAAI,KAAK,UAAU,GAAG;AAChD,UAAI,QAAQ;AAAO,aAAK,MAAM;AAAA,eACrB,SAAS;AAAK,aAAK,MAAM;AAAA;AAC7B,eAAO;AAAA,IAChB;AAEA,WAAO;AAAA,EACX;AAAA,EAEQ,iBAAiB,KAAqB;AAE1C,QAAI,KAAK,GACL,KAAK,KAAK,UAAU;AAExB,WAAO,KAAK,IAAI;AACZ,YAAM,MAAO,KAAK,OAAQ;AAC1B,UAAI,KAAK,UAAU,GAAG,EAAE,OAAO,KAAK;AAChC,aAAK,MAAM;AAAA,MACf,OAAO;AACH,aAAK;AAAA,MACT;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ;AACJ,SAAK,YAAY,CAAC;AAAA,EACtB;AACJ;;;AC3FO,IAAM,aAAN,MAAiB;AAAA,EAKpB,cAAc;AACV,SAAK,mBAAmB,IAAI,iBAAyB;AACrD,SAAK,cAAc;AACnB,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,UAAU,KAAgD;AACtD,QAAI,QAAQ,UAAU;AAClB,UAAI,KAAK,gBAAgB,MAAM;AAC3B,aAAK,cAAc,KAAK;AAAA,MAC5B;AACA;AAAA,IACJ;AACA,SAAK,iBAAiB,eAAe,IAAI,OAAO,IAAI,KAAK,KAAK,KAAK;AAAA,EACvE;AAAA,EAEA,YAAY;AACR,SAAK,SAAS;AAAA,EAClB;AAAA,EAEA,QAAQ;AACJ,SAAK,cAAc;AACnB,SAAK,iBAAiB,MAAM;AAAA,EAChC;AAAA,EAEA,aAAa;AACT,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,KAAwB;AACxB,QAAI,QAAQ,UAAU;AAClB,aAAO,KAAK;AAAA,IAChB;AACA,WAAO,KAAK,iBAAiB,eAAe,GAAG;AAAA,EACnD;AACJ;;;AC9BO,IAAM,eAAN,MAA8D;AAAA,EAgBjE,YACI,aACA,WACA,WACF;AACE,SAAK,cAAc;AACnB,SAAK,oBAAoB,oBAAI,IAAI;AACjC,SAAK,qBAAqB,CAAC;AAC3B,SAAK,aAAa,IAAI,WAAW;AACjC,SAAK,UAAU,WAAW;AAC1B,SAAK,SAAS,WAAW;AACzB,SAAK,UAAU;AAEf,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAClB,SAAK,cAAc,aAAa;AAAA,EACpC;AAAA,EAEA,YAAY;AACR,SAAK,WAAW,UAAU;AAAA,EAC9B;AAAA,EAEA,WAAW,KAAwB;AAC/B,UAAM,SAAS,WAAW,IAAI;AAC9B,QAAI,UAAU,OAAO,aAAa,GAAG;AACjC,UAAI,gBAAgB,KAAK,kBAAkB,IAAI,MAAM;AACrD,UAAI,CAAC,eAAe;AAChB,wBAAgB,oBAAI,IAAI;AACxB,aAAK,kBAAkB,IAAI,QAAQ,aAAa;AAAA,MACpD;AACA,UAAI,CAAC,cAAc,IAAI,GAAG,GAAG;AACzB,sBAAc,IAAI,KAAK,KAAK,WAAW,SAAS,CAAC;AAAA,MACrD;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,UAAU,KAAgD;AACtD,QAAI,KAAK,eAAe,GAAG;AACvB;AAAA,IACJ;AACA,SAAK,WAAW,UAAU,GAAG;AAC7B,QAAI,CAAC,KAAK,SAAS;AACf,gBAAU,IAAI;AACd,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AAAA,EAEA,SAAS,OAAe;AACpB,QAAI,KAAK,eAAe,GAAG;AACvB;AAAA,IACJ;AACA,QAAI,KAAK,mBAAmB,SAAS,GAAG;AACpC,iBAAW,gBAAgB,KAAK,oBAAoB;AAChD,qBAAa,OAAO,KAAK,KAAK;AAAA,MAClC;AACA,UAAI,CAAC,KAAK,SAAS;AACf,kBAAU,IAAI;AACd,aAAK,UAAU;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,UAAU,SAA6C;AACnD,SAAK,OAAO;AACZ,UAAM,eAAe;AAAA,MACjB;AAAA,MACA,QAAQ,CAAC;AAAA,IACb;AACA,SAAK,mBAAmB,KAAK,YAAY;AAEzC,WAAO,MAAM;AACT,YAAM,QAAQ,KAAK,mBAAmB,QAAQ,YAAY;AAC1D,UAAI,SAAS,GAAG;AACZ,aAAK,mBAAmB,OAAO,OAAO,CAAC;AACvC,aAAK,QAAQ;AAAA,MACjB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EAEA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAEA,UAAU;AACN,cAAU,IAAI;AACd,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,SAAS;AACL,SAAK,SAAS;AACd,iBAAa,IAAI;AAEjB,SAAK,kBAAkB,MAAM;AAC7B,SAAK,qBAAqB,CAAC;AAC3B,SAAK,WAAW,MAAM;AACtB,SAAK,WAAW,WAAW;AAAA,EAC/B;AAAA,EAEA,gBAA+B;AAC3B,IAAI,OAAO,KAAK,aAAa,GAAG,gCAAgC;AAEhE,UAAM,cAAc,oBAAI,IAA8B;AAGtD,eAAW;AAAA,MACP;AAAA,MACA;AAAA,IACJ,KAAK,KAAK,kBAAkB,QAAQ,GAAG;AACnC,UAAI,OAAO,aAAa,GAAG;AACvB,mBAAW,CAAC,KAAK,QAAQ,KAAK,cAAc,QAAQ,GAAG;AACnD,gBAAM,cAAc,KAAK,WAAW,IAAI,GAAG;AAC3C,cAAI,gBAAgB,QAAQ,YAAY,aAAa;AACjD,wBAAY,IAAI,MAAM;AAAA,UAC1B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAGA,eAAW,UAAU,aAAa;AAC9B,WAAK,kBAAkB,OAAO,MAAM;AAAA,IACxC;AAEA,SAAK,mBAAmB,QAAQ,CAAC,iBAAiB;AAC9C,UAAI,aAAa,OAAO,QAAQ;AAC5B,qBAAa,QAAQ,KAAK,YAAY,aAAa,MAAM,CAAC;AAC1D,qBAAa,SAAS,CAAC;AAAA,MAC3B;AAAA,IACJ,CAAC;AAED,SAAK,WAAW,MAAM;AACtB,SAAK,UAAU;AAGf,WAAO,CAAC,GAAG,WAAW;AAAA,EAC1B;AACJ;;;AC1JA,SAAS,YAAY,GAAQ,GAAQ;AACjC,MAAI,MAAM,UAAa,MAAM;AAAW,WAAO;AAC/C,MAAI,MAAM;AAAW,WAAO;AAC5B,MAAI,MAAM;AAAW,WAAO;AAC5B,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,MAAI,OAAO;AAAM,WAAO;AACxB,MAAI,OAAO;AAAM,WAAO;AACxB,SAAO;AACX;AAaO,IAAM,WAAN,MAA6C;AAAA,EAOhD,YACI,MACA,WACA,WACF;AACE,SAAK,QAAQ,QAAQ,CAAC;AACtB,SAAK,eAAe,IAAI;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AACA,SAAK,gBAAgB,CAAC;AAEtB,SAAK,cAAc,aAAa;AAAA,EACpC;AAAA,EAEA,iBAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,OAAe;AACf,SAAK,aAAa,WAAW,KAAK;AAClC,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EAEA,IAAI,OAAe,OAAU;AACzB,QAAI,SAAS,KAAK,MAAM,QAAQ;AAC5B,MAAI,KAAK,kCAAkC;AAC3C,YAAM,QAAa,CAAC;AACpB,eAAS,IAAI,KAAK,MAAM,QAAQ,IAAI,OAAO,EAAE,GAAG;AAC5C,cAAM,KAAK,MAAc;AAAA,MAC7B;AACA,YAAM,KAAK,KAAK;AAChB,WAAK,OAAO,KAAK,MAAM,QAAQ,GAAG,KAAK;AACvC;AAAA,IACJ;AACA,QAAI,KAAK,MAAM,KAAK,MAAM,OAAO;AAE7B;AAAA,IACJ;AACA,SAAK,MAAM,KAAK,IAAI;AACpB,SAAK,aAAa,UAAU,EAAE,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;AAE5D,SAAK,aAAa,SAAS;AAAA,MACvB;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP,OAAO,CAAC,KAAK;AAAA,IACjB,CAAC;AAED,SAAK,aAAa,UAAU;AAAA,EAChC;AAAA,EAEA,UAAU,WAAmB;AACzB,QAAI,YAAY,KAAK,MAAM,QAAQ;AAC/B,WAAK,OAAO,WAAW,KAAK,MAAM,SAAS,WAAW,CAAC,CAAC;AAAA,IAC5D,WAAW,YAAY,KAAK,MAAM,QAAQ;AACtC,YAAM,QAAa,CAAC;AACpB,eAAS,IAAI,KAAK,MAAM,QAAQ,IAAI,WAAW,EAAE,GAAG;AAChD,cAAM,KAAK,MAAc;AAAA,MAC7B;AACA,WAAK,OAAO,KAAK,MAAM,QAAQ,GAAG,KAAK;AAAA,IAC3C;AAAA,EACJ;AAAA,EAEA,YAAY;AACR,SAAK,aAAa,WAAW,QAAQ;AACrC,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY,OAAe,OAAe,OAAY;AAC1D,UAAM,cAAc,KAAK,MAAM;AAC/B,UAAM,UAAU,MAAM,UAAU,OAAO;AAAA,MACnC,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACP;AACA,UAAM,YAAY,KAAK,MAAM;AAE7B,QAAI,gBAAgB,WAAW;AAE3B,WAAK,aAAa,UAAU;AAAA,QACxB,OAAO;AAAA,QACP,KAAK,QAAQ,MAAM;AAAA,MACvB,CAAC;AAAA,IACL,OAAO;AAEH,WAAK,aAAa,UAAU,EAAE,OAAO,OAAO,KAAK,UAAU,CAAC;AAG5D,WAAK,aAAa,UAAU,EAAE,OAAO,WAAW,KAAK,YAAY,CAAC;AAClE,WAAK,aAAa,UAAU,QAAQ;AAAA,IACxC;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,OAAe,OAAe,OAAY;AAC7C,QAAI,UAAU,KAAK,MAAM,WAAW,GAAG;AAEnC,aAAO,CAAC;AAAA,IACZ;AACA,QAAI;AACJ,QAAI,QAAQ,CAAC,KAAK,MAAM,QAAQ;AAC5B,mBAAa;AAAA,IACjB,WAAW,QAAQ,GAAG;AAClB,mBAAa,KAAK,MAAM,SAAS;AAAA,IACrC,WAAW,QAAQ,KAAK,MAAM,QAAQ;AAClC,mBAAa,KAAK,MAAM;AAAA,IAC5B,OAAO;AACH,mBAAa;AAAA,IACjB;AAEA,UAAM,UAAU,KAAK,YAAY,YAAY,OAAO,KAAK;AAEzD,SAAK,aAAa,SAAS;AAAA,MACvB;AAAA,MACA,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACJ,CAAC;AAED,SAAK,aAAa,UAAU;AAC5B,WAAO;AAAA,EACX;AAAA,EAEA,KAAK,SAAiC,aAAa;AAC/C,UAAM,UAAU,KAAK,MAChB,IAAI,CAAC,SAAY,UAAkB,KAAK,EACxC,KAAK,CAAC,GAAG,MAAM,OAAO,KAAK,MAAM,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC,CAAC;AACxD,SAAK,MAAM,KAAK,MAAM;AAEtB,SAAK,aAAa,SAAS;AAAA,MACvB;AAAA,MACA,MAAM;AAAA,MACN;AAAA,IACJ,CAAC;AAGD,SAAK,aAAa,UAAU,EAAE,OAAO,GAAG,KAAK,KAAK,MAAM,OAAO,CAAC;AAEhE,SAAK,aAAa,UAAU;AAE5B,WAAO;AAAA,EACX;AAAA,EAEA,UAAU;AACN,UAAM,UAAoB,CAAC;AAC3B,aAAS,IAAI,KAAK,MAAM,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAC7C,cAAQ,KAAK,CAAC;AAAA,IAClB;AAGA,SAAK,MAAM,QAAQ;AAGnB,SAAK,aAAa,SAAS;AAAA,MACvB;AAAA,MACA,MAAM;AAAA,MACN;AAAA,IACJ,CAAC;AAGD,SAAK,aAAa,UAAU,EAAE,OAAO,GAAG,KAAK,KAAK,MAAM,OAAO,CAAC;AAEhE,SAAK,aAAa,UAAU;AAE5B,WAAO;AAAA,EACX;AAAA,EAEA,UAAU,WAAmB,OAAe,SAAiB;AACzD,UAAM,UAAU,KAAK,MAAM,OAAO,WAAW,KAAK;AAClD,SAAK,MAAM,OAAO,SAAS,GAAG,GAAG,OAAO;AAexC,UAAM,aAAa,KAAK,IAAI,WAAW,OAAO;AAC9C,UAAM,aAAa,KAAK,IAAI,WAAW,OAAO,IAAI;AAClD,SAAK,aAAa,UAAU,EAAE,OAAO,YAAY,KAAK,WAAW,CAAC;AAElE,SAAK,aAAa,SAAS;AAAA,MACvB;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA,IAAI;AAAA,IACR,CAAC;AAED,SAAK,aAAa,UAAU;AAAA,EAChC;AAAA,EAEA,UAAU,SAAoD;AAC1D,SAAK,OAAO;AACZ,UAAM,0BAA0B,KAAK,aAAa,UAAU,OAAO;AACnE,YAAQ;AAAA,MACJ;AAAA,QACI;AAAA,QACA,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO,KAAK,MAAM,MAAM;AAAA,MAC5B;AAAA,IACJ,CAAC;AACD,UAAM,gBAAgB,MAAM;AACxB,8BAAwB;AACxB,WAAK,QAAQ;AACb,WAAK,gBAAgB,KAAK,cAAc;AAAA,QACpC,CAAC,QAAQ,QAAQ;AAAA,MACrB;AAAA,IACJ;AACA,UAAM,eAAe;AAAA,MACjB;AAAA,MACA;AAAA,IACJ;AACA,SAAK,cAAc,KAAK,YAAY;AACpC,WAAO,MAAM,aAAa,cAAc;AAAA,EAC5C;AAAA,EAEA,oBAAoB;AAChB,UAAM,WAAW,KAAK;AACtB,SAAK,gBAAgB,CAAC;AACtB,WAAO;AAAA,EACX;AAAA,EAEA,SAAS;AACL,SAAK,aAAa,OAAO;AAAA,EAC7B;AAAA,EAEA,UAAU;AACN,SAAK,aAAa,QAAQ;AAAA,EAC9B;AAAA,EAEA,kBAAkB;AACd,WAAO,KAAK;AAAA,EAChB;AACJ;AAEO,IAAM,kBAAN,MAA6D;AAAA,EAYhE,YACI,QACA,gBAGA,WACF;AACE,SAAK,SAAS;AACd,SAAK,oBAAoB;AACzB,SAAK,iBAAiB;AACtB,SAAK,QAAQ,CAAC;AACd,SAAK,eAAe,IAAI;AAAA,MACpB;AAAA,MACA;AAAA,QACI,SAAS,MAAM;AACX,eAAK,OAAO,OAAO;AACnB,eAAK,oBAAoB,KAAK,OAAO,UAAU,CAAC,WAAW;AACvD,iBAAK,aAAa,MAAM;AAAA,UAC5B,CAAC;AAAA,QACL;AAAA,QACA,QAAQ,MAAM;AACV,eAAK,oBAAoB;AACzB,eAAK,QAAQ,CAAC;AACd,eAAK,OAAO,QAAQ;AAAA,QACxB;AAAA,MACJ;AAAA,MACA;AAAA,IACJ;AACA,SAAK,gBAAgB,CAAC;AAEtB,SAAK,cAAc,aAAa;AAAA,EACpC;AAAA,EAEA,cAAc,QAA+B;AACzC,SAAK,oBAAoB;AACzB,QAAI,KAAK,MAAM,SAAS,GAAG;AACvB,WAAK,aAAa;AAAA,QACd;AAAA,UACI;AAAA,UACA,OAAO;AAAA,UACP,OAAO,KAAK,MAAM;AAAA,QACtB;AAAA,MACJ,CAAC;AAAA,IACL;AACA,SAAK,QAAQ,CAAC;AACd,SAAK,OAAO,QAAQ;AAEpB,SAAK,SAAS;AACd,SAAK,OAAO,OAAO;AACnB,SAAK,oBAAoB,KAAK,OAAO,UAAU,CAAC,WAAW;AACvD,WAAK,aAAa,MAAM;AAAA,IAC5B,CAAC;AAAA,EACL;AAAA,EAEA,IAAI,OAAe;AAKf,SAAK,aAAa,WAAW,KAAK;AAClC,IAAI;AAAA,MACA,SAAS,KAAK,QAAQ,KAAK,MAAM;AAAA,MACjC;AAAA,IACJ;AACA,WAAO,KAAK,MAAM,KAAK;AAAA,EAC3B;AAAA,EAEA,iBAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,OAAe,OAAU;AACzB,UAAM,IAAI,MAAM,WAAW;AAAA,EAC/B;AAAA,EAEA,YAAY;AACR,SAAK,aAAa,WAAW,QAAQ;AACrC,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EAEA,UAAU,SAAoD;AAC1D,SAAK,OAAO;AACZ,UAAM,0BAA0B,KAAK,aAAa,UAAU,OAAO;AACnE,YAAQ;AAAA,MACJ;AAAA,QACI;AAAA,QACA,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO,KAAK,MAAM,MAAM;AAAA,MAC5B;AAAA,IACJ,CAAC;AACD,UAAM,gBAAgB,MAAM;AACxB,8BAAwB;AACxB,WAAK,QAAQ;AACb,WAAK,gBAAgB,KAAK,cAAc;AAAA,QACpC,CAAC,QAAQ,QAAQ;AAAA,MACrB;AAAA,IACJ;AACA,UAAM,eAAe;AAAA,MACjB;AAAA,MACA;AAAA,IACJ;AACA,SAAK,cAAc,KAAK,YAAY;AACpC,WAAO,MAAM,aAAa,cAAc;AAAA,EAC5C;AAAA,EAEA,oBAAoB;AAChB,UAAM,WAAW,KAAK;AACtB,SAAK,gBAAgB,CAAC;AACtB,WAAO;AAAA,EACX;AAAA,EAEQ,aAAa,QAAuC;AACxD,UAAM,oBAAoB,iBAAiB,KAAK,eAAe,MAAM,CAAC;AACtE,eAAW,eAAe,mBAAmB;AACzC,YAAM,eAAe,KAAK,MAAM;AAChC,sBAAgB,KAAK,OAAO,WAAW;AACvC,YAAM,cAAc,KAAK,MAAM;AAC/B,cAAQ,YAAY,MAAM;AAAA,QACtB,4BAA4B;AACxB,eAAK,aAAa,UAAU;AAAA,YACxB,OAAO,YAAY;AAAA,YACnB,KAAK,YAAY,QAAQ,YAAY;AAAA,UACzC,CAAC;AACD,cAAI,iBAAiB,aAAa;AAC9B,kBAAM,WAAW,KAAK,IAAI,cAAc,WAAW;AACnD,iBAAK,aAAa,UAAU;AAAA,cACxB,OAAO,YAAY,QAAQ,YAAY;AAAA,cACvC,KAAK;AAAA,YACT,CAAC;AACD,iBAAK,aAAa,UAAU,QAAQ;AAAA,UACxC;AACA;AAAA,QACJ;AAAA,QACA,wBAA0B;AACtB,gBAAM,aAAa,KAAK;AAAA,YACpB,YAAY;AAAA,YACZ,YAAY;AAAA,UAChB;AACA,gBAAM,WACF,KAAK,IAAI,YAAY,MAAM,YAAY,EAAE,IACzC,YAAY;AAChB,eAAK,aAAa,UAAU;AAAA,YACxB,OAAO;AAAA,YACP,KAAK;AAAA,UACT,CAAC;AACD;AAAA,QACJ;AAAA,QACA,wBAA0B;AACtB,eAAK,aAAa,UAAU;AAAA,YACxB,OAAO,YAAY;AAAA,YACnB,KAAK,YAAY,OAAO,YAAY,QAAQ;AAAA,UAChD,CAAC;AACD;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,aAAa,SAAS,WAAW;AAAA,IAC1C;AACA,SAAK,aAAa,UAAU;AAAA,EAChC;AAAA,EAEA,SAAS;AACL,SAAK,aAAa,OAAO;AAAA,EAC7B;AAAA,EAEA,UAAU;AACN,SAAK,aAAa,QAAQ;AAAA,EAC9B;AAAA,EAEA,kBAAkB;AACd,WAAO,KAAK;AAAA,EAChB;AACJ;AAEO,SAAS,QACZ,QACA,OACiC;AACjC,SAAO,IAAI,gBAAgB,QAAQ,WAAW,QAAQ;AAClD,eAAW,SAAS,QAAQ;AACxB,cAAQ,MAAM,MAAM;AAAA,QAChB;AACI,gBAAM;AAAA,YACF,MAAM,MAAM;AAAA,YACZ,OAAO,MAAM;AAAA,YACb,OAAO,MAAM;AAAA,YACb,OAAO,MAAM,OAAO,IAAI,CAAC,QAAQ,MAAM,GAAG,CAAC;AAAA,UAC/C;AACA;AAAA,QACJ;AACI,gBAAM;AAAA,MACd;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AAEO,SAAS,YACZ,QACA,OACiC;AACjC,QAAM,YAAY,IAAI,UAAqB,CAAC,CAAC;AAC7C,SAAO,IAAI,gBAAgB,QAAQ,WAAW,QAAQ;AAClD,eAAW,SAAS,QAAQ;AACxB,cAAQ,MAAM,MAAM;AAAA,QAChB,4BAA4B;AACxB,gBAAM,cACF,MAAM,OAAO,IAAI,CAAC,SAAS,MAAM,IAAI,CAAC,KAAK,CAAC;AAChD,gBAAM,UAAU;AAAA,YACZ,MAAM;AAAA,YACN,MAAM;AAAA,YACN;AAAA,UACJ,EAAE;AACF,qBAAW,QAAQ,aAAa;AAC5B,kBAAM,UAAU,WAAW,MAAM;AAAA,cAC7B;AAAA,cACA,OAAO;AAAA,cACP,OAAO;AAAA,cACP,OAAO;AAAA,YACX,CAAC;AAAA,UACL;AACA;AAAA,QACJ;AAAA,QACA,wBAA0B;AACtB,gBAAM,UAAU,KAAK,MAAM,MAAM,MAAM,OAAO;AAC9C;AAAA,QACJ;AAAA,QACA,wBAA0B;AACtB,gBAAM,UAAU,KAAK,MAAM,MAAM,MAAM,OAAO,MAAM,EAAE;AACtD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC;AACL;AAEO,SAAS,WACZ,QACA,OACiC;AACjC,SAAO,YAAY,QAAQ,CAAC,SAAU,MAAM,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,CAAE;AACpE;;;AC/hBA,IAAM,mBAAmB,OAAO,YAAY;AAC5C,IAAM,qBAAqB,OAAO,cAAc;AAkEhD,SAAS,qBACL,cACA,0BACA,YACA,OAGF;AACE,QAAM,SAAS,aAAa,eAAe;AAC3C,QAAM,kBAAwD;AAAA,IAC1D,SAAS,MAAM;AACX,aAAO;AAAA,IACX;AAAA,IACA,QAAQ,MAAM;AACV,mBAAa,OAAO;AAAA,IACxB;AAAA,IACA,SAAS,MAAM;AACX,mBAAa,QAAQ;AAAA,IACzB;AAAA,IACA,SAAS,CAAI,IAAmB,cAC5B,KAAK,QAAQ,cAAc,EAAE,GAAG,SAAS;AAAA,IAC7C,YAAY,CAAC,IAAyB,cAClC,KAAK,WAAW,cAAc,EAAE,GAAG,SAAS;AAAA,IAChD,aAAa,CAAI,IAAqB,cAClC,KAAK,YAAY,cAAc,EAAE,GAAG,SAAS;AAAA,IAEjD,WAAW,CAAC,YACR,aAAa,UAAU,OAAO;AAAA,IAElC,CAAC,kBAAkB,GAAG,MAAM;AAAA,IAE5B,GAAG;AAAA,EACP;AAEA,QAAM,wBAAwB,CAAC,SAA0B;AACrD,QAAI,SAAS,kBAAkB;AAC3B,aAAO;AAAA,QACH,OAAO;AAAA,QACP,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,cAAc;AAAA,MAClB;AAAA,IACJ;AACA,QAAI,QAAQ,iBAAiB;AACzB,aAAO;AAAA,QACH,OAAO,gBAAgB,IAAoC;AAAA,QAC3D,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,cAAc;AAAA,MAClB;AAAA,IACJ;AACA,QAAI,SAAS,UAAU;AACnB,aAAO;AAAA,QACH,OAAO,aAAa,UAAU;AAAA,QAC9B,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,cAAc;AAAA,MAClB;AAAA,IACJ;AACA,UAAM,cAAc,OAAO,SAAS,WAAW,SAAS,IAAI,IAAI;AAChE,QAAI,gBAAgB,QAAQ,YAAY,SAAS,MAAM,MAAM;AACzD,aAAO;AAAA,QACH,OAAO,aAAa,IAAI,WAAW;AAAA,QACnC,UAAU;AAAA,QACV,YAAY;AAAA,QACZ,cAAc;AAAA,MAClB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,EAAE,OAAO,OAAO,IAAI,MAAM,UAAU,QAAQ;AAAA,IAC9C,KAAK,CAAC,QAAQ,MAAM,aAAa;AAC7B,YAAM,aAAa,sBAAsB,IAAI;AAC7C,UAAI,CAAC,YAAY;AACb,eAAO,OAAO,IAAW;AAAA,MAC7B;AACA,aAAO,WAAW;AAAA,IACtB;AAAA,IACA,KAAK,CAAC,QAAQ,MAAM,OAAO,aAAa;AACpC,UAAI,SAAS,kBAAkB;AAC3B,eAAO;AAAA,MACX;AACA,UAAI,QAAQ,iBAAiB;AACzB,QAAI;AAAA,UACA;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AACA,UAAI,SAAS,UAAU;AACnB,eAAO,MAAM,MAAM,KAAK;AAAA,MAC5B;AACA,YAAM,cACF,OAAO,SAAS,WAAW,SAAS,IAAI,IAAI;AAChD,UAAI,gBAAgB,QAAQ,YAAY,SAAS,MAAM,MAAM;AACzD,eAAO,MAAM,aAAa,KAAK;AAAA,MACnC;AACA,MAAI;AAAA,QACA;AAAA,QACA,EAAE,KAAK;AAAA,MACX;AACA,aAAO;AAAA,IACX;AAAA,IACA,KAAK,CAAC,QAAQ,SAAS;AACnB,aAAO,sBAAsB,IAAI,MAAM;AAAA,IAC3C;AAAA,IACA,SAAS,CAAC,WAAW;AACjB,YAAM,OAAiB,CAAC;AACxB,YAAM,SAAS,aAAa,UAAU;AACtC,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC7B,aAAK,KAAK,EAAE,SAAS,CAAC;AAAA,MAC1B;AACA,WAAK,KAAK,QAAQ;AAClB,aAAO;AAAA,IACX;AAAA,IACA,gBAAgB,MAAM;AAClB,MAAI,KAAK,6CAA6C;AACtD,aAAO;AAAA,IACX;AAAA,IACA,gBAAgB,MAAM;AAClB,MAAI,KAAK,qCAAqC;AAC9C,aAAO;AAAA,IACX;AAAA,IACA,0BAA0B,CAAC,QAAQ,SAAS;AACxC,aAAO,sBAAsB,IAAI;AAAA,IACrC;AAAA,IACA,gBAAgB,MAAM;AAClB,MAAI,KAAK,6CAA6C;AACtD,aAAO;AAAA,IACX;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AAEO,SAAS,WACZ,SAAc,CAAC,GACf,YAAoB,cACP;AACb,QAAM,WAAW,IAAI,SAAS,QAAQ,SAAS;AAC/C,QAAM,OAAO;AAAA,IACT;AAAA,IACA;AAAA,MACI,OAAO,WAAuC;AAC1C,cAAM,UAAe,CAAC;AACtB,iBAAS,IAAI,SAAS,UAAU,IAAI,GAAG,KAAK,GAAG,EAAE,GAAG;AAChD,cAAI,UAAU,SAAS,IAAI,CAAC,CAAC,GAAG;AAC5B,oBAAQ,KAAK,SAAS,OAAO,GAAG,GAAG,CAAC,CAAC,EAAG,CAAC,CAAC;AAAA,UAC9C;AAAA,QACJ;AACA,eAAO,QAAQ,QAAQ;AAAA,MAC3B;AAAA,MACA,UAAU,MAAc,OAAe,IAAY;AAC/C,iBAAS,UAAU,MAAM,OAAO,EAAE;AAAA,MACtC;AAAA,MACA,OAAO,OAAe,UAAkB,OAAY;AAChD,eAAO,SAAS,OAAO,OAAO,OAAO,KAAK;AAAA,MAC9C;AAAA,MACA,KAAK,IAA6B;AAC9B,iBAAS,KAAK,EAAE;AAChB,eAAO;AAAA,MACX;AAAA,MACA,UAAU;AACN,iBAAS,QAAQ;AACjB,eAAO;AAAA,MACX;AAAA,MACA,MAAM;AACF,cAAM,SAAS,SAAS,eAAe,EAAE;AACzC,YAAI,WAAW,GAAG;AACd,iBAAO;AAAA,QACX;AACA,eAAO,SAAS,OAAO,SAAS,GAAG,GAAG,CAAC,CAAC,EAAG,CAAC;AAAA,MAChD;AAAA,MACA,QAAQ;AACJ,cAAM,SAAS,SAAS,eAAe,EAAE;AACzC,YAAI,WAAW,GAAG;AACd,iBAAO;AAAA,QACX;AACA,eAAO,SAAS,OAAO,GAAG,GAAG,CAAC,CAAC,EAAG,CAAC;AAAA,MACvC;AAAA,MACA,WAAW,OAAY;AACnB,iBAAS,OAAO,GAAG,GAAG,KAAK;AAC3B,eAAO,SAAS,eAAe,EAAE;AAAA,MACrC;AAAA,MACA,QAAQ,OAAY;AAChB,iBAAS,OAAO,UAAU,GAAG,KAAK;AAClC,eAAO,SAAS,eAAe,EAAE;AAAA,MACrC;AAAA,MACA,SAAS;AACL,eAAO,KAAK,QAAQ;AAAA,MACxB;AAAA,MACA,cAAc,CACV,kBACa;AACb,eAAO,qBAAqB,eAAe,MAAM,SAAS;AAAA,MAC9D;AAAA,MACA,aAAa;AAAA,IACjB;AAAA,IACA;AAAA,IACA,CAAC,MAAM,UAAU;AACb,UAAI,SAAS,UAAU;AACnB,iBAAS,UAAU,KAAK;AAAA,MAC5B,OAAO;AACH,iBAAS,IAAI,MAAM,KAAK;AAAA,MAC5B;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAEO,SAAS,KACZ,UACA,YAAoB,QAAQ,SAAS,gBAC9B;AACP,WAAS,cAAuB;AAC5B,UAAM,IAAI,MAAM,6BAA6B;AAAA,EACjD;AACA,QAAM,IAAI;AAAA,IACN;AAAA,IACA;AAAA,MACI,MAAM;AAAA,MACN,SAAS;AAAA,MACT,KAAK;AAAA,MACL,OAAO;AAAA,MACP,cAAc,CACV,kBACa;AACb,eAAO,qBAAqB,eAAe,GAAG,SAAS;AAAA,MAC3D;AAAA,MACA,aAAa;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA,SAAO;AACX;AAEO,SAAS,gBAAgB,MAA2C;AACvE,SAAO,KAAK,kBAAkB,EAAE;AACpC;AAEO,SAAS,mBACZ,OACoC;AACpC,SAAO,CAAC,EACJ,SACA,OAAO,UAAU,YACjB,oBAAoB,SACpB,MAAM,gBAAgB,MAAM;AAEpC;;;ACpTO,IAAM,cAAN,MAAmE;AAAA,EAiBtE,YACI,aACA,WACA,WACF;AACE,SAAK,cAAc;AACnB,SAAK,oBAAoB,oBAAI,IAAI;AACjC,SAAK,qBAAqB,CAAC;AAC3B,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,QAAQ;AACb,SAAK,UAAU,WAAW;AAC1B,SAAK,SAAS,WAAW;AACzB,SAAK,UAAU;AAEf,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAClB,SAAK,cAAc,aAAa;AAAA,EACpC;AAAA,EAEA,YAAY;AACR,SAAK,SAAS;AAAA,EAClB;AAAA,EAEA,WAAW,KAAW;AAClB,UAAM,SAAS,WAAW,IAAI;AAC9B,QAAI,UAAU,OAAO,aAAa,GAAG;AACjC,UAAI,gBAAgB,KAAK,kBAAkB,IAAI,MAAM;AACrD,UAAI,CAAC,eAAe;AAChB,wBAAgB,oBAAI,IAAI;AACxB,aAAK,kBAAkB,IAAI,QAAQ,aAAa;AAAA,MACpD;AACA,UAAI,CAAC,cAAc,IAAI,GAAG,GAAG;AACzB,sBAAc,IAAI,KAAK,KAAK,KAAK;AAAA,MACrC;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,UAAU,KAAW;AACjB,QAAI,KAAK,eAAe,GAAG;AACvB;AAAA,IACJ;AACA,QAAI,CAAC,KAAK,UAAU,IAAI,GAAG,GAAG;AAC1B,WAAK,UAAU,IAAI,KAAK,KAAK,KAAK;AAAA,IACtC;AACA,QAAI,CAAC,KAAK,SAAS;AACf,gBAAU,IAAI;AACd,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AAAA,EAEA,SAAS,OAAe;AACpB,QAAI,KAAK,eAAe,GAAG;AACvB;AAAA,IACJ;AACA,QAAI,KAAK,mBAAmB,SAAS,GAAG;AACpC,iBAAW,gBAAgB,KAAK,oBAAoB;AAChD,qBAAa,OAAO,KAAK,KAAK;AAAA,MAClC;AACA,UAAI,CAAC,KAAK,SAAS;AACf,kBAAU,IAAI;AACd,aAAK,UAAU;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,UAAU,SAA6C;AACnD,SAAK,OAAO;AACZ,UAAM,eAAe;AAAA,MACjB,eAAe,MAAM;AACjB,cAAM,QAAQ,KAAK,mBAAmB,QAAQ,YAAY;AAC1D,YAAI,SAAS,GAAG;AACZ,eAAK,mBAAmB,OAAO,OAAO,CAAC;AACvC,eAAK,QAAQ;AAAA,QACjB;AAAA,MACJ;AAAA,MACA;AAAA,MACA,QAAQ,CAAC;AAAA,IACb;AACA,SAAK,mBAAmB,KAAK,YAAY;AAEzC,WAAO,MAAM,aAAa,cAAc;AAAA,EAC5C;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EAEA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAEA,UAAU;AACN,cAAU,IAAI;AACd,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,SAAS;AACL,SAAK,SAAS;AACd,iBAAa,IAAI;AAEjB,SAAK,kBAAkB,MAAM;AAC7B,SAAK,qBAAqB,CAAC;AAC3B,SAAK,UAAU,MAAM;AACrB,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,gBAA+B;AAC3B,IAAI,OAAO,KAAK,aAAa,GAAG,+BAA+B;AAE/D,UAAM,cAAc,oBAAI,IAA8B;AAGtD,eAAW;AAAA,MACP;AAAA,MACA;AAAA,IACJ,KAAK,KAAK,kBAAkB,QAAQ,GAAG;AACnC,UAAI,OAAO,aAAa,GAAG;AACvB,mBAAW,CAAC,KAAK,QAAQ,KAAK,cAAc,QAAQ,GAAG;AACnD,gBAAM,cAAc,KAAK,UAAU,IAAI,GAAG;AAC1C,cAAI,gBAAgB,UAAa,YAAY,aAAa;AACtD,wBAAY,IAAI,MAAM;AAAA,UAC1B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAGA,eAAW,UAAU,aAAa;AAC9B,WAAK,kBAAkB,OAAO,MAAM;AAAA,IACxC;AAEA,SAAK,mBAAmB,QAAQ,CAAC,iBAAiB;AAC9C,UAAI,aAAa,OAAO,QAAQ;AAC5B,qBAAa,QAAQ,KAAK,YAAY,aAAa,MAAM,CAAC;AAC1D,qBAAa,SAAS,CAAC;AAAA,MAC3B;AAAA,IACJ,CAAC;AAED,SAAK,UAAU,MAAM;AACrB,SAAK,UAAU;AAGf,WAAO,CAAC,GAAG,WAAW;AAAA,EAC1B;AAAA,EAEA,oBAAoB;AAChB,UAAM,WAAW,KAAK;AACtB,SAAK,qBAAqB,CAAC;AAC3B,WAAO;AAAA,EACX;AACJ;;;ACjLO,IAAK,gBAAL,kBAAKC,mBAAL;AACH,EAAAA,eAAA,SAAM;AACN,EAAAA,eAAA,SAAM;AACN,EAAAA,eAAA,SAAM;AAHE,SAAAA;AAAA,GAAA;AAYZ,UAAU,gBAAsB,QAA2B;AACvD,MAAI,OAAO,WAAW,GAAG;AACrB;AAAA,EACJ;AACA,MAAI,YAAyC,OAAO,CAAC;AACrD,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACpC,UAAM,QAAQ,OAAO,CAAC;AACtB,QAAI,WAAW,SAAS,MAAM,MAAM;AAChC,cAAQ,UAAU,MAAM;AAAA,QACpB,KAAK;AAAA,QACL,KAAK;AACD,cAAI,MAAM,SAAS,iBAAmB;AAClC,wBAAY;AAAA,cACR,MAAM,UAAU;AAAA;AAAA,cAChB,MAAM,MAAM;AAAA,cACZ,OAAO,MAAM;AAAA;AAAA,YACjB;AACA;AAAA,UACJ;AACA,cAAI,MAAM,SAAS,iBAAmB;AAClC,wBAAY;AACZ;AAAA,UACJ;AACA;AAAA,QACJ,KAAK;AACD,cAAI,MAAM,SAAS,iBAAmB;AAClC,wBAAY;AAAA,cACR,MAAM;AAAA;AAAA,cACN,MAAM,MAAM;AAAA,cACZ,OAAO,MAAM;AAAA,YACjB;AAAA,UACJ;AACA;AAAA,MACR;AAAA,IACJ,OAAO;AACH,UAAI,WAAW;AACX,cAAM;AAAA,MACV;AACA,kBAAY;AAAA,IAChB;AAAA,EACJ;AACA,MAAI,WAAW;AACX,UAAM;AAAA,EACV;AACJ;AAEA,IAAM,aAAa,OAAO,UAAU;AACpC,IAAM,aAAa,OAAO,UAAU;AACpC,IAAM,oBAAoB,OAAO,aAAa;AAEvC,IAAM,OAAN,MAAuC;AAAA,EAU1C,YAAY,MAAyC,WAAoB;AACrE,SAAK,QAAQ,IAAI,IAAI,QAAQ,CAAC,CAAC;AAC/B,SAAK,iBAAiB,IAAI,IAAI;AAAA,MAC1B;AAAA,MACA,CAAC;AAAA,MACD;AAAA,IACJ;AAEA,SAAK,aAAa;AAClB,SAAK,cAAc,aAAa;AAAA,EACpC;AAAA,EAEA,iBAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,KAAuB;AACvB,SAAK,iBAAiB,EAAE,WAAW,GAAG;AACtC,WAAO,KAAK,MAAM,IAAI,GAAG;AAAA,EAC7B;AAAA,EAEA,IAAI,KAAiB;AACjB,SAAK,iBAAiB,EAAE,WAAW,GAAG;AACtC,WAAO,KAAK,MAAM,IAAI,GAAG;AAAA,EAC7B;AAAA,EAEA,IAAI,KAAQ,OAAU;AAClB,QAAI,KAAK,MAAM,IAAI,GAAG,MAAM,OAAO;AAE/B;AAAA,IACJ;AACA,UAAM,SAAS,KAAK,MAAM,IAAI,GAAG;AACjC,SAAK,MAAM,IAAI,KAAK,KAAK;AACzB,SAAK,iBAAiB,EAAE,UAAU,GAAG;AAErC,QAAI,CAAC,QAAQ;AACT,WAAK,iBAAiB,EAAE,UAAU,UAAU;AAC5C,WAAK,iBAAiB,EAAE,UAAU,UAAU;AAAA,IAChD;AAEA,SAAK,iBAAiB,EAAE,SAAS;AAAA,MAC7B,MAAM,SAAS,kBAAoB;AAAA,MACnC,MAAM;AAAA,MACN;AAAA,IACJ,CAAC;AAED,SAAK,iBAAiB,EAAE,UAAU;AAAA,EACtC;AAAA,EAEA,OAAO,KAAQ;AACX,QAAI,CAAC,KAAK,MAAM,IAAI,GAAG,GAAG;AAEtB;AAAA,IACJ;AACA,SAAK,MAAM,OAAO,GAAG;AACrB,SAAK,iBAAiB,EAAE,UAAU,GAAG;AACrC,SAAK,iBAAiB,EAAE,UAAU,UAAU;AAC5C,SAAK,iBAAiB,EAAE,UAAU,UAAU;AAE5C,SAAK,iBAAiB,EAAE,SAAS;AAAA,MAC7B,MAAM;AAAA,MACN,MAAM;AAAA,IACV,CAAC;AAED,SAAK,iBAAiB,EAAE,UAAU;AAAA,EACtC;AAAA,EAEA,QAAQ;AACJ,QAAI,KAAK,MAAM,SAAS,GAAG;AAEvB;AAAA,IACJ;AACA,UAAM,OAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AACzC,SAAK,MAAM,MAAM;AACjB,eAAW,OAAO,MAAM;AACpB,WAAK,iBAAiB,EAAE,UAAU,GAAG;AACrC,WAAK,iBAAiB,EAAE,SAAS;AAAA,QAC7B,MAAM;AAAA,QACN,MAAM;AAAA,MACV,CAAC;AAAA,IACL;AACA,SAAK,iBAAiB,EAAE,UAAU,UAAU;AAE5C,SAAK,iBAAiB,EAAE,UAAU;AAAA,EACtC;AAAA,EAEA,QAAQ,IAAgC;AACpC,eAAW,CAAC,KAAK,KAAK,KAAK,KAAK,QAAQ,GAAG;AACvC,SAAG,OAAO,GAAG;AAAA,IACjB;AAAA,EACJ;AAAA,EAEA,SAAS,WAA6B;AAClC,QAAI;AACJ,UAAM,SAAS,IAAI,SAAY,CAAC,GAAG,WAAW;AAAA,MAC1C,SAAS,MAAM;AACX,uBAAe,KAAK,UAAU,CAAC,WAAW;AACtC,qBAAW,SAAS,QAAQ;AACxB,oBAAQ,MAAM,MAAM;AAAA,cAChB,KAAK;AACD,uBAAO,OAAO,UAAU,GAAG,CAAC,MAAM,IAAI,CAAC;AACvC;AAAA,cACJ,KAAK;AACD;AAAA,cACJ,KAAK,iBAAmB;AACpB,sBAAM,QAAQ,OAAO,eAAe;AACpC,sBAAM,QAAQ,MAAM,QAAQ,MAAM,IAAI;AACtC,oBAAI,UAAU,IAAI;AACd,yBAAO,OAAO,OAAO,GAAG,CAAC,CAAC;AAAA,gBAC9B;AACA;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,MACA,QAAQ,MAAM;AACV,uBAAe;AACf,uBAAe;AAAA,MACnB;AAAA,IACJ,CAAC;AACD,UAAM,WAAW,KAAK,QAAQ,SAAS;AACvC,WAAO;AAAA,EACX;AAAA,EAEA,CAAC,OAAO;AACJ,SAAK,iBAAiB,EAAE,WAAW,UAAU;AAC7C,UAAM,OAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AACzC,eAAW,OAAO,MAAM;AACpB,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,CAAC,SAAS;AACN,SAAK,iBAAiB,EAAE,WAAW,UAAU;AAC7C,UAAM,OAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AACzC,UAAM,SAAc,CAAC;AACrB,eAAW,OAAO,MAAM;AACpB,WAAK,iBAAiB,EAAE,WAAW,GAAG;AACtC,aAAO,KAAK,KAAK,MAAM,IAAI,GAAG,CAAE;AAAA,IACpC;AACA,eAAW,SAAS,QAAQ;AACxB,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,CAAC,UAAU;AACP,SAAK,iBAAiB,EAAE,WAAW,UAAU;AAC7C,UAAM,OAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AACzC,UAAM,UAAoB,CAAC;AAC3B,eAAW,OAAO,MAAM;AACpB,WAAK,iBAAiB,EAAE,WAAW,GAAG;AACtC,cAAQ,KAAK,CAAC,KAAK,KAAK,MAAM,IAAI,GAAG,CAAE,CAAC;AAAA,IAC5C;AACA,eAAW,SAAS,SAAS;AACzB,YAAM;AAAA,IACV;AAAA,EACJ;AAAA,EAEA,IAAI,OAAO;AACP,SAAK,iBAAiB,EAAE,WAAW,UAAU;AAC7C,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EAEA,UAAU,SAAsD;AAC5D,SAAK,OAAO;AAEZ,UAAM,gBAA2C;AAAA,MAC7C,MAAM,KAAK,KAAK,MAAM,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO;AAAA,QACpD,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,MACJ,EAAE;AAAA,IACN;AACA,YAAQ,aAAa;AAErB,UAAM,cAAc,KAAK,iBAAiB,EAAE,UAAU,OAAO;AAC7D,WAAO,MAAM;AACT,kBAAY;AACZ,WAAK,QAAQ;AAAA,IACjB;AAAA,EACJ;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EAEA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAEA,UAAU;AACN,SAAK,iBAAiB,EAAE,OAAO;AAAA,EACnC;AAAA,EAEA,SAAS;AACL,SAAK,iBAAiB,EAAE,QAAQ;AAAA,EACpC;AACJ;AA9Ma;AAgNN,SAAS,mBACZC,OACuE;AACvE,SAAOA,MAAK,iBAAiB;AACjC;AAEO,SAAS,KAAW,UAAoB,CAAC,GAAG,WAAoB;AACnE,SAAO,IAAI,KAAW,SAAS,SAAS;AAC5C;AAEO,SAAS,OAAO,OAAiD;AACpE,SAAO,iBAAiB;AAC5B;;;AC/QA,IAAM,+BAA+B,OAAO,wBAAwB;AAE7D,IAAM,QAAN,MAAiE;AAAA,EAcpE,YAAY,KAAQ,WAAoB;AACpC,SAAK,OAAO;AACZ,SAAK,eAAe;AACpB,SAAK,iBAAiB,CAAC;AAEvB,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAElB,SAAK,cAAc,aAAa;AAAA,EACpC;AAAA,EAEA,MAAS;AACL,eAAW,IAAI;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,IAAI,QAAW;AACX,QAAI,WAAW,KAAK,MAAM;AACtB,UAAI,KAAK,cAAc;AACnB,aAAK,gBAAgB;AAAA,MACzB;AACA,WAAK,OAAO;AACZ,UAAI,KAAK,aAAa,GAAG;AACrB,kBAAU,IAAI;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,UAAU,SAA4D;AAClE,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK;AAAc,WAAK,eAAe,oBAAI,IAAI;AACpD,UAAM,eAA+C;AAAA,MACjD,eAAe,MAAM;AACjB,YAAI,KAAK,cAAc,IAAI,OAAO,GAAG;AACjC,eAAK,cAAc,OAAO,OAAO;AACjC,eAAK,QAAQ;AAAA,QACjB;AACA,aAAK,iBAAiB,KAAK,eAAe;AAAA,UACtC,CAAC,QAAQ,QAAQ;AAAA,QACrB;AAAA,MACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA;AAAA,IACJ;AACA,SAAK,eAAe,KAAK,YAAY;AACrC,SAAK,aAAa,IAAI,SAAS,KAAK,YAAY;AAChD,YAAQ,QAAW,KAAK,IAAI;AAC5B,WAAO,MAAM,aAAa,cAAc;AAAA,EAC5C;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EAEA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAEA,UAAU;AACN,cAAU,IAAI;AAAA,EAClB;AAAA,EAEA,SAAS;AACL,iBAAa,IAAI;AACjB,SAAK,eAAe;AACpB,SAAK,iBAAiB,CAAC;AAAA,EAC3B;AAAA,EAEA,gBAA+B;AAC3B,IAAI,OAAO,KAAK,aAAa,GAAG,yBAAyB;AACzD,QAAI,KAAK,cAAc;AACnB,iBAAW,CAAC,YAAY,YAAY,KAAK,KAAK,cAAc;AACxD,YAAI,eAAe,KAAK,cAAc;AAClC,qBAAW,QAAW,KAAK,IAAI;AAAA,QACnC;AACA,aAAK,aAAa,IAAI,YAAY,CAAC;AAAA,MACvC;AACA,WAAK,eAAe;AAAA,IACxB;AACA,WAAO,CAAC,GAAG,uBAAuB,IAAI,CAAC;AAAA,EAC3C;AAAA,EAEA,IAAO,IAAmC;AACtC,WAAO,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC;AAAA,EACpC;AAAA,EAEA,CAAC,4BAA4B,IAAI;AAC7B,UAAM,WAAW,KAAK;AACtB,SAAK,iBAAiB,CAAC;AACvB,WAAO;AAAA,EACX;AACJ;AAEO,SAAS,MAAS,KAAQ,WAA8B;AAC3D,SAAO,IAAI,MAAM,KAAK,SAAS;AACnC;AAEO,SAAS,uBAA0BC,QAAiB;AACvD,SAAOA,OAAM,4BAA4B,EAAE;AAC/C;;;ACpIO,SAAS,wBACZ,kBACA,sBACA,YACA,YACA,WACU;AACV,MAAI,QAAQ;AACZ,QAAM,aAAqC,CAAC;AAC5C,QAAM,QAAkB,CAAC;AACzB,QAAM,kBAA8B,CAAC;AAErC,YAAU,eAAe,QAAgB;AACrC,eAAW,QAAQ,iBAAiB,MAAM,GAAG;AACzC,YAAM,UAAU,qBAAqB,IAAI;AACzC,UACI,YAAY,UACZ,cAAc,WACd,WAAW,YACb;AACE,cAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAEA,QAAM,gBAAgB,CAAC,WAAmB;AACtC,WAAO,QAAQ;AACf,WAAO,UAAU;AACjB,YAAQ,QAAQ;AAChB,UAAM,KAAK,MAAM;AACjB,WAAO,UAAU;AAGjB,eAAW,QAAQ,eAAe,OAAO,MAAM,GAAG;AAC9C,UAAI,CAAC,WAAW,IAAI,GAAG;AACnB,mBAAW,IAAI,IAAI;AAAA,UACf,QAAQ;AAAA,QACZ;AAAA,MACJ;AACA,YAAM,WAAW,WAAW,IAAI;AAChC,UAAI,SAAS,UAAU,QAAW;AAE9B,sBAAc,QAAQ;AACtB,eAAO,UAAU,KAAK;AAAA;AAAA,UAElB,OAAO;AAAA;AAAA,UAEP,SAAS;AAAA,QACb;AAAA,MACJ,WAAW,SAAS,SAAS;AAKzB,eAAO,UAAU,KAAK;AAAA;AAAA,UAElB,OAAO;AAAA,UACP,SAAS;AAAA,QACb;AAAA,MACJ;AAAA,IACJ;AAGA,QAAI,OAAO,YAAY,OAAO,OAAO;AAEjC,YAAM,YAAsB,CAAC;AAC7B,iBAAS;AAEL,cAAM,WAAW,MAAM,IAAI;AAC3B,iBAAS,UAAU;AAEnB,kBAAU,KAAK,SAAS,MAAM;AAC9B,YAAI,aAAa,QAAQ;AACrB;AAAA,QACJ;AAAA,MACJ;AAEA,sBAAgB,KAAK,SAAS;AAAA,IAClC;AAAA,EACJ;AAEA,aAAW,UAAU,WAAW;AAC5B,QAAI,CAAC,WAAW,MAAM,GAAG;AACrB,iBAAW,MAAM,IAAI;AAAA,QACjB;AAAA,MACJ;AACA,oBAAc,WAAW,MAAM,CAAC;AAAA,IACpC;AAAA,EACJ;AAEA,SAAO;AACX;;;AC+BA,IAAM,mBAAoC;AAC1C,IAAM,mBAAoC;AAC1C,IAAM,wBAAoC;AAC1C,IAAM,4BAAoC;AAUnC,IAAM,QAAN,MAAqB;AAAA,EA4CxB,YACIC,iBAIF;AACE,SAAK,kBAAkBA;AAEvB,SAAK,SAAS;AACd,SAAK,eAAe,CAAC;AACrB,SAAK,mBAAmB,CAAC;AAEzB,SAAK,aAAa,CAAC;AACnB,SAAK,aAAa,oBAAI,IAAI;AAE1B,SAAK,iBAAiB,CAAC;AACvB,SAAK,gBAAgB,CAAC;AACtB,SAAK,uBAAuB,CAAC;AAC7B,SAAK,sBAAsB,CAAC;AAE5B,SAAK,mBAAmB,CAAC;AACzB,SAAK,mBAAmB,CAAC;AAEzB,SAAK,mBAAmB;AACxB,SAAK,eAAe,oBAAI,IAAI;AAE5B,SAAK,qBAAqB,oBAAI,IAAI;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAAiB;AACvB,IAAI,OAAO,CAAC,KAAK,WAAW,IAAI,MAAM,GAAG,wBAAwB;AAEjE,QAAI;AACJ,QAAI,KAAK,aAAa,SAAS,GAAG;AAC9B,WAAK,KAAK,aAAa,IAAI;AAAA,IAC/B,OAAO;AACH,WAAK,KAAK;AAAA,IACd;AAEA,SAAK,WAAW,IAAI,QAAQ,EAAE;AAC9B,SAAK,WAAW,EAAE,IAAI;AACtB,SAAK,eAAe,EAAE,IAAI;AAE1B,QAAI;AACJ,QAAI,KAAK,iBAAiB,SAAS,GAAG;AAClC,cAAQ,KAAK,iBAAiB,IAAI;AAAA,IACtC,OAAO;AACH,cAAQ,KAAK,oBAAoB;AACjC,WAAK,oBAAoB,UAAU;AAAA,IACvC;AAEA,SAAK,qBAAqB,EAAE,IAAI;AAChC,SAAK,oBAAoB,KAAK,IAAI;AAElC,SAAK,iBAAiB,EAAE,IAAI,CAAC;AAC7B,SAAK,iBAAiB,EAAE,IAAI,CAAC;AAAA,EACjC;AAAA,EAEA,aAAa,QAAiB;AAC1B,UAAM,KAAK,KAAK,WAAW,IAAI,MAAM;AACrC,IAAI,OAAO,IAAI,uBAAuB;AACtC,UAAM,QAAQ,KAAK,qBAAqB,EAAE;AAC1C,IAAI,OAAO,UAAU,QAAW,iBAAiB;AAGjD,IAAI;AAAA,MACA,KAAK,iBAAiB,EAAE,EAAE,WAAW;AAAA,MACrC;AAAA,IACJ;AACA,IAAI;AAAA,MACA,KAAK,iBAAiB,EAAE,EAAE,WAAW;AAAA,MACrC;AAAA,IACJ;AAEA,SAAK,qBAAqB,EAAE,IAAI;AAChC,SAAK,oBAAoB,KAAK,IAAI;AAElC,SAAK,sBAAsB,EAAE;AAC7B,SAAK,eAAe,EAAE,IAAI;AAC1B,WAAO,KAAK,cAAc,EAAE;AAC5B,SAAK,WAAW,OAAO,MAAM;AAC7B,SAAK,WAAW,EAAE,IAAI;AACtB,SAAK,aAAa,OAAO,EAAE;AAG3B,SAAK,aAAa,KAAK,EAAE;AACzB,SAAK,iBAAiB,KAAK,KAAK;AAAA,EACpC;AAAA,EAEA,UAAU,QAAiB;AACvB,WAAO,KAAK,WAAW,IAAI,MAAM;AAAA,EACrC;AAAA,EAEA,gBAAgB,QAAiB;AAC7B,UAAM,WAAW,KAAK,WAAW,IAAI,MAAM;AAC3C,IAAI,OAAO,UAAU,uCAAuC;AAC5D,SAAK,qBAAqB,QAAQ;AAAA,EACtC;AAAA,EAEQ,qBAAqB,UAAkB;AAC3C,UAAM,SAAS,KAAK,WAAW,QAAQ;AACvC,QAAI,UAAU,EAAE,KAAK,eAAe,QAAQ,IAAI,mBAAmB;AAC/D,WAAK,eAAe,QAAQ,KAAK;AACjC,WAAK,eAAe,QAAQ,KAAK,CAAC;AAClC,WAAK,sBAAsB,UAAU,kBAAwB;AAE7D,YAAM,QAAQ,KAAK,qBAAqB,QAAQ;AAChD,UAAI,UAAU,UAAa,QAAQ,KAAK,kBAAkB;AACtD,aAAK,mBAAmB;AAAA,MAC5B;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,iBAAiB,QAAiB;AAC9B,UAAM,WAAW,KAAK,WAAW,IAAI,MAAM;AAC3C,IAAI,OAAO,UAAU,uCAAuC;AAC5D,SAAK,sBAAsB,QAAQ;AAAA,EACvC;AAAA,EAEQ,sBAAsB,UAAkB;AAC5C,QAAI,KAAK,eAAe,QAAQ,IAAI,kBAAkB;AAClD,WAAK,eAAe,QAAQ,KAAK,CAAC;AAAA,IACtC;AAAA,EACJ;AAAA,EAEA,wBAAwB,QAAiB;AACrC,UAAM,WAAW,KAAK,WAAW,IAAI,MAAM;AAC3C,IAAI,OAAO,UAAU,+CAA+C;AACpE,SAAK,eAAe,QAAQ,KAAK;AAAA,EACrC;AAAA,EAEA,CAAS,oBACL,UACA,WACA,eACF;AACE,QAAI,WAAW;AACX,YAAM,UAAU,oBAAI,IAAY;AAChC,iBAAW,WAAW,UAAU,WAAW;AACvC,mBAAW,QAAQ,cAAc,OAAO,GAAG;AACvC,cAAI,CAAC,UAAU,UAAU,IAAI,IAAI,KAAK,CAAC,QAAQ,IAAI,IAAI,GAAG;AACtD,oBAAQ,IAAI,IAAI;AAChB,kBAAM;AAAA,UACV;AAAA,QACJ;AAAA,MACJ;AACA;AAAA,IACJ;AACA,eAAW,QAAQ,cAAc,QAAQ,GAAG;AACxC,UAAI,SAAS;AAAU,cAAM;AAAA,IACjC;AAAA,EACJ;AAAA,EAEA,QAAQ,YAAqB,UAAmB;AAC5C,UAAM,SAAS,KAAK,WAAW,IAAI,UAAU;AAC7C,UAAM,OAAO,KAAK,WAAW,IAAI,QAAQ;AACzC,IAAI,OAAO,QAAQ,iCAAiC,EAAE,WAAW,CAAC;AAClE,IAAI,OAAO,MAAM,+BAA+B,EAAE,SAAS,CAAC;AAO5D,SAAK,iBAAiB,MAAM,EAAE,KAAK,IAAI;AACvC,SAAK,iBAAiB,IAAI,EAAE,KAAK,MAAM;AAEvC,QACI,WAAW,SACV,KAAK,eAAe,MAAM,IAAI,2BAA2B,GAC5D;AACE,YAAM,aACF,KAAK,eAAe,MAAM,IAAI;AAClC,UAAI,CAAC,YAAY;AACb,cAAM,SAAS,KAAK,WAAW,MAAM;AACrC,QAAI,OAAO,QAAQ,8BAA8B;AACjD,aAAK,sBAAsB,QAAQ,aAAmB;AACtD,aAAK,eAAe,MAAM,KACtB,4BAA4B;AAAA,MACpC,OAAO;AACH,aAAK,eAAe,MAAM,KAAK;AAAA,MACnC;AAAA,IACJ;AAEA,UAAM,YAAY,KAAK,qBAAqB,MAAM;AAClD,UAAM,UAAU,KAAK,qBAAqB,IAAI;AAC9C,IAAI,OAAO,YAAY,QAAW,iBAAiB;AACnD,IAAI,OAAO,cAAc,QAAW,iBAAiB;AAOrD,UAAM,WAAW,YAAY;AAC7B,QAAI,UAAU;AAKV,WAAK,aAAa,IAAI,MAAM;AAC5B,WAAK,aAAa,IAAI,IAAI;AAAA,IAC9B;AAAA,EACJ;AAAA,EAEA,QAAQ,YAAqB,UAAmB;AAC5C,UAAM,SAAS,KAAK,WAAW,IAAI,UAAU;AAC7C,UAAM,OAAO,KAAK,WAAW,IAAI,QAAQ;AACzC,IAAI,OAAO,QAAQ,+BAA+B;AAClD,IAAI,OAAO,MAAM,6BAA6B;AAE9C,WAAO,KAAK,iBAAiB,MAAM,EAAE,SAAS,IAAI;AAAA,EACtD;AAAA,EAEA,WAAW,YAAqB,UAAmB;AAC/C,UAAM,SAAS,KAAK,WAAW,IAAI,UAAU;AAC7C,UAAM,OAAO,KAAK,WAAW,IAAI,QAAQ;AACzC,IAAI,OAAO,QAAQ,kCAAkC;AACrD,IAAI,OAAO,MAAM,gCAAgC;AAQjD,oBAAgB,KAAK,iBAAiB,MAAM,GAAG,IAAI;AACnD,oBAAgB,KAAK,iBAAiB,IAAI,GAAG,MAAM;AAGnD,QAAI,WAAW,MAAM;AACjB,WAAK,eAAe,MAAM,IACtB,KAAK,eAAe,MAAM,IAAI,CAAC;AAAA,IACvC;AAIA,UAAM,gBAAgB,KAAK,cAAc,MAAM;AAC/C,UAAM,cAAc,KAAK,cAAc,IAAI;AAC3C,QAAI,iBAAiB,eAAe,kBAAkB,aAAa;AAK/D,WAAK,aAAa,IAAI,MAAM;AAC5B,WAAK,aAAa,IAAI,IAAI;AAAA,IAC9B;AAAA,EACJ;AAAA,EAEQ,uBACJ,UACA,YACA,YACA,SACF;AACE,QAAI,QAAQ,IAAI,QAAQ;AAAG;AAC3B,YAAQ,IAAI,QAAQ;AACpB,eAAW,QAAQ,KAAK,iBAAiB,QAAQ,GAAG;AAChD,YAAM,UAAU,KAAK,qBAAqB,IAAI;AAC9C,MAAI,OAAO,YAAY,QAAW,iBAAiB;AACnD,UAAI,cAAc,WAAW,WAAW,YAAY;AAChD,aAAK;AAAA,UACD;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEQ,gBACJ,eACA,YACA,YACF;AACE,UAAM,UAAU,oBAAI,IAAY;AAChC,eAAW,YAAY,eAAe;AAClC,WAAK;AAAA,QACD;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,OAAO,WAAwB;AAGnC,QAAI,aAAa;AACjB,QAAI,aAAa;AACjB,eAAW,YAAY,WAAW;AAC9B,YAAM,YAAY,KAAK,cAAc,QAAQ;AAC7C,UAAI,WAAW;AAKX,YAAI,UAAU,aAAa;AACvB,uBAAa,UAAU;AAC3B,YAAI,UAAU,aAAa;AACvB,uBAAa,UAAU;AAAA,MAC/B,OAAO;AACH,cAAM,QAAQ,KAAK,qBAAqB,QAAQ;AAGhD,QAAI,OAAO,UAAU,QAAW,iBAAiB;AACjD,YAAI,QAAQ;AAAY,uBAAa;AACrC,YAAI,QAAQ;AAAY,uBAAa;AAAA,MACzC;AAAA,IACJ;AAMA,UAAM,eAAe,KAAK;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAMA,UAAM,aAAa;AAAA,MACf,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAKA,UAAM,mBAA6B,CAAC;AACpC,eAAW,aAAa,YAAY;AAChC,iBAAW,YAAY,WAAW;AAC9B,cAAM,QAAQ,KAAK,qBAAqB,QAAQ;AAChD,QAAI,OAAO,UAAU,QAAW,iBAAiB;AACjD,yBAAiB,KAAK,KAAK;AAAA,MAC/B;AAAA,IACJ;AAMA,qBAAiB,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAGrC,QAAI,IAAI;AACR,eAAW,aAAa,YAAY;AAChC,iBAAW,YAAY,WAAW;AAC9B,cAAM,QAAQ,iBAAiB,CAAC;AAChC,aAAK,oBAAoB,KAAK,IAAI;AAClC,aAAK,qBAAqB,QAAQ,IAAI;AACtC,aAAK;AAAA,MACT;AAAA,IACJ;AAQA,eAAW,aAAa,YAAY;AAChC,UAAI;AACJ,UAAI,UAAU,SAAS,GAAG;AACtB,gBAAQ;AAAA,UACJ,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,WAAW,IAAI,IAAI,SAAS;AAAA,QAChC;AAAA,MACJ;AAEA,iBAAW,YAAY,WAAW;AAC9B,YAAI,OAAO;AACP,eAAK,cAAc,QAAQ,IAAI;AAC/B,gBAAM,QAAQ,KAAK,qBAAqB,QAAQ;AAChD,UAAI,OAAO,UAAU,QAAW,iBAAiB;AACjD,cAAI,QAAQ,MAAM;AAAY,kBAAM,aAAa;AACjD,cAAI,QAAQ,MAAM;AAAY,kBAAM,aAAa;AAAA,QACrD;AAAA,MACJ;AAAA,IACJ;AAEA,eAAW,aAAa,YAAY;AAChC,iBAAW,YAAY,WAAW;AAC9B,YAAI,UAAU,SAAS,GAAG;AACtB,cAAI,EAAE,KAAK,eAAe,QAAQ,IAAI,mBAAmB;AACrD,iBAAK,eAAe,QAAQ,KAAK;AAAA,UACrC;AACA,cACI,EACI,KAAK,eAAe,QAAQ,IAC5B,4BAEN;AAEE,kBAAM,SAAS,KAAK,WAAW,QAAQ;AACvC,YAAI,OAAO,QAAQ,2BAA2B;AAC9C,iBAAK;AAAA,cACD;AAAA,cACA;AAAA,YACJ;AACA,iBAAK,eAAe,QAAQ,KACxB;AAAA,UACR;AAAA,QACJ,WAAW,KAAK,eAAe,QAAQ,IAAI,kBAAkB;AAEzD,eAAK,eAAe,QAAQ,IACxB,KAAK,eAAe,QAAQ,IAC5B,EAAE,mBAAmB;AACzB,iBAAO,KAAK,cAAc,QAAQ;AAClC,eAAK,qBAAqB,QAAQ;AAAA,QACtC;AAAA,MACJ;AAAA,IACJ;AAIA,WAAO;AAAA,EACX;AAAA,EAEQ,iBAAiB,KAAa,aAAsB;AACxD,IAAI,OAAO,OAAO,kDAAkD;AACpE,QAAQ,aAAa,MAAM,GAAG;AAE1B,eAAS,IAAI,GAAG,IAAI,KAAK,oBAAoB,QAAQ,EAAE,GAAG;AACtD,cAAM,MAAM,KAAK,oBAAoB,CAAC;AACtC,cAAM,SAAS,gBAAgB,IAAI,OAAO;AAC1C,YAAI,QAAQ,QAAW;AACnB,UAAI,KAAK,GAAG,eAAe,YAAY;AAAA,QAC3C,OAAO;AACH,gBAAM,IAAI,KAAK,WAAW,GAAG;AAC7B,cAAI,CAAC,GAAG;AACJ,YAAI;AAAA,cACA,GAAG,eAAe,SAAS;AAAA,YAC/B;AAAA,UACJ,OAAO;AACH,kBAAM,UAAU,CAAC,EACb,KAAK,eAAe,GAAG,IAAI;AAE/B,kBAAM,YAAY,KAAK,cAAc,GAAG;AACxC,gBAAI,WAAW;AACX,cAAI;AAAA,gBACA,GAAG,eAAe,SAAS,OAAQ,EAAU,oBAAoB,KAAK,iBAAiB,GAAG,GAAG,KAAK,GAAG,YAAY,CAAC,GAAG,UAAU,SAAS,EAAE,KAAK,GAAG,kBAAkB,UAAU,eAAe,UAAU,eAAe,UAAU,UAAU;AAAA,cAC9O;AAAA,YACJ,OAAO;AACH,cAAI;AAAA,gBACA,GAAG,eAAe,SAAS,OAAQ,EAAU,oBAAoB,KAAK,iBAAiB,GAAG,GAAG,KAAK,GAAG,KAAK,UAAU,UAAU;AAAA,cAClI;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEQ,eAAe,aAA2B,QAAuB;AACrE,WAAO,KAAK,gBAAgB,aAAa,MAAM;AAAA,EACnD;AAAA,EAEQ,sBAAsB,UAAkB,QAAuB;AACnE,UAAM,YAAY,KAAK,cAAc,QAAQ;AAE7C,UAAM,YAAsB,CAAC;AAC7B,UAAM,cAAc,oBAAI,IAAa;AACrC,QAAI,WAAW;AACX,iBAAW,iBAAiB,UAAU,WAAW;AAC7C,kBAAU,KAAK,aAAa;AAC5B,cAAM,SAAS,KAAK,WAAW,aAAa;AAC5C,QAAI,OAAO,QAAQ,iBAAiB;AACpC,oBAAY,IAAI,MAAM;AAAA,MAC1B;AAAA,IACJ,OAAO;AACH,gBAAU,KAAK,QAAQ;AACvB,YAAM,SAAS,KAAK,WAAW,QAAQ;AACvC,MAAI,OAAO,QAAQ,iBAAiB;AACpC,kBAAY,IAAI,MAAM;AAAA,IAC1B;AAaA,QAAI,WAAW,eAAqB;AAChC,YAAM,WAAW,UAAU;AAAA,QACvB,CAACC,cAAa,KAAK,eAAeA,SAAQ,IAAI;AAAA,MAClD;AACA,iBAAWA,aAAY,WAAW;AAC9B,cAAM,aACF,KAAK,eAAeA,SAAQ,IAAI;AACpC,YAAI,CAAC,YAAY;AACb,cAAI,UAAU;AACV,iBAAK,eAAeA,SAAQ,KAAK;AAAA,UACrC;AACA,gBAAM,QAAQ,KAAK,qBAAqBA,SAAQ;AAChD,cAAI,UAAU,UAAa,QAAQ,KAAK,kBAAkB;AACtD,iBAAK,mBAAmB;AAAA,UAC5B;AACA,eAAK,eAAeA,SAAQ,KAAK;AAAA,QACrC;AAAA,MACJ;AAAA,IACJ;AAEA,SAAK,gBAAgB,aAAa,MAAM;AAGxC,UAAM,gBAA2B,CAAC;AAClC,eAAW,UAAU,aAAa;AAC9B,UAAI,KAAK,WAAW,IAAI,MAAM,MAAM,QAAW;AAC3C,sBAAc,KAAK,MAAM;AAAA,MAC7B;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,UAAU;AACN,QAAI,OAAO;AACP,WAAK,mBAAmB,QAAQ,CAAC,EAAE,cAAc,UAAU,MAAM;AAC7D,cAAM,QAAQ;AACd;AAAA,UACI,KAAK;AAAA,YACD,CAAC,OAAO;AAAA,cACJ,GAAG,UAAU,CAAC;AAAA,YAClB;AAAA,YACA;AAAA,UACJ;AAAA,UACA;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,KAAK,aAAa,OAAO,GAAG;AAC5B,WAAK,OAAO,KAAK,YAAY;AAC7B,WAAK,aAAa,MAAM;AAAA,IAC5B;AAEA,eAAS;AACL,YAAM,cAAc,KAAK;AACzB,UAAI,eAAe,KAAK,WAAW,QAAQ;AACvC,aAAK,mBAAmB;AACxB;AAAA,MACJ;AACA,WAAK;AAEL,YAAM,WAAW,KAAK,oBAAoB,WAAW;AACrD,UAAI,aAAa,QAAW;AACxB;AAAA,MACJ;AAEA,YAAM,UAAU,KAAK,eAAe,QAAQ,IAAI;AAChD,UAAI,CAAC,SAAS;AACV;AAAA,MACJ;AAIA,YAAM,SAAS,KAAK,WAAW,QAAQ;AACvC,MAAI,OAAO,QAAQ,4BAA4B;AAE/C,YAAM,kBAAkB,KAAK,cAAc,QAAQ;AAGnD,YAAM,cAAc,KAAK;AAAA,QACrB;AAAA,QACA;AAAA,MACJ;AAEA,iBAAWC,WAAU,aAAa;AAC9B,aAAK,iBAAiBA,OAAM;AAAA,MAChC;AAIA,UAAI,KAAK,aAAa,OAAO,GAAG;AAC5B,cAAM,aAAa,KAAK,OAAO,KAAK,YAAY;AAChD,YAAI,aAAa,KAAK,kBAAkB;AACpC,eAAK,mBAAmB;AAAA,QAC5B;AACA,aAAK,aAAa,MAAM;AAAA,MAC5B;AAGA,YAAM,eAAe,KAAK,cAAc,QAAQ;AAGhD,UAAI,CAAC,mBAAmB,cAAc;AAElC,aAAK,sBAAsB,UAAU,aAAmB;AAAA,MAC5D,WAAW,mBAAmB,CAAC,cAAc;AAAA,MAG7C,WAAW,cAAc;AAErB,aAAK,sBAAsB,UAAU,aAAmB;AAAA,MAC5D,WAAW,KAAK,eAAe,QAAQ,IAAI,uBAAuB;AAE9D,aAAK,sBAAsB,UAAU,aAAmB;AAAA,MAC5D;AAAA,IACJ;AAEA,QAAI,OAAO;AACP,WAAK,mBAAmB,QAAQ,CAAC,EAAE,cAAc,UAAU,MAAM;AAC7D,cAAM,QAAQ;AACd;AAAA,UACI,KAAK;AAAA,YACD,CAAC,OAAO;AAAA,cACJ,GAAG,UAAU,CAAC;AAAA,YAClB;AAAA,YACA;AAAA,UACJ;AAAA,UACA;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EAEA,kBAAkB;AACd,QAAI,KAAK,aAAa,OAAO,GAAG;AAC5B,WAAK,OAAO,KAAK,YAAY;AAC7B,WAAK,aAAa,MAAM;AAAA,IAC5B;AAEA,UAAM,WAAsB,CAAC;AAC7B,aACQ,cAAc,GAClB,cAAc,KAAK,oBAAoB,QACvC,EAAE,aACJ;AACE,YAAM,WAAW,KAAK,oBAAoB,WAAW;AACrD,UAAI,aAAa,QAAW;AACxB;AAAA,MACJ;AAEA,YAAM,UAAU,KAAK,eAAe,QAAQ,IAAI;AAChD,UAAI,CAAC,SAAS;AACV;AAAA,MACJ;AAEA,YAAM,SAAS,KAAK,WAAW,QAAQ;AACvC,MAAI,OAAO,QAAQ,4BAA4B;AAC/C,eAAS,KAAK,MAAM;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,eACJ,UACA,gBACF;AACE,SAAK,sBAAsB,QAAQ;AACnC,eAAW,QAAQ,KAAK,iBAAiB,QAAQ,GAAG;AAChD,YAAM,cAAc,KAAK,cAAc,IAAI;AAC3C,UAAI,aAAa;AACb,mBAAW,aAAa,YAAY,WAAW;AAC3C,cAAI,CAAC,kBAAkB,CAAC,eAAe,IAAI,SAAS,GAAG;AACnD,iBAAK,qBAAqB,SAAS;AAAA,UACvC;AAAA,QACJ;AAAA,MACJ,OAAO;AACH,YAAI,CAAC,kBAAkB,CAAC,eAAe,IAAI,IAAI,GAAG;AAC9C,eAAK,qBAAqB,IAAI;AAAA,QAClC;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAGA,CAAC,uBAAuB,QAAiB;AACrC,UAAM,WAAW,KAAK,WAAW,IAAI,MAAM;AAC3C,IAAI;AAAA,MACA,aAAa;AAAA,MACb;AAAA,MACA,EAAE,OAAO;AAAA,IACb;AACA,UAAM,YAAY,KAAK,cAAc,QAAQ;AAC7C,eAAW,QAAQ,KAAK,iBAAiB,QAAQ,GAAG;AAChD,YAAM,WAAW,KAAK,WAAW,IAAI;AACrC,MAAI,OAAO,aAAa,QAAW,iBAAiB;AACpD,UAAI,CAAC,aAAa,CAAC,UAAU,UAAU,IAAI,IAAI,GAAG;AAC9C,cAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAM,UAAmC,OAAgB;AACrD,UAAM,QAAQ,CAAC;AACf,UAAM,KAAK,wBAAwB;AACnC,UAAM,KAAK,aAAa;AACxB,UAAM,KAAK,wBAAwB;AACnC,UAAM,KAAK,wBAAwB;AACnC,QAAI,OAAO;AACP,YAAM,KAAK,kBAAkB,KAAK,UAAU,KAAK,KAAK;AAAA,IAC1D;AAEA,UAAM,aAAa,CAAC,OAAe;AAC/B,YAAM,SAAS,KAAK,WAAW,EAAE;AACjC,UAAI,CAAC;AAAQ;AACb,YAAM,cAAc,SAAS,MAAM;AACnC,YAAM,QAAyC;AAAA,QAC3C,OAAO;AAAA,QACP,OAAO,GAAG;AAAA,EAAO,YAAY;AAAA,MACjC;AAGA,YAAM,QAAQ;AAKd,UAAI,KAAK,eAAe,EAAE,IAAI,kBAAkB;AAC5C,cAAM,QAAQ;AACd,cAAM,YAAY;AAClB,cAAM,YAAY;AAAA,MACtB,OAAO;AACH,cAAM,QAAQ;AACd,cAAM,YAAY;AAClB,cAAM,YAAY;AAAA,MACtB;AAIA,UAAI,YAAY,UAAU;AACtB,cAAM,WAAW;AACjB,cAAM,WAAW;AAAA,MACrB;AAEA,YAAM,aAAuB,CAAC;AAC9B,iBAAW,CAAC,UAAU,OAAO,KAAK,OAAO,QAAQ,KAAK,GAAG;AACrD,mBAAW,KAAK,GAAG,YAAY,KAAK,UAAU,OAAO,GAAG;AAAA,MAC5D;AAEA,YAAM,KAAK,OAAO,OAAO,WAAW,KAAK,GAAG,IAAI;AAAA,IACpD;AAEA,UAAM,SAAS,oBAAI,IAAe;AAClC,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,YAAM,YAAY,KAAK,cAAc,EAAE;AACvC,UAAI,WAAW;AACX,eAAO,IAAI,SAAS;AAAA,MACxB;AAAA,IACJ;AACA,eAAW,SAAS,QAAQ;AACxB,YAAM,KAAK,4BAA4B;AACvC,YAAM,KAAK,0BAA0B;AACrC,iBAAW,WAAW,MAAM,WAAW;AACnC,mBAAW,OAAO;AAAA,MACtB;AACA,YAAM,KAAK,KAAK;AAAA,IACpB;AAEA,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,YAAM,YAAY,KAAK,cAAc,EAAE;AACvC,UAAI;AAAW;AACf,iBAAW,EAAE;AAAA,IACjB;AAEA,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,UAAI,KAAK,iBAAiB,EAAE,GAAG;AAC3B,mBAAW,QAAQ,KAAK,iBAAiB,EAAE,GAAG;AAC1C,gBAAM,KAAK,OAAO,WAAW,OAAO;AAAA,QACxC;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,KAAK,GAAG;AACd,WAAO,MAAM,KAAK,IAAI;AAAA,EAC1B;AAAA,EAEA,eACI,WACA,cACF;AACE,UAAM,QAAQ;AAAA,MACV;AAAA,MACA;AAAA,IACJ;AACA,SAAK,mBAAmB,IAAI,KAAK;AACjC,WAAO,MAAM;AACT,WAAK,mBAAmB,OAAO,KAAK;AAAA,IACxC;AAAA,EACJ;AAAA,EAEA,gBAAgB;AACZ,UAAM,WAAsB,CAAC;AAC7B,aAAS,IAAI,GAAG,IAAI,KAAK,WAAW,QAAQ,EAAE,GAAG;AAC7C,YAAM,SAAS,KAAK,WAAW,CAAC;AAChC,UAAI,QAAQ;AACR,iBAAS,KAAK,MAAM;AAAA,MACxB;AAAA,IACJ;AACA,UAAM,QAA8B,CAAC;AACrC,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,UAAI,KAAK,iBAAiB,EAAE,GAAG;AAC3B,mBAAW,QAAQ,KAAK,iBAAiB,EAAE,GAAG;AAC1C,gBAAM,SAAS,KAAK,WAAW,EAAE;AACjC,gBAAM,SAAS,KAAK,WAAW,IAAI;AACnC,cAAI,UAAU,QAAQ;AAClB,kBAAM,KAAK,CAAC,QAAQ,MAAM,CAAC;AAAA,UAC/B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,EAAE,UAAU,MAAM;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,oBAA+B;AAC3B,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,sBAAsB,QAA4B;AAC9C,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,oBACI,QACuD;AACvD,WAAO,KAAK;AAAA,EAChB;AACJ;AAKA,IAAI,OAAM;AACN,QAAM,UAAU,oBAAoB,SAAS,oBAE3C;AACE,WAAO,KAAK,WAAW,OAAO,CAAC,WAAW,CAAC,CAAC,MAAM;AAAA,EACtD;AACA,QAAM,UAAU,wBAAwB,SAAS,sBAEzB,QAAiB;AACrC,UAAM,KAAK,KAAK,WAAW,IAAI,MAAM;AACrC,IAAI,OAAO,IAAI,uCAAuC;AACtD,WAAO,KAAK,iBAAiB,EAAE,EAAE,IAAI,CAAC,SAAS,KAAK,WAAW,IAAI,CAAC;AAAA,EACxE;AAEA,QAAM,UAAU,sBAAsB,SAAS,oBAE3C,QACF;AACE,UAAM,KAAK,KAAK,WAAW,IAAI,MAAM;AACrC,QAAI,OAAO;AAAW,aAAO;AAC7B,UAAM,QAAQ,KAAK,qBAAqB,EAAE;AAC1C,IAAI,OAAO,UAAU,QAAW,iBAAiB;AACjD,UAAM,OAAO,KAAK,eAAe,EAAE;AACnC,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AACJ;AAEA,SAAS,gBAAgB,OAAiB,OAAe;AACrD,MAAI,UAAU,MAAM,MAAM,SAAS,CAAC,GAAG;AACnC,UAAM,IAAI;AACV;AAAA,EACJ;AACA,QAAM,QAAQ,MAAM,QAAQ,KAAK;AACjC,QAAM,KAAK,IAAI,MAAM,MAAM,SAAS,CAAC;AACrC,QAAM,IAAI;AACd;;;AC1iCO,IAAK,iBAAL,kBAAKC,oBAAL;AACH,EAAAA,gBAAA,SAAM;AADE,SAAAA;AAAA,GAAA;AAUZ,IAAM,kBAAkB,OAAO,WAAW;AAInC,SAAS,aACZC,QACkB;AAClB,QAAMC,QAAQD,OAAc,eAAe;AAC3C,EAAI,OAAOC,OAAM,wCAAwC;AACzD,SAAOA;AACX;AAEO,SAAS,QAAQ,OAAwC;AAC5D,SAAO,CAAC,EAAE,SAAS,OAAO,UAAU,YAAY,mBAAmB;AACvE;AAEO,SAAS,MAAoB,QAAW,WAA8B;AACzE,QAAM,YAAY,KAAK,OAAO,QAAQ,MAAM,GAAG,SAAS;AACxD,QAAM,WAAqB,CAAC;AAC5B,SAAO,KAAK,MAAM,EAAE,QAAQ,CAAC,QAAQ;AACjC,WAAO,eAAe,UAAU,KAAK;AAAA,MACjC,KAAK,MAAM;AACP,eAAO,UAAU,IAAI,GAAG;AAAA,MAC5B;AAAA,MACA,KAAK,CAAC,aAAa;AACf,kBAAU,IAAI,KAAK,QAAQ;AAAA,MAC/B;AAAA,MACA,YAAY;AAAA,IAChB,CAAC;AAAA,EACL,CAAC;AACD,SAAO,eAAe,UAAU,iBAAiB;AAAA,IAC7C,KAAK,MAAM;AAAA,IACX,YAAY;AAAA,EAChB,CAAC;AACD,SAAO;AACX;AAEA,MAAM,YAAY,SAAS,eACvB,aACA,SACA,WACU;AACV,QAAM,YAAY,aAAa,WAAW;AAC1C,SAAO,UAAU,UAAU,CAAC,WAAW;AACnC,UAAM,cAAkC,CAAC;AACzC,eAAW,SAAS,QAAQ;AACxB,UACI,MAAM,4BACN,MAAM,0BACR;AACE,oBAAY,KAAK;AAAA,UACb,MAAM;AAAA,UACN,MAAM,MAAM;AAAA,UACZ,OAAO,MAAM;AAAA,QACjB,CAAC;AAAA,MACL;AAAA,IACJ;AACA,QAAI,YAAY,QAAQ;AACpB,cAAQ,WAAW;AAAA,IACvB;AAAA,EACJ,CAAC;AACL;AAEA,MAAM,QAAQ,SAAS,WACnB,aACAC,QACgB;AAChB,SAAO;AAAA,IACH,KAAK,MAAM,YAAYA,MAAK;AAAA,IAC5B,KAAK,CAAC,aAAmB;AACrB,kBAAYA,MAAK,IAAI;AAAA,IACzB;AAAA,IACA,WAAW,CAAC,YAAY;AACpB,aAAO,MAAM,UAAU,aAAa,CAAC,WAAW;AAC5C,mBAAW,SAAS,QAAQ;AACxB,cAAI,MAAM,SAASA,QAAO;AACtB,oBAAQ,QAAW,MAAM,KAAa;AAAA,UAC1C;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;;;AC/DO,SAAS,cAAc,KAA8B;AACxD,SAAO,OAAO,IAAI,kBAAkB;AACxC;AAeA,IAAI,wBAAwB,IAAI,MAAmB,cAAc;AACjE,IAAI,yBAAoD,CAAC;AACzD,IAAI,aAAa;AACjB,IAAI,aAAa;AACjB,IAAI,cAAmC;AACvC,IAAI,iBAAiBC;AACrB,IAAI,wBAGA,oBAAI,IAAI;AACZ,IAAI,yBAGA,oBAAI,IAAI;AACZ,IAAI,cAA4D,oBAAI,IAAI;AAExE,SAAS,cAAc,UAAsB;AACzC,SAAO;AACX;AAEA,SAASA,kBAAiB,UAAsB;AAC5C,MAAK,OAAe,gBAAgB;AAChC,QAAI,YAAY;AAChB,mBAAe,MAAM;AACjB,UAAI;AAAW;AACf,eAAS;AAAA,IACb,CAAC;AACD,WAAO,MAAM;AACT,kBAAY;AAAA,IAChB;AAAA,EACJ;AACA,QAAM,SAAS,WAAW,UAAU,CAAC;AACrC,SAAO,MAAM,aAAa,MAAM;AACpC;AAEO,SAAS,QAAQ;AACpB,0BAAwB,IAAI,MAAmB,cAAc;AAC7D,2BAAyB,CAAC;AAC1B,eAAa;AACb,eAAa;AACb,MAAI;AAAa,gBAAY;AAC7B,gBAAc;AACd,mBAAiBA;AACjB,0BAAwB,oBAAI,IAAI;AAChC,2BAAyB,oBAAI,IAAI;AACjC,gBAAc,oBAAI,IAAI;AAC1B;AAEO,SAAS,mBACZ,QACA,mBACF;AACE,cAAY,IAAI,QAAQ,iBAAiB;AAC7C;AAEO,SAAS,eAAe,QAA8B;AACzD,QAAM,MAAM,YAAY,IAAI,MAAM;AAClC,MAAI,KAAK;AACL,gBAAY,OAAO,MAAM;AAAA,EAC7B;AACA,SAAO;AACX;AAEO,SAAS,wBACZ,WACA,QACF;AACE,MAAI,UAAU,sBAAsB,IAAI,SAAS;AACjD,MAAI,CAAC,SAAS;AACV,cAAU,oBAAI,IAAI;AAClB,0BAAsB,IAAI,WAAW,OAAO;AAAA,EAChD;AACA,UAAQ,IAAI,MAAM;AACtB;AAEO,SAAS,0BACZ,WACA,QACF;AACE,QAAM,UAAU,sBAAsB,IAAI,SAAS;AACnD,MAAI,SAAS;AACT,YAAQ,OAAO,MAAM;AAAA,EACzB;AACJ;AA2BO,SAAS,QAAQ,cAAuB,aAAsB;AACjE,MAAI;AACJ,MAAI;AAGJ,MAAI;AAGJ,MAAI;AAQJ,MAAI;AAQJ,MAAI;AACJ,MAAI,wBAAwB,OAAO;AAC/B,mBAAe;AACf,+BAA2B,uBAAuB,YAAY;AAAA,EAClE,WAAW,wBAAwB,aAAa;AAC5C,mBAAe;AACf,+BAA2B,sBAAsB,YAAY;AAAA,EACjE,WAAW,QAAQ,YAAY,GAAG;AAC9B,UAAMC,QAAO,aAAa,YAAY;AACtC,UAAM,cAAc,mBAAmBA,KAAI;AAE3C,mBAAe;AACf,+BAA2B;AAAA,MACvB,MAAM,CAAC;AAAA,MACP,eACI,YAAY,kBAAkB;AAAA,IAGtC;AAAA,EACJ,WAAW,mBAAmB,YAAY,GAAG;AACzC,UAAM,eAAe,gBAAgB,YAAY;AACjD,mBAAe,aAAa,gBAAgB;AAC5C,+BAA2B;AAAA,MACvB,QAAQ,aAAa;AAAA,MACrB,eAAe,aAAa,kBAAkB;AAAA,IAClD;AAAA,EACJ,WAAW,OAAO,YAAY,GAAG;AAC7B,UAAM,cAAc,mBAAmB,YAAY;AACnD,QAAI,sBAAsB,UAAU,WAAW,GAAG;AAC9C,iBAAW,OAAO,sBAAsB;AAAA,QACpC;AAAA,MACJ,GAAG;AACC,8BAAsB,gBAAgB,GAAG;AAAA,MAC7C;AAAA,IACJ;AACA,8BAA0B;AAAA,MACtB,MAAM,MAAM,KAAK,aAAa,KAAK,CAAC;AAAA,MACpC,eAAe,YAAY,kBAAkB;AAAA,IACjD;AAAA,EACJ,WACI,OAAO,iBAAiB,cACxB,iBAAiB,YAAY,GAC/B;AACE,sBAAkB;AAAA,EACtB;AAGA,MAAI,cAAc;AACd,QAAI,sBAAsB,UAAU,YAAY,GAAG;AAC/C,iBAAW,OAAO,sBAAsB;AAAA,QACpC;AAAA,MACJ,GAAG;AACC,8BAAsB,gBAAgB,GAAG;AAAA,MAC7C;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,0BAA0B;AAC1B,eAAW,gBAAgB,0BAA0B;AACjD,mBAAa,cAAc;AAC3B,UACI,uBAAuB,eACvB,uBAAuB,OACzB;AACE,qBAAa,gBAAgB,YAAY;AAAA,UACrC,aAAa;AAAA,QACjB;AAAA,MACJ,OAAO;AACH,qBAAa,gBAAgB;AAC7B,qBAAa;AAAA,UACT,IAAI;AAAA,YACA;AAAA,UACJ;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAEA,MAAI,0BAA0B;AAC1B,eAAW,gBAAgB,yBAAyB,eAAe;AAC/D,mBAAa,QAAQ;AAAA,QACjB;AAAA,UACI;AAAA,UACA,OAAO;AAAA,UACP,OAAO,yBAAyB;AAAA,QACpC;AAAA,MACJ,CAAC;AACD,mBAAa,cAAc;AAE3B,UAAI,mBAAmB,WAAW,GAAG;AACjC,qBAAa,gBAAgB,YAAY;AAAA,UACrC,aAAa;AAAA,QACjB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,yBAAyB;AACzB,eAAW,gBAAgB,wBAAwB,eAAe;AAC9D,mBAAa;AAAA,QACT,wBAAwB,KAAK,IAAI,CAAC,SAAS;AAAA,UACvC;AAAA,UACA,MAAM;AAAA,QACV,EAAE;AAAA,MACN;AACA,mBAAa,cAAc;AAE3B,UAAI,OAAO,WAAW,GAAG;AACrB,qBAAa,gBAAgB,YAAY;AAAA,UACrC,aAAa;AAAA,QACjB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,0BAA0B;AAC1B,eAAW,gBAAgB,yBAAyB,eAAe;AAC/D,mBAAa,cAAc;AAE3B,UAAI,QAAQ,WAAW,GAAG;AACtB,qBAAa,gBAAgB,MAAM;AAAA,UAC/B;AAAA,UACA,aAAa;AAAA,QACjB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGA,MAAI,iBAAiB;AACjB,UAAM,mBAAmB,sBAAsB,IAAI,eAAe;AAClE,QAAI,kBAAkB;AAElB,YAAM,iBACF,OAAO,gBAAgB,cACvB,iBAAiB,WAAW,IACrB,cACD,MAAM;AACF,QAAI;AAAA,UACA;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AACV,uBAAiB,QAAQ,CAAC,cAAc;AACpC,kBAAU,cAAc;AACxB,gCAAwB,gBAAgB,SAAS;AAAA,MACrD,CAAC;AAAA,IACL;AACA,0BAAsB,OAAO,eAAe;AAAA,EAChD;AACJ;AAEA,SAAS,gBAAgB;AACrB,MAAI;AAAY;AAChB,eAAa;AACb,gBAAc,eAAe,MAAM;AAC/B,iBAAa;AACb,kBAAc;AACd,eAAW;AAAA,EACf,CAAC;AACL;AAEO,SAAS,QAAQ;AACpB,MAAI,YAAY;AACZ;AAAA,EACJ;AACA,MAAI,aAAa;AACb,gBAAY;AACZ,kBAAc;AAAA,EAClB;AACA,eAAa;AACb,aAAW;AACf;AAEO,SAAS,UAAU,WAAkD;AACxE,mBAAiB,aAAa;AAClC;AAEO,SAAS,OAAO,YAAwB;AAQ3C,aAAW,cAAc;AACzB,MAAI,WAAW,eAAe,GAAG;AAC7B,eAAW,QAAQ;AAAA,EACvB;AACJ;AAEO,SAAS,QAAQ,YAAwB;AAQ5C,EAAI,OAAO,WAAW,aAAa,GAAG,gBAAgB;AACtD,MAAI,WAAW,eAAe,GAAG;AAC7B,eAAW,OAAO;AAAA,EACtB;AACA,aAAW,cAAc;AAC7B;AAEA,SAAS,eAAe,aAA+B,QAAuB;AAC1E,QAAM,eAAe,oBAAI,IAAiB;AAC1C,aAAW,UAAU,aAAa;AAQ9B,YAAQ,QAAQ;AAAA,MACZ;AACI,eAAO,eAAe;AACtB;AAAA,MACJ;AACI,eACK,gBAAgB,WAAW,EAC3B,QAAQ,CAAC,MAAM,aAAa,IAAI,CAAC,CAAC;AACvC;AAAA,MACJ;AACI,eAAO,UAAU;AAEjB,mBAAW,YAAY;AAAA,UACnB;AAAA,QACJ,GAAG;AACC,uBAAa,IAAI,QAAQ;AAAA,QAC7B;AACA;AAAA,MACJ;AACI,QAAI,gBAAgB,QAAQ,gBAAgB;AAAA,IACpD;AAAA,EACJ;AACA,aAAW,UAAU,aAAa;AAC9B,iBAAa,OAAO,MAAM;AAAA,EAC9B;AACA,aAAW,UAAU,cAAc;AAG/B,cAAU,MAAM;AAAA,EACpB;AACA,SAAO;AACX;AAEA,SAAS,aAAa;AAClB,eAAa;AACb,wBAAsB,QAAQ;AAC9B,SAAO;AACP,eAAa;AACb,MAAI,YAAY;AAGZ,UAAM;AAAA,EACV;AACJ;AAEO,SAAS,UAAU,QAAqB;AAE3C,wBAAsB,UAAU,MAAM;AAC1C;AAEO,SAAS,aAAa,QAAqB;AAE9C,wBAAsB,aAAa,MAAM;AAC7C;AAEO,SAAS,QAAQ,YAAyB,UAAuB;AAQpE,wBAAsB,QAAQ,YAAY,QAAQ;AACtD;AAEO,SAAS,WAAW,YAAyB,UAAuB;AAQvE,wBAAsB,WAAW,YAAY,QAAQ;AACzD;AAEO,SAAS,UAAU,QAAqB;AAE3C,wBAAsB,gBAAgB,MAAM;AAC5C,gBAAc;AAClB;AAOO,SAAS,kBAAkB,QAAqB;AAMnD,wBAAsB,wBAAwB,MAAM;AACxD;AAEO,SAAS,WACZ,QACA,IACA,WACC;AAED,yBAAuB,KAAK,MAAM;AAClC,MAAI;AACA,WAAO,GAAG;AAAA,EACd,UAAE;AAEE,IAAI;AAAA,MACA,WAAW,uBAAuB,IAAI;AAAA,MACtC;AAAA,IACJ;AAAA,EACJ;AACJ;AAEO,SAAS,aAAgB,IAAa,WAAuB;AAEhE,yBAAuB,KAAK,IAAI;AAChC,MAAI;AACA,WAAO,GAAG;AAAA,EACd,UAAE;AAEE,IAAI;AAAA,MACA,SAAS,uBAAuB,IAAI;AAAA,MACpC;AAAA,IACJ;AAAA,EACJ;AACJ;AAEO,SAAS,WACZ,YACsC;AACtC,MAAI,uBAAuB,WAAW;AAAG,WAAO;AAChD,QAAM,SAAS,uBAAuB,uBAAuB,SAAS,CAAC;AACvE,MAAI,QAAQ;AAOR,WAAO,OAAO,UAAU;AAAA,EAC5B;AACA,SAAO;AACX;AAEO,UAAU,uBAAuB,YAAsC;AAC1E,SAAO,sBAAsB,uBAAuB,UAAU;AAClE;AAEO,SAASC,OAAM,cAA4B,OAAgB;AAC9D,SAAO,sBAAsB,MAAM,CAAC,WAAW;AAC3C,WAAO;AAAA,MACH,UAAU,WAAW;AAAA,MACrB,MAAM,GAAG,OAAO,mBAAoB,OAAe;AAAA,IACvD;AAAA,EACJ,GAAG,KAAK;AACZ;AAEO,SAAS,eAAe,IAA+C;AAC1E,SAAO,sBAAsB,eAAe,CAAC,WAAW;AACpD,WAAO;AAAA,MACH,UAAU;AAAA,MACV,MAAM,OAAO;AAAA,IACjB;AAAA,EACJ,GAAG,EAAE;AACT;AAEO,SAAS,gBAAgB;AAC5B,QAAM,EAAE,UAAU,MAAM,IAAI,sBAAsB,cAAc;AAChE,QAAM,SAAS,oBAAI,IAAyB;AAC5C,WAAS,QAAQ,CAAC,WAAW;AACzB,WAAO,IAAI,QAAQ,OAAO,WAAW;AAAA,EACzC,CAAC;AACD,SAAO,EAAE,UAAU,OAAO,OAAO;AACrC;;;AC9ZA,SAAS,YAAe,GAAM,GAAM;AAChC,SAAO,MAAM;AACjB;AAEA,IAAM,8BAA8B,OAAO,uBAAuB;AAE3D,IAAM,cAAN,MAAoE;AAAA,EAa/D,eAGN;AACE,UAAM,SAAS,KAAK;AACpB,QAAI,UAAU,CAAC,OAAO,IAAI;AACtB,aAAO,EAAE,WAAW,OAAO,OAAO;AAAA,IACtC;AACA,QAAI,QAAQ,MAAM,CAAC,OAAO,OAAO;AAE7B,aAAO,EAAE,WAAW,OAAO,OAAO;AAAA,IACtC;AACA,QAAI,QAAQ,MAAM,OAAO,OAAO;AAG5B,YAAM,YAAY,OAAO;AACzB,YAAM,YAAY,KAAK,OAAO;AAC9B,UAAI,UAAU,MAAM,KAAK,IAAI,WAAW,UAAU,KAAK,GAAG;AAGtD,eAAO;AAAA,UACH,WAAW;AAAA,UACX,QAAQ;AAAA,YACJ,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,OAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AACA,aAAO,EAAE,WAAW,MAAM,QAAQ,UAAU;AAAA,IAChD;AAEA,WAAO,EAAE,WAAW,MAAM,QAAQ,KAAK,OAAO,EAAE;AAAA,EACpD;AAAA,EAEA,MAAS;AACL,eAAW,IAAI;AACf,UAAM,EAAE,OAAO,IAAI,KAAK,aAAa;AACrC,QAAI,CAAC,OAAO,IAAI;AACZ,YAAM,OAAO;AAAA,IACjB;AACA,WAAO,OAAO;AAAA,EAClB;AAAA,EAEA,SAAS;AACL,QAAI,KAAK,cAAc;AACnB,YAAM,IAAI;AAAA,QACN;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAGA,SAAK,eAAe;AACpB,QAAI;AACJ,UAAM,kBAAkB,oBAAI,IAA8B;AAC1D,QAAI;AACA,eAAS;AAAA,QACL,IAAI;AAAA,QACJ,OAAO;AAAA,QACP,OAAO;AAAA,UACH,CAAC,eAAe;AACZ,gBAAI,CAAC,gBAAgB,IAAI,UAAU,GAAG;AAClC,8BAAgB,IAAI,UAAU;AAC9B,qBAAO,UAAU;AACjB,kBACI,CAAC,KAAK,cAAc,IAAI,UAAU,KAClC,cAAc,UAAU,KACxB,KAAK,aAAa,GACpB;AACE,wBAAQ,YAAY,IAAI;AAAA,cAC5B;AAAA,YACJ;AACA,mBAAO;AAAA,UACX;AAAA,UACA,MAAM,KAAK,IAAI;AAAA,UACf,KAAK;AAAA,QACT;AAAA,MACJ;AAAA,IACJ,SAAS,GAAP;AACE,eAAS;AAAA,QACL,IAAI;AAAA,QACJ,OAAO,UAAU,CAAC;AAAA,MACtB;AAAA,IACJ;AACA,SAAK,eAAe;AAGpB,eAAW,kBAAkB,KAAK,eAAe;AAC7C,UACI,CAAC,gBAAgB,IAAI,cAAc,KACnC,cAAc,cAAc,KAC5B,KAAK,aAAa,GACpB;AAEE,mBAAW,gBAAgB,IAAI;AAAA,MACnC;AACA,cAAQ,cAAc;AAAA,IAC1B;AACA,SAAK,gBAAgB;AAErB,UAAM,mBACF,CAAC,OAAO,MAAM,OAAO,iBAAiB,wBAChC,OAAO,QACP;AAEV,QAAI,kBAAkB;AAGlB,UAAI,KAAK,aAAa,GAAG;AACrB,0BAAkB,IAAI;AAAA,MAC1B;AAEA,UAAI,iBAAiB,sBAAsB,MAAM;AAE7C,yBAAiB,qBAAqB,IAAI,IAAI;AAAA,MAClD,OAAO;AAOH,mBAAW,eAAe,iBAAiB,sBAAsB;AAC7D,sBAAY,aAAa;AAAA,QAC7B;AAGA,cAAM,oBAAoB,IAAI;AAAA,UAC1B,KAAK;AAAA,QACT;AACA,mBAAW,eAAe,iBAAiB,sBAAsB;AAC7D,qBAAW,cAAc,YAAY,QAAQ,GAAG;AAC5C,8BAAkB,IAAI,UAAU;AAAA,UACpC;AAAA,QACJ;AACA,mBAAW,eAAe,iBAAiB,sBAAsB;AAC7D,4BAAkB,OAAO,WAAW;AAAA,QACxC;AACA,0BAAkB,OAAO,IAAI;AAAA,MACjC;AAAA,IACJ;AAEA,QAAI,CAAC,OAAO,IAAI;AACZ,UAAIC;AACJ,UACI,OAAO,iBAAiB,yBACxB,OAAO,MAAM,sBAAsB,MACrC;AAGE,QAAAA,SAAQ,IAAI;AAAA,UACR;AAAA,QACJ;AAAA,MACJ,OAAO;AACH,QAAAA,SAAQ,OAAO;AAAA,MACnB;AACA,UAAI,KAAK,eAAe;AACpB,YAAI;AACA,mBAAS;AAAA,YACL,IAAI;AAAA,YACJ,OAAO;AAAA,YACP,OAAO,KAAK,cAAcA,MAAK;AAAA,UACnC;AAAA,QACJ,SAAS,YAAP;AAEE,mBAAS;AAAA,YACL,IAAI;AAAA,YACJ,OAAO,UAAU,UAAU;AAAA,UAC/B;AAAA,QACJ;AAAA,MACJ,OAAO;AACH,iBAAS;AAAA,UACL,IAAI;AAAA,UACJ,OAAAA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,KAAK,aAAa,GAAG;AACrB,WAAK,UAAU;AAAA,IACnB;AAEA,QAAI,oBAAoB,iBAAiB,sBAAsB,MAAM;AAEjE,YAAM;AAAA,IACV;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,YAAY,IAAa,WAAoB;AACzC,SAAK,aAAa;AAClB,SAAK,cAAc,aAAa,SAAS,GAAG;AAC5C,SAAK,gBAAgB;AACrB,SAAK,UAAU;AACf,SAAK,MAAM;AACX,SAAK,gBAAgB;AACrB,SAAK,eAAe;AACpB,SAAK,MAAM;AACX,SAAK,gBAAgB,oBAAI,IAAI;AAC7B,SAAK,iBAAiB,CAAC;AAAA,EAC3B;AAAA,EAEA,QAAQ,SAAoC;AACxC,SAAK,gBAAgB;AACrB,WAAO;AAAA,EACX;AAAA,EAEA,OAAO,IAAmC;AACtC,SAAK,MAAM;AACX,WAAO;AAAA,EACX;AAAA,EAEA,UAAU,SAAyD;AAC/D,WAAO,IAAI;AACX,QAAI;AACJ,QAAI;AACA,aAAO,CAAC,QAAW,KAAK,IAAI,CAAC;AAAA,IACjC,SAAS,GAAP;AACE,aAAO,CAAC,UAAU,CAAC,GAAG,MAAS;AAAA,IACnC;AACA,QAAI,CAAC,KAAK,gBAAgB;AACtB,WAAK,iBAAiB,CAAC;AAAA,IAC3B;AACA,UAAM,eAA+C;AAAA,MACjD,eAAe,MAAM;AACjB,aAAK,iBAAiB,KAAK,eAAe;AAAA,UACtC,CAAC,QAAQ,QAAQ;AAAA,QACrB;AACA,gBAAQ,IAAI;AAAA,MAChB;AAAA,MACA;AAAA,IACJ;AACA,SAAK,eAAe,KAAK,YAAY;AACrC,YAAQ,GAAG,IAAI;AACf,WAAO,MAAM,aAAa,cAAc;AAAA,EAC5C;AAAA,EAEA,SAAS;AACL,WAAO,IAAI;AAAA,EACf;AAAA,EAEA,UAAU;AACN,YAAQ,IAAI;AAAA,EAChB;AAAA,EAEA,UAAU;AACN,cAAU,IAAI;AACd,SAAK,cAAc,MAAM;AAAA,EAC7B;AAAA,EAEA,SAAS;AACL,SAAK,UAAU;AAEf,eAAW,cAAc,KAAK,eAAe;AACzC,UAAI,cAAc,UAAU,GAAG;AAC3B,mBAAW,YAAY,IAAI;AAAA,MAC/B;AACA,cAAQ,UAAU;AAAA,IACtB;AACA,SAAK,cAAc,MAAM;AACzB,iBAAa,IAAI;AAAA,EACrB;AAAA,EAEA,cAAc,aAA8C;AACxD,UAAM,EAAE,WAAW,OAAO,IAAI,KAAK,aAAa;AAKhD,SAAK,oBAAoB,MAAM;AAO/B,UAAM,cAA6B,CAAC;AACpC,QAAI,WAAW;AACX,iBAAW,cAAc,uBAAuB,IAAI,GAAG;AACnD,oBAAY,KAAK,UAAU;AAAA,MAC/B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEA,eAAqB;AACjB,QAAI,KAAK,SAAS,IAAI;AAClB,WAAK,UAAU,EAAE,GAAG,KAAK,SAAS,OAAO,KAAK;AAAA,IAClD,OAAO;AACH,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AAAA,EAEA,UAAyB;AACrB,UAAMA,SAAQ,IAAI;AAAA,MACd;AAAA,IACJ;AACA,QAAI,KAAK,eAAe;AACpB,UAAI;AACA,aAAK,UAAU;AAAA,UACX,IAAI;AAAA,UACJ,OAAO;AAAA,UACP,OAAO,KAAK,cAAcA,MAAK;AAAA,QACnC;AAAA,MACJ,SAAS,GAAP;AACE,aAAK,UAAU,EAAE,IAAI,OAAO,OAAO,UAAU,CAAC,EAAE;AAAA,MACpD;AAAA,IACJ,OAAO;AACH,WAAK,UAAU;AAAA,QACX,IAAI;AAAA,QACJ,OAAAA;AAAA,MACJ;AAAA,IACJ;AACA,SAAK,oBAAoB,KAAK,OAAO;AACrC,WAAO,CAAC,GAAG,uBAAuB,IAAI,CAAC;AAAA,EAC3C;AAAA,EAEQ,oBAAoB,QAA8B;AACtD,eAAW,gBAAgB,KAAK,gBAAgB;AAC5C,UAAI,OAAO,IAAI;AACX,qBAAa,QAAQ,QAAW,OAAO,KAAK;AAAA,MAChD,OAAO;AACH,qBAAa,QAAQ,OAAO,OAAO,MAAS;AAAA,MAChD;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,IAAO,IAAmC;AACtC,WAAO,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC,CAAC;AAAA,EACpC;AAAA,EAEA,CAAC,2BAA2B,IAAI;AAC5B,UAAM,WAAW,KAAK;AACtB,SAAK,iBAAiB,CAAC;AACvB,WAAO;AAAA,EACX;AACJ;AAEO,IAAM,aAAN,cAAyB,MAAM;AAAC;AAEvC,IAAM,mBAAN,cAA+B,WAAW;AAAC;AAEpC,IAAM,wBAAN,cAAoC,WAAW;AAAA,EAIlD,YAAY,KAAa,mBAAqC;AAC1D,UAAM,GAAG;AACT,SAAK,oBAAoB;AACzB,SAAK,uBAAuB,oBAAI,IAAI;AAAA,EACxC;AACJ;AAEO,SAAS,KAAQ,IAAa,WAAoB;AACrD,SAAO,IAAI,YAAY,IAAI,SAAS;AACxC;AAEO,SAAS,sBAAyBC,OAAsB;AAC3D,SAAOA,MAAK,2BAA2B,EAAE;AAC7C;;;ACphBO,SAAS,gBAAgB,MAAsC;AAClE,SAAO,CAAC,EACJ,QACA,OAAO,SAAS,YAChB,kBAAkB,QAClB,OAAO,KAAK,iBAAiB;AAErC;AAqFA,SAAS,yBACL,KACkB;AAClB,MAAI,CAAC;AAAK,WAAO;AACjB,SAAO;AACX;AAEA,SAAS,2BACL,KACkB;AAClB,MAAI,QAAQ;AAAW,WAAO;AAC9B,SAAO,OAAO,QAAQ,WAAW,MAAM,SAAS,GAAG;AACvD;AAEA,SAAS,UAAU,KAAyD;AACxE,MAAI,QAAQ;AAAW,WAAO;AAC9B,SAAO,QAAQ,OAAO,QAAQ;AAClC;AAMA,IAAM,eAUF;AAAA,EACA,kBAAkB,EAAE,KAAK,gBAAgB;AAAA,EACzC,eAAe,EAAE,KAAK,aAAa;AAAA,EACnC,qBAAqB,EAAE,KAAK,mBAAmB;AAAA,EAC/C,aAAa,EAAE,KAAK,WAAW;AAAA,EAC/B,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,qBAAqB,EAAE,KAAK,mBAAmB;AAAA,EAC/C,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,eAAe,EAAE,KAAK,aAAa;AAAA,EACnC,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,qBAAqB,EAAE,KAAK,mBAAmB;AAAA,EAC/C,cAAc,EAAE,KAAK,YAAY;AAAA,EACjC,cAAc,EAAE,KAAK,YAAY;AAAA,EACjC,aAAa,EAAE,KAAK,WAAW;AAAA,EAC/B,cAAc,EAAE,KAAK,YAAY;AAAA,EACjC,kBAAkB,EAAE,KAAK,gBAAgB;AAAA,EACzC,wBAAwB,EAAE,KAAK,sBAAsB;AAAA,EACrD,oBAAoB,EAAE,KAAK,kBAAkB;AAAA,EAC7C,oBAAoB,EAAE,KAAK,kBAAkB;AAAA,EAC7C,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,wBAAwB,EAAE,KAAK,sBAAsB;AAAA,EACrD,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,qBAAqB,EAAE,KAAK,mBAAmB;AAAA,EAC/C,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,gBAAgB,EAAE,KAAK,cAAc;AAAA,EACrC,aAAa,EAAE,KAAK,WAAW;AAAA,EAC/B,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,iBAAiB,EAAE,KAAK,eAAe;AAAA,EACvC,kBAAkB,EAAE,KAAK,gBAAgB;AAAA,EACzC,cAAc,EAAE,KAAK,YAAY;AAAA,EACjC,MAAM,CAAC;AAAA,EACP,QAAQ,CAAC;AAAA,EACT,WAAW,EAAE,KAAK,YAAY;AAAA,EAC9B,QAAQ,CAAC;AAAA,EACT,OAAO,CAAC;AAAA,EACR,iBAAiB,EAAE,KAAK,kBAAkB;AAAA,EAC1C,KAAK,CAAC;AAAA,EACN,IAAI,CAAC;AAAA,EACL,OAAO,CAAC;AAAA,EACR,gBAAgB,CAAC;AAAA,EACjB,cAAc,CAAC;AAAA,EACf,WAAW,CAAC;AAAA,EACZ,UAAU,EAAE,KAAK,MAAM,KAAK,yBAAyB;AAAA,EACrD,SAAS,EAAE,KAAK,KAAK;AAAA,EACrB,SAAS,CAAC;AAAA,EACV,MAAM,CAAC;AAAA,EACP,OAAO,EAAE,KAAK,YAAY;AAAA,EAC1B,OAAO,EAAE,KAAK,KAAK;AAAA,EACnB,MAAM,EAAE,KAAK,2BAA2B;AAAA,EACxC,SAAS,EAAE,KAAK,WAAW,KAAK,2BAA2B;AAAA,EAC3D,SAAS,CAAC;AAAA,EACV,iBAAiB,EAAE,KAAK,kBAAkB;AAAA,EAC1C,UAAU,CAAC;AAAA,EACX,QAAQ,CAAC;AAAA,EACT,aAAa,EAAE,KAAK,cAAc;AAAA,EAClC,MAAM,CAAC;AAAA,EACP,UAAU,EAAE,KAAK,WAAW;AAAA,EAC5B,UAAU,CAAC;AAAA,EACX,SAAS,CAAC;AAAA,EACV,OAAO,CAAC;AAAA,EACR,KAAK,CAAC;AAAA,EACN,SAAS,EAAE,KAAK,UAAU;AAAA,EAC1B,UAAU,CAAC;AAAA,EACX,UAAU,CAAC;AAAA,EACX,WAAW,CAAC;AAAA,EACZ,SAAS,CAAC;AAAA,EACV,cAAc,EAAE,KAAK,eAAe;AAAA,EACpC,KAAK,EAAE,KAAK,UAAU;AAAA,EACtB,MAAM,EAAE,KAAK,KAAK;AAAA,EAClB,YAAY,EAAE,KAAK,aAAa;AAAA,EAChC,aAAa,EAAE,KAAK,cAAc;AAAA,EAClC,YAAY,EAAE,KAAK,aAAa;AAAA,EAChC,gBAAgB,EAAE,KAAK,iBAAiB;AAAA,EACxC,YAAY,EAAE,KAAK,aAAa;AAAA,EAChC,SAAS,CAAC;AAAA,EACV,QAAQ,EAAE,KAAK,2BAA2B;AAAA,EAC1C,QAAQ,CAAC;AAAA,EACT,MAAM,EAAE,KAAK,2BAA2B;AAAA,EACxC,MAAM,CAAC;AAAA,EACP,UAAU,CAAC;AAAA,EACX,IAAI,CAAC;AAAA,EACL,YAAY,EAAE,KAAK,aAAa;AAAA,EAChC,aAAa,EAAE,KAAK,cAAc;AAAA,EAClC,eAAe,EAAE,KAAK,KAAK;AAAA,EAC3B,WAAW,EAAE,KAAK,YAAY;AAAA,EAC9B,WAAW,CAAC;AAAA,EACZ,IAAI,EAAE,KAAK,KAAK;AAAA,EAChB,OAAO,EAAE,KAAK,QAAQ;AAAA,EACtB,QAAQ,EAAE,KAAK,KAAK;AAAA,EACpB,UAAU,EAAE,KAAK,KAAK;AAAA,EACtB,SAAS,EAAE,KAAK,KAAK;AAAA,EACrB,WAAW,EAAE,KAAK,KAAK;AAAA,EACvB,UAAU,EAAE,KAAK,KAAK;AAAA,EACtB,MAAM,CAAC;AAAA,EACP,OAAO,CAAC;AAAA,EACR,MAAM,CAAC;AAAA,EACP,MAAM,CAAC;AAAA,EACP,SAAS,CAAC;AAAA,EACV,MAAM,EAAE,KAAK,yBAAyB;AAAA,EACtC,KAAK,EAAE,KAAK,2BAA2B;AAAA,EACvC,KAAK,EAAE,KAAK,2BAA2B;AAAA,EACvC,WAAW;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA,EACT;AAAA,EACA,OAAO,CAAC;AAAA,EACR,QAAQ,CAAC;AAAA,EACT,KAAK,EAAE,KAAK,2BAA2B;AAAA,EACvC,WAAW;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA,EACT;AAAA,EACA,UAAU,CAAC;AAAA,EACX,OAAO,EAAE,KAAK,MAAM,KAAK,yBAAyB;AAAA,EAClD,MAAM,CAAC;AAAA,EACP,UAAU,EAAE,KAAK,WAAW;AAAA,EAC5B,OAAO,CAAC;AAAA,EACR,YAAY,EAAE,KAAK,aAAa;AAAA,EAChC,MAAM,CAAC;AAAA,EACP,SAAS,EAAE,KAAK,2BAA2B;AAAA,EAC3C,SAAS,CAAC;AAAA,EACV,MAAM,CAAC;AAAA,EACP,aAAa,CAAC;AAAA,EACd,aAAa,EAAE,KAAK,cAAc;AAAA,EAClC,SAAS;AAAA,IACL,KAAK,CAAC,QAAQ;AACV,UAAI,QAAQ;AAAM,eAAO;AACzB,UAAI,QAAQ;AAAO,eAAO;AAC1B,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,QAAQ,CAAC;AAAA,EACT,SAAS,CAAC;AAAA,EACV,UAAU,EAAE,KAAK,WAAW;AAAA,EAC5B,gBAAgB,EAAE,KAAK,iBAAiB;AAAA,EACxC,KAAK,CAAC;AAAA,EACN,UAAU,CAAC;AAAA,EACX,UAAU,CAAC;AAAA,EACX,MAAM,CAAC;AAAA,EACP,MAAM,EAAE,KAAK,2BAA2B;AAAA,EACxC,SAAS,EAAE,KAAK,WAAW,KAAK,2BAA2B;AAAA,EAC3D,SAAS,CAAC;AAAA,EACV,OAAO,CAAC;AAAA,EACR,UAAU,CAAC;AAAA,EACX,OAAO,CAAC;AAAA,EACR,MAAM,EAAE,KAAK,2BAA2B;AAAA,EACxC,OAAO,CAAC;AAAA,EACR,MAAM,CAAC;AAAA,EACP,MAAM,EAAE,KAAK,2BAA2B;AAAA,EACxC,YAAY,CAAC;AAAA,EACb,KAAK,CAAC;AAAA,EACN,QAAQ,CAAC;AAAA,EACT,SAAS,CAAC;AAAA,EACV,QAAQ,CAAC;AAAA,EACT,OAAO,EAAE,KAAK,2BAA2B;AAAA,EACzC,MAAM,EAAE,KAAK,2BAA2B;AAAA,EACxC,OAAO,CAAC;AAAA,EACR,UAAU,EAAE,KAAK,YAAY,KAAK,2BAA2B;AAAA,EAC7D,QAAQ,CAAC;AAAA,EACT,OAAO,CAAC;AAAA,EACR,WAAW,EAAE,KAAK,UAAU;AAAA,EAC5B,MAAM,CAAC;AAAA,EACP,QAAQ,EAAE,KAAK,SAAS;AAAA;AAAA,EAExB,OAAO,EAAE,KAAK,2BAA2B;AAAA,EACzC,MAAM,CAAC;AACX;AAEO,SAAS,aACZ,SACA,eACA,KACF;AACE,MAAI,QAAQ,UAAa,QAAQ,QAAQ,QAAQ,OAAO;AACpD,YAAQ,gBAAgB,aAAa;AAAA,EACzC,WAAW,QAAQ,MAAM;AACrB,YAAQ,aAAa,eAAe,EAAE;AAAA,EAC1C,WAAW,OAAO,QAAQ,UAAU;AAChC,YAAQ,aAAa,eAAe,GAAG;AAAA,EAC3C,WAAW,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;AAC3D,YAAQ,aAAa,eAAe,IAAI,SAAS,CAAC;AAAA,EACtD;AACJ;AAEO,SAAS,WAAW,SAAkB,WAAmB,OAAY;AAIxE,MAAI,EAAE,mBAAmB,cAAc;AACnC,iBAAa,SAAS,WAAW,KAAK;AACtC;AAAA,EACJ;AACA,MAAI,cAAc,SAAS;AAEvB,YAAQ,QAAQ,SAAS;AAAA,MACrB,KAAK;AAAA,MACL,KAAK;AAGD,qBAAa,SAAS,WAAW,KAAK;AACtC,QAAC,QAAgB,QAAQ,2BAA2B,KAAK;AACzD;AAAA,MAEJ,KAAK;AAGD,QAAC,QAAgB,QAAQ;AACzB;AAAA,MAEJ,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAGD,qBAAa,SAAS,WAAW,KAAK;AACtC,QAAC,QAAgB,QAAQ;AACzB;AAAA,MACJ;AAEI,qBAAa,SAAS,WAAW,KAAK;AAAA,IAC9C;AACA;AAAA,EACJ;AACA,QAAM,WAAW,aAAa,SAAS;AACvC,MAAI,UAAU;AACV,QAAI,CAAC,SAAS,KAAK;AACf,YAAM,iBAAiB;AACvB,mBAAa,SAAS,WAAW,cAAc;AAAA,IACnD;AACA,QAAI,SAAS,QAAQ,MAAM;AACvB,YAAM,WAAW,SAAS,MAAM,SAAS,IAAI,KAAK,IAAI;AACtD,MAAC,QAAgB,SAAS,OAAO,SAAS,IAAI;AAAA,IAClD;AACA;AAAA,EACJ;AACA,eAAa,SAAS,WAAW,KAAK;AAC1C;;;AClYO,SAAS,gBACZ,UACA,WACU;AACV,MAAI,SAAS,WAAW,GAAG;AACvB,WAAO;AAAA,EACX;AACA,MAAI,SAAS,WAAW,GAAG;AACvB,WAAO,SAAS,CAAC;AAAA,EACrB;AACA,SAAO,IAAI,qBAAqB,CAAC,GAAG,UAAU,SAAS;AAC3D;;;ACRO,SAAS,kBACZC,gBACA,SACA,WACU;AACV,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,mBAAmB;AAEvB,QAAMC,aAAkD,CAACC,QAAO,QAAQ;AACpE,QAAIA,QAAO;AACP,iBAAW,SAAS,eAAe;AACnC,qBAAeA;AACf,UAAI,WAAW,WAAW,GAAG;AACzB,mBAAW,UAAUA,MAAK;AAAA,MAC9B,OAAO;AACH,QAAI,KAAK,iDAAiD,GAAG;AAAA,MACjE;AAAA,IACJ,WAAW,kBAAkB;AACzB,iBAAW,SAASF,eAAc,GAAG,CAAC;AAAA,IAC1C,OAAO;AACH,iBAAW,SAAS,eAAe;AACnC,oBAAc;AACd,iBAAW,iCAA+C;AAAA,IAC9D;AAAA,EACJ;AAEA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,UAAU,CAAC,kBAAkB;AACzB,YAAI,cAAc;AACd,wBAAc,aAAa,YAAY;AAAA,QAC3C;AAAA,MACJ;AAAA,MACA,UAAU,CAAC,UAAU;AACjB,YAAI,+BAA6C;AAC7C,qBAAW,SAASA,eAAc,WAAW,CAAC;AAAA,QAClD;AAAA,MACJ;AAAA,MACA,OAAO,MAAM;AACT,eAAO,kBAAkBA,gBAAe,SAAS,SAAS;AAAA,MAC9D;AAAA,MACA,SAAS,MAAM;AACX,2BAAmB;AACnB,8BAAsB,QAAQ,UAAUC,UAAS;AACjD,2BAAmB;AAAA,MACvB;AAAA,MACA,WAAW,MAAM;AACb,uBAAe;AACf,8BAAsB;AACtB,8BAAsB;AAAA,MAC1B;AAAA,IACJ;AAAA,IACA;AAAA,IACA,YAAY,qBAAqB,eAAe;AAAA,EACpD;AACA,SAAO;AACX;;;AC5DO,SAAS,kBAAkB,MAAY,WAAgC;AAC1E,SAAO,IAAI;AAAA,IACP;AAAA,MACI,UAAU,CAAC,kBAAkB;AACzB,sBAAc,YAAY;AAAA,UACtB;AAAA,UACA,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO,CAAC,IAAI;AAAA,QAChB,CAAC;AAAA,MACL;AAAA,MACA,OAAO,MAAM;AACT,eAAO,kBAAkB,MAAM,SAAS;AAAA,MAC5C;AAAA,IACJ;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACjB;AACJ;;;AClBO,SAAS,eAAe,KAAa,WAAgC;AACxE,QAAM,WAAW,SAAS,eAAe,GAAG;AAC5C,SAAO,IAAI;AAAA,IACP;AAAA,MACI,UAAU,CAAC,kBAAkB;AACzB,sBAAc,YAAY;AAAA,UACtB;AAAA,UACA,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO,CAAC,QAAQ;AAAA,QACpB,CAAC;AAAA,MACL;AAAA,MACA,OAAO,MAAM;AACT,eAAO,eAAe,KAAK,SAAS;AAAA,MACxC;AAAA,IACJ;AAAA,IACA;AAAA,IACA,QACM,aAAa,QAAQ,KAAK,UAAU,GAAG,OACvC,aAAa;AAAA,EACvB;AACJ;;;AChBO,SAAS,cAAc,SAA+B;AACzD,MAAI,aAAa,OAAO,GAAG;AACvB,WAAO;AAAA,EACX;AACA,MAAI,gBAAgB,OAAO,GAAG;AAC1B,WAAO,QAAQ,aAAa,aAAa;AAAA,EAC7C;AACA,MAAI,mBAAmB,MAAM;AACzB,WAAO,kBAAkB,OAAO;AAAA,EACpC;AACA,MAAI,MAAM,QAAQ,OAAO,GAAG;AACxB,WAAO,gBAAgB,QAAQ,IAAI,CAAC,SAAS,cAAc,IAAI,CAAC,CAAC;AAAA,EACrE;AACA,MACI,YAAY,QACZ,YAAY,UACZ,OAAO,YAAY,WACrB;AACE,WAAO;AAAA,EACX;AACA,MAAI,OAAO,YAAY,YAAY;AAC/B,IAAI,KAAK,gDAAgD;AACzD,WAAO;AAAA,EACX;AACA,MAAI,OAAO,YAAY,UAAU;AAC7B,IAAI,KAAK,8CAA8C;AACvD,WAAO;AAAA,EACX;AACA,MAAI,OAAO,YAAY,UAAU;AAC7B,WAAO,eAAe,OAAO;AAAA,EACjC;AACA,MAAI,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU;AAC5D,WAAO,eAAe,QAAQ,SAAS,CAAC;AAAA,EAC5C;AACA,MACI,OAAO,YAAY,YACnB,SAAS,WACT,OAAO,QAAQ,QAAQ,cACvB,OAAO,QAAQ,cAAc,YAC/B;AACE,WAAO,kBAAkB,eAAe,OAAO;AAAA,EACnD;AACA,MACI,OAAO,YAAY,YACnB,UAAU,WACV,OAAO,QAAQ,SAAS,YAC1B;AACE,UAAM,gBAAgB,MAIpB,IAAI;AACN,UAAM,gBAAgB,KAAK,MAAM;AAC7B,YAAM,SAAS,cAAc,IAAI;AACjC,UAAI,CAAC,QAAQ;AACT,eAAO;AAAA,MACX;AACA,UAAI,OAAO,SAAS,YAAY;AAC5B,eAAO,OAAO;AAAA,MAClB;AACA,YAAM,OAAO;AAAA,IACjB,CAAC;AACD,YAAQ;AAAA,MACJ,CAAC,QAAa;AACV,sBAAc,IAAI,EAAE,MAAM,YAAY,OAAO,IAAI,CAAC;AAAA,MACtD;AAAA,MACA,CAAC,QAAa;AACV,sBAAc,IAAI,EAAE,MAAM,SAAS,OAAO,UAAU,GAAG,EAAE,CAAC;AAAA,MAC9D;AAAA,IACJ;AACA,WAAO,kBAAkB,eAAe,aAAa;AAAA,EACzD;AACA,EAAI,KAAK,+CAA+C,OAAO;AAC/D,SAAO;AACX;AAEO,SAAS,kBACZ,UACY;AACZ,QAAM,mBAAiC,CAAC;AACxC,MAAI,UAAU;AACV,QAAI,MAAM,QAAQ,QAAQ,KAAK,CAAC,gBAAgB,QAAQ,GAAG;AACvD,iBAAW,SAAS,UAAU;AAC1B,yBAAiB,KAAK,cAAc,KAAK,CAAC;AAAA,MAC9C;AAAA,IACJ,OAAO;AACH,uBAAiB,KAAK,cAAc,QAAQ,CAAC;AAAA,IACjD;AAAA,EACJ;AACA,SAAO;AACX;;;ACnDO,IAAM,iBAAN,MAEP;AAAA,EAEI,YAAY,OAAe;AACvB,SAAK,QAAQ;AAAA,EACjB;AAOJ;AAEO,SAAS,oBACZ,WACA,OACA,UACA,WACU;AACV,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,QAAyB,oBAAI,IAAI;AACrC,MAAI;AAEJ,MAAI,kBAAkB,iBAAiB,SAAS,IAC1C,kCAAkC,SAAS,IAC1C;AAEP,WAAS,eAAe;AACpB,QAAI,CAAC,QAAQ;AACT,UAAI,mBAAmB;AACvB,YAAM,YAAgC;AAAA,QAClC,SAAS,CAAC,YAAuC;AAC7C,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC;AAAkB,+BAAmB,CAAC;AAC3C,2BAAiB,KAAK,OAAO;AAAA,QACjC;AAAA,QACA,WAAW,CAAC,YAAwB;AAChC,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,OAAO;AAAA,QACnC;AAAA,QACA,WAAW,CAAC,YAAwB;AAChC,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,OAAO;AAAA,QACnC;AAAA,QACA,SAAS,CAAC,YAA8C;AACpD,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,UAAI,OAAO,CAAC,cAAc,+BAA+B;AACzD,yBAAe;AAAA,QACnB;AAAA,MACJ;AAEA,UAAI;AACJ,UAAI,SAAS,WAAW,GAAG;AACvB,yBAAiB,SAAS,CAAC;AAAA,MAC/B,WAAW,SAAS,WAAW,GAAG;AAC9B,yBAAiB,QACX,EAAE,GAAG,OAAO,UAAU,SAAS,CAAC,EAAE,IAClC,EAAE,UAAU,SAAS,CAAC,EAAE;AAAA,MAClC,OAAO;AACH,yBAAiB,QAAQ,EAAE,GAAG,OAAO,SAAS,IAAI,EAAE,SAAS;AAAA,MACjE;AACA,UAAI;AACJ,UAAI;AACA,oBACI,gBAAgB,gBAAgB,SAAS,KACzC;AAAA,MACR,SAAS,GAAP;AACE,cAAME,SAAQ,UAAU,GAAG,mCAAmC;AAC9D,YAAI,cAAc;AACd,sBAAY,aAAaA,MAAK,KAAK;AAAA,QACvC,OAAO;AACH,sBAAYA;AAAA,QAChB;AAAA,MACJ;AACA,yBAAmB;AACnB,iBAAW,QAAQ,OAAO;AACtB,eAAO,IAAI;AAAA,MACf;AACA,UAAI,EAAE,qBAAqB,QAAQ;AAC/B,iBAAS,cAAc,SAAS;AAAA,MACpC,OAAO;AACH,iBAAS;AAAA,MACb;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,UAAU,MAAM;AAClB,QAAI,UAAU,EAAE,kBAAkB,QAAQ;AACtC,iBAAW,OAAO,MAAM;AAAA,IAC5B;AACA,QAAI,oBAAoB;AACpB,iBAAW,YAAY,oBAAoB;AACvC,iBAAS;AAAA,MACb;AAAA,IACJ;AAEA,eAAW,QAAQ,OAAO;AACtB,cAAQ,IAAI;AAAA,IAChB;AAEA,YAAQ,oBAAI,IAAI;AAChB,uBAAmB;AACnB,yBAAqB;AACrB,yBAAqB;AACrB,aAAS;AACT,mBAAe;AAAA,EACnB;AAEA,QAAM,aAAa,MAAM;AACrB,UAAM,kBAAkB,aAAa;AACrC,QAAI,2BAA2B,OAAO;AAClC,MAAI,KAAK,6CAA6C;AAAA,QAClD,OAAO;AAAA,QACP;AAAA,MACJ,CAAC;AAAA,IACL,OAAO;AACH,iBAAW,IAAI,eAAe;AAAA,IAClC;AACA,WAAO;AAAA,EACX;AAEA,QAAM,mBAAmB,CAAC,iBAAoC;AAC1D,QAAI,WAAW,UAAU,KAAK,oBAAoB;AAC9C,iBAAW,MAAM,oBAAoB;AACjC,WAAG;AAAA,MACP;AAAA,IACJ;AACA,yBAAqB;AACrB,eAAW,SAAS,eAAe;AACnC,YAAQ;AACR,QAAI,iBAAiB,YAAY,GAAG;AAChC,wBAAkB,kCAAkC,YAAY;AAAA,IACpE,OAAO;AACH,wBAAkB;AAAA,IACtB;AACA,UAAM,kBAAkB,WAAW;AACnC,QAAI,WAAW,WAAW,GAAG;AACzB,UAAI,2BAA2B,OAAO;AAClC,mBAAW,UAAU,eAAe;AAAA,MACxC,OAAO;AACH,mBAAW,SAAS,eAAe;AAAA,MACvC;AAAA,IACJ;AACA,QAAI,WAAW,UAAU,KAAK,kBAAkB;AAE5C,iBAAW,kCAAgD;AAAA,IAC/D;AAAA,EACJ;AAEA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,SAAS,MAAM;AACX,mBAAW;AACX,gCAAwB,WAAW,gBAAgB;AAAA,MACvD;AAAA,MACA,WAAW,MAAM;AACb,kCAA0B,WAAW,gBAAgB;AACrD,gBAAQ;AAAA,MACZ;AAAA,MACA,UAAU,CAAC,kBAAkB;AACzB,YAAI,kBAAkB,OAAO;AACzB,wBAAc,aAAa,MAAM;AAAA,QACrC,WAAW,QAAQ;AACf,qBAAW,SAAS,MAAM;AAAA,QAC9B;AAAA,MACJ;AAAA,MACA,UAAU,MAAM;AACZ,mBAAW,SAAS,eAAe;AAAA,MACvC;AAAA,MACA,SAAS,CAACA,WAAiB;AACvB,YAAI,cAAc;AACd,gBAAM,gBAAgB,aAAaA,MAAK;AACxC,mBAAS,gBACH,cAAc,aAAa,IAC3B;AACN,qBAAW,SAAS,MAAM;AAC1B,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,MACA,SAAS,MAAM;AACX,QAAI,OAAO,QAAQ,2BAA2B;AAC9C,YAAI,kBAAkB,OAAO;AACzB;AAAA,QACJ;AACA,mBAAW,kCAAgD;AAAA,MAC/D;AAAA,MACA,WAAW,MAAM;AACb,QAAI,OAAO,QAAQ,2BAA2B;AAC9C,YAAI,kBAAkB,OAAO;AACzB;AAAA,QACJ;AACA,YAAI,oBAAoB;AACpB,qBAAW,YAAY,oBAAoB;AACvC,qBAAS;AAAA,UACb;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,UAAU,CAAC,UAAU;AACjB,YACI,kCACA,kBACF;AACE,qBAAW,YAAY,kBAAkB;AACrC,kBAAM,iBAAiB,SAAS;AAChC,gBAAI,OAAO,mBAAmB,YAAY;AACtC,kBAAI,CAAC,oBAAoB;AACrB,qCAAqB,CAAC;AAAA,cAC1B;AACA,oBAAM,YAAY,MAAM;AACpB,+BAAe;AACf,oBAAI,oBAAoB;AACpB,wBAAM,QACF,mBAAmB,QAAQ,SAAS;AACxC,sBAAI,SAAS,GAAG;AACZ,uCAAmB,OAAO,OAAO,CAAC;AAAA,kBACtC;AAAA,gBACJ;AAAA,cACJ;AACA,iCAAmB,KAAK,SAAS;AAAA,YACrC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,MAAM,UAAU,aAAa;AACzB,eAAO;AAAA,UACH;AAAA,UACA,SAAS,WACH,EAAE,GAAG,OAAO,GAAG,SAAS,IACtB,YAAY;AAAA,UACpB,eAAe;AAAA,QACnB;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,IACA,aAAa,aAAa,UAAU;AAAA,EACxC;AACA,SAAO;AACX;;;ACpRO,SAAS,OAAa,SAA0B;AACnD,MAAI,UAAU,OAAO,GAAG;AACpB,WAAO,QAAQ,IAAI;AAAA,EACvB;AACA,SAAO;AACX;AAEO,SAAS,OACZ,SACA,OACO;AACP,MAAI,aAAa,OAAO,GAAG;AACvB,YAAQ,IAAI,KAAK;AACjB,WAAO;AAAA,EACX;AACA,SAAO;AACX;AAEO,SAAS,aACZ,SACA,UACU;AACV,MAAI,UAAU,OAAO,GAAG;AACpB,WAAO,QAAQ,UAAU,QAAQ;AAAA,EACrC;AACA,WAAS,QAAW,OAAO;AAC3B,SAAO;AACX;AAEO,SAAS,UAAgB,KAAsC;AAClE,SAAO,CAAC,EACJ,OACA,OAAO,QAAQ,YACf,SAAS,OACT,eAAe,OACf,OAAO,IAAI,QAAQ,cACnB,OAAO,IAAI,cAAc;AAEjC;AAEO,SAAS,aAAmB,KAA4C;AAC3E,SAAO,UAAU,GAAG,KAAK,SAAS,OAAO,OAAO,IAAI,QAAQ;AAChE;AAEO,SAAS,OAAa,KAAa,IAAmC;AACzE,SAAO,KAAK,MAAM,GAAG,OAAO,GAAG,CAAC,CAAC;AACrC;AAEO,SAAS,IAAO,KAIrB;AACE,SAAO;AAAA,IACH,KAAK,MAAM,OAAO,GAAG;AAAA,IACrB,WAAW,CAAC,YAAY,aAAa,KAAK,OAAO;AAAA,IACjD,KAAK,CAAI,OAAsC,OAAa,KAAK,EAAE;AAAA,EACvE;AACJ;;;AC1FO,IAAM,iCAAiC,OACzC;AAAA,EACG,GAAG;AAAA,EACH,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM;AAAA,EACN,SAAS;AAAA,EACT,OAAO;AAAA,EACP,OAAO;AAAA,EACP,GAAG;AAAA,EACH,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,YAAY;AAAA,EACZ,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,UAAU;AAAA,EACV,MAAM;AAAA,EACN,UAAU;AAAA,EACV,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,GAAG;AAAA,EACH,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,GAAG;AAAA,EACH,SAAS;AAAA,EACT,KAAK;AAAA,EACL,UAAU;AAAA,EACV,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,GAAG;AAAA,EACH,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA,EACL,OAAO;AAAA,EACP,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AACT;;;ACjHG,IAAM,iBAAiB;AACvB,IAAM,gBAAgB;AACtB,IAAM,mBAAmB;AAEzB,IAAM,0BAA8D;AAAA;AAAA;AAAA,EAGvE,SAAS;AAAA,EACT,eAAe;AAAA,EACf,kBAAkB;AAAA,EAClB,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,eAAe;AAAA,EACf,qBAAqB;AAAA,EACrB,aAAa;AAAA,EACb,kBAAkB;AAAA,EAClB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,gBAAgB;AAAA,EAChB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,aAAa;AAAA,EACb,cAAc;AAAA,EACd,UAAU;AAAA,EACV,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,aAAa;AAAA,EACb,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,GAAG;AAAA,EACH,OAAO;AAAA,EACP,WAAW;AAAA,EACX,OAAO;AAAA,EACP,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,EACV,gBAAgB;AAAA,EAChB,MAAM;AAAA;AAAA,EAEN,KAAK;AAAA,EACL,MAAM;AAAA;AAAA,EAEN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,UAAU;AAAA;AAAA,EAEV,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA;AAAA,EAGN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,eAAe;AAAA,EACf,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb,OAAO;AAAA,EACP,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,YAAY;AAChB;AAEO,IAAM,gCAGT;AAAA,EACA,CAAC,cAAc,GAAG;AAAA,IACd,KAAK;AAAA,MACD,MAAM;AAAA,MACN,UAAU;AAAA,IACd;AAAA,IACA,MAAM;AAAA,MACF,MAAM;AAAA,MACN,UAAU;AAAA,IACd;AAAA,EACJ;AAAA,EACA,CAAC,aAAa,GAAG;AAAA,IACb,eAAe;AAAA,MACX,MAAM;AAAA,MACN,UAAU;AAAA,IACd;AAAA,EACJ;AACJ;;;AC9HO,IAAM,MAAN,MAAoB;AAAA,EAEvB,YAAY,SAAY;AACpB,SAAK,UAAU;AAAA,EACnB;AACJ;AAOO,SAAS,IAAO,KAA6B;AAChD,SAAO,IAAI,IAAI,GAAG;AACtB;;;ACJA,IAAM,6BACF,gBAAgB,QAAQ,YACjB,QAAQ,UACJ,aACL,QAAQ,UAAU;AAE5B,SAAS,mBACL,SACA,MACA,QACF;AACE,QAAM,WAAW,QAAQ,YAAY;AACrC,QAAM,UAAU,KAAK,YAAY;AACjC,MAAI,aAAa,SAAS;AACtB,+BAA2B,KAAK,SAAS,MAAM,MAAM;AAAA,EACzD,OAAO;AACH,YAAQ,aAAa,MAAM,MAAM;AAAA,EACrC;AACJ;AAEO,SAAS,iBACZ,SACA,oBACA,SAIA,WACF;AACE,MAAI,gBAAoC,CAAC;AACzC,MAAI,iBAAuC,CAAC;AAE5C,WAAS,iBAAiB,OAA4B;AAClD,aAAS,IAAI,OAAO,IAAI,eAAe,QAAQ,EAAE,GAAG;AAChD,YAAM,OAAO,eAAe,CAAC;AAC7B,UAAI,MAAM;AACN,eAAO;AAAA,MACX;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,SAAS,CAAC,UAA4B;AAClC,sBAAc,KAAK,KAAK;AACxB,mBAAW,mCAAiD;AAC5D,eAAO;AAAA,MACX;AAAA,MACA,SAAS,MAAM;AACX,YAAI,SAAS;AACT,qBAAW;AAAA;AAAA,UAEX;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,WAAW,MAAM;AACb,YAAI,SAAS;AACT,qBAAW;AAAA;AAAA,UAEX;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,UAAU,CAAC,UAAiC;AACxC,YAAI,oCAAkD,SAAS;AAC3D,cAAI,mBAAmB,KAAK;AACxB,oBAAQ,UAAU;AAAA,UACtB,WAAW,OAAO,YAAY,YAAY;AACtC,oBAAQ,MAAS;AAAA,UACrB;AAAA,QACJ;AACA,YAAI,iCAA+C;AAY/C,mBACQ,IAAI,GAAG,aAAa,GACxB,IAAI,eAAe,QACnB,EAAE,GACJ;AACE,kBAAM,eAAe,eAAe,CAAC;AACrC,kBAAM,WAAW,QAAQ,WAAW,UAAU;AAC9C,gBAAI,gBAAgB,iBAAiB,UAAU;AAC3C,4BAAc;AAAA,YAClB,OAAO;AAEH,6BAAe,CAAC,IAAI;AAAA,YACxB;AAAA,UACJ;AAEA,qBAAW,SAAS,iBAAiB,aAAa,GAAG;AACjD,oBAAQ,MAAM,MAAM;AAAA,cAChB,4BAA4B;AACxB,oBACI,MAAM,UAAU,KAChB,MAAM,QAAQ,KACd,MAAM,UAAU,eAAe,QACjC;AACE,0BAAQ,gBAAgB;AACxB,mCAAiB,CAAC;AAAA,gBACtB,OAAO;AACH,2BAAS,IAAI,MAAM,QAAQ,GAAG,KAAK,GAAG,EAAE,GAAG;AACvC,0BAAM,WACF,eAAe,MAAM,QAAQ,CAAC;AAClC,wBAAI,UAAU;AACV,8BAAQ,YAAY,QAAQ;AAAA,oBAChC;AAAA,kBACJ;AACA,iCAAe;AAAA,oBACX,MAAM;AAAA,oBACN,MAAM;AAAA,kBACV;AAAA,gBACJ;AACA,oBAAI,MAAM,OAAO;AACb,wBAAM,gBAAgB;AAAA,oBAClB,MAAM;AAAA,kBACV;AACA,sBACI,MAAM,MAAM,SAAS,KACrB,MAAM,MAAM;AAAA,oBACR,CAAC,SAAS,KAAK,eAAe;AAAA,kBAClC,GACF;AAME,0BAAM,WACF,SAAS,uBAAuB;AACpC,6BAAS;AAAA,sBACL,GAAG,MAAM;AAAA,oBACb;AACA;AAAA,sBACI;AAAA,sBACA;AAAA,sBACA;AAAA,oBACJ;AAAA,kBACJ,OAAO;AACH,+BAAW,QAAQ,MAAM,OAAO;AAC5B;AAAA,wBACI;AAAA,wBACA;AAAA,wBACA;AAAA,sBACJ;AAAA,oBACJ;AAAA,kBACJ;AACA,iCAAe;AAAA,oBACX,MAAM;AAAA,oBACN;AAAA,oBACA,GAAG,MAAM;AAAA,kBACb;AAAA,gBACJ;AACA;AAAA,cACJ;AAAA,cACA,wBAA0B;AACtB,sBAAM,WAAmB,CAAC;AAC1B,yBAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,QAAQ,EAAE,GAAG;AAC3C,wBAAM,OACF,eAAe,MAAM,QAAQ,CAAC,CAAC;AACnC,sBAAI,MAAM;AACN,6BAAS,KAAK,IAAI;AAAA,kBACtB;AAAA,gBACJ;AACA,sBAAM,gBAAgB;AAAA,kBAClB,MAAM,OAAO,MAAM,QAAQ;AAAA,gBAC/B;AACA,2BAAW,QAAQ,UAAU;AACzB;AAAA,oBACI;AAAA,oBACA;AAAA,oBACA;AAAA,kBACJ;AAAA,gBACJ;AACA,gCAAgB,gBAAgB,KAAK;AACrC;AAAA,cACJ;AAAA,cACA,wBAA0B;AACtB,sBAAM,SAAiB,CAAC;AACxB,yBAAS,IAAI,GAAG,IAAI,MAAM,OAAO,EAAE,GAAG;AAClC,wBAAM,OAAO,eAAe,MAAM,OAAO,CAAC;AAC1C,sBAAI,MAAM;AACN,2BAAO,KAAK,IAAI;AAAA,kBACpB;AAAA,gBACJ;AACA,sBAAM,iBACF,MAAM,KAAK,MAAM,OACX,MAAM,KAAK,MAAM,QACjB,MAAM;AAChB,sBAAM,gBACF,iBAAiB,cAAc;AACnC,2BAAW,QAAQ,QAAQ;AACvB;AAAA,oBACI;AAAA,oBACA;AAAA,oBACA;AAAA,kBACJ;AAAA,gBACJ;AACA,gCAAgB,gBAAgB,KAAK;AACrC;AAAA,cACJ;AAAA,YACJ;AAAA,UACJ;AACA,0BAAgB,CAAC;AAAA,QACrB;AACA,YAAI,kCAAgD,SAAS;AACzD,cAAI,mBAAmB,KAAK;AACxB,oBAAQ,UAAU;AAAA,UACtB,WAAW,OAAO,YAAY,YAAY;AACtC,oBAAQ,OAAO;AAAA,UACnB;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,QAAoB;AAChB,QAAI;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,WAAW,MAAM;AACb,wBAAgB,CAAC;AACjB,yBAAiB,CAAC;AAAA,MACtB;AAAA,IACJ;AAAA,IACA;AAAA,IACA,SACI,mBAAmB,UACb,QAAQ,UACR,UAAU,QAAQ,KAAK;AAAA,EAErC;AACA,SAAO;AACX;;;AC3OA,IAAM,aAAa;AAAA,EACf,EAAE,QAAQ,OAAO,OAAO,MAAM;AAAA,EAC9B,EAAE,QAAQ,cAAc,OAAO,KAAK;AAAA,EACpC,EAAE,QAAQ,cAAc,OAAO,EAAE,SAAS,KAAK,EAAE;AACrD;AAKO,SAAS,oBACZ,SACA,OACA,iBACA,WACU;AACV,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,WAAS,YAAY,OAAyB;AAC1C,IAAI;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA,EACJ;AAEA,WAAS,YAAYC,QAAc;AAC/B,QAAI,WAAW,WAAW,GAAG;AAEzB,iBAAW,UAAUA,MAAK;AAAA,IAC9B,OAAO;AAEH,MAAI;AAAA,QACA;AAAA,QACA;AAAA,QACAA;AAAA,MACJ;AACA,sBAAgBA;AAChB,aAAO;AAAA,IACX;AAAA,EACJ;AAEA,WAAS,cACL,eACA,cACA,mBACF;AACE,QAAI,CAAC,WAAW,iBAAiB,qBAAqB;AAClD,4BAAsB;AACtB,gBAAUC,eAAc,YAAY;AAEpC,UAAI,kBAAkB;AAClB,YAAI,WAAW,UAAU,GAAG;AACxB,2BAAiB,UAAU;AAAA,QAC/B;AACA,yBAAiB,OAAO;AACxB,mBAAW,OAAO,gBAAgB;AAAA,MACtC;AACA,yBAAmB;AAAA,QACf;AAAA,QACA;AAAA,QACA,OAAO;AAAA,MACX;AACA,iBAAW,IAAI,gBAAgB;AAC/B,uBAAiB,OAAO;AAAA,QACpB,aAAa;AAAA,QACb,cAAc;AAAA,QACd,cAAc;AAAA,MAClB,CAAC;AACD,UAAI,WAAW,UAAU,GAAG;AACxB,yBAAiB,QAAQ;AAAA,MAC7B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,WAASA,eAAc,cAAsB;AACzC,QAAIC;AACJ,QACI,OAAO,OAAO,OAAO,YACrB,WAAW,+BAA+B,GAC5C;AACE,MAAAA,WAAU,SAAS,cAAc,SAAS;AAAA,QACtC,IAAI,MAAM;AAAA,MACd,CAAC;AAAA,IACL,OAAO;AACH,MAAAA,WAAU,SAAS,gBAAgB,cAAc,OAAO;AAAA,IAC5D;AACA,QAAI,OAAO;AACP,iBAAW,CAAC,MAAM,GAAG,KAAK,OAAO,QAAQ,KAAK,GAAG;AAC7C,YAAI,SAAS;AAAO;AACpB,YAAI,SAAS;AAAM;AACnB,YACI,WAAW,KAAK,CAAC,EAAE,QAAQ,MAAM,MAAM;AACnC,cAAI,KAAK,WAAW,MAAM,GAAG;AACzB,gBAAI,KAAK;AACL,cAAAA,SAAQ;AAAA,gBACJ,KAAK,MAAM,OAAO,MAAM;AAAA,gBACxB,CAAC,MAAM;AACH,sBAAI,GAAGA,QAAO;AACd,wBAAM;AAAA,gBACV;AAAA,gBACA;AAAA,cACJ;AAAA,YACJ;AACA,mBAAO;AAAA,UACX;AACA,iBAAO;AAAA,QACX,CAAC,GACH;AACE;AAAA,QACJ;AACA,YAAI,UAAU,GAAG,GAAG;AAChB,cAAI,CAAC,iBAAiB;AAClB,8BAAkB,oBAAI,IAAI;AAAA,UAC9B;AACA,0BAAgB,IAAI,MAAM,GAAG;AAAA,QACjC,OAAO;AACH,kBAAQA,UAAS,MAAM,OAAO,GAAG,CAAC;AAAA,QACtC;AAAA,MACJ;AACA,UAAI,iBAAiB;AACjB,YAAI,CAAC,eAAe;AAChB,0BAAgB,oBAAI,IAAI;AAAA,QAC5B;AACA,mBAAW,CAAC,MAAM,SAAS,KAAK,gBAAgB,QAAQ,GAAG;AACvD,wBAAc;AAAA,YACV,aAAa,WAAW,CAACF,QAAO,eAAe;AAC3C,kBAAIA,QAAO;AACP,gBAAI,MAAM,iCAAiC;AAAA,kBACvC;AAAA,kBACA,SAAAE;AAAA,kBACA,OAAO;AAAA,gBACX,CAAC;AAAA,cACL,OAAO;AACH,wBAAQA,UAAS,MAAM,UAAU;AAAA,cACrC;AAAA,YACJ,CAAC;AAAA,UACL;AACA,gBAAM,aAAa,OAAO,SAAS;AACnC,kBAAQA,UAAS,MAAM,UAAU;AAAA,QACrC;AAAA,MACJ;AAAA,IACJ;AACA,WAAOA;AAAA,EACX;AAEA,WAAS,QAAQA,UAAkB,MAAc,KAAc;AAC3D,QAAI,KAAK,WAAW,OAAO,GAAG;AAC1B,YAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,MAACA,SAAgB,QAAQ,IAAI;AAC7B;AAAA,IACJ;AAEA,QAAI,KAAK,WAAW,OAAO,GAAG;AAC1B,YAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,mBAAaA,UAAS,UAAU,GAAG;AACnC;AAAA,IACJ;AAEA,SACKA,oBAAmB,eAAeA,oBAAmB,gBACrD,KAAK,WAAW,UAAU,KAAK,KAAK,WAAW,QAAQ,IAC1D;AACE,YAAM,WAAW,KAAK,WAAW,UAAU,IACrC,OAAO,KAAK,MAAM,CAAC,IACnB,KAAK,MAAM,CAAC;AAClB,UAAI,QAAQ,UAAa,QAAQ,QAAQ,QAAQ,OAAO;AACpD,QAAAA,SAAQ,MAAM,eAAe,QAAQ;AAAA,MACzC,WAAW,OAAO,QAAQ,UAAU;AAChC,QAAAA,SAAQ,MAAM,YAAY,UAAU,GAAG;AAAA,MAC3C,WAAW,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;AAC3D,QAAAA,SAAQ,MAAM,YAAY,UAAU,IAAI,SAAS,CAAC;AAAA,MACtD;AACA;AAAA,IACJ;AAEA,QAAI,KAAK,WAAW,QAAQ,GAAG;AAC3B,YAAM,WAAW,KAAK,MAAM,CAAC;AAC7B,mBAAaA,UAAS,UAAU,GAAG;AACnC;AAAA,IACJ;AAEA,eAAWA,UAAS,MAAM,GAAG;AAAA,EACjC;AAEA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,UAAU,CAAC,kBAAkB;AACzB,YAAI,eAAe;AACf,wBAAc,aAAa,aAAa;AACxC;AAAA,QACJ;AACA,cAAM,sBACF,8BAA8B,cAAc,YAAY,IACpD,OACJ;AACJ,cAAM,eACF,qBAAqB,QAAQ,cAAc;AAC/C,cAAM,oBACF,qBAAqB,YAAY,cAAc;AAEnD,kBAAU;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAEA,sBAAc,YAAY;AAAA,UACtB;AAAA,UACA,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO,CAAC,OAAO;AAAA,QACnB,CAAC;AAAA,MACL;AAAA,MACA,UAAU,MAAM;AAAA,MAAC;AAAA,MACjB,SAAS,MAAM;AACX,0BAAkB,QAAQ;AAAA,MAC9B;AAAA,MACA,WAAW,MAAM;AACb,0BAAkB,UAAU;AAAA,MAChC;AAAA,MACA,OAAO,CAAC,eAAoB,gBAA+B;AACvD,eAAO;AAAA,UACH;AAAA,UACA,gBAAgB,EAAE,GAAG,OAAO,GAAG,cAAc,IAAI;AAAA,UACjD,cACM,gBAAgB,eAAe,CAAC,CAAC,IACjC,gBAAgB,MAAM;AAAA,QAChC;AAAA,MACJ;AAAA,MACA,SAAS,MAAM;AACX,cAAM,oBACF,wBAAwB,OAAO,KAAK;AACxC,cAAM,yBACF,8BAA8B,iBAAiB,IAAI,OAAO,GACpD,YAAY;AACtB,kBAAU;AAAA,UACN;AAAA,YACI,aAAa,CAAC,cAAc;AACxB,cAAI;AAAA,gBACA;AAAA,gBACA;AAAA,cACJ;AAAA,YACJ;AAAA,YACA,cAAc,CAAC,QAAQ;AACnB,cAAI;AAAA,gBACA;AAAA,gBACA;AAAA,cACJ;AAAA,YACJ;AAAA,YACA,cAAc;AAAA,UAClB;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,WAAW,MAAM;AACb,0BAAkB;AAClB,YAAI,eAAe;AACf,qBAAW,eAAe,eAAe;AACrC,wBAAY;AAAA,UAChB;AACA,0BAAgB;AAAA,QACpB;AAEA,kBAAU;AACV,8BAAsB;AACtB,YAAI,kBAAkB;AAClB,qBAAW,OAAO,gBAAgB;AAClC,6BAAmB;AAAA,QACvB;AAEA,wBAAgB;AAAA,MACpB;AAAA,IACJ;AAAA,IACA;AAAA,IACA,aAAa,aAAa;AAAA,EAC9B;AACA,SAAO;AACX;;;AChSO,IAAM,WAA4D,CAAC;AAAA,EACtE;AACJ,MAAM,gBAAgB,kBAAkB,QAAQ,CAAC;AAM1C,SAAS,iBACZ,KACyC;AACzC,SAAO,OAAO,IAAI,qBAAqB;AAC3C;AAEO,SAAS,kCACZ,WACyB;AACzB,SAAO,CAAC,OAAe,cAAc;AACjC,UAAM,WAAW,IAAI,UAAU,KAAK;AACpC,QAAI,SAAS;AACT,gBAAU,UAAU,SAAS,UAAU,KAAK,QAAQ,CAAC;AACzD,QAAI,SAAS;AACT,gBAAU,QAAQ,SAAS,QAAQ,KAAK,QAAQ,CAAC;AACrD,QAAI,SAAS;AACT,gBAAU,QAAQ,SAAS,QAAQ,KAAK,QAAQ,CAAC;AACrD,QAAI,SAAS;AACT,gBAAU,UAAU,SAAS,UAAU,KAAK,QAAQ,CAAC;AACzD,QAAI,CAAC,SAAS;AAAQ,aAAO;AAC7B,WAAO,SAAS,OAAO;AAAA,EAC3B;AACJ;AAEO,SAAS,cACZ,MACA,UACG,UACO;AACV,MAAI,OAAO,SAAS,UAAU;AAC1B,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA,gBAAgB,kBAAkB,QAAQ,CAAC;AAAA,IAC/C;AAAA,EACJ;AACA,SAAO,oBAA4B,MAAM,OAAO,QAAQ;AAC5D;AACA,cAAc,WAAW;;;ACvDlB,IAAMC,YAA4D,CAAC;AAAA,EACtE;AACJ,MAAM,gBAAgB,kBAAkB,QAAQ,CAAC;;;ACD1C,IAAK,6BAAL,kBAAKC,gCAAL;AACH,EAAAA,4BAAA,WAAQ;AACR,EAAAA,4BAAA,aAAU;AAFF,SAAAA;AAAA,GAAA;AAeL,SAAS,4BACZ,cACA,iBACA,OACA,WACU;AACV,QAAM,QAAgB,CAAC;AACvB,QAAM,eAAe,oBAAI,IAAsC;AAE/D,WAAS,OAAO,MAAY,WAAuC;AAC/D,mBAAe,MAAM,SAAS;AAC9B,QAAI,gBAAgB,SAAS;AACzB,wBAAkB,MAAM,SAAS;AAAA,IACrC;AAAA,EACJ;AACA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,SAAS,CAAC,UAAU;AAChB,mBAAW,eAAe,gBAAgB,OAAO,KAAK,GAAG;AACrD,uBAAa;AAAA,YACT;AAAA,YACA;AAAA,UACJ;AACA,qBAAW;AAAA;AAAA,UAEX;AACA,qBAAW;AAAA;AAAA,UAEX;AAAA,QACJ;AACA,YAAI,MAAM,kCAAkC,MAAM,OAAO;AACrD,qBAAW,aAAa,MAAM,OAAO;AACjC,yBAAa;AAAA,cACT;AAAA,cACA;AAAA,YACJ;AAAA,UACJ;AACA,qBAAW;AAAA;AAAA,UAEX;AACA,qBAAW;AAAA;AAAA,UAEX;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,OAAO,MAAM;AACT,eAAO;AAAA,UACH;AAAA,UACA;AAAA,UACA,MAAM,MAAM;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,SAAS,MAAM;AACX,mBAAW,QAAQ,OAAO;AACtB,uBAAa,IAAI,MAAM,mBAAgC;AACvD,qBAAW;AAAA;AAAA,UAEX;AACA,qBAAW;AAAA;AAAA,UAEX;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,WAAW,MAAM;AACb,mBAAW,QAAQ,OAAO;AACtB,uBAAa,IAAI,MAAM,uBAAkC;AACzD,qBAAW;AAAA;AAAA,UAEX;AACA,qBAAW;AAAA;AAAA,UAEX;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,UAAU,CAAC,UAAU;AACjB,gBAAQ,OAAO;AAAA,UACX;AACI,uBAAW,CAAC,MAAM,KAAK,KAAK,aAAa,QAAQ,GAAG;AAChD,kBAAI,UAAU,yBAAoC;AAC9C;AAAA,kBACI;AAAA,kBACA;AAAA,gBACJ;AAAA,cACJ;AAAA,YACJ;AACA;AAAA,UACJ;AACI,uBAAW,CAAC,MAAM,KAAK,KAAK,aAAa,QAAQ,GAAG;AAChD,kBAAI,UAAU,qBAAkC;AAC5C,uBAAO,MAAM,mBAAgC;AAAA,cACjD;AAAA,YACJ;AACA,yBAAa,MAAM;AACnB;AAAA,QACR;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACjB;AACA,SAAO;AACX;;;ACjHO,IAAM,oBAIR,CAAC,EAAE,cAAc,iBAAiB,SAAS,MAAM;AAClD,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA,gBAAgB,kBAAkB,QAAQ,CAAC;AAAA,EAC/C;AACJ;;;ACiGO,SAAS,uBAOZ,MACA,YACA,kBACA,SACA,eACA,QACA,WACU;AACV,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,QAAM,QAAyB,oBAAI,IAAI;AACvC,MAAI;AAEJ,WAAS,eAAe;AACpB,QAAI,CAAC,QAAQ;AACT,UAAI,mBAAmB;AACvB,YAAM,YAAmC;AAAA,QACrC,SAAS,CAAC,YAAuC;AAC7C,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC;AAAkB,+BAAmB,CAAC;AAC3C,2BAAiB,KAAK,OAAO;AAAA,QACjC;AAAA,QACA,WAAW,CAAC,YAAwB;AAChC,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,OAAO;AAAA,QACnC;AAAA,QACA,WAAW,CAAC,YAAwB;AAChC,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,OAAO;AAAA,QACnC;AAAA,QACA,SAAS,CAAC,YAA8C;AACpD,UAAI;AAAA,YACA;AAAA,YACA;AAAA,UACJ;AACA,UAAI,OAAO,CAAC,cAAc,+BAA+B;AACzD,yBAAe;AAAA,QACnB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,kBAAkB,CACd,MACA,SAKAC,aACC;AACD,gBAAM,WAAW,CAAC,UAAiB;AAC/B,oBAAQ,KAAK,MAAM,OAAO,IAAI;AAAA,UAClC;AACA,eAAK,iBAAiB,MAAM,UAAUA,QAAO;AAC7C,gBAAM,cAAc,MAAM;AACtB,iBAAK,oBAAoB,MAAM,UAAUA,QAAO;AAAA,UACpD;AACA,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,WAAW;AACnC,iBAAO;AAAA,QACX;AAAA,QACA,+BAA+B,CAAC,OAAO,UAAU;AAE7C,2BAAiB,KAAK,IAAI,OAAO,KAAK;AACtC,gBAAM,cAAc,aAAa,OAAO,CAAC,KAAK,aAAa;AACvD,gBAAI,QAAQ,QAAW;AAEnB,+BAAiB,KAAK,IAAI;AAAA,YAC9B,OAAO;AAAA,YAEP;AAAA,UACJ,CAAC;AACD,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,WAAW;AACnC,iBAAO;AAAA,QACX;AAAA,QACA,eAAe,CAAC,cAAc;AAC1B,cAAI,CAAC,kBAAkB;AACnB,kBAAM,IAAI;AAAA,cACN,oDAAoD,QAAQ;AAAA,YAChE;AAAA,UACJ;AACA,gBAAM,SAAS,CAACC,eAAyB;AACrC,gBACI,OAAOA,eAAc,YACrBA,sBAAqB,QACrBA,sBAAqB,UACvB;AACE,gCAAkB,aAAaA,UAAS;AAAA,YAC5C,OAAO;AACH,oBAAM,EAAE,OAAO,MAAM,IAAIA;AACzB,kBAAI,UAAU,QAAW;AACrB,kCAAkB,aAAa,KAAK;AAAA,cACxC,OAAO;AACH,kCAAkB,aAAa,OAAO,KAAK;AAAA,cAC/C;AAAA,YACJ;AAAA,UACJ;AACA,iBAAO,OAAO,SAAS,CAAC;AACxB,gBAAM,cAAc;AAAA,YAChB;AAAA,YACA,CAAC,KAAK,WAAW;AACb,kBAAI,QAAQ,QAAW;AACnB,uBAAO,MAAM;AAAA,cACjB,OAAO;AAAA,cAEP;AAAA,YACJ;AAAA,UACJ;AACA,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,WAAW;AACnC,iBAAO;AAAA,QACX;AAAA,QACA,cAAc,CAAC,aAAa;AACxB,cAAI,CAAC,kBAAkB;AACnB,kBAAM,IAAI;AAAA,cACN,oDAAoD,QAAQ;AAAA,YAChE;AAAA,UACJ;AACA,gBAAM,SAAS,CAACC,cAAuB;AACnC,kBAAM,EAAE,OAAO,SAAS,OAAO,IAAIA;AACnC,8BAAkB,YAAY,OAAO,SAAS,MAAM;AAAA,UACxD;AACA,gBAAM,MAAM,OAAO,QAAQ;AAC3B,iBAAO,GAAG;AACV,gBAAM,cAAc,aAAa,UAAU,CAAC,KAAKC,SAAQ;AACrD,gBAAI,QAAQ,QAAW;AACnB,qBAAOA,IAAG;AAAA,YACd,OAAO;AAAA,YAEP;AAAA,UACJ,CAAC;AACD,cAAI,CAAC;AAAoB,iCAAqB,CAAC;AAC/C,6BAAmB,KAAK,WAAW;AACnC,iBAAO;AAAA,QACX;AAAA,QACA,eAAe,MAAM;AACjB,cAAI,CAAC,kBAAkB;AACnB,kBAAM,IAAI;AAAA,cACN,oDAAoD,QAAQ;AAAA,YAChE;AAAA,UACJ;AACA,4BAAkB,cAAc;AAAA,QACpC;AAAA,QACA,gBAAgB,MAAM;AAClB,cAAI,CAAC,kBAAkB;AACnB,kBAAM,IAAI;AAAA,cACN,oDAAoD,QAAQ;AAAA,YAChE;AAAA,UACJ;AACA,4BAAkB,eAAe;AAAA,QACrC;AAAA,MACJ;AAEA,YAAM,iBACF,QAAQ,eAAe,SACjB;AAAA,QACI,GAAG;AAAA,QACH,UAAU,cAAc,aAAa;AAAA,MACzC,IACA;AAAA,QACI,GAAG;AAAA,MACP;AACV,YAAM,YAAY,QAAQ;AAC1B,UAAI;AACJ,UAAI;AACA,oBACI,UAAU,gBAAgB,SAAS,KAAK;AAAA,MAChD,SAAS,GAAP;AACE,cAAMC,SAAQ,UAAU,GAAG,mCAAmC;AAC9D,YAAI,cAAc;AACd,sBAAY,aAAaA,MAAK,KAAK;AAAA,QACvC,OAAO;AACH,sBAAYA;AAAA,QAChB;AAAA,MACJ;AACA,yBAAmB;AACnB,iBAAW,QAAQ,OAAO;AACtB,eAAO,IAAI;AAAA,MACf;AACA,UAAI,EAAE,qBAAqB,QAAQ;AAC/B,iBAAS,cAAc,SAAS;AAAA,MACpC,OAAO;AACH,iBAAS;AAAA,MACb;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAEA,QAAM,aAAa,IAAI;AAAA,IACnB;AAAA,MACI,SAAS,MAAM;AACX,cAAMC,UAAS,aAAa;AAC5B,YAAIA,mBAAkB,OAAO;AACzB,UAAI,KAAK,6CAA6C;AAAA,YAClD,OAAOA;AAAA,YACP;AAAA,UACJ,CAAC;AAAA,QACL,OAAO;AACH,qBAAW,SAASA,OAAM;AAAA,QAC9B;AAAA,MACJ;AAAA,MACA,WAAW,MAAM;AACb,YAAI,oBAAoB;AACpB,qBAAW,YAAY,oBAAoB;AACvC,qBAAS;AAAA,UACb;AAAA,QACJ;AAEA,iBAAS;AACT,2BAAmB;AACnB,6BAAqB;AACrB,6BAAqB;AACrB,uBAAe;AAEf,mBAAW,QAAQ,OAAO;AACtB,kBAAQ,IAAI;AAAA,QAChB;AACA,cAAM,MAAM;AAAA,MAChB;AAAA,MACA,UAAU,CAAC,kBAAkB;AACzB,YAAI,kBAAkB,OAAO;AACzB,wBAAc,aAAa,MAAM;AAAA,QACrC;AAAA,MACJ;AAAA,MACA,SAAS,CAACD,WAAiB;AACvB,YAAI,cAAc;AACd,gBAAM,gBAAgB,aAAaA,MAAK;AACxC,mBAAS,gBACH,cAAc,aAAa,IAC3B;AACN,qBAAW,SAAS,MAAM;AAC1B,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,MACA,UAAU;AACN,QAAI,OAAO,QAAQ,2BAA2B;AAC9C,YAAI,kBAAkB,OAAO;AACzB;AAAA,QACJ;AACA,mBAAW,kCAAgD;AAAA,MAC/D;AAAA,MACA,YAAY;AACR,QAAI,OAAO,QAAQ,2BAA2B;AAC9C,YAAI,kBAAkB,OAAO;AACzB;AAAA,QACJ;AACA,YAAI,oBAAoB;AACpB,qBAAW,YAAY,oBAAoB;AACvC,qBAAS;AAAA,UACb;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,SAAS,OAA8B;AACnC,YACI,kCACA,kBACF;AACE,qBAAW,YAAY,kBAAkB;AACrC,kBAAM,iBAAiB,SAAS;AAChC,gBAAI,OAAO,mBAAmB,YAAY;AACtC,kBAAI,CAAC,oBAAoB;AACrB,qCAAqB,CAAC;AAAA,cAC1B;AACA,oBAAM,YAAY,MAAM;AACpB,+BAAe;AACf,oBAAI,oBAAoB;AACpB,wBAAM,QACF,mBAAmB,QAAQ,SAAS;AACxC,sBAAI,SAAS,GAAG;AACZ,uCAAmB,OAAO,OAAO,CAAC;AAAA,kBACtC;AAAA,gBACJ;AAAA,cACJ;AACA,iCAAmB,KAAK,SAAS;AAAA,YACrC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,QAAQ;AACJ,QAAI;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,IACA,aAAa,iBAAiB,QAAQ;AAAA,EAC1C;AACA,SAAO;AACX;;;AC9ZO,SAAS,oBAMd,SAA4D;AAC1D,QAAM,aAAa,QAAQ,UACrB,+BAA+B,EAAE,QAAQ,OAAO,IAChD;AACN,QAAM,2BAA2B,WAAiC;AAAA,IAY9D,cAAc;AACV,YAAM;AACN,YAAM,aAAa,QAAQ,aACrB,KAAK,aAAa;AAAA,QACd,gBAAgB,QAAQ;AAAA,QACxB,MAAM,QAAQ;AAAA,MAClB,CAAC,IACD;AAEN,YAAM,mBAAmB,QAAQ,UAC3B,SACA,KAAK,gBAAgB;AAE3B,WAAK,iBAAiB,MAA0B,MAAS;AACzD,WAAK,UAAU,CAAC;AAChB,cAAQ,oBAAoB,QAAQ,CAAC,SAAS;AAC1C,aAAK,QAAQ,IAAI,IAAI,MAA0B,MAAS;AAAA,MAC5D,CAAC;AAED,WAAK,cAAc;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,MACT;AACA,WAAK,oBAAoB;AAAA,QACrB,cAAc;AAAA,QACd,KAAK;AAAA,QACL;AAAA,MACJ;AACA,WAAK,oBAAoB;AACzB,WAAK,cAAc,UAAU,QAAQ;AACrC,WAAK,aAAa;AAAA,IACtB;AAAA,IAEA,SAAS;AACL,WAAK,mBAAmB,QAAQ;AAChC,UAAI,KAAK,mBAAmB;AACxB,aAAK,gBAAgB,GAAG,KAAK,iBAAiB;AAAA,MAClD;AAAA,IACJ;AAAA,IAEA,UAAU;AACN,UACI,QAAQ,yBAAyB,SACjC,KAAK,SAAS,WAAW,KACzB,KAAK,SAAS,CAAC,aAAa,qBAC9B;AACE,aAAK,oBAAoB,MAAM,KAAK,KAAK,UAAU;AACnD,aAAK;AAAA,UACD,GAAG,KAAK,kBAAkB;AAAA,YAAI,CAAC,SAC3B,gBAAgB,sBACV,KAAK,UACL;AAAA,UACV;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,WAAmB,CAAC;AACxB,UAAI,CAAC,QAAQ,YAAY;AACrB,mBAAW,MAAM,KAAK,KAAK,UAAU;AACrC,aAAK,gBAAgB;AACrB,aAAK,eAAe,IAAI,QAAQ;AAAA,MACpC;AACA,WAAK,mBAAmB,OAAO;AAC/B,WAAK,mBAAmB,OAAO;AAAA,QAC3B,aAAa,CAAC,UAAU;AACpB,UAAI,OAAO,OAAO,gCAAgC,KAAK;AAAA,QAC3D;AAAA,QACA,cAAc,CAACE,WAAU;AACrB,UAAI,MAAM,uCAAuCA,MAAK;AAAA,QAC1D;AAAA,QACA,cAAc,KAAK,gBAAgB;AAAA,MACvC,CAAC;AAAA,IACL;AAAA,IAEA,SAAS;AACL,aAAO,IAAI;AAAA,IACf;AAAA,IAEA,UAAU;AACN,cAAQ,IAAI;AAAA,IAChB;AAAA,IAEA,oBAAoB;AAChB,WAAK,OAAO;AACZ,WAAK,mBAAmB,QAAQ;AAAA,IACpC;AAAA,IAEA,uBAAuB;AACnB,WAAK,mBAAmB,UAAU;AAClC,WAAK,QAAQ;AAAA,IACjB;AAAA,IAEA,kBAAkB;AAAA,IAElB;AAAA,IAEA,yBACI,MACA,UACA,UACF;AACE,WAAK,QAAQ,IAAa,EAAE,IAAI,QAAQ;AAAA,IAC5C;AAAA,EACJ;AA7GI,EATE,mBASK,iBAAiB,QAAQ,kBAAkB;AAClD,EAVE,mBAUK,qBAAqB,QAAQ,sBAAsB,CAAC;AA6G/D,MAAI,QAAQ,SAAS;AACjB,mBAAe,OAAO,QAAQ,SAAS,oBAAoB;AAAA,MACvD,SAAS,QAAQ;AAAA,IACrB,CAAC;AAAA,EACL,OAAO;AACH,mBAAe,OAAO,QAAQ,SAAS,kBAAkB;AAAA,EAC7D;AACJ;;;AC9IO,SAAS,MACZ,QACA,MACU;AACV,QAAM,aAAa,eAAe,MAAM;AACxC,MAAI,YAAY;AACZ,IAAI;AAAA,MACA;AAAA,IACJ;AACA,eAAW;AAAA,EACf;AACA,EAAI;AAAA,IACA,OAAO,WAAW,WAAW;AAAA,IAC7B;AAAA,IACA,EAAE,OAAO;AAAA,EACb;AACA,QAAM,OAAO,iBAAiB,QAAQ,cAAc,IAAI,GAAG,MAAM,MAAM;AACvE,OAAK,OAAO;AAEZ,MAAI;AACJ,OAAK,OAAO;AAAA,IACR,aAAa,CAAC,UAAU;AACpB,MAAI,OAAO,OAAO,sCAAsC,KAAK;AAAA,IACjE;AAAA,IACA,cAAc,CAACC,WAAU;AACrB,kBAAYA;AACZ,MAAI,MAAM,yBAAyBA,MAAK;AAAA,IAC5C;AAAA,IACA,eACK,kBAAkB,UACb,OAAO,eACP,OAAO,KAAK,iBAAiB;AAAA,EAC3C,CAAC;AACD,MAAI,WAAW;AACX,SAAK,QAAQ;AACb,UAAM;AAAA,EACV;AAUA,OAAK,QAAQ;AAEb,MAAI,eAAe;AACnB,QAAM,cAAc,MAAM;AACtB,QAAI,cAAc;AACd,MAAI,KAAK,gDAAgD;AACzD;AAAA,IACJ;AACA,mBAAe,MAAM;AACrB,mBAAe;AACf,SAAK,UAAU;AACf,UAAM;AACN,WAAO,gBAAgB;AACvB,SAAK,OAAO;AACZ,SAAK,QAAQ;AAAA,EACjB;AACA,qBAAmB,QAAQ,WAAW;AAEtC,QAAM;AAEN,SAAO;AACX;;;ACCA,IAAO,cAAQ;AAER,IAAM,UACT,OAAkC,WAAc;",
  "names": ["ArrayEventType", "error", "event", "renderJSXNode", "collection", "DictEventType", "dict", "field", "processHandler", "vertexId", "vertex", "ModelEventType", "model", "dict", "field", "defaultScheduler", "dict", "debug", "error", "calc", "renderJSXNode", "subscribe", "error", "error", "error", "createElement", "element", "Fragment", "IntrinsicObserverEventType", "options", "formValue", "validity", "val", "error", "result", "error", "error"]
}
