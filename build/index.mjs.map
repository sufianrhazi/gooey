{
  "version": 3,
  "sources": ["../src/types.ts", "../src/log.ts", "../src/util.ts", "../src/tarjan.ts", "../src/graph.ts", "../src/engine.ts", "../src/ref.ts", "../src/jsx.ts", "../src/arrayevent.ts", "../src/sentinel.ts", "../src/calc.ts", "../src/field.ts", "../src/fieldmap.ts", "../src/subscriptionemitter.ts", "../src/subscriptionconsumer.ts", "../src/trackeddata.ts", "../src/collection.ts", "../src/rendernode.tsx", "../src/view.ts", "../src/model.ts", "../src/index.ts"],
  "sourcesContent": ["export class InvariantError extends Error {\n    detail?: any;\n    constructor(msg: string, detail?: any) {\n        super(msg);\n        this.detail = detail;\n    }\n}\n", "import { InvariantError } from './types';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function getLogLevel(): LogLevel {\n    if (currentLevel >= levels.info) return 'info';\n    if (currentLevel >= levels.warn) return 'warn';\n    if (currentLevel >= levels.debug) return 'debug';\n    return 'error';\n}\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function group(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.group(...items);\n    }\n}\n\nexport function groupEnd() {\n    if (currentLevel >= levels.debug) {\n        console.groupEnd();\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function fail(msg: string, ...items: any[]): never {\n    error('Invariant error', msg, ...items);\n    throw new InvariantError(`Invariant error: ${msg}`);\n}\n\nexport function assert(check: any, msg: string): asserts check {\n    if (!check) {\n        error(\n            'Assertion failure',\n            check === undefined\n                ? 'undefined'\n                : check === null\n                ? 'null'\n                : check.toString(),\n            'is not truthy',\n            msg\n        );\n        throw new InvariantError(`Assertion failure: ${msg}`);\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new InvariantError('Assertion failure', { context, items });\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function* noopGenerator() {}\n\nexport const dead = (): any => {\n    throw new Error('Cannot call dead function');\n};\n\nexport const uniqueid = (() => {\n    let id = 1;\n    return () => id++;\n})();\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy<TItem, TKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TKey, TVal]\n): Map<TKey, TVal[]> {\n    const grouped: Map<TKey, TVal[]> = new Map();\n    items.forEach((item) => {\n        const [key, val] = grouper(item);\n        let inner = grouped.get(key);\n        if (!inner) {\n            inner = [];\n            grouped.set(key, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function alwaysFalse(): false {\n    return false;\n}\n\nexport function strictEqual<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low)) + low;\n}\n\nexport function median(numbers: number[]): number {\n    const sorted = numbers.slice().sort((a, b) => a - b);\n    return (\n        (sorted[Math.floor((numbers.length - 1) / 2)] +\n            sorted[Math.ceil((numbers.length - 1) / 2)]) /\n        2\n    );\n}\n\nexport function wrapError(e: unknown, msg?: string): Error {\n    if (e instanceof Error) return e;\n    // @ts-ignore -- 2nd error cause param harmless to add\n    const err = new Error(msg ?? 'Unknown error', { cause: e });\n    return err;\n}\n", "type Vertex = {\n    nodeId: number;\n    index?: number;\n    lowlink?: number;\n    onStack?: boolean;\n};\n\nexport function tarjanStronglyConnected(\n    reverseAdjacency: readonly (readonly number[])[],\n    topologicalIndexById: readonly (number | undefined)[],\n    lowerBound: number,\n    upperBound: number,\n    fromNodes: Iterable<number>\n): number[][] {\n    let index = 0;\n    const nodeVertex: Record<number, Vertex> = {};\n    const stack: Vertex[] = [];\n    const reverseTopoSort: number[][] = [];\n\n    function* getDepenencies(nodeId: number) {\n        for (const toId of reverseAdjacency[nodeId]) {\n            const toIndex = topologicalIndexById[toId];\n            if (\n                toIndex !== undefined &&\n                lowerBound <= toIndex &&\n                toIndex <= upperBound\n            ) {\n                yield toId;\n            }\n        }\n    }\n\n    const strongconnect = (vertex: Vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index = index + 1;\n        stack.push(vertex);\n        vertex.onStack = true;\n\n        // Consider successors of v\n        for (const toId of getDepenencies(vertex.nodeId)) {\n            if (!nodeVertex[toId]) {\n                nodeVertex[toId] = {\n                    nodeId: toId,\n                };\n            }\n            const toVertex = nodeVertex[toId];\n            if (toVertex.index === undefined) {\n                // Successor toVertex has not yet been visited; recurse on it\n                strongconnect(toVertex);\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    toVertex.lowlink!\n                );\n            } else if (toVertex.onStack) {\n                // Successor toVertex is in stack S and hence in the current SCC\n                // If toVertex is not on stack, then (vertex, toVertex) is an edge pointing to an SCC already found and must be ignored\n                // Note: The next line may look odd - but is correct.\n                // It says toVertex.index not toVertex.lowlink; that is deliberate and from the original paper\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    toVertex.index\n                );\n            }\n        }\n\n        // If vertex is a root node, pop the stack and generate an SCC\n        if (vertex.lowlink === vertex.index) {\n            // start a new strongly connected component\n            const component: number[] = [];\n            for (;;) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const toVertex = stack.pop()!;\n                toVertex.onStack = false;\n                // add toVertex to current strongly connected component\n                component.push(toVertex.nodeId);\n                if (toVertex === vertex) {\n                    break;\n                }\n            }\n            // output the current strongly connected component\n            reverseTopoSort.push(component);\n        }\n    };\n\n    for (const nodeId of fromNodes) {\n        if (!nodeVertex[nodeId]) {\n            nodeVertex[nodeId] = {\n                nodeId,\n            };\n            strongconnect(nodeVertex[nodeId]);\n        }\n    }\n\n    return reverseTopoSort;\n}\n", "/*\n * The Directed Graph\n * ==================\n *\n * The directed graph is a fully dynamic directed graph: vertices and edges may be added and removed at any time.\n *\n * Main challenge: maintain the topological ordering after each batch of vertex/edge additions/removals.\n *\n * Each vertex has a set of flags which may be set/cleared:\n * - \"dirty\": which is set when the vertex\u2019s underlying data is modified/invalidated.\n * - \"cycle\": set when the vertex is part of a cycle (more correctly: a strongly connected component with >1 vertex)\n * - \"self cycle\": set when the vertex has an edge pointing to itself (completely separate from \"cycle\")\n * - \"cycle informed\": set when the vertex has been processed as a cycle\n *\n * Edges in the graph have two colors:\n * - \u201Chard\u201D: represent data dependencies that propagate\n * - \u201Csoft\u201D: exist solely to maintain topological ordering\n *\n * When a dirty vertex is processed, its dirtiness is cleared. Depending on the result of processing the vertex,\n * dirtiness may be propagated to destination vertices, which have their dirty bit set.\n *\n *\n * Topological Ordering\n * --------------------\n *\n * Our primary goal is to process the dirty vertices in this graph in topological order. One hitch is that during the\n * processing of dirty vertices, edges may be added and vertices may be marked as dirty.\n *\n * Since a topological ordering means arrows go from left to right, the only thing that could possibly break a\n * topological ordering is the addition of an edge that goes in the opposite direction.\n *\n * When we add an edge that goes in the opposite direction, we add the vertices to a set that need to be reordered.\n *\n * It's important to note that if topological order is maintained, a cycle can only occur if an edge is added in the\n * incorrect order (or to itself).\n *\n * This graph uses a variation on the Pearce Kelly algorithm to maintain the topological ordering in this case\n * (https://whileydave.com/publications/pk07_jea/) while supporting cycles.\n *\n * The general structure of this variation is:\n * - Get the lower and upper index bounds of the set of out of order vertices\n * - Instead of using DFS to determine the correct order of the subgraph within the upper/lower bounds, use Tarjan's\n *   strongly connected component algorithm to both determine the order and obtain strongly connected components\n *\n *\n * Handling Cycles\n * ---------------\n *\n * One edge case not explicitly handled by the Pearce Kelly algorithm is how to handle cycles/strongly connected\n * components. This directed graph allows for cycles in the directed graph to exist.\n *\n * Note: The term cycle to mean a set of vertices that can all reach each other. This set may have a size of one.\n *\n * In this case, for the purposes of the graph, all nodes in a cycle are treated as a single unit:\n * - If any of the cycle vertices are marked as \u201Cdirty\u201D they all are marked as \u201Cdirty\u201D\n * - If any of the cycle vertices are processed, they are all processed (in arbitrary order) and dirtiness is propagated\n *   only to vertices that are not members of the cycle.\n *\n * When an edge is added that introduces a cycle, that edge will go from right to left. We will identify these cycles\n * when reordering. In every cycle there is at least one edge that goes in the wrong direction.\n *\n * If an edge that connects two vertices in a cycle is removed there are two cases to consider:\n *\n * Case 1) If the removed edge goes in the correct direction, the cycle may be broken. If broken, there exists at least\n * one edge in the cycle that goes in the wrong direction. In this case, the topological order of the subgraph\n * reachable/that reaches the vertices needs to be reordered. Tarjan\u2019s strongly connected components algorithm is used\n * to reorder the reachable subgraph in this case: identify the subgraph via a DFS traversal forward and backward, then\n * perform the algorithm on the subgraph.\n *\n * Case 2) If the edge goes in the wrong direction, no adjustments to the topological ordering need to be performed.\n * (This is a bold statement. Can a proof be demonstrated? Does this apply if edges are added to vertices in the middle\n * of a cycle?)\n *\n * **Open question**: when sorting and assigning vertices in a cycle, do we ever put anything in the middle of a cycle? We\n * should not.\n *\n * Given:\n * - a b c d e\n * - a->b->d->e->a\n * - And an addition: c->d\n * - We should place c before a as in: c a b d e\n * - This is since the component really \u201Clives\u201D at the first index of a cycle.\n *\n *\n * Graph Processing\n * ----------------\n *\n * The goal of graph processing is to visit all of the vertices marked as dirty and get them marked as not dirty.\n * Processing the graph is a coroutine operation, where a set of actions is produced and in response a Boolean is returned,\n * which indicates whether or not dirtiness should be propagated.\n *\n * When visiting a dirty node, one of three things happens:\n * - If the vertex is part of a cycle, it emits a cycle action.\n * - Otherwise, a recalculate action is emitted.\n *\n * While the graph doesn't concern itself with what these actions perform, in practice:\n * - Invalidation events clear cached data associated with the vertex. These always propagate dirtiness.\n * - Cycle events raise an error. These propagate dirtiness if the error is caught and the value produced is equal to the\n *   prior value.\n * - Recalculation events cause the calculation associated with the vertex to be re-executed. Propagation occurs if the\n *   value produced is equal to the prior value.\n *\n * The naive procedure of processing the graph is to iterate through the dirty vertices in topological order of the graph.\n * Upon discovering a dirty vertex:\n * - If it is part of a cycle, and is not cycle informed, emit a cycle, mark as informed, and conditionally propagate dirtiness\n * - If it ((is not part of a cycle) or (is part of a cycle and is cycle informed)), emit a recalculation and conditionally propagate dirtiness\n *\n * After processing a dirty vertex, perform any pending vertex/edge additions and removals caused by processing while\n * maintaining topological order. Proceed to the dirty vertex with lowest priority order. This ordering of dirty vertices\n * can be maintained with a priority queue that supports reassigning weights.\n *\n * Once all dirty vertices are processed, the operation is complete.\n *\n * It is possible for this algorithm to loop indefinitely. To avoid this, a process limit can be imposed (either per-vertex\n * or globally).\n *\n */\nimport { tarjanStronglyConnected } from './tarjan';\nimport * as log from './log';\n\nexport enum EdgeColor {\n    EDGE_SOFT = 0b01,\n    EDGE_HARD = 0b10,\n}\n\ninterface CycleInfo {\n    lowerBound: number;\n    upperBound: number;\n    vertexIds: Set<number>;\n}\n\nexport enum ProcessAction {\n    INVALIDATE,\n    RECALCULATE,\n    CYCLE,\n}\n\nconst VERTEX_BIT_DIRTY /* ********** */ = 0b0001;\nconst VERTEX_BIT_CYCLE /* ********** */ = 0b0010;\nconst VERTEX_BIT_SELF_CYCLE /* ***** */ = 0b0100;\nconst VERTEX_BIT_CYCLE_INFORMED /* * */ = 0b1000;\n\ninterface DebugAttributes {\n    isActive: boolean;\n    name: string;\n}\n\ntype DebugFormatter<TVertex> = (vertex: TVertex) => DebugAttributes;\ntype DebugSubscription = (graphviz: string, label: string) => void;\n\nexport class Graph<TVertex> {\n    static EDGE_SOFT = EdgeColor.EDGE_SOFT;\n    static EDGE_HARD = EdgeColor.EDGE_HARD;\n\n    /** identifiers available for reuse */\n    protected declare availableIds: number[];\n    protected declare availableIndices: number[];\n    protected declare nextId: number;\n\n    /** Mapping of id -> vertex */\n    protected declare vertexToId: Map<TVertex, number>;\n    protected declare vertexById: (TVertex | undefined)[];\n\n    /** Mapping of id -> bits */\n    protected declare vertexBitsById: number[];\n\n    /** Mapping of id -> CycleInfo */\n    protected declare cycleInfoById: Record<number, CycleInfo | undefined>;\n\n    /** Mapping of id -> hard edges in the forward direction */\n    protected declare forwardAdjacencyHard: number[][];\n\n    /** Mapping of id -> hard|soft edges in the forward direction */\n    protected declare forwardAdjacencyEither: number[][];\n\n    /** Mapping of id -> hard|soft edges in the reverse direction */\n    protected declare reverseAdjacencyEither: number[][];\n\n    /** Mapping of id -> index into topologicalOrdering */\n    protected declare topologicalIndexById: (number | undefined)[];\n\n    /** Ordered list of vertex ids */\n    protected declare topologicalOrdering: (number | undefined)[];\n\n    /** The start index of process(), moves forward in each step, may move back as a result of dirty vertices being added / reordered */\n    protected declare startVertexIndex: number;\n\n    /** Set of vertex ids that need reordering */\n    protected declare toReorderIds: Set<number>;\n\n    private declare debugSubscriptions: Set<{\n        formatter: DebugFormatter<TVertex>;\n        subscription: DebugSubscription;\n    }>;\n\n    private declare postActions: (() => void)[];\n\n    private declare _processHandler: (\n        vertex: TVertex,\n        action: ProcessAction,\n        addPostAction: (postAction: () => void) => void\n    ) => boolean;\n\n    constructor(\n        processHandler: (\n            vertex: TVertex,\n            action: ProcessAction,\n            addPostAction: (postAction: () => void) => void\n        ) => boolean\n    ) {\n        this._processHandler = processHandler;\n\n        this.nextId = 1;\n        this.availableIds = [];\n        this.availableIndices = [];\n\n        this.vertexById = [];\n        this.vertexToId = new Map();\n\n        this.vertexBitsById = [];\n        this.cycleInfoById = {};\n        this.topologicalIndexById = [];\n        this.topologicalOrdering = [];\n\n        this.forwardAdjacencyHard = [];\n        this.forwardAdjacencyEither = [];\n        this.reverseAdjacencyEither = [];\n\n        this.postActions = [];\n\n        this.startVertexIndex = 0;\n        this.toReorderIds = new Set();\n\n        this.debugSubscriptions = new Set();\n    }\n\n    /**\n     * Vertex ids can be reused.\n     *\n     * If a vertex is added, it gets a new id\n     * If a vertex is deleted, its id is removed\n     * If a\n     */\n    addVertex(vertex: TVertex) {\n        log.assert(!this.vertexToId.has(vertex), 'double vertex addition');\n\n        let id: number;\n        if (this.availableIds.length > 0) {\n            id = this.availableIds.pop() as number;\n        } else {\n            id = this.nextId++;\n        }\n\n        this.vertexToId.set(vertex, id);\n        this.vertexById[id] = vertex;\n        this.vertexBitsById[id] = 0;\n\n        let index: number;\n        if (this.availableIndices.length > 0) {\n            index = this.availableIndices.pop() as number;\n        } else {\n            index = this.topologicalOrdering.length;\n            this.topologicalOrdering.length += 1;\n        }\n\n        this.topologicalIndexById[id] = index;\n        this.topologicalOrdering[index] = id;\n\n        this.forwardAdjacencyHard[id] = [];\n        this.forwardAdjacencyEither[id] = [];\n        this.reverseAdjacencyEither[id] = [];\n    }\n\n    removeVertex(vertex: TVertex) {\n        const id = this.vertexToId.get(vertex);\n        log.assert(id, 'double vertex removal');\n        const index = this.topologicalIndexById[id];\n        log.assert(index !== undefined, 'malformed graph');\n\n        // Note: no need to clear edges as you can only remove vertices with no edges\n        log.assert(\n            this.forwardAdjacencyEither[id].length === 0,\n            'cannot remove vertex with forward edges'\n        );\n        log.assert(\n            this.reverseAdjacencyEither[id].length === 0,\n            'cannot remove vertex with reverse edges'\n        );\n\n        this.topologicalIndexById[id] = undefined;\n        this.topologicalOrdering[index] = undefined;\n\n        this.clearVertexDirtyInner(id);\n        this.vertexBitsById[id] = 0;\n        delete this.cycleInfoById[id];\n        this.vertexToId.delete(vertex);\n        this.vertexById[id] = undefined;\n        this.toReorderIds.delete(id);\n\n        // Mark vertices as available for reuse\n        this.availableIds.push(id);\n        this.availableIndices.push(index);\n    }\n\n    hasVertex(vertex: TVertex) {\n        return this.vertexToId.has(vertex);\n    }\n\n    markVertexDirty(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexDirty on nonexistent vertex');\n        this.markVertexDirtyInner(vertexId);\n    }\n\n    private markVertexDirtyInner(vertexId: number) {\n        const vertex = this.vertexById[vertexId];\n        if (vertex && !(this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY)) {\n            this.vertexBitsById[vertexId] |= VERTEX_BIT_DIRTY;\n            this.processHandler(vertex, ProcessAction.INVALIDATE);\n\n            const index = this.topologicalIndexById[vertexId];\n            if (index !== undefined && index < this.startVertexIndex) {\n                this.startVertexIndex = index;\n            }\n        }\n    }\n\n    clearVertexDirty(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexDirty on nonexistent vertex');\n        this.clearVertexDirtyInner(vertexId);\n    }\n\n    private clearVertexDirtyInner(vertexId: number) {\n        if (this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY) {\n            this.vertexBitsById[vertexId] &= ~VERTEX_BIT_DIRTY;\n        }\n    }\n\n    markVertexCycleInformed(vertex: TVertex) {\n        const vertexId = this.vertexToId.get(vertex);\n        log.assert(vertexId, 'markVertexCycleInformed on nonexistent vertex');\n        this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE_INFORMED;\n    }\n\n    private *cycleAwareAdjacency(\n        vertexId: number,\n        cycleInfo: CycleInfo | undefined,\n        adjacencyList: number[][]\n    ) {\n        if (cycleInfo) {\n            const yielded = new Set<number>();\n            for (const cycleId of cycleInfo.vertexIds) {\n                for (const toId of adjacencyList[cycleId]) {\n                    if (!cycleInfo.vertexIds.has(toId) && !yielded.has(toId)) {\n                        yielded.add(toId);\n                        yield toId;\n                    }\n                }\n            }\n            return;\n        }\n        for (const toId of adjacencyList[vertexId]) {\n            if (toId !== vertexId) yield toId;\n        }\n    }\n\n    addEdge(fromVertex: TVertex, toVertex: TVertex, kind: EdgeColor) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'addEdge from vertex not found');\n        log.assert(toId, 'addEdge to vertex not found');\n\n        DEBUG &&\n            log.assert(\n                !this.forwardAdjacencyEither[fromId].includes(toId),\n                'addEdge duplicate'\n            );\n        this.forwardAdjacencyEither[fromId].push(toId);\n        this.reverseAdjacencyEither[toId].push(fromId);\n        if (kind === EdgeColor.EDGE_HARD) {\n            this.forwardAdjacencyHard[fromId].push(toId);\n        }\n\n        if (\n            fromId === toId &&\n            (this.vertexBitsById[fromId] & VERTEX_BIT_SELF_CYCLE) === 0\n        ) {\n            const isInformed =\n                this.vertexBitsById[fromId] & VERTEX_BIT_CYCLE_INFORMED;\n            if (!isInformed) {\n                const vertex = this.vertexById[fromId];\n                log.assert(vertex, 'missing vertex in self-cycle');\n                this.processHandler(vertex, ProcessAction.CYCLE);\n                this.vertexBitsById[fromId] |=\n                    VERTEX_BIT_CYCLE_INFORMED | VERTEX_BIT_SELF_CYCLE;\n            } else {\n                this.vertexBitsById[fromId] |= VERTEX_BIT_SELF_CYCLE;\n            }\n        }\n\n        const fromIndex = this.topologicalIndexById[fromId];\n        const toIndex = this.topologicalIndexById[toId];\n        log.assert(toIndex !== undefined, 'malformed graph');\n        log.assert(fromIndex !== undefined, 'malformed graph');\n\n        // Check for out-of-order edge insertion and add to resort batch\n        const badOrder = fromIndex > toIndex; // Note: equal is ok: you can't reorder a self-edge\n        if (badOrder) {\n            this.toReorderIds.add(fromId);\n            this.toReorderIds.add(toId);\n        }\n    }\n\n    hasEdge(fromVertex: TVertex, toVertex: TVertex, kind: EdgeColor) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'addEdge from vertex not found');\n        log.assert(toId, 'addEdge to vertex not found');\n\n        return this.forwardAdjacencyEither[fromId].includes(toId);\n    }\n\n    removeEdge(fromVertex: TVertex, toVertex: TVertex, kind: EdgeColor) {\n        const fromId = this.vertexToId.get(fromVertex);\n        const toId = this.vertexToId.get(toVertex);\n        log.assert(fromId, 'removeEdge from vertex not found');\n        log.assert(toId, 'removeEdge to vertex not found');\n\n        DEBUG &&\n            log.assert(\n                this.forwardAdjacencyEither[fromId].includes(toId),\n                'removeEdge on edge that does not exist'\n            );\n\n        removeUnordered(this.forwardAdjacencyEither[fromId], toId);\n        removeUnordered(this.reverseAdjacencyEither[toId], fromId);\n        if (kind === EdgeColor.EDGE_HARD) {\n            removeUnordered(this.forwardAdjacencyHard[fromId], toId);\n        }\n\n        // If we are removing a self-cycle, clear the self cycle bit\n        if (fromId === toId) {\n            this.vertexBitsById[fromId] =\n                this.vertexBitsById[fromId] & ~VERTEX_BIT_SELF_CYCLE;\n        }\n\n        // If the removed edge is between two nodes in a cycle, it _may_ break the cycle\n        const fromCycleInfo = this.cycleInfoById[fromId];\n        const toCycleInfo = this.cycleInfoById[toId];\n        if (fromCycleInfo && toCycleInfo && fromCycleInfo === toCycleInfo) {\n            this.toReorderIds.add(fromId);\n            this.toReorderIds.add(toId);\n        }\n    }\n\n    private visitDfsForwardRecurse(\n        vertexId: number,\n        lowerBound: number,\n        upperBound: number,\n        visited: Set<number>\n    ) {\n        if (visited.has(vertexId)) return;\n        visited.add(vertexId);\n        for (const toId of this.forwardAdjacencyEither[vertexId]) {\n            const toIndex = this.topologicalIndexById[toId];\n            log.assert(toIndex !== undefined, 'malformed graph');\n            if (lowerBound <= toIndex && toIndex <= upperBound) {\n                this.visitDfsForwardRecurse(\n                    toId,\n                    lowerBound,\n                    upperBound,\n                    visited\n                );\n            }\n        }\n    }\n\n    private visitDfsForward(\n        startVertices: Iterable<number>,\n        lowerBound: number,\n        upperBound: number\n    ) {\n        const visited = new Set<number>();\n        for (const vertexId of startVertices) {\n            this.visitDfsForwardRecurse(\n                vertexId,\n                lowerBound,\n                upperBound,\n                visited\n            );\n        }\n        return visited;\n    }\n\n    private resort(toReorder: Set<number>) {\n        // Determine the bounds of the subgraph to reorder\n        let lowerBound = Infinity;\n        let upperBound = -Infinity;\n        for (const vertexId of toReorder) {\n            const cycleInfo = this.cycleInfoById[vertexId];\n            if (cycleInfo) {\n                if (cycleInfo.lowerBound < lowerBound)\n                    lowerBound = cycleInfo.lowerBound;\n                if (cycleInfo.upperBound > upperBound)\n                    upperBound = cycleInfo.upperBound;\n            } else {\n                const index = this.topologicalIndexById[vertexId];\n                log.assert(index !== undefined, 'malformed graph');\n                if (index < lowerBound) lowerBound = index;\n                if (index > upperBound) upperBound = index;\n            }\n        }\n\n        // Determine \"seed\" vertices for Tarjan's algorithm (those that are reachable in reverse from the ones that need reordering, within bounds)\n        const seedVertices = this.visitDfsForward(\n            toReorder,\n            lowerBound,\n            upperBound\n        );\n\n        // Use Tarjan's strongly connected algorithm (limited by the bound subgraph, sourced solely from the nodes we\n        // want to reorder) to get topological order & strongly connected components\n        const components = tarjanStronglyConnected(\n            this.reverseAdjacencyEither,\n            this.topologicalIndexById,\n            lowerBound,\n            upperBound,\n            seedVertices\n        );\n\n        // Mark cycles and grab the list of current indexes that will be overwritten\n        const allocatedIndexes: number[] = [];\n        for (const component of components) {\n            let cycle: CycleInfo | undefined;\n            if (component.length > 1) {\n                cycle = {\n                    upperBound: -Infinity,\n                    lowerBound: Infinity,\n                    vertexIds: new Set(component),\n                };\n            }\n\n            for (const vertexId of component) {\n                const index = this.topologicalIndexById[vertexId];\n                log.assert(index !== undefined, 'malformed graph');\n                if (cycle) {\n                    if (index < cycle.lowerBound) cycle.lowerBound = index;\n                    if (index > cycle.upperBound) cycle.upperBound = index;\n\n                    if (!(this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE)) {\n                        this.vertexBitsById[vertexId] |= VERTEX_BIT_CYCLE;\n                    }\n                    if (\n                        !(\n                            this.vertexBitsById[vertexId] &\n                            VERTEX_BIT_CYCLE_INFORMED\n                        )\n                    ) {\n                        // A vertex is discovered to be part of a cycle, inform it\n                        const vertex = this.vertexById[vertexId];\n                        log.assert(vertex, 'uninformed vertex missing');\n                        this.processHandler(vertex, ProcessAction.CYCLE);\n                        this.vertexBitsById[vertexId] |=\n                            VERTEX_BIT_CYCLE_INFORMED;\n                    }\n\n                    this.cycleInfoById[vertexId] = cycle;\n                } else if (this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE) {\n                    // Vertex no longer part of a cycle, clear the cycle bits and mark as dirty\n                    this.vertexBitsById[vertexId] =\n                        this.vertexBitsById[vertexId] &\n                        ~(VERTEX_BIT_CYCLE | VERTEX_BIT_CYCLE_INFORMED);\n                    delete this.cycleInfoById[vertexId];\n                    this.markVertexDirtyInner(vertexId);\n                }\n                allocatedIndexes.push(index);\n            }\n        }\n\n        // Sort the allocated indexes so we can incrementally assign vertices to these indexes\n        allocatedIndexes.sort((a, b) => a - b);\n        let i = 0;\n        for (const component of components) {\n            for (const vertexId of component) {\n                const index = allocatedIndexes[i];\n                this.topologicalOrdering[index] = vertexId;\n                this.topologicalIndexById[vertexId] = index;\n                i += 1;\n            }\n        }\n\n        return lowerBound;\n    }\n\n    private addPostAction = (action: () => void) => {\n        this.postActions.push(action);\n    };\n\n    private processHandler(vertex: TVertex, action: ProcessAction) {\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const name = formatter(vertex).name;\n                const label = `${ProcessAction[action]}: ${name}`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                            isActive: v === vertex,\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n        return this._processHandler(vertex, action, this.addPostAction);\n    }\n\n    private processVertex(vertexId: number) {\n        const vertex = this.vertexById[vertexId];\n        log.assert(vertex, 'nonexistent vertex dirtied');\n        return this.processHandler(vertex, ProcessAction.RECALCULATE);\n    }\n\n    process() {\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const label = `Process start`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n        if (this.toReorderIds.size > 0) {\n            this.resort(this.toReorderIds);\n            this.toReorderIds.clear();\n        }\n\n        for (;;) {\n            const vertexIndex = this.startVertexIndex;\n            if (vertexIndex >= this.vertexById.length) {\n                const postActions = this.postActions;\n                this.postActions = [];\n                for (const postAction of postActions) {\n                    postAction();\n                }\n                if (vertexIndex !== this.startVertexIndex) {\n                    // The result of processing postActions has dirtied the graph,\n                    // so we jump back and re-process\n                    continue;\n                }\n\n                this.startVertexIndex = 0;\n                break;\n            }\n            this.startVertexIndex++;\n\n            const vertexId = this.topologicalOrdering[vertexIndex];\n            if (vertexId === undefined) {\n                continue;\n            }\n\n            const isDirty = this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY;\n            if (!isDirty) {\n                continue;\n            }\n\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'nonexistent vertex dirtied');\n\n            const cycleInfo = this.cycleInfoById[vertexId];\n\n            let shouldPropagate = false;\n            const recheckIds: null | number[] =\n                cycleInfo ||\n                this.vertexBitsById[vertexId] & VERTEX_BIT_SELF_CYCLE\n                    ? []\n                    : null;\n            if (cycleInfo) {\n                for (const cycleId of cycleInfo.vertexIds) {\n                    if (!this.vertexById[cycleId]) continue; // broken cycles may release vertices in cycle\n                    const isInformed =\n                        this.vertexBitsById[cycleId] &\n                        VERTEX_BIT_CYCLE_INFORMED;\n                    if (isInformed) {\n                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                        recheckIds!.push(cycleId);\n                    }\n                    shouldPropagate =\n                        this.processVertex(cycleId) || shouldPropagate;\n                }\n            } else {\n                const isInformed =\n                    this.vertexBitsById[vertexId] & VERTEX_BIT_CYCLE_INFORMED;\n                if (isInformed && recheckIds) {\n                    recheckIds.push(vertexId);\n                }\n                shouldPropagate =\n                    this.processVertex(vertexId) || shouldPropagate;\n            }\n\n            if (this.toReorderIds.size > 0) {\n                const lowerBound = this.resort(this.toReorderIds);\n                if (lowerBound < this.startVertexIndex) {\n                    this.startVertexIndex = lowerBound;\n                }\n                this.toReorderIds.clear();\n            }\n\n            // If cycles remain after recalculating an informed cycle, the recalculation failed to break the cycle, so\n            // we need to call the process handler with CYCLE actions to correctly set their error state\n            if (recheckIds) {\n                for (const cycleId of recheckIds) {\n                    const isStillCycle =\n                        this.vertexBitsById[cycleId] &\n                        (VERTEX_BIT_CYCLE | VERTEX_BIT_SELF_CYCLE);\n                    if (isStillCycle) {\n                        const cycleVertex = this.vertexById[cycleId];\n                        log.assert(cycleVertex, 'nonexistent vertex in cycle');\n                        shouldPropagate =\n                            this.processHandler(\n                                cycleVertex,\n                                ProcessAction.CYCLE\n                            ) || shouldPropagate;\n                    }\n                }\n            }\n\n            // Check if we gained or lost new cycle nodes which need to be propagated\n            const newCycleInfo = this.cycleInfoById[vertexId];\n            if (!cycleInfo && newCycleInfo) {\n                shouldPropagate = true;\n            }\n            if (cycleInfo && !newCycleInfo) {\n                shouldPropagate = true;\n            }\n            if (\n                cycleInfo &&\n                newCycleInfo &&\n                newCycleInfo.vertexIds !== cycleInfo.vertexIds\n            ) {\n                shouldPropagate = true;\n            }\n\n            if (shouldPropagate) {\n                // 3 sets of vertices to union + propagate:\n                // - the vertexId we are processing\n                // - the vertexIds that were part of the cycle prior to recalculating\n                // - the vertexIds that were part of the cycle after to recalculating\n                const toPropagate: Set<number> = new Set();\n                toPropagate.add(vertexId);\n                if (cycleInfo) {\n                    for (const oldVertexId of cycleInfo.vertexIds) {\n                        toPropagate.add(oldVertexId);\n                    }\n                }\n                if (newCycleInfo) {\n                    for (const newVertexId of newCycleInfo.vertexIds) {\n                        toPropagate.add(newVertexId);\n                    }\n                }\n\n                for (const cycleId of toPropagate) {\n                    if (!this.vertexById[cycleId]) continue; // broken cycles may release vertices in cycle\n                    this.propagateDirty(cycleId, toPropagate);\n                }\n            } else {\n                this.clearVertexDirtyInner(vertexId);\n            }\n        }\n\n        if (DEBUG) {\n            this.debugSubscriptions.forEach(({ subscription, formatter }) => {\n                const label = `Process end`;\n                subscription(\n                    this.debug(\n                        (v) => ({\n                            ...formatter(v),\n                        }),\n                        label\n                    ),\n                    label\n                );\n            });\n        }\n    }\n\n    getOrderedDirty() {\n        if (this.toReorderIds.size > 0) {\n            this.resort(this.toReorderIds);\n            this.toReorderIds.clear();\n        }\n\n        const vertices: TVertex[] = [];\n        for (\n            let vertexIndex = 0;\n            vertexIndex < this.topologicalOrdering.length;\n            ++vertexIndex\n        ) {\n            const vertexId = this.topologicalOrdering[vertexIndex];\n            if (vertexId === undefined) {\n                continue;\n            }\n\n            const isDirty = this.vertexBitsById[vertexId] & VERTEX_BIT_DIRTY;\n            if (!isDirty) {\n                continue;\n            }\n\n            const vertex = this.vertexById[vertexId];\n            log.assert(vertex, 'nonexistent vertex dirtied');\n            vertices.push(vertex);\n        }\n        return vertices;\n    }\n\n    private propagateDirty(\n        vertexId: number,\n        cycleVertexIds: null | Set<number>\n    ) {\n        this.clearVertexDirtyInner(vertexId);\n        for (const toId of this.forwardAdjacencyHard[vertexId]) {\n            const toCycleInfo = this.cycleInfoById[toId];\n            if (toCycleInfo) {\n                for (const toCycleId of toCycleInfo.vertexIds) {\n                    if (!cycleVertexIds || !cycleVertexIds.has(toCycleId)) {\n                        this.markVertexDirtyInner(toCycleId);\n                    }\n                }\n            } else {\n                if (!cycleVertexIds || !cycleVertexIds.has(toId)) {\n                    this.markVertexDirtyInner(toId);\n                }\n            }\n        }\n    }\n\n    debug(getAttrs: DebugFormatter<TVertex>, label?: string) {\n        const lines = [];\n        lines.push('digraph dependencies {');\n        lines.push(`  graph [];`);\n        lines.push(`  edge [penwidth=2.0];`);\n        lines.push(`  node [penwidth=2.0];`);\n        if (label) {\n            lines.push(`  graph [label=${JSON.stringify(label)};]`);\n        }\n\n        const emitVertex = (id: number) => {\n            const vertex = this.vertexById[id];\n            if (!vertex) return;\n            const customAttrs = getAttrs(vertex);\n            const attrs: Record<string, string | number> = {\n                style: 'filled',\n                label: `${id}\\n${customAttrs.name}`,\n            };\n\n            // Shapes:\n            attrs.shape = 'ellipse';\n\n            // Fill colors:\n            // - dirty: black / #F9C784\n            // - clean: black / white\n            if (this.vertexBitsById[id] & VERTEX_BIT_DIRTY) {\n                attrs.style = 'filled';\n                attrs.fontcolor = '#FFFFFF';\n                attrs.fillcolor = '#FC7A1E';\n            } else {\n                attrs.style = 'filled';\n                attrs.fontcolor = '#000000';\n                attrs.fillcolor = '#FFFFFF';\n            }\n\n            // Border:\n            // - active: #485696\n            if (customAttrs.isActive) {\n                attrs.penwidth = 4.0;\n                attrs.pencolor = '#485696';\n            }\n\n            const labelItems: string[] = [];\n            for (const [attrName, attrVal] of Object.entries(attrs)) {\n                labelItems.push(`${attrName}=${JSON.stringify(attrVal)}`);\n            }\n\n            lines.push(`  v_${id} [${labelItems.join(',')}]`);\n        };\n\n        const cycles = new Set<CycleInfo>();\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const cycleInfo = this.cycleInfoById[id];\n            if (cycleInfo) {\n                cycles.add(cycleInfo);\n            }\n        }\n        for (const cycle of cycles) {\n            lines.push('  subgraph cluster_cycle {');\n            lines.push(`  graph [label=\"cycle\";]`);\n            for (const cycleId of cycle.vertexIds) {\n                emitVertex(cycleId);\n            }\n            lines.push('  }');\n        }\n\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const cycleInfo = this.cycleInfoById[id];\n            if (cycleInfo) continue;\n            emitVertex(id);\n        }\n\n        for (let id = 0; id < this.vertexById.length; ++id) {\n            const hard = new Set(this.forwardAdjacencyHard[id] || []);\n            if (this.forwardAdjacencyEither[id]) {\n                for (const toId of this.forwardAdjacencyEither[id]) {\n                    if (hard.has(toId)) {\n                        lines.push(`  v_${id} -> v_${toId};`);\n                    } else {\n                        lines.push(`  v_${id} -> v_${toId} [style=\"dotted\"];`);\n                    }\n                }\n            }\n        }\n        lines.push('}');\n        return lines.join('\\n');\n    }\n\n    debugSubscribe(\n        formatter: DebugFormatter<TVertex>,\n        subscription: (graphviz: string, label: string) => void\n    ) {\n        const entry = {\n            formatter,\n            subscription,\n        };\n        this.debugSubscriptions.add(entry);\n        return () => {\n            this.debugSubscriptions.delete(entry);\n        };\n    }\n}\n\n/**\n * Test-only interfaces; omitted in build\n */\nexport interface Graph<TVertex> {\n    _test_getVertices(): TVertex[];\n    _test_getDependencies(vertex: TVertex): TVertex[];\n    _test_getVertexInfo(\n        vertex: TVertex\n    ): undefined | { id: number; index: number; bits: number };\n}\n\n/**\n * Inject test-only interfaces if we are in a test environment\n */\nif (TEST) {\n    Graph.prototype._test_getVertices = function _test_getVertices<TVertex>(\n        this: Graph<TVertex>\n    ) {\n        return this.vertexById.filter((vertex) => !!vertex);\n    };\n    Graph.prototype._test_getDependencies = function _test_getDependencies<\n        TVertex\n    >(this: Graph<TVertex>, vertex: TVertex) {\n        const id = this.vertexToId.get(vertex);\n        log.assert(id, 'getDependencies on nonexistent vertex');\n        return this.forwardAdjacencyEither[id].map(\n            (toId) => this.vertexById[toId]\n        );\n    };\n\n    Graph.prototype._test_getVertexInfo = function _test_getVertexInfo<TVertex>(\n        this: Graph<TVertex>,\n        vertex: TVertex\n    ) {\n        const id = this.vertexToId.get(vertex);\n        if (id === undefined) return undefined;\n        const index = this.topologicalIndexById[id];\n        log.assert(index !== undefined, 'malformed graph');\n        const bits = this.vertexBitsById[id];\n        return {\n            id,\n            index,\n            bits,\n        };\n    };\n}\n\nfunction removeUnordered(array: number[], value: number) {\n    if (value === array[array.length - 1]) {\n        array.pop();\n        return;\n    }\n    const index = array.indexOf(value);\n    array[index] = array[array.length - 1];\n    array.pop();\n}\n", "import * as log from './log';\nimport { noop } from './util';\nimport { Graph, ProcessAction } from './graph';\nimport type { RenderNode } from './rendernode';\nimport { RenderNodeCommitPhase } from './rendernode';\n\nexport interface Retainable {\n    __debugName: string;\n    __refcount: number;\n    __alive: () => void;\n    __dead: () => void;\n}\n\nexport interface Processable {\n    __processable: true;\n    __debugName: string;\n    __recalculate?: (\n        addPostAction: (postAction: () => void) => void\n    ) => boolean;\n    __cycle?: (addPostAction: (postAction: () => void) => void) => boolean;\n    __invalidate?: () => boolean;\n}\n\nexport function isProcessable(val: any): val is Processable {\n    return val && val.__processable === true;\n}\n\nlet globalDependencyGraph = new Graph<Processable>(processHandler);\nlet renderNodesToCommit = new Set<RenderNode>();\nlet trackReadSets: (Set<Retainable> | null)[] = [];\nlet trackCreateSets: (Set<Retainable> | null)[] = [];\nlet isFlushing = false;\nlet needsFlush = false;\nlet flushHandle: (() => void) | null = null;\nlet flushScheduler = defaultScheduler;\n\nfunction noopScheduler(callback: () => void) {\n    return noop;\n}\n\nfunction defaultScheduler(callback: () => void) {\n    if ((window as any).queueMicrotask) {\n        let cancelled = false;\n        queueMicrotask(() => {\n            if (cancelled) return;\n            callback();\n        });\n        return () => {\n            cancelled = true;\n        };\n    }\n    const handle = setTimeout(callback, 0);\n    return () => clearTimeout(handle);\n}\n\nexport function reset() {\n    globalDependencyGraph = new Graph<Processable>(processHandler);\n    renderNodesToCommit = new Set<RenderNode>();\n    trackReadSets = [];\n    trackCreateSets = [];\n    isFlushing = false;\n    needsFlush = false;\n    if (flushHandle) flushHandle();\n    flushHandle = null;\n    flushScheduler = defaultScheduler;\n}\n\nfunction scheduleFlush() {\n    if (needsFlush) return;\n    needsFlush = true;\n    flushHandle = flushScheduler(() => {\n        needsFlush = false;\n        flushHandle = null;\n        flushInner();\n    });\n}\n\nexport function flush() {\n    if (!needsFlush || isFlushing) return;\n    if (flushHandle) {\n        flushHandle();\n        flushHandle = null;\n    }\n    needsFlush = false;\n    flushInner();\n}\n\nexport function subscribe(scheduler?: (callback: () => void) => () => void) {\n    flushScheduler = scheduler ?? noopScheduler;\n}\n\nexport function retain(retainable: Retainable) {\n    DEBUG &&\n        log.debug(\n            'retain',\n            retainable.__debugName,\n            'was',\n            retainable.__refcount\n        );\n    retainable.__refcount += 1;\n    if (retainable.__refcount === 1) {\n        retainable.__alive();\n    }\n}\n\nexport function release(retainable: Retainable) {\n    DEBUG &&\n        log.debug(\n            'release',\n            retainable.__debugName,\n            'was',\n            retainable.__refcount\n        );\n    log.assert(retainable.__refcount > 0, 'double release');\n    if (retainable.__refcount === 1) {\n        retainable.__dead();\n    }\n    retainable.__refcount -= 1;\n}\n\nfunction processHandler(\n    vertex: Processable,\n    action: ProcessAction,\n    addPostAction: (postAction: () => void) => void\n) {\n    DEBUG &&\n        log.debug('process', ProcessAction[action], vertex.__debugName, vertex);\n    switch (action) {\n        case ProcessAction.INVALIDATE:\n            return vertex.__invalidate?.() ?? false;\n        case ProcessAction.RECALCULATE:\n            return vertex.__recalculate?.(addPostAction) ?? false;\n        case ProcessAction.CYCLE:\n            return vertex.__cycle?.(addPostAction) ?? false;\n        default:\n            log.assertExhausted(action, 'unknown action');\n    }\n}\n\nfunction flushInner() {\n    // Flushing has a few phases:\n    // - 1: process the global dependency graph to get state to a stable resolution\n    // - 2: notify \"onUnmount\"\n    // - 2.5: record document.activeElement\n    // - 3: commit DOM deletions (notify \"raw\" DOM deletions)\n    // - 4: commit DOM insertions (notify \"raw\" DOM insertions)\n    // - 4.5: restore document.activeElement if it was moved\n    // - 5: notify \"onMount\"\n    isFlushing = true;\n    globalDependencyGraph.process();\n    for (const renderNode of renderNodesToCommit) {\n        renderNode.commit?.(RenderNodeCommitPhase.COMMIT_UNMOUNT);\n    }\n    const prevFocus = document.activeElement;\n    for (const renderNode of renderNodesToCommit) {\n        renderNode.commit?.(RenderNodeCommitPhase.COMMIT_DEL);\n    }\n    for (const renderNode of renderNodesToCommit) {\n        renderNode.commit?.(RenderNodeCommitPhase.COMMIT_INS);\n    }\n    if (\n        prevFocus &&\n        (prevFocus instanceof HTMLElement || prevFocus instanceof SVGElement) &&\n        document.documentElement.contains(prevFocus)\n    ) {\n        prevFocus.focus();\n    }\n    for (const renderNode of renderNodesToCommit) {\n        renderNode.commit?.(RenderNodeCommitPhase.COMMIT_MOUNT);\n    }\n    renderNodesToCommit.clear();\n    isFlushing = false;\n    if (needsFlush) {\n        flush();\n    }\n}\n\nexport function addVertex(vertex: Processable) {\n    DEBUG && log.debug('addVertex', vertex.__debugName);\n    globalDependencyGraph.addVertex(vertex);\n}\n\nexport function removeVertex(vertex: Processable) {\n    DEBUG && log.debug('removeVertex', vertex.__debugName);\n    globalDependencyGraph.removeVertex(vertex);\n}\n\nexport function removeRenderNode(vertex: RenderNode) {\n    renderNodesToCommit.delete(vertex);\n}\n\nexport function dirtyRenderNode(renderNode: RenderNode) {\n    DEBUG && log.debug('dirty renderNode', renderNode.__debugName);\n    renderNodesToCommit.add(renderNode);\n    scheduleFlush();\n}\n\nexport function addHardEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'add edge:hard',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.addEdge(fromVertex, toVertex, Graph.EDGE_HARD);\n}\n\nexport function addSoftEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'add edge:soft',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.addEdge(fromVertex, toVertex, Graph.EDGE_SOFT);\n}\n\nexport function removeHardEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'del edge:hard',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.removeEdge(fromVertex, toVertex, Graph.EDGE_HARD);\n}\n\nexport function removeSoftEdge(fromVertex: Processable, toVertex: Processable) {\n    DEBUG &&\n        log.debug(\n            'del edge:soft',\n            fromVertex.__debugName,\n            '->',\n            toVertex.__debugName\n        );\n    globalDependencyGraph.removeEdge(fromVertex, toVertex, Graph.EDGE_SOFT);\n}\n\nexport function markDirty(vertex: Processable) {\n    DEBUG && log.debug('dirty', vertex.__debugName);\n    globalDependencyGraph.markVertexDirty(vertex);\n    scheduleFlush();\n}\n\nexport function unmarkDirty(vertex: Processable) {\n    DEBUG && log.debug('clean', vertex.__debugName);\n    globalDependencyGraph.clearVertexDirty(vertex);\n}\n\nexport function markCycleInformed(vertex: Processable) {\n    DEBUG && log.debug('cycle informed', vertex.__debugName);\n    globalDependencyGraph.markVertexCycleInformed(vertex);\n}\n\nexport function trackReads<T>(\n    set: Set<Retainable>,\n    fn: () => T,\n    debugName?: string\n): T {\n    DEBUG && log.group('trackReads', debugName ?? 'call');\n    trackReadSets.push(set);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            set === trackReadSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function untrackReads<T>(fn: () => T, debugName?: string): T {\n    DEBUG && log.group('untrackReads', debugName ?? 'call');\n    trackReadSets.push(null);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            null === trackReadSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function trackCreates<T>(\n    set: Set<Retainable | (Retainable & Processable)>,\n    fn: () => T,\n    debugName?: string\n): T {\n    DEBUG && log.group('trackCreates', debugName ?? 'call');\n    trackCreateSets.push(set);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            set === trackCreateSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function untrackCreates<T>(fn: () => T, debugName?: string): T {\n    DEBUG && log.group('untrackCreates', debugName ?? 'call');\n    trackCreateSets.push(null);\n    try {\n        return fn();\n    } finally {\n        DEBUG && log.groupEnd();\n        log.assert(\n            null === trackCreateSets.pop(),\n            'Calculation tracking consistency error'\n        );\n    }\n}\n\nexport function notifyCreate(retainable: Retainable) {\n    if (trackCreateSets.length === 0) return;\n    const createSet = trackCreateSets[trackCreateSets.length - 1];\n    if (createSet) {\n        DEBUG &&\n            log.debug(\n                'notifying dependency',\n                retainable.__debugName,\n                'to was created'\n            );\n        if (!createSet.has(retainable)) {\n            createSet.add(retainable);\n        }\n    }\n}\n\nexport function notifyRead(dependency: Retainable) {\n    if (trackReadSets.length === 0) return;\n    const calculationReads = trackReadSets[trackReadSets.length - 1];\n    if (calculationReads) {\n        DEBUG &&\n            log.debug(\n                'adding dependency',\n                dependency.__debugName,\n                'to active calculation'\n            );\n        if (!calculationReads.has(dependency)) {\n            retain(dependency);\n            calculationReads.add(dependency);\n        }\n    }\n}\n\nexport function debug(activeVertex?: Processable, label?: string) {\n    return globalDependencyGraph.debug((vertex) => {\n        return {\n            isActive: vertex === activeVertex,\n            name: `${vertex.__debugName} (rc=${(vertex as any).__refcount})`,\n        };\n    }, label);\n}\n\nexport function debugSubscribe(fn: (label: string, graphviz: string) => void) {\n    return globalDependencyGraph.debugSubscribe((vertex) => {\n        return {\n            isActive: false,\n            name: vertex.__debugName,\n        };\n    }, fn);\n}\n\nexport function debugGetGraph() {\n    return globalDependencyGraph;\n}\n", "/**\n * A ref object that can be passed to native elements.\n */\nexport class Ref<T> {\n    declare current: T | undefined;\n    constructor(current?: T | undefined) {\n        this.current = current;\n    }\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val?: T): Ref<T> {\n    return new Ref(val);\n}\n\n/**\n * A standard ref callback\n */\nexport type RefCallback<T> = (val: T | undefined) => void;\n\n/**\n * Ref types may be passed as the ref prop to intrinsic elements to obtain a\n * reference to the underlying Element\n */\nexport type RefObjectOrCallback<T> = Ref<T> | RefCallback<T>;\n", "import { Calculation } from './calc';\nimport { Collection, View } from './collection';\nimport { RenderNode } from './rendernode';\nimport type { ClassComponentInterface } from './rendernode';\nimport type { RefObjectOrCallback } from './ref';\n\n/**\n * The core type that can be used as a child or root of a JSX expression\n */\nexport type JSXNode =\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    | bigint\n    | symbol\n    | Function\n    | Element\n    | RenderNode\n    | JSXNodeCalculation\n    | JSXNodeCollection\n    | JSXNodeView\n    | JSXNodeArray;\n\n// The following interfaces are to allow for a recursive type alias: JSXNode\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSXNodeCalculation extends Calculation<JSXNode> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSXNodeCollection extends Collection<JSXNode> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSXNodeView extends View<JSXNode, any> {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface JSXNodeArray extends Array<JSXNode> {}\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        /**\n         * The core type produced by a JSX expression\n         */\n        type Element = RenderNode;\n\n        /**\n         * The core type allowable as a child node in a JSX expression\n         *\n         * Note: this is not used by TypeScript internally and exported for convenience so you may type a component like:\n         *\n         *   const TakesExactlyOneChild: Component<{ children: JSX.Node }> = ({ children }) => (<div>{children}</div>);\n         *\n         */\n        type Node = JSXNode;\n\n        /**\n         * The mapping of element name to intrinsic element path\n         */\n        interface IntrinsicElements extends KnownElements {\n            [unknownElement: string]: any;\n        }\n\n        /**\n         * The object property of children\n         */\n        interface ElementChildrenAttribute {\n            children: {};\n        }\n\n        /**\n         * The class property of props\n         */\n        interface ElementAttributesProperty {\n            props: {};\n        }\n\n        /**\n         * The class component interface\n         */\n        type ElementClass = ClassComponentInterface;\n    }\n}\n\nfunction attrBooleanToEmptyString(\n    val: boolean | undefined\n): string | undefined {\n    if (!val) return undefined;\n    return '';\n}\n\nfunction attrStringOrNumberToNumber(\n    val: string | number | undefined\n): number | undefined {\n    if (val === undefined) return undefined;\n    return typeof val === 'number' ? val : parseInt(val);\n}\n\nfunction attrYesNo(val: '' | 'yes' | 'no' | undefined): boolean | undefined {\n    if (val === undefined) return undefined;\n    return val === 'no' ? false : true;\n}\n\n// All attributes (except for value) share similar behavior. This map holds:\n// - Mapping of html attribute name to idl property name\n// - Formatter of jsx property value to idl property value\n// - A flag to omit setting an html attribute (only used for indeterminate)\nconst attrBehavior: Record<\n    string,\n    {\n        // idl name\n        idn?: string | null;\n        // idl value formatter\n        idv?: (jsxAttr: any) => any;\n        // no attribute (do not call setAttribute)\n        noa?: true;\n    }\n> = {\n    'accept-charset': { idn: 'acceptCharset' },\n    'aria-atomic': { idn: 'ariaAtomic' },\n    'aria-autocomplete': { idn: 'ariaAutoComplete' },\n    'aria-busy': { idn: 'ariaBusy' },\n    'aria-checked': { idn: 'ariaChecked' },\n    'aria-colcount': { idn: 'ariaColCount' },\n    'aria-colindex': { idn: 'ariaColIndex' },\n    'aria-colindextext': { idn: 'ariaColIndexText' },\n    'aria-colspan': { idn: 'ariaColSpan' },\n    'aria-current': { idn: 'ariaCurrent' },\n    'aria-disabled': { idn: 'ariaDisabled' },\n    'aria-expanded': { idn: 'ariaExpanded' },\n    'aria-haspopup': { idn: 'ariaHasPopup' },\n    'aria-hidden': { idn: 'ariaHidden' },\n    'aria-invalid': { idn: 'ariaInvalid' },\n    'aria-keyshortcuts': { idn: 'ariaKeyShortcuts' },\n    'aria-label': { idn: 'ariaLabel' },\n    'aria-level': { idn: 'ariaLevel' },\n    'aria-live': { idn: 'ariaLive' },\n    'aria-modal': { idn: 'ariaModal' },\n    'aria-multiline': { idn: 'ariaMultiLine' },\n    'aria-multiselectable': { idn: 'ariaMultiSelectable' },\n    'aria-orientation': { idn: 'ariaOrientation' },\n    'aria-placeholder': { idn: 'ariaPlaceholder' },\n    'aria-posinset': { idn: 'ariaPosInSet' },\n    'aria-pressed': { idn: 'ariaPressed' },\n    'aria-readonly': { idn: 'ariaReadOnly' },\n    'aria-required': { idn: 'ariaRequired' },\n    'aria-roledescription': { idn: 'ariaRoleDescription' },\n    'aria-rowcount': { idn: 'ariaRowCount' },\n    'aria-rowindex': { idn: 'ariaRowIndex' },\n    'aria-rowindextext': { idn: 'ariaRowIndexText' },\n    'aria-rowspan': { idn: 'ariaRowSpan' },\n    'aria-selected': { idn: 'ariaSelected' },\n    'aria-setsize': { idn: 'ariaSetSize' },\n    'aria-sort': { idn: 'ariaSort' },\n    'aria-valuemax': { idn: 'ariaValueMax' },\n    'aria-valuemin': { idn: 'ariaValueMin' },\n    'aria-valuenow': { idn: 'ariaValueNow' },\n    'aria-valuetext': { idn: 'ariaValueText' },\n    'http-equiv': { idn: 'httpEquiv' },\n    abbr: {},\n    accept: {},\n    accesskey: { idn: 'accessKey' },\n    action: {},\n    allow: {},\n    allowfullscreen: { idn: 'allowFullscreen' },\n    alt: {},\n    as: {},\n    async: {},\n    autocapitalize: {},\n    autocomplete: {},\n    autofocus: {},\n    autoplay: {},\n    charset: { idn: null },\n    checked: {},\n    cite: {},\n    class: { idn: 'className' },\n    color: { idn: null },\n    cols: { idv: attrStringOrNumberToNumber },\n    colspan: { idn: 'colSpan', idv: attrStringOrNumberToNumber },\n    content: {},\n    contenteditable: { idn: 'contentEditable' },\n    controls: {},\n    coords: {},\n    crossorigin: { idn: 'crossOrigin' },\n    data: {},\n    datetime: { idn: 'dateTime' },\n    decoding: {},\n    default: {},\n    defer: {},\n    dir: {},\n    dirname: { idn: 'dirName' },\n    disabled: {},\n    download: {},\n    draggable: {},\n    enctype: {},\n    enterkeyhint: { idn: 'enterKeyHint' },\n    for: { idn: 'htmlFor' },\n    form: { idn: null },\n    formaction: { idn: 'formAction' },\n    formenctype: { idn: 'formEnctype' },\n    formmethod: { idn: 'formMethod' },\n    formnovalidate: { idn: 'formNoValidate' },\n    formtarget: { idn: 'formTarget' },\n    headers: {},\n    height: { idv: attrStringOrNumberToNumber },\n    hidden: {},\n    high: { idv: attrStringOrNumberToNumber },\n    href: {},\n    hreflang: {},\n    id: {},\n    imagesizes: { idn: 'imageSizes' },\n    imagesrcset: { idn: 'imageSrcset' },\n    indeterminate: { noa: true },\n    inputmode: { idn: 'inputMode' },\n    integrity: {},\n    is: { idn: null },\n    ismap: { idn: 'isMap' },\n    itemid: { idn: null },\n    itemprop: { idn: null },\n    itemref: { idn: null },\n    itemscope: { idn: null },\n    itemtype: { idn: null },\n    kind: {},\n    label: {},\n    lang: {},\n    list: {},\n    loading: {},\n    loop: { idv: attrBooleanToEmptyString },\n    low: { idv: attrStringOrNumberToNumber },\n    max: { idv: attrStringOrNumberToNumber },\n    maxlength: {\n        idn: 'maxLength',\n        idv: attrStringOrNumberToNumber,\n    },\n    media: {},\n    method: {},\n    min: { idv: attrStringOrNumberToNumber },\n    minlength: {\n        idn: 'minLength',\n        idv: attrStringOrNumberToNumber,\n    },\n    multiple: {},\n    muted: {},\n    name: {},\n    nomodule: { idn: 'noModule' },\n    nonce: {},\n    novalidate: { idn: 'noValidate' },\n    open: {},\n    optimum: { idv: attrStringOrNumberToNumber },\n    pattern: {},\n    ping: {},\n    placeholder: {},\n    playsinline: { idn: 'playsInline' },\n    poster: {},\n    preload: {},\n    readonly: { idn: 'readOnly' },\n    referrerpolicy: { idn: 'referrerPolicy' },\n    rel: {},\n    required: {},\n    reversed: {},\n    role: {},\n    rows: { idv: attrStringOrNumberToNumber },\n    rowspan: { idn: 'rowSpan', idv: attrStringOrNumberToNumber },\n    sandbox: {},\n    scope: {},\n    selected: {},\n    shape: {},\n    size: { idv: attrStringOrNumberToNumber },\n    sizes: {},\n    slot: {},\n    span: { idv: attrStringOrNumberToNumber },\n    spellcheck: {},\n    src: {},\n    srcdoc: {},\n    srclang: {},\n    srcset: {},\n    start: { idv: attrStringOrNumberToNumber },\n    step: { idv: attrStringOrNumberToNumber },\n    style: {},\n    tabindex: { idn: 'tabIndex', idv: attrStringOrNumberToNumber },\n    target: {},\n    title: {},\n    translate: { idv: attrYesNo },\n    type: {},\n    usemap: { idn: 'useMap' },\n    // value: {}, // NOTE: value is special and depends on the element\n    width: { idv: attrStringOrNumberToNumber },\n    wrap: {},\n};\n\nexport function setAttribute(\n    element: Element,\n    attributeName: string,\n    val: unknown\n) {\n    if (val === undefined || val === null || val === false) {\n        element.removeAttribute(attributeName);\n    } else if (val === true) {\n        element.setAttribute(attributeName, '');\n    } else if (typeof val === 'string') {\n        element.setAttribute(attributeName, val);\n    } else if (typeof val === 'number' || typeof val === 'bigint') {\n        element.setAttribute(attributeName, val.toString());\n    }\n}\n\nexport function assignProp(element: Element, attribute: string, value: any) {\n    // Note: SVG elements (and probably other kinds) do not have the same\n    // shared IDL behaviors. For example, it's an error to set the .width\n    // property of an SVGSVGElement\n    if (!(element instanceof HTMLElement)) {\n        setAttribute(element, attribute, value);\n        return;\n    }\n    if (attribute === 'value') {\n        // Note: value is special and treated differently, depending on the element\n        switch (element.tagName) {\n            case 'PROGRESS':\n            case 'METER':\n                // Passthru attribue\n                // Numeric idl value\n                setAttribute(element, attribute, value);\n                (element as any).value = attrStringOrNumberToNumber(value);\n                break;\n\n            case 'SELECT':\n                // No attribue\n                // Passthru idl value; provided for convenience as writing to select.value assigns the corresponding option as the selected value\n                (element as any).value = value;\n                break;\n\n            case 'BUTTON':\n            case 'DATA':\n            case 'INPUT':\n            case 'LI':\n            case 'OPTION':\n            case 'PARAM':\n            case 'TEXTAREA':\n                // Passthru attribute\n                // Passthru idl\n                setAttribute(element, attribute, value);\n                (element as any).value = value;\n                break;\n            default:\n                // Passthru attribute\n                setAttribute(element, attribute, value);\n        }\n        return;\n    }\n    const behavior = attrBehavior[attribute];\n    if (behavior) {\n        if (!behavior.noa) {\n            const attributeValue = value;\n            setAttribute(element, attribute, attributeValue);\n        }\n        if (behavior.idn !== null) {\n            const idlValue = behavior.idv ? behavior.idv(value) : value;\n            (element as any)[behavior.idn ?? attribute] = idlValue;\n        }\n        return;\n    }\n    setAttribute(element, attribute, value);\n}\n\n/*\n * Interfaces adopted from HTML Living Standard Last Updated 30 November 2021: https://html.spec.whatwg.org/\n */\n\n// Note: abstract roles are **not** in this list, as \"Authors MUST NOT use abstract roles in content\"\ntype AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'associationlist'\n    | 'associationlistitemkey'\n    | 'associationlistitemvalue'\n    | 'banner'\n    | 'blockquote'\n    | 'button'\n    | 'caption'\n    | 'cell'\n    | 'checkbox'\n    | 'code'\n    | 'columnheader'\n    | 'combobox'\n    | 'comment'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'deletion'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'emphasis'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'generic'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'insertion'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'mark'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'meter'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'paragraph'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'strong'\n    | 'subscript'\n    | 'suggestion'\n    | 'superscript'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'time'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | string;\n\ntype DirValue = 'ltr' | 'rtl' | 'auto' | string;\n\ntype BrowsingContextValue = '_blank' | '_self' | '_parent' | '_top' | string;\n\ntype ReferrerPolicyValue =\n    | ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'same-origin'\n    | 'origin'\n    | 'strict-origin'\n    | 'origin-when-cross-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url'\n    | string;\n\ntype CrossOriginValue = 'anonymous' | '' | 'use-credentials';\n\ntype LazyLoadingValue = 'lazy' | 'eager' | string;\n\ntype ImageDecodingHintValue = 'sync' | 'async' | 'auto' | string;\n\ntype SandboxValue =\n    | 'allow-forms'\n    | 'allow-modals'\n    | 'allow-orientation-lock'\n    | 'allow-pointer-lock'\n    | 'allow-popups'\n    | 'allow-popups-to-escape-sandbox'\n    | 'allow-presentation'\n    | 'allow-same-origin'\n    | 'allow-scripts'\n    | 'allow-top-navigation'\n    | 'allow-top-navigation-by-user-activation'\n    | 'allow-downloads'\n    | string;\n\ntype EncTypeValue =\n    | 'application/x-www-form-urlencoded'\n    | 'multipart/form-data'\n    | 'text/plain'\n    | string;\n\ntype FormMethodValue = 'get' | 'post' | 'dialog' | string;\n\ntype AutocompleteValue = 'on' | 'off' | string;\n\ninterface JSXElementInterface {\n    /** a guide for creating a keyboard shortcut that activates or focuses the element */\n    accesskey?: string | undefined;\n    'aria-atomic'?: string | undefined; //  ariaAtomic\n    'aria-autocomplete'?: string | undefined; //  ariaAutoComplete\n    'aria-busy'?: string | undefined; //  ariaBusy\n    'aria-checked'?: string | undefined; //  ariaChecked\n    'aria-colcount'?: string | undefined; //  ariaColCount\n    'aria-colindex'?: string | undefined; //  ariaColIndex\n    'aria-colindextext'?: string | undefined; //  ariaColIndexText\n    'aria-colspan'?: string | undefined; //  ariaColSpan\n    'aria-current'?: string | undefined; //  ariaCurrent\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description'?: string | undefined; //  ariaDescription\n    */\n    'aria-disabled'?: string | undefined; //  ariaDisabled\n    'aria-expanded'?: string | undefined; //  ariaExpanded\n    'aria-haspopup'?: string | undefined; //  ariaHasPopup\n    'aria-hidden'?: string | undefined; //  ariaHidden\n    'aria-invalid'?: string | undefined; //  ariaInvalid\n    'aria-keyshortcuts'?: string | undefined; //  ariaKeyShortcuts\n    'aria-label'?: string | undefined; //  ariaLabel\n    'aria-level'?: string | undefined; //  ariaLevel\n    'aria-live'?: string | undefined; //  ariaLive\n    'aria-modal'?: string | undefined; //  ariaModal\n    'aria-multiline'?: string | undefined; //  ariaMultiLine\n    'aria-multiselectable'?: string | undefined; //  ariaMultiSelectable\n    'aria-orientation'?: string | undefined; //  ariaOrientation\n    'aria-placeholder'?: string | undefined; //  ariaPlaceholder\n    'aria-posinset'?: string | undefined; //  ariaPosInSet\n    'aria-pressed'?: string | undefined; //  ariaPressed\n    'aria-readonly'?: string | undefined; //  ariaReadOnly\n    'aria-required'?: string | undefined; //  ariaRequired\n    'aria-roledescription'?: string | undefined; //  ariaRoleDescription\n    'aria-rowcount'?: string | undefined; //  ariaRowCount\n    'aria-rowindex'?: string | undefined; //  ariaRowIndex\n    'aria-rowindextext'?: string | undefined; //  ariaRowIndexText\n    'aria-rowspan'?: string | undefined; //  ariaRowSpan\n    'aria-selected'?: string | undefined; //  ariaSelected\n    'aria-setsize'?: string | undefined; //  ariaSetSize\n    'aria-sort'?: string | undefined; //  ariaSort\n    'aria-valuemax'?: string | undefined; //  ariaValueMax\n    'aria-valuemin'?: string | undefined; //  ariaValueMin\n    'aria-valuenow'?: string | undefined; //  ariaValueNow\n    'aria-valuetext'?: string | undefined; //  ariaValueText\n    /** autocapitalization hint */\n    autocapitalize?:\n        | 'off'\n        | 'none'\n        | 'on'\n        | 'sentences'\n        | 'words'\n        | 'characters'\n        | string\n        | undefined;\n    /** focus as soon as the page is loaded or as soon as the dialog within which it finds itself is shown */\n    autofocus?: boolean | undefined;\n    /** the various classes that the element belongs to */\n    class?: string | undefined;\n    /** indicates if the element is editable */\n    contenteditable?: '' | 'true' | 'false' | string | undefined;\n    /** specifies the element's text directionality */\n    dir?: DirValue | undefined;\n    /** specifies the element's drag behavior */\n    draggable?: boolean | undefined;\n    /** specifies what action label (or icon) to present for the enter key on virtual keyboards */\n    enterkeyhint?:\n        | 'enter'\n        | 'done'\n        | 'go'\n        | 'next'\n        | 'previous'\n        | 'search'\n        | 'send'\n        | string\n        | undefined;\n    /** indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user */\n    hidden?: boolean | undefined;\n    /** the unique id of the element */\n    id?: string | undefined;\n    inputmode?:\n        | 'none'\n        | 'text'\n        | 'tel'\n        | 'url'\n        | 'email'\n        | 'numeric'\n        | 'decimal'\n        | 'search'\n        | string\n        | undefined;\n    is?: string | undefined;\n    itemid?: string | undefined;\n    itemprop?: string | undefined;\n    itemref?: string | undefined;\n    itemscope?: boolean | undefined;\n    itemtype?: string | undefined;\n    lang?: string | undefined;\n    nonce?: string | undefined;\n    role?: AriaRole | undefined;\n    slot?: string | undefined;\n    spellcheck?: boolean | undefined;\n    style?: string | undefined;\n    tabindex?: -1 | 0 | '-1' | '0' | string | number | undefined; // \"-1\" and \"0\" used as convenience\n    title?: string | undefined;\n    translate?: '' | 'yes' | 'no' | undefined;\n}\n\ninterface JSXAnchorElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** Browsing context for hyperlink navigation */\n    target?: BrowsingContextValue | undefined;\n    /** Whether to download the resource instead of navigating to it, and its filename if so */\n    download?: string | undefined;\n    /** URLs to ping */\n    ping?: string | undefined;\n    /** Relationship between the location in the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXAreaElementInterface extends JSXElementInterface {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    shape?:\n        | 'circle'\n        | 'circ'\n        | 'default'\n        | 'poly'\n        | 'polygon'\n        | 'rect'\n        | 'rectangle'\n        | string\n        | undefined;\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n    download?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXMediaElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Hints how much buffering the media resource will likely need */\n    preload?: 'none' | 'metadata' | 'auto' | undefined;\n    /** Hint that the media resource can be started automatically when the page is loaded */\n    autoplay?: boolean | undefined;\n    /** Whether to loop the media resource */\n    loop?: boolean | undefined;\n    /** Whether to mute the media resource by default */\n    muted?: boolean | undefined;\n    /** Show user agent controls */\n    controls?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXAudioElementInterface extends JSXMediaElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBRElementInterface extends JSXElementInterface {}\n\ninterface JSXBaseElementInterface extends JSXElementInterface {\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBodyElementInterface extends JSXElementInterface {}\n\ninterface JSXButtonElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formaction?: string | undefined;\n    formenctype?: EncTypeValue | undefined;\n    formmethod?: FormMethodValue | undefined;\n    formnovalidate?: boolean | undefined;\n    formtarget?: BrowsingContextValue | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | string | undefined;\n    value?: string | undefined;\n}\n\ninterface JSXCanvasElementInterface extends JSXElementInterface {\n    width?: string | number | undefined;\n    height?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDListElementInterface extends JSXElementInterface {}\n\ninterface JSXDataElementInterface extends JSXElementInterface {\n    value?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDataListElementInterface extends JSXElementInterface {}\n\ninterface JSXDetailsElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\ninterface JSXDialogElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDivElementInterface extends JSXElementInterface {}\n\ninterface JSXEmbedElementInterface extends JSXElementInterface {\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: string | number | undefined;\n    height?: string | number | undefined;\n}\n\ninterface JSXFieldSetElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\ninterface JSXFormElementInterface extends JSXElementInterface {\n    'accept-charset'?: 'UTF-8' | string | undefined;\n    action?: string | undefined;\n    autocomplete?: AutocompleteValue | undefined;\n    enctype?: EncTypeValue | undefined;\n    method?: FormMethodValue | undefined;\n    name?: string | undefined;\n    novalidate?: boolean | undefined;\n    target?: BrowsingContextValue | undefined;\n    rel?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadingElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHRElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHtmlElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXIFrameElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** A document to render in the iframe */\n    srcdoc?: string | undefined;\n    /** Name of nested browsing context */\n    name?: string | undefined;\n    /** Security rules for nested content */\n    sandbox?: SandboxValue | undefined; // TODO: This _could_ be a SandboxValue[], but feels awkward\n    /** Permissions policy to be applied to the iframe's contents */\n    allow?: string | undefined;\n    /** Whether to allow the iframe's contents to use requestFullscreen() */\n    allowfullscreen?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\ninterface JSXImageElementInterface extends JSXElementInterface {\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Name of image map to use */\n    usemap?: string | undefined;\n    /** Whether the image is a server-side image map */\n    ismap?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Decoding hint to use when processing this image for presentation */\n    decoding?: ImageDecodingHintValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\ntype FormInputTypeValues =\n    | 'button'\n    | 'checkbox'\n    | 'color'\n    | 'date'\n    | 'datetime-local'\n    | 'email'\n    | 'file'\n    | 'hidden'\n    | 'image'\n    | 'month'\n    | 'number'\n    | 'password'\n    | 'radio'\n    | 'range'\n    | 'reset'\n    | 'search'\n    | 'submit'\n    | 'tel'\n    | 'text'\n    | 'time'\n    | 'url'\n    | 'week'\n    | string;\n\ninterface JSXInputElementInterface extends JSXElementInterface {\n    /** Hint for expected file type in file upload controls */\n    accept?: string | undefined;\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the control is checked */\n    checked?: boolean | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: string | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** URL to use for form submission */\n    formaction?: string | undefined;\n    /** Entry list encoding type to use for form submission */\n    formenctype?: EncTypeValue | undefined;\n    /** Variant to use for form submission */\n    formmethod?: FormMethodValue | undefined;\n    /** Bypass form control validation for form submission */\n    formnovalidate?: boolean | undefined;\n    /** Browsing context for form submission */\n    formtarget?: BrowsingContextValue | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n    /** Third, indeterminate state for checkboxes */\n    indeterminate?: boolean | undefined;\n    /** List of autocomplete options */\n    list?: string | undefined;\n    /** Maximum value */\n    max?: string | number | undefined;\n    /** Maximum length of value */\n    maxlength?: string | number | undefined;\n    /** Minimum value */\n    min?: string | number | undefined;\n    /** Minimum length of value */\n    minlength?: string | number | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Pattern to be matched by the form control's value */\n    pattern?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: string | number | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Granularity to be matched by the form control's value */\n    step?: string | number | undefined;\n    /** Type of form control */\n    type?: FormInputTypeValues | undefined;\n    /** Value of the form control */\n    value?: string | number | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n}\n\ninterface JSXModElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n    /** Date and (optionally) time of the change */\n    datetime?: string | undefined;\n}\n\ninterface JSXLabelElementInterface extends JSXElementInterface {\n    /** Associate the label with form control */\n    for?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLegendElementInterface extends JSXElementInterface {}\n\ninterface JSXLIElementInterface extends JSXElementInterface {\n    /** Ordinal value of the list item */\n    value?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLinkElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Relationship between the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Sizes of the icons (for rel=\"icon\") */\n    sizes?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel=\"preload\") */\n    imagesrcset?: string | undefined;\n    /** Image sizes for different page layouts (for rel=\"preload\") */\n    imagesizes?: string | undefined;\n    /** Potential destination for a preload request (for rel=\"preload\" and rel=\"modulepreload\") */\n    as?: string | undefined;\n    /** Color to use when customizing a site's icon (for rel=\"mask-icon\") */\n    color?: string | undefined;\n    /** Whether the link is disabled */\n    disabled?: boolean | undefined;\n}\n\ninterface JSXMapElementInterface extends JSXElementInterface {\n    /** Name of image map to reference from the usemap attribute */\n    name?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXMenuElementInterface extends JSXElementInterface {}\n\ninterface JSXMetaElementInterface extends JSXElementInterface {\n    /** Metadata name */\n    name?:\n        | 'application-name'\n        | 'author'\n        | 'description'\n        | 'generator'\n        | 'keywords'\n        | 'referrer'\n        | 'theme-color'\n        | 'color-scheme'\n        | string\n        | undefined;\n    /** Pragma directive */\n    'http-equiv'?: string | undefined;\n    /** Value of the element */\n    content?: string | undefined;\n    /** Character encoding declaration */\n    charset?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n}\n\ninterface JSXMeterElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: string | number | undefined;\n    /** Lower bound of range */\n    min?: string | number | undefined;\n    /** Upper bound of range */\n    max?: string | number | undefined;\n    /** High limit of low range */\n    low?: string | number | undefined;\n    /** Low limit of high range */\n    high?: string | number | undefined;\n    /** Optimum value in gauge */\n    optimum?: string | number | undefined;\n}\n\ninterface JSXObjectElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    data?: string | undefined;\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** Name of nested browsing context */\n    name?: BrowsingContextValue | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | undefined;\n    /** Vertical dimension */\n    height?: string | undefined;\n}\n\ninterface JSXOListElementInterface extends JSXElementInterface {\n    /** Number the list backwards */\n    reversed?: boolean | undefined;\n    /** Starting value of the list */\n    start?: string | number | undefined;\n    /** Kind of list marker */\n    type?:\n        | 'decimal'\n        | 'lower-alpha'\n        | 'upper-alpha'\n        | 'lower-roman'\n        | 'upper-roman'\n        | string\n        | undefined;\n}\n\ninterface JSXOptGroupElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n}\n\ninterface JSXOptionElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Whether the option is selected by default */\n    selected?: boolean | undefined;\n    /** Value to be used for form submission */\n    value?: string | undefined;\n}\n\ninterface JSXOutputElementInterface extends JSXElementInterface {\n    /** Specifies controls from which the output was calculated */\n    for?: string | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Name of the element to use in the form.elements API. */\n    name?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXParagraphElementInterface extends JSXElementInterface {}\n\ninterface JSXParamElementInterface extends JSXElementInterface {\n    /** Name of parameter */\n    name?: string | undefined;\n    /** Value of parameter */\n    value?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPictureElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPreElementInterface extends JSXElementInterface {}\n\ninterface JSXProgressElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: string | number | undefined;\n    /** Upper bound of range */\n    max?: string | number | undefined;\n}\n\ninterface JSXQuoteElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n}\n\ninterface JSXScriptElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Type of script */\n    type?: 'application/json' | 'text/json' | 'module' | string | undefined;\n    /** Prevents execution in user agents that support module scripts */\n    nomodule?: boolean | undefined;\n    /** Execute script when available, without blocking while fetching */\n    async?: boolean | undefined;\n    /** Defer script execution */\n    defer?: boolean | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\ninterface JSXSelectElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: string | number | undefined;\n    /** Value of the element */\n    value?: string | undefined;\n}\n\ninterface JSXSlotElementInterface extends JSXElementInterface {\n    /** Name of shadow tree slot */\n    name?: string | undefined;\n}\n\ninterface JSXSourceElementInterface extends JSXElementInterface {\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** (in video or audio) \u2014 Address of the resource */\n    src?: string | undefined;\n    /** (in picture) \u2014 Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** (in picture) \u2014 Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** (in picture) \u2014 Applicable media */\n    media?: string | undefined;\n    /** (in picture) \u2014 Horizontal dimension */\n    width?: string | number | undefined;\n    /** (in picture) \u2014 Vertical dimension */\n    height?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXSpanElementInterface extends JSXElementInterface {}\n\ninterface JSXStyleElementInterface extends JSXElementInterface {\n    /** Applicable media */\n    media?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableCaptionElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableSectionElementInterface extends JSXElementInterface {}\n\ninterface JSXTableCellElementInterface extends JSXElementInterface {\n    /** Number of columns that the cell is to span */\n    colspan?: string | number | undefined;\n    /** Number of rows that the cell is to span */\n    rowspan?: string | number | undefined;\n    /** The header cells for this cell */\n    headers?: string | undefined;\n}\n\ninterface JSXTableHeaderElementInterface extends JSXTableCellElementInterface {\n    /** Specifies which cells the header cell applies to */\n    scope?: string | undefined;\n\n    /** Alternative label to use for the header cell when referencing the cell in other contexts */\n    abbr?: string | undefined;\n}\n\ninterface JSXTableColElementInterface extends JSXElementInterface {\n    /** Number of columns spanned by the element */\n    span?: string | number | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTemplateElementInterface extends JSXElementInterface {}\n\ninterface JSXTextAreaElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Maximum number of characters per line */\n    cols?: string | number | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: DirValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Maximum length of value */\n    maxlength?: string | number | undefined;\n    /** Minimum length of value */\n    minlength?: string | number | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Number of lines to show */\n    rows?: string | number | undefined;\n    /** How the value of the form control is to be wrapped for form submission */\n    wrap?: 'soft' | 'hard' | string | undefined;\n}\n\ninterface JSXTimeElementInterface extends JSXElementInterface {\n    /** Machine-readable value */\n    datetime?: string | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTitleElementInterface extends JSXElementInterface {}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableRowElementInterface extends JSXElementInterface {}\n\ninterface JSXTrackElementInterface extends JSXElementInterface {\n    /** The type of text track */\n    kind?:\n        | 'subtitles'\n        | 'captions'\n        | 'descriptions'\n        | 'chapters'\n        | 'metadata'\n        | string\n        | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Language of the text track */\n    srclang?: string | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Enable the track if no other text track is more suitable */\n    default?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXUListElementInterface extends JSXElementInterface {}\n\ninterface JSXVideoElementInterface extends JSXMediaElementInterface {\n    /** Poster frame to show prior to video playback */\n    poster?: string | undefined;\n    /** Encourage the user agent to display video content within the element's playback area */\n    playsinline?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | number | undefined;\n    /** Vertical dimension */\n    height?: string | number | undefined;\n}\n\n/**\n * Good old bivarianceHack to allow assignability of specific event handlers to more generic event handlers :facepalm:\n */\ntype EventHandler<TEvent extends Event, TElement extends Element> =\n    | undefined\n    | {\n          bivarianceHack(event: TEvent, target: TElement): void;\n      }['bivarianceHack'];\n\ninterface JSXRefProps<TElement extends Element> {\n    ref?: undefined | RefObjectOrCallback<TElement>;\n}\n\ninterface JSXAttrProps {\n    [key: `attr:${string}`]: Calculation<any> | any;\n    [key: `prop:${string}`]: Calculation<any> | any;\n}\n\ninterface JSXEventProps<TElement extends Element> {\n    'on:abort'?: EventHandler<Event, TElement>;\n    'onpassive:abort'?: EventHandler<Event, TElement>;\n    'oncapture:abort'?: EventHandler<Event, TElement>;\n    'on:auxclick'?: EventHandler<PointerEvent, TElement>;\n    'onpassive:auxclick'?: EventHandler<PointerEvent, TElement>;\n    'oncapture:auxclick'?: EventHandler<PointerEvent, TElement>;\n    'on:beforeinput'?: EventHandler<InputEvent, TElement>;\n    'onpassive:beforeinput'?: EventHandler<InputEvent, TElement>;\n    'oncapture:beforeinput'?: EventHandler<InputEvent, TElement>;\n    'on:blur'?: EventHandler<FocusEvent, TElement>;\n    'onpassive:blur'?: EventHandler<FocusEvent, TElement>;\n    'oncapture:blur'?: EventHandler<FocusEvent, TElement>;\n    'on:cancel'?: EventHandler<Event, TElement>;\n    'onpassive:cancel'?: EventHandler<Event, TElement>;\n    'oncapture:cancel'?: EventHandler<Event, TElement>;\n    'on:change'?: EventHandler<Event, TElement>;\n    'onpassive:change'?: EventHandler<Event, TElement>;\n    'oncapture:change'?: EventHandler<Event, TElement>;\n    'on:click'?: EventHandler<PointerEvent, TElement>;\n    'onpassive:click'?: EventHandler<PointerEvent, TElement>;\n    'oncapture:click'?: EventHandler<PointerEvent, TElement>;\n    'on:close'?: EventHandler<Event, TElement>;\n    'onpassive:close'?: EventHandler<Event, TElement>;\n    'oncapture:close'?: EventHandler<Event, TElement>;\n    'on:compositionend'?: EventHandler<CompositionEvent, TElement>;\n    'onpassive:compositionend'?: EventHandler<CompositionEvent, TElement>;\n    'oncapture:compositionend'?: EventHandler<CompositionEvent, TElement>;\n    'on:compositionstart'?: EventHandler<CompositionEvent, TElement>;\n    'onpassive:compositionstart'?: EventHandler<CompositionEvent, TElement>;\n    'oncapture:compositionstart'?: EventHandler<CompositionEvent, TElement>;\n    'on:compositionupdate'?: EventHandler<CompositionEvent, TElement>;\n    'onpassive:compositionupdate'?: EventHandler<CompositionEvent, TElement>;\n    'oncapture:compositionupdate'?: EventHandler<CompositionEvent, TElement>;\n    'on:connect'?: EventHandler<MessageEvent, TElement>;\n    'onpassive:connect'?: EventHandler<MessageEvent, TElement>;\n    'oncapture:connect'?: EventHandler<MessageEvent, TElement>;\n    'on:contextlost'?: EventHandler<Event, TElement>;\n    'onpassive:contextlost'?: EventHandler<Event, TElement>;\n    'oncapture:contextlost'?: EventHandler<Event, TElement>;\n    'on:contextmenu'?: EventHandler<PointerEvent, TElement>;\n    'onpassive:contextmenu'?: EventHandler<PointerEvent, TElement>;\n    'oncapture:contextmenu'?: EventHandler<PointerEvent, TElement>;\n    'on:contextrestored'?: EventHandler<Event, TElement>;\n    'onpassive:contextrestored'?: EventHandler<Event, TElement>;\n    'oncapture:contextrestored'?: EventHandler<Event, TElement>;\n    'on:copy'?: EventHandler<Event, TElement>;\n    'onpassive:copy'?: EventHandler<Event, TElement>;\n    'oncapture:copy'?: EventHandler<Event, TElement>;\n    'on:cut'?: EventHandler<Event, TElement>;\n    'onpassive:cut'?: EventHandler<Event, TElement>;\n    'oncapture:cut'?: EventHandler<Event, TElement>;\n    'on:dblclick'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:dblclick'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:dblclick'?: EventHandler<MouseEvent, TElement>;\n    'on:drag'?: EventHandler<DragEvent, TElement>;\n    'onpassive:drag'?: EventHandler<DragEvent, TElement>;\n    'oncapture:drag'?: EventHandler<DragEvent, TElement>;\n    'on:dragend'?: EventHandler<DragEvent, TElement>;\n    'onpassive:dragend'?: EventHandler<DragEvent, TElement>;\n    'oncapture:dragend'?: EventHandler<DragEvent, TElement>;\n    'on:dragenter'?: EventHandler<DragEvent, TElement>;\n    'onpassive:dragenter'?: EventHandler<DragEvent, TElement>;\n    'oncapture:dragenter'?: EventHandler<DragEvent, TElement>;\n    'on:dragleave'?: EventHandler<DragEvent, TElement>;\n    'onpassive:dragleave'?: EventHandler<DragEvent, TElement>;\n    'oncapture:dragleave'?: EventHandler<DragEvent, TElement>;\n    'on:dragover'?: EventHandler<DragEvent, TElement>;\n    'onpassive:dragover'?: EventHandler<DragEvent, TElement>;\n    'oncapture:dragover'?: EventHandler<DragEvent, TElement>;\n    'on:dragstart'?: EventHandler<DragEvent, TElement>;\n    'onpassive:dragstart'?: EventHandler<DragEvent, TElement>;\n    'oncapture:dragstart'?: EventHandler<DragEvent, TElement>;\n    'on:drop'?: EventHandler<DragEvent, TElement>;\n    'onpassive:drop'?: EventHandler<DragEvent, TElement>;\n    'oncapture:drop'?: EventHandler<DragEvent, TElement>;\n    'on:emptied'?: EventHandler<Event, TElement>;\n    'onpassive:emptied'?: EventHandler<Event, TElement>;\n    'oncapture:emptied'?: EventHandler<Event, TElement>;\n    'on:error'?: EventHandler<Event, TElement>;\n    'onpassive:error'?: EventHandler<Event, TElement>;\n    'oncapture:error'?: EventHandler<Event, TElement>;\n    'on:focus'?: EventHandler<FocusEvent, TElement>;\n    'onpassive:focus'?: EventHandler<FocusEvent, TElement>;\n    'oncapture:focus'?: EventHandler<FocusEvent, TElement>;\n    'on:focusin'?: EventHandler<FocusEvent, TElement>;\n    'onpassive:focusin'?: EventHandler<FocusEvent, TElement>;\n    'oncapture:focusin'?: EventHandler<FocusEvent, TElement>;\n    'on:focusout'?: EventHandler<FocusEvent, TElement>;\n    'onpassive:focusout'?: EventHandler<FocusEvent, TElement>;\n    'oncapture:focusout'?: EventHandler<FocusEvent, TElement>;\n    'on:formdata'?: EventHandler<FormDataEvent, TElement>;\n    'onpassive:formdata'?: EventHandler<FormDataEvent, TElement>;\n    'oncapture:formdata'?: EventHandler<FormDataEvent, TElement>;\n    'on:hashchange'?: EventHandler<HashChangeEvent, TElement>;\n    'onpassive:hashchange'?: EventHandler<HashChangeEvent, TElement>;\n    'oncapture:hashchange'?: EventHandler<HashChangeEvent, TElement>;\n    'on:input'?: EventHandler<InputEvent, TElement>;\n    'onpassive:input'?: EventHandler<InputEvent, TElement>;\n    'oncapture:input'?: EventHandler<InputEvent, TElement>;\n    'on:invalid'?: EventHandler<Event, TElement>;\n    'onpassive:invalid'?: EventHandler<Event, TElement>;\n    'oncapture:invalid'?: EventHandler<Event, TElement>;\n    'on:keydown'?: EventHandler<KeyboardEvent, TElement>;\n    'onpassive:keydown'?: EventHandler<KeyboardEvent, TElement>;\n    'oncapture:keydown'?: EventHandler<KeyboardEvent, TElement>;\n    'on:keyup'?: EventHandler<KeyboardEvent, TElement>;\n    'onpassive:keyup'?: EventHandler<KeyboardEvent, TElement>;\n    'oncapture:keyup'?: EventHandler<KeyboardEvent, TElement>;\n    'on:languagechange'?: EventHandler<Event, TElement>;\n    'onpassive:languagechange'?: EventHandler<Event, TElement>;\n    'oncapture:languagechange'?: EventHandler<Event, TElement>;\n    'on:load'?: EventHandler<Event, TElement>;\n    'onpassive:load'?: EventHandler<Event, TElement>;\n    'oncapture:load'?: EventHandler<Event, TElement>;\n    'on:loadstart'?: EventHandler<Event, TElement>;\n    'onpassive:loadstart'?: EventHandler<Event, TElement>;\n    'oncapture:loadstart'?: EventHandler<Event, TElement>;\n    'on:message'?: EventHandler<MessageEvent, TElement>;\n    'onpassive:message'?: EventHandler<MessageEvent, TElement>;\n    'oncapture:message'?: EventHandler<MessageEvent, TElement>;\n    'on:messageerror'?: EventHandler<MessageEvent, TElement>;\n    'onpassive:messageerror'?: EventHandler<MessageEvent, TElement>;\n    'oncapture:messageerror'?: EventHandler<MessageEvent, TElement>;\n    'on:mousedown'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mousedown'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mousedown'?: EventHandler<MouseEvent, TElement>;\n    'on:mouseenter'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mouseenter'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mouseenter'?: EventHandler<MouseEvent, TElement>;\n    'on:mouseleave'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mouseleave'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mouseleave'?: EventHandler<MouseEvent, TElement>;\n    'on:mousemove'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mousemove'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mousemove'?: EventHandler<MouseEvent, TElement>;\n    'on:mouseout'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mouseout'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mouseout'?: EventHandler<MouseEvent, TElement>;\n    'on:mouseover'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mouseover'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mouseover'?: EventHandler<MouseEvent, TElement>;\n    'on:mouseup'?: EventHandler<MouseEvent, TElement>;\n    'onpassive:mouseup'?: EventHandler<MouseEvent, TElement>;\n    'oncapture:mouseup'?: EventHandler<MouseEvent, TElement>;\n    'on:offline'?: EventHandler<Event, TElement>;\n    'onpassive:offline'?: EventHandler<Event, TElement>;\n    'oncapture:offline'?: EventHandler<Event, TElement>;\n    'on:online'?: EventHandler<Event, TElement>;\n    'onpassive:online'?: EventHandler<Event, TElement>;\n    'oncapture:online'?: EventHandler<Event, TElement>;\n    'on:open'?: EventHandler<Event, TElement>;\n    'onpassive:open'?: EventHandler<Event, TElement>;\n    'oncapture:open'?: EventHandler<Event, TElement>;\n    'on:pagehide'?: EventHandler<PageTransitionEvent, TElement>;\n    'onpassive:pagehide'?: EventHandler<PageTransitionEvent, TElement>;\n    'oncapture:pagehide'?: EventHandler<PageTransitionEvent, TElement>;\n    'on:pageshow'?: EventHandler<PageTransitionEvent, TElement>;\n    'onpassive:pageshow'?: EventHandler<PageTransitionEvent, TElement>;\n    'oncapture:pageshow'?: EventHandler<PageTransitionEvent, TElement>;\n    'on:paste'?: EventHandler<Event, TElement>;\n    'onpassive:paste'?: EventHandler<Event, TElement>;\n    'oncapture:paste'?: EventHandler<Event, TElement>;\n    'on:popstate'?: EventHandler<PopStateEvent, TElement>;\n    'onpassive:popstate'?: EventHandler<PopStateEvent, TElement>;\n    'oncapture:popstate'?: EventHandler<PopStateEvent, TElement>;\n    'on:progress'?: EventHandler<Event, TElement>;\n    'onpassive:progress'?: EventHandler<Event, TElement>;\n    'oncapture:progress'?: EventHandler<Event, TElement>;\n    'on:readystatechange'?: EventHandler<Event, TElement>;\n    'onpassive:readystatechange'?: EventHandler<Event, TElement>;\n    'oncapture:readystatechange'?: EventHandler<Event, TElement>;\n    'on:rejectionhandled'?: EventHandler<PromiseRejectionEvent, TElement>;\n    'onpassive:rejectionhandled'?: EventHandler<\n        PromiseRejectionEvent,\n        TElement\n    >;\n    'oncapture:rejectionhandled'?: EventHandler<\n        PromiseRejectionEvent,\n        TElement\n    >;\n    'on:reset'?: EventHandler<Event, TElement>;\n    'onpassive:reset'?: EventHandler<Event, TElement>;\n    'oncapture:reset'?: EventHandler<Event, TElement>;\n    'on:securitypolicyviolation'?: EventHandler<Event, TElement>;\n    'onpassive:securitypolicyviolation'?: EventHandler<Event, TElement>;\n    'oncapture:securitypolicyviolation'?: EventHandler<Event, TElement>;\n    'on:select'?: EventHandler<Event, TElement>;\n    'onpassive:select'?: EventHandler<Event, TElement>;\n    'oncapture:select'?: EventHandler<Event, TElement>;\n    'on:slotchange'?: EventHandler<Event, TElement>;\n    'onpassive:slotchange'?: EventHandler<Event, TElement>;\n    'oncapture:slotchange'?: EventHandler<Event, TElement>;\n    'on:stalled'?: EventHandler<Event, TElement>;\n    'onpassive:stalled'?: EventHandler<Event, TElement>;\n    'oncapture:stalled'?: EventHandler<Event, TElement>;\n    'on:storage'?: EventHandler<StorageEvent, TElement>;\n    'onpassive:storage'?: EventHandler<StorageEvent, TElement>;\n    'oncapture:storage'?: EventHandler<StorageEvent, TElement>;\n    'on:submit'?: EventHandler<SubmitEvent, TElement>;\n    'onpassive:submit'?: EventHandler<SubmitEvent, TElement>;\n    'oncapture:submit'?: EventHandler<SubmitEvent, TElement>;\n    'on:suspend'?: EventHandler<Event, TElement>;\n    'onpassive:suspend'?: EventHandler<Event, TElement>;\n    'oncapture:suspend'?: EventHandler<Event, TElement>;\n    'on:toggle'?: EventHandler<Event, TElement>;\n    'onpassive:toggle'?: EventHandler<Event, TElement>;\n    'oncapture:toggle'?: EventHandler<Event, TElement>;\n    'on:unhandledrejection'?: EventHandler<PromiseRejectionEvent, TElement>;\n    'onpassive:unhandledrejection'?: EventHandler<\n        PromiseRejectionEvent,\n        TElement\n    >;\n    'oncapture:unhandledrejection'?: EventHandler<\n        PromiseRejectionEvent,\n        TElement\n    >;\n    'on:unload'?: EventHandler<Event, TElement>;\n    'onpassive:unload'?: EventHandler<Event, TElement>;\n    'oncapture:unload'?: EventHandler<Event, TElement>;\n    'on:visibilitychange'?: EventHandler<Event, TElement>;\n    'onpassive:visibilitychange'?: EventHandler<Event, TElement>;\n    'oncapture:visibilitychange'?: EventHandler<Event, TElement>;\n    'on:wheel'?: EventHandler<WheelEvent, TElement>;\n    'onpassive:wheel'?: EventHandler<WheelEvent, TElement>;\n    'oncapture:wheel'?: EventHandler<WheelEvent, TElement>;\n    [key: `on:${string}`]: EventHandler<Event, TElement>;\n    [key: `onpassive:${string}`]: EventHandler<Event, TElement>;\n    [key: `oncapture:${string}`]: EventHandler<Event, TElement>;\n}\n\ninterface JSXDataProps {\n    [key: `data-${string}`]:\n        | Calculation<string | undefined>\n        | string\n        | undefined;\n}\n\ntype JSXElementInterfaceProps<TJSXType extends JSXElementInterface> = {\n    [Key in keyof TJSXType]:\n        | (Calculation<any> & (() => TJSXType[Key]))\n        | TJSXType[Key];\n};\n\ntype JSXChildrenProps<HasChildren extends boolean> = HasChildren extends true\n    ? { children?: JSX.Node | JSX.Node[] }\n    : { children?: never };\n\ntype WithCalculationsAndRef<\n    TJSXType extends JSXElementInterface,\n    TElement extends Element,\n    HasChildren extends boolean\n> = JSXRefProps<TElement> &\n    JSXAttrProps &\n    JSXEventProps<TElement> &\n    JSXDataProps &\n    JSXElementInterfaceProps<TJSXType> &\n    JSXChildrenProps<HasChildren>;\n\nexport interface KnownElements {\n    a: WithCalculationsAndRef<\n        JSXAnchorElementInterface,\n        HTMLAnchorElement,\n        true\n    >;\n    abbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    address: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    area: WithCalculationsAndRef<\n        JSXAreaElementInterface,\n        HTMLAreaElement,\n        false\n    >;\n    article: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    aside: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    audio: WithCalculationsAndRef<\n        JSXAudioElementInterface,\n        HTMLAudioElement,\n        true\n    >;\n    b: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    base: WithCalculationsAndRef<\n        JSXBaseElementInterface,\n        HTMLBaseElement,\n        false\n    >;\n    bdi: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    bdo: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    blockquote: WithCalculationsAndRef<\n        JSXQuoteElementInterface,\n        HTMLQuoteElement,\n        true\n    >;\n    body: WithCalculationsAndRef<\n        JSXBodyElementInterface,\n        HTMLBodyElement,\n        true\n    >;\n    br: WithCalculationsAndRef<JSXBRElementInterface, HTMLBRElement, false>;\n    button: WithCalculationsAndRef<\n        JSXButtonElementInterface,\n        HTMLButtonElement,\n        true\n    >;\n    canvas: WithCalculationsAndRef<\n        JSXCanvasElementInterface,\n        HTMLCanvasElement,\n        true\n    >;\n    caption: WithCalculationsAndRef<\n        JSXTableCaptionElementInterface,\n        HTMLTableCaptionElement,\n        true\n    >;\n    cite: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    code: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    col: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        false\n    >;\n    colgroup: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        true\n    >;\n    data: WithCalculationsAndRef<\n        JSXDataElementInterface,\n        HTMLDataElement,\n        true\n    >;\n    datalist: WithCalculationsAndRef<\n        JSXDataListElementInterface,\n        HTMLDataListElement,\n        true\n    >;\n    dd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    del: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    details: WithCalculationsAndRef<\n        JSXDetailsElementInterface,\n        HTMLDetailsElement,\n        true\n    >;\n    dfn: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    dialog: WithCalculationsAndRef<\n        JSXDialogElementInterface,\n        HTMLDialogElement,\n        true\n    >;\n    div: WithCalculationsAndRef<JSXDivElementInterface, HTMLDivElement, true>;\n    dl: WithCalculationsAndRef<\n        JSXDListElementInterface,\n        HTMLDListElement,\n        true\n    >;\n    dt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    em: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    embed: WithCalculationsAndRef<\n        JSXEmbedElementInterface,\n        HTMLEmbedElement,\n        false\n    >;\n    fieldset: WithCalculationsAndRef<\n        JSXFieldSetElementInterface,\n        HTMLFieldSetElement,\n        true\n    >;\n    figcaption: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    figure: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    footer: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    form: WithCalculationsAndRef<\n        JSXFormElementInterface,\n        HTMLFormElement,\n        true\n    >;\n    h1: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h2: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h3: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h4: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h5: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h6: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    head: WithCalculationsAndRef<\n        JSXHeadElementInterface,\n        HTMLHeadElement,\n        true\n    >;\n    header: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hgroup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hr: WithCalculationsAndRef<JSXHRElementInterface, HTMLHRElement, false>;\n    html: WithCalculationsAndRef<\n        JSXHtmlElementInterface,\n        HTMLHtmlElement,\n        true\n    >;\n    i: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    iframe: WithCalculationsAndRef<\n        JSXIFrameElementInterface,\n        HTMLIFrameElement,\n        true\n    >;\n    img: WithCalculationsAndRef<\n        JSXImageElementInterface,\n        HTMLImageElement,\n        false\n    >;\n    input: WithCalculationsAndRef<\n        JSXInputElementInterface,\n        HTMLInputElement,\n        false\n    >;\n    ins: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    kbd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    label: WithCalculationsAndRef<\n        JSXLabelElementInterface,\n        HTMLLabelElement,\n        true\n    >;\n    legend: WithCalculationsAndRef<\n        JSXLegendElementInterface,\n        HTMLLegendElement,\n        true\n    >;\n    li: WithCalculationsAndRef<JSXLIElementInterface, HTMLLIElement, true>;\n    link: WithCalculationsAndRef<\n        JSXLinkElementInterface,\n        HTMLLinkElement,\n        false\n    >;\n    main: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    map: WithCalculationsAndRef<JSXMapElementInterface, HTMLMapElement, true>;\n    mark: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    menu: WithCalculationsAndRef<\n        JSXMenuElementInterface,\n        HTMLMenuElement,\n        true\n    >;\n    meta: WithCalculationsAndRef<\n        JSXMetaElementInterface,\n        HTMLMetaElement,\n        false\n    >;\n    meter: WithCalculationsAndRef<\n        JSXMeterElementInterface,\n        HTMLMeterElement,\n        true\n    >;\n    nav: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    noscript: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    object: WithCalculationsAndRef<\n        JSXObjectElementInterface,\n        HTMLObjectElement,\n        true\n    >;\n    ol: WithCalculationsAndRef<\n        JSXOListElementInterface,\n        HTMLOListElement,\n        true\n    >;\n    optgroup: WithCalculationsAndRef<\n        JSXOptGroupElementInterface,\n        HTMLOptGroupElement,\n        true\n    >;\n    option: WithCalculationsAndRef<\n        JSXOptionElementInterface,\n        HTMLOptionElement,\n        true\n    >;\n    output: WithCalculationsAndRef<\n        JSXOutputElementInterface,\n        HTMLOutputElement,\n        true\n    >;\n    p: WithCalculationsAndRef<\n        JSXParagraphElementInterface,\n        HTMLParagraphElement,\n        true\n    >;\n    param: WithCalculationsAndRef<\n        JSXParamElementInterface,\n        HTMLParamElement,\n        false\n    >;\n    picture: WithCalculationsAndRef<\n        JSXPictureElementInterface,\n        HTMLPictureElement,\n        true\n    >;\n    pre: WithCalculationsAndRef<JSXPreElementInterface, HTMLPreElement, true>;\n    progress: WithCalculationsAndRef<\n        JSXProgressElementInterface,\n        HTMLProgressElement,\n        true\n    >;\n    q: WithCalculationsAndRef<JSXQuoteElementInterface, HTMLQuoteElement, true>;\n    rp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    rt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ruby: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    s: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    samp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    script: WithCalculationsAndRef<\n        JSXScriptElementInterface,\n        HTMLScriptElement,\n        true\n    >;\n    section: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    select: WithCalculationsAndRef<\n        JSXSelectElementInterface,\n        HTMLSelectElement,\n        true\n    >;\n    slot: WithCalculationsAndRef<\n        JSXSlotElementInterface,\n        HTMLSlotElement,\n        true\n    >;\n    small: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    source: WithCalculationsAndRef<\n        JSXSourceElementInterface,\n        HTMLSourceElement,\n        false\n    >;\n    span: WithCalculationsAndRef<\n        JSXSpanElementInterface,\n        HTMLSpanElement,\n        true\n    >;\n    strong: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    style: WithCalculationsAndRef<\n        JSXStyleElementInterface,\n        HTMLStyleElement,\n        true\n    >;\n    sub: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    summary: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    sup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    table: WithCalculationsAndRef<\n        JSXTableElementInterface,\n        HTMLTableElement,\n        true\n    >;\n    tbody: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    td: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    template: WithCalculationsAndRef<\n        JSXTemplateElementInterface,\n        HTMLTemplateElement,\n        true\n    >;\n    textarea: WithCalculationsAndRef<\n        JSXTextAreaElementInterface,\n        HTMLTextAreaElement,\n        true\n    >;\n    tfoot: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    th: WithCalculationsAndRef<\n        JSXTableHeaderElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    thead: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    time: WithCalculationsAndRef<\n        JSXTimeElementInterface,\n        HTMLTimeElement,\n        true\n    >;\n    title: WithCalculationsAndRef<\n        JSXTitleElementInterface,\n        HTMLTitleElement,\n        true\n    >;\n    tr: WithCalculationsAndRef<\n        JSXTableRowElementInterface,\n        HTMLTableRowElement,\n        true\n    >;\n    track: WithCalculationsAndRef<\n        JSXTrackElementInterface,\n        HTMLTrackElement,\n        false\n    >;\n    u: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ul: WithCalculationsAndRef<\n        JSXUListElementInterface,\n        HTMLUListElement,\n        true\n    >;\n    var: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    video: WithCalculationsAndRef<\n        JSXVideoElementInterface,\n        HTMLVideoElement,\n        true\n    >;\n    wbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, false>;\n}\n", "import * as log from './log';\n\nexport enum ArrayEventType {\n    SPLICE = 'splice',\n    MOVE = 'move',\n    SORT = 'sort',\n}\n\nexport interface ArrayEventSplice<T> {\n    type: ArrayEventType.SPLICE;\n    index: number;\n    count: number;\n    items?: T[] | undefined;\n}\nexport interface ArrayEventMove {\n    type: ArrayEventType.MOVE;\n    from: number;\n    count: number;\n    to: number;\n}\nexport interface ArrayEventSort {\n    type: ArrayEventType.SORT;\n    from: number;\n    indexes: number[];\n}\n\nexport type ArrayEvent<T> =\n    | ArrayEventSplice<T>\n    | ArrayEventMove\n    | ArrayEventSort;\n\nexport function shiftEventBy<T>(shiftAmount: number, event: ArrayEvent<T>) {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            event.index += shiftAmount;\n            break;\n        }\n        case ArrayEventType.SORT: {\n            event.from += shiftAmount;\n            for (let i = 0; i < event.indexes.length; ++i) {\n                event.indexes[i] += shiftAmount;\n            }\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            event.from += shiftAmount;\n            event.to += shiftAmount;\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n}\nexport function shiftEvent<T>(\n    slotSizes: number[],\n    slotIndex: number,\n    event: ArrayEvent<T>\n) {\n    let shiftAmount = 0;\n    for (let i = 0; i < slotIndex; ++i) {\n        shiftAmount += slotSizes[i];\n    }\n    shiftEventBy(shiftAmount, event);\n    if (event.type === ArrayEventType.SPLICE) {\n        slotSizes[slotIndex] += (event.items?.length ?? 0) - event.count;\n    }\n}\n\nconst EMPTY_ARRAY: readonly [] = [];\n\nexport function applyArrayEvent<T>(\n    target: T[],\n    event: ArrayEvent<T>\n): readonly T[] {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            if (event.items) {\n                return target.splice(event.index, event.count, ...event.items);\n            } else {\n                return target.splice(event.index, event.count);\n            }\n        }\n        case ArrayEventType.SORT: {\n            const duped = target.slice(event.from);\n            for (let i = 0; i < event.indexes.length; ++i) {\n                target[i] = duped[event.indexes[i] - event.from];\n            }\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            const slice = target.splice(event.from, event.count);\n            target.splice(event.to, 0, ...slice);\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n    return EMPTY_ARRAY;\n}\n\nexport function* arrayEventFlatMap<T, V>(\n    slotSizes: number[],\n    flatMap: (item: T) => readonly V[],\n    target: V[],\n    event: ArrayEvent<T>\n): IterableIterator<ArrayEvent<V>> {\n    switch (event.type) {\n        case ArrayEventType.SPLICE: {\n            let fromIndex = 0;\n            let count = 0;\n            for (let i = 0; i < event.index; ++i) {\n                fromIndex += i < slotSizes.length ? slotSizes[i] : 0;\n            }\n            for (let i = 0; i < event.count; ++i) {\n                const slotIndex = event.index + i;\n                count +=\n                    slotIndex < slotSizes.length ? slotSizes[slotIndex] : 0;\n            }\n            const slotItems: number[] = [];\n            const items: V[] = [];\n            if (event.items) {\n                for (const item of event.items) {\n                    const slot = flatMap(item);\n                    slotItems.push(slot.length);\n                    items.push(...slot);\n                }\n            }\n            target.splice(fromIndex, count, ...items);\n            slotSizes.splice(event.index, event.count, ...slotItems);\n            yield {\n                type: ArrayEventType.SPLICE,\n                index: fromIndex,\n                count,\n                items,\n            };\n            break;\n        }\n        case ArrayEventType.SORT: {\n            const slotStartIndex: number[] = [];\n            let realIndex = 0;\n            for (const slotSize of slotSizes) {\n                slotStartIndex.push(realIndex);\n                realIndex += slotSize;\n            }\n            const copiedSlotSizes = slotSizes.slice();\n            const copiedSource = target.slice();\n\n            const newIndexes: number[] = [];\n            let destSlotIndex = 0;\n            let destIndex = 0;\n            for (const sourceIndex of event.indexes) {\n                const realCount = copiedSlotSizes[sourceIndex];\n                const realIndex = slotStartIndex[sourceIndex];\n                for (let i = 0; i < realCount; ++i) {\n                    newIndexes.push(realIndex + i);\n                    target[destIndex] = copiedSource[realIndex + i];\n                    destIndex += 1;\n                }\n                slotSizes[destSlotIndex] = copiedSlotSizes[sourceIndex];\n                destSlotIndex += 1;\n            }\n            yield {\n                type: ArrayEventType.SORT,\n                from: slotStartIndex[event.from],\n                indexes: newIndexes,\n            };\n            break;\n        }\n        case ArrayEventType.MOVE: {\n            let fromIndex = 0;\n            let toIndex = 0;\n            let count = 0;\n            for (let i = 0; i < event.from; ++i) {\n                fromIndex += slotSizes[i];\n            }\n            for (let i = 0; i < event.count; ++i) {\n                count += slotSizes[event.from + i];\n            }\n            const movedSlots = slotSizes.splice(event.from, event.count);\n            const movedItems = target.splice(fromIndex, count);\n            for (let i = 0; i < event.to; ++i) {\n                toIndex += slotSizes[i];\n            }\n            slotSizes.splice(event.to, 0, ...movedSlots);\n            target.splice(toIndex, 0, ...movedItems);\n            yield {\n                type: ArrayEventType.MOVE,\n                from: fromIndex,\n                count,\n                to: toIndex,\n            };\n            break;\n        }\n        default:\n            log.assertExhausted(event);\n    }\n}\n\nexport function addArrayEvent<T>(\n    events: ArrayEvent<T>[],\n    event: ArrayEvent<T>\n) {\n    const lastEvent = events.length > 0 ? events[events.length - 1] : null;\n    if (\n        lastEvent &&\n        event.type === ArrayEventType.SPLICE &&\n        lastEvent.type === ArrayEventType.SPLICE\n    ) {\n        // Case 1: The insertion point of the next event is at the splice end of the last event\n        // - In this case, we add to the event's count and append items\n        const lastEventSpliceEnd =\n            lastEvent.index + (lastEvent.items?.length ?? 0);\n        if (lastEventSpliceEnd === event.index) {\n            lastEvent.count += event.count;\n            if (lastEvent.items && event.items) {\n                lastEvent.items.push(...event.items);\n            } else if (event.items) {\n                lastEvent.items = event.items;\n            }\n            return;\n        }\n        // TODO: add additional merge cases\n    }\n    events.push(event);\n}\n", "/**\n * An unchanging, internal sentinel value, used to identify a lack of assignment\n */\nexport const Sentinel = Symbol('sentinel');\nexport type Sentinel = typeof Sentinel;\n", "/*\n * ### Calculations\n *\n * A calculation exists on the directed graph as a single vertex. They only get dirtied via propagation.\n *\n * The calculation abstraction represents a \u201Cpure\u201D function which takes no arguments and should produce the same value\n * if the data it reads is unchanged. Calculations have the following state:\n * - An optional error handler, which provides an alternative value in case of a cycle/error in calculation/processing\n * - An optional equality function, which determines whether or not subsequent results are the same value\n * - The cached value of its result\n * - The items it owns with respect to retaining\n *\n * A calculation may be in an error state, in which any calls to it raise an exception.\n *\n *\n * #### Calculation Caching\n *\n * All calculations have their results cached. A calculation may be invalidated, which discards the cached result if it\n * exists.\n *\n * Additionally, calculations have an equality comparator. By default this comparator is strict reference equality.\n *\n * If a cached calculation is recalculated, if the recalculated result compares equal to the cached result, the newly\n * produced result is discarded and the cached result is kept.\n *\n * When a calculation is called, the calculation is treated as an access with respect to tracking, even if the\n * calculation is in an error state or its result is cached. If the calculation is cached, the cached value is returned.\n * If the calculation is uncached, the underlying function is executed, its result cached, and that value is returned.\n *\n *\n * #### Calculation Error Handling\n *\n * Calculations have an error state, which is initially clear, and an optional error handler which is not set.\n *\n * The optional error handler is a function that takes one parameter, a value which indicates the error was due to a cycle\n * or due to an exception.\n *\n * The error handler is always executed in an \u201Cuntracked\u201D context.\n *\n * When a calculation\u2019s function is executed, all exceptions are caught. If an error handler is present, it is called\n * with a value that indicates the error was due to an exception and the return value of the error handler is used as if\n * it was the return value of the function (including equality comparison of the cached value). On completion of an\n * error handler, the calculation is popped off the global tracking stack, and inbound edge replacement proceeds as\n * normal. This means that only accesses that occur during the execution of the function (not during the execution of\n * the error handler) are tracked in the directed graph.\n *\n * If an exception is caught and there is no error handler present, the error state is set on the calculation so that\n * further calls raise an exception, the calculation is popped off the global tracking stack, inbound edge replacement\n * proceeds as normal, and the caught exception is re-thrown. This means that access that occur during the execution of the\n * function prior to the exception are tracked in the directed graph.\n *\n * The error state is cleared when the calculation is recalculated or when the calculation is invalidated.\n *\n * A calculation in a non-error state may be informed that it participates in a cycle. In this case if there is no error\n * handler the calculation\u2019s cache is cleared and is set to an error state. If there is an error handler, it is called with\n * a value that indicates the error is due to a cycle and the returned value is set to the cache if unequal to the value in\n * cache.\n *\n *\n * #### Calculation Execution\n *\n * When a calculation\u2019s function is being executed, all calls to other calculations (cached or uncached) or fields are\n * tracked. These tracked accesses are added to the directed graph as inbound, \u201Chard\u201D edges: from the item being\n * accessed (either a calculation or a field) and to the calculation performing the access. Each execution replaces all\n * inbound \u201Chard\u201D edges.\n *\n * This tracking of access is shallow. That is to say:\n * * There is a stack of active calculations\n * * When a calculation starts execution it is added pushed on the top of the stack\n * * When a calculation finishes execution (either naturally or via exception) it is popped off the top of the stack\n * * Tracking only impacts the calculation on the top of the stack\n *\n * For example, if a calculation\u2019s function (A) is called, which calls another calculation\u2019s function (B), which accesses a\n * field (C), the resulting hard edges added are:\n * * C -> B\n * * B -> A\n *\n * Sometimes it is desirable to avoid this tracking. In this case a sentinel untracked value can be pushed to the stack of\n * calculations, call a function, and then pop the sentinel off the stack. When accesses occur while this sentinel value is\n * on top of the stack, no tracking is necessary. This is called executing a function in an \u201Cuntracked\u201D context.\n *\n *\n * #### Calculation Behavior\n *\n * This strict set of behaviors around caching, data tracking, and error handling are specifically chosen so that the\n * maintained topological ordering of the directed graph holds the quality that data accesses are placed before all things\n * doing the access. This allows us to intelligently recalculate functions only when their data dependencies have changed.\n * In other words, caching should be \u201Cperfect\u201D with no need to choose specific cache keys that need to be invalidated for\n * classes of calculations, or no need to manually invalidate cached calculations.\n *\n * For example, let\u2019s look at the following function that we\u2019ll call X:\n *\n * ```\n * calc(() => {\n *   if (A()) return B();\n *   if (C()) return D();\n *   return E();\n * })\n * ```\n *\n * There are three possible variations of the directed graph when calling X:\n * 1. If `A()` returns true, then `X` depends on `A` and `B`.\n * 2. If `A()` returns false and `C()` returns true, then `X` depends on `A` and `C` and `D`.\n * 3. If `A()` returns false and `C()` returns false, then `X` depends on `A` and `C` and `E`.\n *\n * This is to say that in case 2, we know for a fact that the return value does not and cannot depend on `B`, so we do not\n * need to recalculate/invalidate `X` if `B` were to change.\n *\n * Similarly in case 2, if `C` were to throw an exception, the effect of this exception depends on the fact that `A` was\n * called and returned a value that was true. If `A` were to change, even though the calculation is in an error state, it\n * could be that `A` now returns a value such that `C` is never called\u2014so we should recalculate `X` if `A` were to change\n * even if `X` is in the error state.\n *\n * In other words, we always know what values depend on the result of calculating `X`, so we know exactly when to\n * recalculate/invalidate `X`.\n *\n * If you are familiar with React hooks, you may recognize that the list of dependencies that React hooks forces you to\n * list explicitly when using `useMemo()` is the set of all possible data accesses, not the set of data accesses that\n * matter for each invocation. This is strikingly different than gooey, which performs the work of automatically tracking\n * only the values that the function uses.\n *\n *\n * #### Calculation Processing\n *\n * While the directed graph is processing, it emits one of three actions: invalidation, recalculation, and cycle.\n * * On an invalidation event, the calculation\u2019s cache is discarded and the error state is cleared. Propagation occurs if\n *   the calculation was cached.\n * * On a recalculation event, the calculation\u2019s underlying function is executed. Propagation occurs if the calculation is\n *   uncached.\n * * On a cycle event\n *     * If there is no error handler for the calculation, the calculation is invalidated and placed in an error state.\n *       Propagation occurs if the calculation was not in an error state.\n *     * If there is an error handler, it is called and the result is handled in the same manner as if it was the result of\n *       a recalculation event. Propagation occurs if the calculation was not cached or the error handler\u2019s return value\n *       does not equal the prior cached value.\n */\n\nimport * as log from './log';\nimport { Sentinel } from './sentinel';\nimport {\n    Processable,\n    Retainable,\n    notifyCreate,\n    notifyRead,\n    addHardEdge,\n    addVertex,\n    retain,\n    release,\n    removeHardEdge,\n    removeVertex,\n    markCycleInformed,\n    unmarkDirty,\n    trackReads,\n    untrackReads,\n    isProcessable,\n} from './engine';\nimport { wrapError } from './util';\n\nenum CalculationState {\n    READY,\n    CALLING,\n    CACHED,\n    ERROR,\n    DEAD,\n}\n\nexport enum CalculationErrorType {\n    CYCLE,\n    EXCEPTION,\n}\n\nconst CalculationSymbol = Symbol('calculation');\nconst CalculationUnsubscribeSymbol = Symbol('calculationUnsubscribe');\n\ninterface CalcSubscriptionHandlerHack<T> {\n    bivarianceHack(\n        errorType: undefined,\n        val: T,\n        addPostAction: (postAction: () => void) => void\n    ): void;\n    bivarianceHack(\n        errorType: CalculationErrorType,\n        val: Error,\n        addPostAction: (postAction: () => void) => void\n    ): void;\n}\ntype CalcSubscriptionHandler<T> =\n    CalcSubscriptionHandlerHack<T>['bivarianceHack'];\n\ninterface CalcErrorHandlerHack<T> {\n    bivarianceHack(errorType: CalculationErrorType, val: Error): T;\n}\ntype CalcErrorHandler<T> = CalcErrorHandlerHack<T>['bivarianceHack'];\n\ninterface CalcUnsubscribe<T> {\n    (): void;\n    _type: typeof CalculationUnsubscribeSymbol;\n    calculation: Calculation<T>;\n}\n\nexport interface Calculation<T> extends Retainable, Processable {\n    (): T;\n    onError: (handler: CalcErrorHandler<T>) => this;\n    setCmp: (eq: (a: T, b: T) => boolean) => this;\n    subscribe: (handler: CalcSubscriptionHandler<T>) => CalcUnsubscribe<T>;\n    retain: () => void;\n    release: () => void;\n    _subscriptions?: Set<CalcSubscriptionHandler<T>>;\n    _type: typeof CalculationSymbol;\n    _fn: () => T;\n    _eq: (a: T, b: T) => boolean;\n    _errorHandler?: CalcErrorHandler<T>;\n    _state: CalculationState;\n    _retained?: Set<Retainable | (Processable & Retainable)>;\n    _val?: T;\n    _error?: any;\n}\n\nexport function isCalculation(val: any): val is Calculation<unknown> {\n    return val && val._type === CalculationSymbol;\n}\n\nexport function isCalcUnsubscribe(val: any): val is CalcUnsubscribe<unknown> {\n    return val && val._type === CalculationUnsubscribeSymbol;\n}\n\nfunction strictEqual<T>(a: T, b: T) {\n    return a === b;\n}\n\nfunction calcSetError<T>(this: Calculation<T>, handler: CalcErrorHandler<T>) {\n    this._errorHandler = handler;\n    return this;\n}\n\nfunction calcSetCmp<T>(this: Calculation<T>, eq: (a: T, b: T) => boolean) {\n    this._eq = eq;\n    return this;\n}\n\nfunction calcSubscribe<T>(\n    this: Calculation<T>,\n    handler: CalcSubscriptionHandler<T>\n): CalcUnsubscribe<T> {\n    retain(this);\n    try {\n        this();\n    } catch (e) {\n        // Intentionally ignore exception\n    }\n    if (!this._subscriptions) {\n        this._subscriptions = new Set();\n    }\n    this._subscriptions.add(handler);\n    const unsubscribe = () => {\n        this._subscriptions?.delete(handler);\n        release(this);\n    };\n    const unsubscribeData = {\n        _type: CalculationUnsubscribeSymbol,\n        calculation: this,\n    } as const;\n    return Object.assign(unsubscribe, unsubscribeData);\n}\n\nfunction calcRetain<T>(this: Calculation<T>) {\n    retain(this);\n}\n\nfunction calcRelease<T>(this: Calculation<T>) {\n    retain(this);\n}\n\nclass CycleError extends Error {\n    declare sourceCalculation: Calculation<any>;\n\n    constructor(msg: string, sourceCalculation: Calculation<any>) {\n        super(msg);\n        this.sourceCalculation = sourceCalculation;\n    }\n}\n\nfunction calculationCall<T>(calculation: Calculation<T>): T {\n    notifyRead(calculation);\n\n    const state = calculation._state;\n    switch (state) {\n        case CalculationState.DEAD:\n            // Note: dead calculations are just plain old functions\n            return calculation._fn();\n        case CalculationState.CACHED:\n            return calculation._val as T;\n        case CalculationState.CALLING:\n            calculation._state = CalculationState.ERROR;\n            calculation._error = new CycleError(\n                'Cycle reached: calculation reached itself',\n                calculation\n            );\n            throw calculation._error;\n        case CalculationState.ERROR:\n            if (calculation._error === Sentinel) {\n                throw new Error('Cycle reached: calculation reached itself');\n            } else {\n                throw new Error(\n                    'Calculation in error state: ' + calculation._error.message\n                );\n            }\n            break;\n        case CalculationState.READY: {\n            const calculationReads: Set<Retainable> = new Set();\n            let result: T | Sentinel = Sentinel;\n            let exception: any;\n            calculation._state = CalculationState.CALLING;\n            try {\n                result = trackReads(\n                    calculationReads,\n                    () => calculation._fn(),\n                    calculation.__debugName\n                );\n            } catch (e) {\n                exception = e;\n            }\n\n            if (\n                (calculation._state as CalculationState) ===\n                CalculationState.DEAD\n            ) {\n                // It's possible that a cycle which is recalculated releases itself entirely\n                // In this case we release all of the things retained (automatically, see note XXX:AUTO_RETAIN)\n                for (const retained of calculationReads) {\n                    release(retained);\n                }\n                if (result === Sentinel) throw exception;\n                return result;\n            }\n\n            // If A calls B, which calls A, and B has an error handler:\n            // B will catch and return the self-cycle error.\n            // In this case, A will mark itself in the ERROR state.\n            if (\n                // Cast due to TypeScript limitation\n                (calculation._state as CalculationState) ===\n                CalculationState.ERROR\n            ) {\n                exception = calculation._error;\n            }\n\n            let isActiveCycle = false;\n            let isActiveCycleRoot = false;\n            if (exception) {\n                if (exception instanceof CycleError) {\n                    isActiveCycle = true;\n                    isActiveCycleRoot =\n                        exception.sourceCalculation === calculation;\n                }\n                const errorHandler = calculation._errorHandler;\n                if (errorHandler) {\n                    result = untrackReads(\n                        () =>\n                            isActiveCycle\n                                ? errorHandler(\n                                      CalculationErrorType.CYCLE,\n                                      new Error('Cycle')\n                                  )\n                                : errorHandler(\n                                      CalculationErrorType.EXCEPTION,\n                                      exception\n                                  ),\n                        calculation.__debugName\n                    );\n                }\n\n                if (isActiveCycle) {\n                    markCycleInformed(calculation);\n                }\n            }\n\n            if (result === Sentinel) {\n                if ('_val' in calculation) {\n                    delete calculation._val;\n                }\n                calculation._error = exception;\n                calculation._state = CalculationState.ERROR;\n            } else {\n                calculation._val = result;\n                if ('_error' in calculation) {\n                    delete calculation._error;\n                }\n                calculation._state = CalculationState.CACHED;\n                unmarkDirty(calculation);\n            }\n\n            if (calculation._retained) {\n                for (const priorDependency of calculation._retained) {\n                    if (\n                        isProcessable(priorDependency) &&\n                        !calculationReads.has(priorDependency)\n                    ) {\n                        removeHardEdge(priorDependency, calculation);\n                    }\n                    // XXX:AUTO_RETAIN: THIS IS SURPRISING\n                    // We retain all dependencies read when they are first added to a tracked calculation\n                    // So we need to release prior dependencies to keep the refcount stable\n                    // This is a bit gross...\n                    release(priorDependency);\n                }\n            }\n            for (const dependency of calculationReads) {\n                if (isProcessable(dependency)) {\n                    if (\n                        !calculation._retained ||\n                        !calculation._retained.has(dependency)\n                    ) {\n                        addHardEdge(dependency, calculation);\n                    }\n                }\n            }\n            calculation._retained = calculationReads;\n\n            if (result === Sentinel) {\n                throw exception;\n            } else if (isActiveCycle && !isActiveCycleRoot) {\n                throw exception;\n            } else {\n                return result;\n            }\n        }\n        default:\n            log.assertExhausted(state, 'Calculation in unknown state');\n    }\n}\n\nfunction calculationAlive<T>(this: Calculation<T>) {\n    addVertex(this);\n    this._state = CalculationState.READY;\n}\n\nfunction calculationDead<T>(this: Calculation<T>) {\n    if (this._retained) {\n        for (const retained of this._retained) {\n            if (isProcessable(retained)) {\n                removeHardEdge(retained, this);\n            }\n            release(retained);\n        }\n    }\n    delete this._retained;\n    removeVertex(this);\n    this._state = CalculationState.DEAD;\n    delete this._val;\n}\n\nfunction calculationRecalculate<T>(\n    this: Calculation<T>,\n    addPostAction: (postAction: () => void) => void\n) {\n    switch (this._state) {\n        case CalculationState.DEAD:\n            log.fail('cannot recalculate dead calculation');\n            break;\n        case CalculationState.CALLING:\n            log.fail('cannot recalculate calculation being tracked');\n            break;\n        case CalculationState.READY:\n        case CalculationState.ERROR:\n        case CalculationState.CACHED: {\n            const priorResult = '_val' in this ? (this._val as T) : Sentinel;\n            this._state = CalculationState.READY;\n            let newResult: T;\n            try {\n                newResult = calculationCall(this);\n            } catch (e) {\n                this._state = CalculationState.ERROR;\n                this._error = e;\n                if (this._subscriptions) {\n                    const error = wrapError(e, 'Unknown error in calculation');\n                    for (const subscription of this._subscriptions) {\n                        subscription(\n                            CalculationErrorType.EXCEPTION,\n                            error,\n                            addPostAction\n                        );\n                    }\n                }\n                return true; // Errors always propagate\n            }\n            if (priorResult !== Sentinel && this._eq(priorResult, newResult)) {\n                this._val = priorResult;\n                return false;\n            }\n            if (this._subscriptions) {\n                for (const subscription of this._subscriptions) {\n                    subscription(undefined, newResult, addPostAction);\n                }\n            }\n            return true;\n        }\n        default:\n            log.assertExhausted(this._state, 'Calculation in unknown state');\n    }\n}\n\nfunction calculationInvalidate<T>(this: Calculation<T>) {\n    switch (this._state) {\n        case CalculationState.DEAD:\n            log.fail('cannot invalidate dead calculation');\n            break;\n        case CalculationState.CALLING:\n            log.fail('cannot invalidate calculation being tracked');\n            break;\n        case CalculationState.READY:\n            return false;\n        case CalculationState.ERROR:\n            this._state = CalculationState.READY;\n            return false;\n        case CalculationState.CACHED:\n            this._state = CalculationState.READY;\n            return true;\n        default:\n            log.assertExhausted(this._state, 'Calculation in unknown state');\n    }\n}\n\nfunction calculationCycle<T>(\n    this: Calculation<T>,\n    addPostAction: (postAction: () => void) => void\n) {\n    switch (this._state) {\n        case CalculationState.DEAD:\n            log.fail('cannot trigger cycle on dead calculation');\n            break;\n        case CalculationState.CALLING:\n            log.fail('cannot trigger cycle on calculation being tracked');\n            break;\n        case CalculationState.ERROR:\n        case CalculationState.CACHED:\n        case CalculationState.READY: {\n            const priorResult = '_val' in this ? (this._val as T) : Sentinel;\n            this._state = CalculationState.READY;\n            const errorHandler = this._errorHandler;\n            if (errorHandler) {\n                this._val = untrackReads(\n                    () =>\n                        errorHandler(\n                            CalculationErrorType.CYCLE,\n                            new Error('Cycle')\n                        ),\n                    this.__debugName\n                );\n                this._state = CalculationState.CACHED;\n                unmarkDirty(this);\n            } else {\n                this._state = CalculationState.ERROR;\n                this._error = Sentinel;\n                if (this._subscriptions) {\n                    for (const subscription of this._subscriptions) {\n                        subscription(\n                            CalculationErrorType.CYCLE,\n                            new Error('Cycle'),\n                            addPostAction\n                        );\n                    }\n                }\n                return true; // Errors always propagate\n            }\n            if (priorResult !== Sentinel && this._eq(priorResult, this._val)) {\n                this._val = priorResult;\n                return false;\n            }\n            if (this._subscriptions) {\n                for (const subscription of this._subscriptions) {\n                    subscription(undefined, this._val, addPostAction);\n                }\n            }\n            return true;\n        }\n        default:\n            log.assertExhausted(this._state, 'Calculation in unknown state');\n    }\n}\n\nexport function calc<T>(fn: () => T, debugName?: string) {\n    const calculationData = {\n        // Dynamic members\n        _fn: fn,\n        _state: CalculationState.DEAD,\n        _call: calculationCall,\n        _eq: strictEqual,\n\n        // Statically defined\n        _type: CalculationSymbol,\n        onError: calcSetError,\n        setCmp: calcSetCmp,\n        subscribe: calcSubscribe,\n        retain: calcRetain,\n        release: calcRelease,\n\n        // Retainable\n        __alive: calculationAlive,\n        __dead: calculationDead,\n        __refcount: 0,\n\n        // Processable\n        __processable: true,\n        __debugName: debugName ?? fn.name,\n        __recalculate: calculationRecalculate,\n        __cycle: calculationCycle,\n        __invalidate: calculationInvalidate,\n    } as const;\n    const calculation: Calculation<T> = Object.assign(\n        () => calculationCall(calculation),\n        calculationData\n    );\n    notifyCreate(calculation);\n    return calculation;\n}\n", "import * as log from './log';\nimport {\n    Processable,\n    Retainable,\n    addVertex,\n    markDirty,\n    removeVertex,\n    notifyRead,\n} from './engine';\n\ntype FieldSubscriber<T> = (val: T) => void;\n\nexport class Field<T> implements Processable, Retainable {\n    private declare _isAlive?: boolean | undefined;\n    private declare _val: T;\n    // Map of subscriber to the clock time\n    private declare _subscribers?: Map<FieldSubscriber<T>, number>;\n    private declare _changeClock: number;\n\n    declare __processable: true;\n    declare __refcount: number;\n    declare __debugName: string;\n\n    constructor(val: T, debugName?: string) {\n        this._val = val;\n        this._isAlive = false;\n        this._changeClock = 0;\n\n        this.__processable = true;\n        this.__refcount = 0;\n\n        this.__debugName = debugName ?? 'field';\n    }\n\n    get(): T {\n        notifyRead(this);\n        return this._val;\n    }\n\n    set(newVal: T) {\n        if (newVal !== this._val) {\n            if (this._subscribers) {\n                this._changeClock += 1;\n            }\n            this._val = newVal;\n            if (this._isAlive) {\n                markDirty(this);\n            }\n        }\n    }\n\n    subscribe(subscriber: FieldSubscriber<T>): () => void {\n        if (!this._subscribers) this._subscribers = new Map();\n        this._subscribers.set(subscriber, this._changeClock);\n        return () => this._subscribers?.delete(subscriber);\n    }\n\n    __alive() {\n        this._isAlive = true;\n        addVertex(this);\n    }\n\n    __dead() {\n        removeVertex(this);\n        this._isAlive = false;\n    }\n\n    __recalculate() {\n        log.assert(this._isAlive, 'cannot flush dead field');\n        if (this._subscribers) {\n            for (const [subscriber, observeClock] of this._subscribers) {\n                if (observeClock < this._changeClock) {\n                    subscriber(this._val);\n                }\n                this._subscribers.set(subscriber, 0);\n            }\n            this._changeClock = 0;\n        }\n        return true;\n    }\n}\n\nexport function field<T>(val: T, debugName?: string): Field<T> {\n    return new Field(val, debugName);\n}\n", "import {\n    Processable,\n    Retainable,\n    addSoftEdge,\n    removeSoftEdge,\n    retain,\n    release,\n} from './engine';\nimport { Field } from './field';\n\nexport class FieldMap implements Retainable {\n    private declare keysField: Field<number>;\n    private declare fieldMap: Map<string, Field<any>>;\n    private declare consumer: (Retainable & Processable) | null;\n    private declare emitter: (Retainable & Processable) | null;\n\n    declare __debugName: string;\n    declare __refcount: number;\n\n    constructor(\n        keysField: Field<number>,\n        consumer: (Retainable & Processable) | null,\n        emitter: (Retainable & Processable) | null,\n        debugName?: string\n    ) {\n        this.__refcount = 0;\n        this.__debugName = debugName ?? 'fieldmap';\n        this.keysField = keysField;\n        this.fieldMap = new Map();\n        this.consumer = consumer;\n        this.emitter = emitter;\n    }\n\n    getOrMake(prop: string, val: any) {\n        let field = this.fieldMap.get(prop);\n        if (!field) {\n            field = new Field(val, `${this.__debugName}:${prop}`);\n            this.fieldMap.set(prop, field);\n\n            if (this.__refcount > 0) {\n                retain(field);\n                if (this.consumer) addSoftEdge(this.consumer, field);\n                if (this.emitter) addSoftEdge(field, this.emitter);\n            }\n        }\n        return field;\n    }\n\n    set(prop: string, val: any) {\n        const field = this.getOrMake(prop, val);\n        return field.set(val);\n    }\n\n    delete(prop: string) {\n        const field = this.fieldMap.get(prop);\n        if (field) {\n            field.set(undefined);\n            this.fieldMap.delete(prop);\n\n            if (this.__refcount > 0) {\n                if (this.emitter) removeSoftEdge(field, this.emitter);\n                if (this.consumer) removeSoftEdge(this.consumer, field);\n                release(field);\n            }\n        }\n    }\n\n    __dead() {\n        for (const field of this.fieldMap.values()) {\n            if (this.emitter) removeSoftEdge(field, this.emitter);\n            if (this.consumer) removeSoftEdge(this.consumer, field);\n            release(field);\n        }\n\n        if (this.emitter) removeSoftEdge(this.keysField, this.emitter);\n        if (this.consumer) removeSoftEdge(this.consumer, this.keysField);\n        release(this.keysField);\n\n        if (this.emitter) release(this.emitter);\n        if (this.consumer) release(this.consumer);\n    }\n\n    __alive() {\n        if (this.emitter) retain(this.emitter);\n        if (this.consumer) retain(this.consumer);\n\n        retain(this.keysField);\n        if (this.emitter) addSoftEdge(this.keysField, this.emitter);\n        if (this.consumer) addSoftEdge(this.consumer, this.keysField);\n\n        for (const field of this.fieldMap.values()) {\n            retain(field);\n            if (this.emitter) addSoftEdge(field, this.emitter);\n            if (this.consumer) addSoftEdge(this.consumer, field);\n        }\n    }\n}\n", "import {\n    Processable,\n    Retainable,\n    markDirty,\n    addVertex,\n    removeVertex,\n} from './engine';\nimport * as log from './log';\n\ntype SubscriptionEmitterHandler<TEmitEvent> = {\n    bivarianceHack(events: TEmitEvent[]): void;\n}['bivarianceHack'];\n\nexport class SubscriptionEmitter<TEmitEvent>\n    implements Processable, Retainable\n{\n    /** Per-emitter function to add an event to the sequence of events for a subscriber */\n    // Note: for reasons I don't understand; this cannot be typed as:\n    //     private declare appendEvent: (events: TEmitEvent[], event: TEmitEvent) => void;\n    // without causing bizarre type errors across the application\n    private declare appendEvent: (events: any[], event: any) => void;\n    private declare subscribers: {\n        handler: SubscriptionEmitterHandler<TEmitEvent>;\n        events: TEmitEvent[];\n    }[];\n    private declare isActive: boolean;\n\n    // Processable\n    declare __processable: true;\n    declare __debugName: string;\n\n    __recalculate() {\n        for (const subscriber of this.subscribers) {\n            subscriber.handler(subscriber.events);\n            subscriber.events = [];\n        }\n        return true;\n    }\n\n    // Retainable\n    declare __refcount: number;\n\n    __alive() {\n        this.isActive = true;\n        addVertex(this);\n    }\n\n    __dead() {\n        log.assert(\n            this.subscribers.length === 0,\n            'released subscription emitter that had subscribers'\n        );\n        removeVertex(this);\n        this.isActive = false;\n    }\n\n    constructor(\n        appendEvent: (events: TEmitEvent[], event: TEmitEvent) => void,\n        debugName: string\n    ) {\n        this.appendEvent = appendEvent;\n        this.subscribers = [];\n        this.isActive = false;\n        this.__refcount = 0;\n        this.__processable = true;\n        this.__debugName = `emitter:${debugName}`;\n    }\n\n    addEvent(event: TEmitEvent) {\n        if (!this.isActive) return;\n        let firstAdded = false;\n        for (const subscriber of this.subscribers) {\n            if (subscriber.events.length === 0) firstAdded = true;\n            this.appendEvent(subscriber.events, event);\n        }\n        if (firstAdded) {\n            markDirty(this);\n        }\n    }\n\n    subscribe(handler: SubscriptionEmitterHandler<TEmitEvent>) {\n        this.subscribers.push({ handler, events: [] });\n        return () => {\n            const index = this.subscribers.findIndex(\n                (subscriber) => subscriber.handler === handler\n            );\n            if (index === -1) return;\n            this.subscribers.splice(index, 1);\n        };\n    }\n}\n", "import {\n    Processable,\n    Retainable,\n    addHardEdge,\n    removeHardEdge,\n    addSoftEdge,\n    removeSoftEdge,\n    markDirty,\n    addVertex,\n    retain,\n    release,\n    removeVertex,\n} from './engine';\nimport { Field } from './field';\nimport { SubscriptionEmitter } from './subscriptionemitter';\n\ntype SubscriptionConsumerHandler<TData, TConsumeEvent, TEmitEvent> = {\n    bivarianceHack(\n        target: TData,\n        events: TConsumeEvent[]\n    ): IterableIterator<TEmitEvent>;\n}['bivarianceHack'];\n\nexport class SubscriptionConsumer<TData, TConsumeEvent, TEmitEvent>\n    implements Processable, Retainable\n{\n    private declare target: TData;\n    private declare handler: SubscriptionConsumerHandler<\n        TData,\n        TConsumeEvent,\n        TEmitEvent\n    >;\n    private declare events: TConsumeEvent[];\n    private declare isActive: boolean;\n    private declare sourceEmitter: SubscriptionEmitter<TConsumeEvent>;\n    private declare transformEmitter: SubscriptionEmitter<TEmitEvent>;\n    private declare unsubscribe?: () => void;\n\n    // Note: for reasons I don't understand; this cannot be typed as:\n    //     private declare appendEvent: (events: TConsumeEvent[], event: TConsumeEvent) => void;\n    // without causing bizarre type errors across the application\n    private declare appendEvent: (events: any[], event: any) => void;\n\n    // Processable\n    declare __processable: true;\n    declare __debugName: string;\n\n    __recalculate() {\n        for (const emitEvent of this.handler(this.target, this.events)) {\n            this.transformEmitter.addEvent(emitEvent);\n        }\n        this.events.splice(0, this.events.length);\n        return false;\n    }\n\n    // Retainable\n    declare __refcount: number;\n\n    __alive() {\n        this.isActive = true;\n        addVertex(this);\n        retain(this.sourceEmitter);\n        addHardEdge(this.sourceEmitter, this);\n        this.unsubscribe = this.sourceEmitter.subscribe((events) => {\n            for (const event of events) {\n                this.addEvent(event);\n            }\n        });\n    }\n\n    __dead() {\n        if (this.unsubscribe) {\n            this.unsubscribe();\n            removeHardEdge(this.sourceEmitter, this);\n            release(this.sourceEmitter);\n        }\n        this.events.splice(0, this.events.length);\n        removeVertex(this);\n        this.isActive = false;\n    }\n\n    constructor(\n        target: TData,\n        sourceEmitter: SubscriptionEmitter<TConsumeEvent>,\n        transformEmitter: SubscriptionEmitter<TEmitEvent>,\n        handler: SubscriptionConsumerHandler<TData, TConsumeEvent, TEmitEvent>,\n        appendEvent: (events: TConsumeEvent[], event: TConsumeEvent) => void,\n        debugName: string\n    ) {\n        this.target = target;\n        this.handler = handler;\n        this.events = [];\n        this.isActive = false;\n        this.sourceEmitter = sourceEmitter;\n        this.transformEmitter = transformEmitter;\n        this.appendEvent = appendEvent;\n        this.__refcount = 0;\n        this.__processable = true;\n        this.__debugName = `consumer:${debugName}`;\n    }\n\n    addEvent(event: TConsumeEvent) {\n        if (!this.isActive) return;\n        const firstEvent = this.events.length === 0;\n        this.appendEvent(this.events, event);\n        if (firstEvent) {\n            markDirty(this);\n        }\n    }\n\n    addField(field: Field<any>) {\n        if (this.isActive) {\n            retain(field);\n            addSoftEdge(this, field);\n        }\n    }\n\n    removeField(field: Field<any>) {\n        if (this.isActive) {\n            removeSoftEdge(this, field);\n            release(field);\n        }\n    }\n}\n", "import { Retainable, notifyCreate, notifyRead } from './engine';\nimport { FieldMap } from './fieldmap';\nimport { Field } from './field';\nimport { SubscriptionEmitter } from './subscriptionemitter';\nimport { SubscriptionConsumer } from './subscriptionconsumer';\n\nexport class TrackedDataHandle<\n    TData extends object,\n    TMethods extends Retainable,\n    TEmitEvent,\n    TConsumeEvent\n> {\n    declare target: TData;\n    declare methods: TMethods;\n\n    declare fieldMap: FieldMap;\n    declare keys: Set<string>;\n    declare keysField: Field<number>;\n    declare dataAccessor: DataAccessor;\n    declare emitter: SubscriptionEmitter<TEmitEvent>;\n    declare consumer: null | SubscriptionConsumer<\n        TData,\n        TConsumeEvent,\n        TEmitEvent\n    >;\n    declare revocable: {\n        proxy: TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>;\n        revoke: () => void;\n    };\n\n    constructor(\n        target: TData,\n        proxyHandler: ProxyHandler<TEmitEvent>,\n        methods: TMethods,\n        derivedEmitter: null | SubscriptionEmitter<TConsumeEvent>,\n        handleEvents:\n            | null\n            | ((\n                  target: TData,\n                  events: TConsumeEvent[]\n              ) => IterableIterator<TEmitEvent>),\n        appendEmitEvent: (events: TEmitEvent[], event: TEmitEvent) => void,\n        appendConsumeEvent: (\n            events: TConsumeEvent[],\n            event: TConsumeEvent\n        ) => void,\n        debugName = 'trackeddata'\n    ) {\n        this.target = target;\n        this.methods = methods;\n\n        this.emitter = new SubscriptionEmitter<TEmitEvent>(\n            appendEmitEvent,\n            debugName\n        );\n\n        if (derivedEmitter && handleEvents) {\n            this.consumer = new SubscriptionConsumer(\n                target,\n                derivedEmitter,\n                this.emitter,\n                handleEvents,\n                appendConsumeEvent,\n                debugName\n            );\n        } else {\n            this.consumer = null;\n        }\n\n        this.keys = new Set<string>(Object.keys(target));\n        this.keysField = new Field(this.keys.size, `${debugName}:@keys`);\n        this.fieldMap = new FieldMap(\n            this.keysField,\n            this.consumer,\n            this.emitter,\n            debugName\n        );\n\n        const emitEvent = (event: TEmitEvent) => {\n            this.emitter.addEvent(event);\n        };\n\n        this.dataAccessor = {\n            get: (prop, receiver) => {\n                if (prop === '__tdHandle') {\n                    return this;\n                }\n                if (prop === '__debugName') {\n                    return debugName;\n                }\n                if (prop === '__processable') {\n                    return false;\n                }\n                if (\n                    prop === '__refcount' ||\n                    prop === '__alive' ||\n                    prop === '__dead'\n                ) {\n                    return methods[prop];\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.get(this.target, prop, receiver);\n                }\n                if (prop in methods) {\n                    return (methods as any)[prop];\n                }\n                const value = Reflect.get(this.target, prop, receiver);\n                const field = this.fieldMap.getOrMake(prop, value);\n                notifyRead(this.revocable.proxy);\n                notifyRead(field);\n                return value;\n            },\n            peekHas: (prop) => {\n                return Reflect.has(target, prop);\n            },\n            has: (prop) => {\n                if (\n                    prop === '__refcount' ||\n                    prop === '__alive' ||\n                    prop === '__dead'\n                ) {\n                    return prop in methods;\n                }\n                if (prop === '__processable') {\n                    return true;\n                }\n                if (prop in methods) {\n                    return true;\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.has(this.target, prop);\n                }\n                const value = Reflect.has(target, prop);\n                const field = this.fieldMap.getOrMake(prop, value);\n                notifyRead(this.revocable.proxy);\n                notifyRead(field);\n                return value;\n            },\n            set: (prop, value, receiver) => {\n                if (prop === '__refcount') {\n                    methods[prop] = value;\n                    return true;\n                }\n                if (prop in methods) {\n                    return false; // Prevent writes to owned methods\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.set(this.target, prop, value, receiver);\n                }\n                const hadProp = Reflect.has(target, prop);\n                const field = this.fieldMap.getOrMake(prop, value);\n                field.set(value);\n                if (!hadProp) {\n                    this.keys.add(prop);\n                    this.keysField.set(this.keys.size);\n                }\n                return Reflect.set(target, prop, value, this.revocable.proxy);\n            },\n            delete: (prop) => {\n                if (\n                    prop === '__refcount' ||\n                    prop === '__alive' ||\n                    prop === '__dead' ||\n                    prop === '__processable'\n                ) {\n                    return false; // Prevent deletes of internal symbols\n                }\n                if (prop in methods) {\n                    return false; // Prevent deletes of owned methods\n                }\n                if (typeof prop === 'symbol') {\n                    return Reflect.deleteProperty(this.target, prop);\n                }\n                const hadProp = Reflect.has(target, prop);\n                const result = Reflect.deleteProperty(target, prop);\n                if (hadProp) {\n                    this.keys.delete(prop);\n                    this.keysField.set(this.keys.size);\n                    this.fieldMap.delete(prop);\n                }\n                return result;\n            },\n        };\n\n        this.revocable = Proxy.revocable<\n            TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>\n        >(target as TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>, {\n            get: (target, prop, receiver) =>\n                proxyHandler.get(this.dataAccessor, emitEvent, prop, receiver),\n            has: (target, prop) =>\n                proxyHandler.has(this.dataAccessor, emitEvent, prop),\n            set: (target, prop, value, receiver) =>\n                proxyHandler.set(\n                    this.dataAccessor,\n                    emitEvent,\n                    prop,\n                    value,\n                    receiver\n                ),\n            deleteProperty: (target, prop) =>\n                proxyHandler.delete(this.dataAccessor, emitEvent, prop),\n            ownKeys: () => {\n                const keys = this.keys;\n                this.keysField.get(); // force a read to add a dependency on keys\n                return [...keys];\n            },\n        });\n\n        notifyCreate(this.revocable.proxy);\n    }\n}\n\nexport type TrackedData<\n    TData extends object,\n    TMethods extends Retainable,\n    TEmitEvent,\n    TConsumeEvent\n> = TData &\n    TMethods & {\n        __tdHandle: TrackedDataHandle<\n            TData,\n            TMethods,\n            TEmitEvent,\n            TConsumeEvent\n        >;\n    };\n\nexport function getTrackedDataHandle<\n    TData extends object,\n    TMethods extends Retainable,\n    TEmitEvent,\n    TConsumeEvent\n>(\n    trackedData: TrackedData<TData, TMethods, TEmitEvent, TConsumeEvent>\n): undefined | TrackedDataHandle<TData, TMethods, TEmitEvent, TConsumeEvent> {\n    return trackedData.__tdHandle;\n}\n\nexport interface DataAccessor {\n    get: (prop: string | symbol, receiver: any) => any;\n    has: (prop: string | symbol) => any;\n    peekHas: (prop: string | symbol) => any;\n    set: (prop: string | symbol, value: any, receiver: any) => any;\n    delete: (prop: string | symbol) => boolean;\n}\n\nexport interface ProxyHandler<TEmitEvent> {\n    get: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol,\n        receiver: any\n    ) => any;\n    has: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol\n    ) => any;\n    set: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol,\n        value: any,\n        receiver: any\n    ) => any;\n    delete: (\n        dataAccessor: DataAccessor,\n        emitter: (event: TEmitEvent) => void,\n        prop: string | symbol\n    ) => boolean;\n}\n", "import {\n    TrackedData,\n    TrackedDataHandle,\n    getTrackedDataHandle,\n    ProxyHandler,\n} from './trackeddata';\nimport { untrackReads, retain, release, Retainable } from './engine';\nimport {\n    ArrayEvent,\n    ArrayEventType,\n    arrayEventFlatMap,\n    addArrayEvent,\n} from './arrayevent';\nimport * as log from './log';\n\nexport interface CollectionImpl<T> extends Retainable {\n    _type: 'collection';\n    splice(start: number, deleteCount?: number | undefined): T[];\n    splice(start: number, deleteCount: number, ...items: T[]): T[];\n    push(...items: T[]): number;\n    pop(): T | undefined;\n    shift(): T | undefined;\n    unshift(...items: T[]): number;\n    sort(cmp?: ((a: T, b: T) => number) | undefined): this;\n    reverse(): this;\n\n    reject: (pred: (val: T) => boolean) => T[];\n    moveSlice: (fromIndex: number, count: number, toIndex: number) => void;\n\n    mapView: <V>(\n        fn: (val: T) => V,\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n    filterView: (\n        fn: (val: T) => boolean,\n        debugName?: string | undefined\n    ) => View<T, ArrayEvent<T>>;\n    flatMapView: <V>(\n        fn: (val: T) => V[],\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n\n    subscribe: (handler: (event: ArrayEvent<T>[]) => void) => () => void;\n}\n\nexport function makeCollectionPrototype<T>(): CollectionImpl<T> {\n    return {\n        _type: 'collection',\n\n        // Array mutation values\n        splice: collectionSplice,\n        push: collectionPush,\n        pop: collectionPop,\n        shift: collectionShift,\n        unshift: collectionUnshift,\n        sort: collectionSort,\n        reverse: collectionReverse,\n\n        // Handy API values\n        reject: collectionReject,\n        moveSlice: collectionMoveSlice,\n\n        // View production\n        mapView,\n        filterView,\n        flatMapView,\n        subscribe: collectionSubscribe,\n\n        // Retainable\n        __refcount: 0,\n        __alive: collectionAlive,\n        __dead: collectionDead,\n        __debugName: 'collection',\n    };\n}\n\nexport interface ViewImpl<T> extends Retainable {\n    _type: 'view';\n    splice(start: number, deleteCount?: number | undefined): never;\n    splice(start: number, deleteCount: number, ...items: T[]): never;\n    push(...items: T[]): never;\n    pop(): never;\n    shift(): never;\n    unshift(...items: T[]): never;\n    sort(cmp?: ((a: T, b: T) => number) | undefined): never;\n    reverse(): never;\n\n    mapView: <V>(\n        fn: (val: T) => V,\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n    filterView: (\n        fn: (val: T) => boolean,\n        debugName?: string | undefined\n    ) => View<T, ArrayEvent<T>>;\n    flatMapView: <V>(\n        fn: (val: T) => V[],\n        debugName?: string | undefined\n    ) => View<V, ArrayEvent<T>>;\n\n    subscribe: (handler: (event: ArrayEvent<T>[]) => void) => () => void;\n}\n\nexport function makeViewPrototype<T>(\n    sourceCollection: TrackedData<any, any, unknown, unknown>\n): ViewImpl<T> {\n    return {\n        _type: 'view',\n\n        // Array mutation values\n        splice: viewSplice,\n        push: viewPush,\n        pop: viewPop,\n        shift: viewShift,\n        unshift: viewUnshift,\n        sort: viewSort,\n        reverse: viewReverse,\n\n        // View production\n        mapView,\n        filterView,\n        flatMapView,\n        subscribe: collectionSubscribe,\n\n        // Retainable\n        __refcount: 0,\n        __alive(this: View<T>) {\n            retain(sourceCollection);\n            const tdHandle = getTrackedDataHandle(this);\n            log.assert(tdHandle, 'missing tdHandle');\n            retain(tdHandle.fieldMap);\n        },\n        __dead(this: View<T>) {\n            const tdHandle = getTrackedDataHandle(this);\n            log.assert(tdHandle, 'missing tdHandle');\n            release(tdHandle.fieldMap);\n            release(sourceCollection);\n        },\n        __debugName: 'collection',\n    };\n}\n\nexport type Collection<T> = TrackedData<\n    T[],\n    CollectionImpl<T>,\n    ArrayEvent<T>,\n    ArrayEvent<T>\n>;\nexport type View<T, TConsumeEvent = any> = TrackedData<\n    readonly T[],\n    ViewImpl<T>,\n    ArrayEvent<T>,\n    TConsumeEvent\n>;\n\nexport function isCollection(val: any): val is Collection<any> {\n    return val && val._type === 'collection';\n}\n\nexport function isView(val: any): val is View<any> {\n    return val && val._type === 'view';\n}\n\nexport const CollectionHandler: ProxyHandler<ArrayEvent<any>> = {\n    get: (dataAccessor, emitter, prop, receiver) => {\n        return dataAccessor.get(prop, receiver);\n    },\n    has: (dataAccessor, emitter, prop) => {\n        return dataAccessor.has(prop);\n    },\n    set: (dataAccessor, emitter, prop, value, receiver) => {\n        if (typeof prop === 'string') {\n            const numericProp = parseInt(prop, 10);\n            if (!isNaN(numericProp)) {\n                emitter({\n                    type: ArrayEventType.SPLICE,\n                    index: numericProp,\n                    count: 1,\n                    items: [value],\n                });\n            }\n        }\n        return dataAccessor.set(prop, value, receiver);\n    },\n    delete: (dataAccessor, emitter, prop) => {\n        return dataAccessor.delete(prop);\n    },\n};\n\nexport const ViewHandler: ProxyHandler<ArrayEvent<any>> = {\n    get: (dataAccessor, emitter, prop, receiver) => {\n        return dataAccessor.get(prop, receiver);\n    },\n    has: (dataAccessor, emitter, prop) => {\n        return dataAccessor.has(prop);\n    },\n    set: (dataAccessor, emitter, prop, value, receiver) => {\n        if (prop === '__refcount') {\n            return dataAccessor.set(prop, value, receiver);\n        }\n        log.fail('Cannot mutate readonly view');\n    },\n    delete: (dataAccessor, emitter, prop) => {\n        log.fail('Cannot mutate readonly view');\n    },\n};\n\nexport function collection<T>(items: T[], debugName?: string): Collection<T> {\n    const handle = new TrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >(\n        items,\n        CollectionHandler,\n        makeCollectionPrototype(),\n        null,\n        null,\n        addArrayEvent,\n        addArrayEvent,\n        debugName\n    );\n    return handle.revocable.proxy;\n}\n\nfunction viewSplice<T>(\n    this: View<T>,\n    index: number,\n    count: number,\n    ...items: T[]\n): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction spliceInner<T>(\n    tdHandle: TrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >,\n    index: number,\n    count: number,\n    ...items: T[]\n) {\n    const startLength = tdHandle.target.length;\n    const removed = Array.prototype.splice.call(\n        tdHandle.target,\n        index,\n        count,\n        ...items\n    );\n    const endLength = tdHandle.target.length;\n    if (startLength === endLength) {\n        // invalidate fields affected by splice\n        for (let i = index; i < index + items.length; ++i) {\n            tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n        }\n    } else {\n        // invalidate fields affected by splice\n        for (let i = index; i < endLength; ++i) {\n            tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n        }\n        // destroy any dead fields\n        for (let i = endLength; i < startLength; ++i) {\n            tdHandle.fieldMap.delete(i.toString());\n        }\n        tdHandle.fieldMap.set('length', endLength);\n    }\n    tdHandle.emitter.addEvent({\n        type: ArrayEventType.SPLICE,\n        index,\n        count,\n        items,\n    });\n    return removed;\n}\n\nfunction collectionSplice<T>(\n    this: Collection<T>,\n    index: number,\n    count = 0,\n    ...items: T[]\n) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    return spliceInner(tdHandle, index, count, ...items);\n}\n\nfunction viewPush<T>(this: View<T>, ...items: T[]): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionPush<T>(this: Collection<T>, ...items: T[]) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    spliceInner(tdHandle, tdHandle.target.length, 0, ...items);\n    return tdHandle.target.length;\n}\n\nfunction viewPop<T>(this: View<T>): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionPop<T>(this: Collection<T>): T | undefined {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    return spliceInner(tdHandle, tdHandle.target.length - 1, 1)[0];\n}\n\nfunction viewShift<T>(this: View<T>): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionShift<T>(this: Collection<T>): T | undefined {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    return spliceInner(tdHandle, 0, 1)[0];\n}\n\nfunction viewUnshift<T>(this: View<T>, ...items: T[]): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction collectionUnshift<T>(this: Collection<T>, ...items: T[]) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    spliceInner(tdHandle, 0, 0, ...items);\n    return tdHandle.target.length;\n}\n\nfunction collectionReject<T>(\n    this: Collection<T>,\n    pred: (val: T) => boolean\n): T[] {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'missing tdHandle');\n\n    let start: null | number = null;\n    let length = tdHandle.target.length;\n    let toRemove = false;\n    const removed: T[] = [];\n    for (let i = 0; i < length; ++i) {\n        toRemove = pred(tdHandle.target[i]);\n        if (toRemove && start === null) {\n            start = i;\n        }\n        if (!toRemove && start !== null) {\n            const count = i - start;\n            removed.push(...spliceInner(tdHandle, start, count));\n            length -= count;\n            i -= count;\n            start = null;\n        }\n    }\n    if (start !== null) {\n        const count = length - start;\n        removed.push(...spliceInner(tdHandle, start, count));\n    }\n    return removed;\n}\n\nfunction collectionMoveSlice<T>(\n    this: Collection<T>,\n    fromIndex: number,\n    count: number,\n    toIndex: number\n) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'moveSlice missing tdHandle');\n    const removed = tdHandle.target.splice(fromIndex, count);\n    tdHandle.target.splice(toIndex, 0, ...removed);\n    tdHandle.emitter.addEvent({\n        type: ArrayEventType.MOVE,\n        from: fromIndex,\n        count,\n        to: toIndex,\n    });\n}\n\nfunction collectionSubscribe<T>(\n    this: Collection<T> | View<T>,\n    handler: (event: ArrayEvent<T>[]) => void\n) {\n    const tdHandle = getTrackedDataHandle<\n        readonly T[],\n        CollectionImpl<T> | ViewImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<any>\n    >(this);\n    log.assert(tdHandle, 'subscribe missing tdHandle');\n    retain(tdHandle.emitter);\n    const unsubscribe = tdHandle.emitter.subscribe((events) => {\n        handler(events);\n    });\n    return () => {\n        unsubscribe();\n        release(tdHandle.emitter);\n    };\n}\n\nfunction collectionAlive<T>(this: Collection<T>) {\n    const tdHandle = getTrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    retain(tdHandle.fieldMap);\n}\n\nfunction collectionDead<T>(this: Collection<T>) {\n    const tdHandle = getTrackedDataHandle<\n        T[],\n        CollectionImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<T>\n    >(this);\n    log.assert(tdHandle, 'missing tdHandle');\n    release(tdHandle.fieldMap);\n}\n\nfunction viewSort<T>(\n    this: Collection<T>,\n    sortFn?: (a: T, b: T) => number\n): never {\n    log.fail('Cannot mutate readonly view');\n}\n\nfunction viewReverse<T>(this: Collection<T>): never {\n    log.fail('Cannot mutate readonly view');\n}\n\n// https://tc39.es/ecma262/multipage/indexed-collections.html#sec-sortcompare\nfunction defaultSort(x: any, y: any) {\n    if (x === undefined && y === undefined) return 0;\n    if (x === undefined) return 1;\n    if (y === undefined) return -1;\n    const xStr = '' + x;\n    const yStr = '' + y;\n    if (xStr < yStr) return -1;\n    if (xStr > yStr) return 1;\n    return 0;\n}\n\nfunction collectionSort<T>(\n    this: Collection<T>,\n    sortFn: (a: T, b: T) => number = defaultSort\n) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'collectionSort missing tdHandle');\n    let indexes: null | number[] = null;\n    if (tdHandle.emitter) {\n        indexes = (tdHandle.target as T[])\n            .map((_unused: T, index: number) => index)\n            .sort((a, b) => sortFn(tdHandle.target[a], tdHandle.target[b]));\n    }\n    tdHandle.target.sort(sortFn);\n    if (indexes) {\n        tdHandle.emitter.addEvent({\n            type: ArrayEventType.SORT,\n            from: 0,\n            indexes,\n        });\n    }\n\n    // Invalidate sorted fields\n    for (let i = 0; i < tdHandle.target.length; ++i) {\n        tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n    }\n    return this;\n}\n\nfunction collectionReverse<T>(this: Collection<T>) {\n    const tdHandle = getTrackedDataHandle(this);\n    log.assert(tdHandle, 'collectionReverse missing tdHandle');\n    tdHandle.target.reverse();\n    if (tdHandle.emitter) {\n        const indexes: number[] = [];\n        for (let i = tdHandle.target.length - 1; i >= 0; --i) {\n            indexes.push(i);\n        }\n        tdHandle.emitter.addEvent({\n            type: ArrayEventType.SORT,\n            from: 0,\n            indexes,\n        });\n    }\n\n    // Invalidate sorted fields\n    for (let i = 0; i < tdHandle.target.length; ++i) {\n        tdHandle.fieldMap.set(i.toString(), tdHandle.target[i]);\n    }\n    return this;\n}\n\nfunction mapView<T, V>(\n    this: Collection<T> | View<T>,\n    fn: (item: T) => V,\n    debugName?: string\n): View<V, ArrayEvent<T>> {\n    return makeFlatMapView(this, (item: T) => [fn(item)], debugName);\n}\nfunction filterView<T>(\n    this: Collection<T> | View<T>,\n    fn: (item: T) => boolean,\n    debugName?: string\n): View<T, ArrayEvent<T>> {\n    return makeFlatMapView(\n        this,\n        (item: T) => (fn(item) ? [item] : []),\n        debugName\n    );\n}\nfunction flatMapView<T, V>(\n    this: Collection<T> | View<T>,\n    fn: (item: T) => V[],\n    debugName?: string\n): View<V, ArrayEvent<T>> {\n    return makeFlatMapView(this, fn, debugName);\n}\n\nfunction makeFlatMapView<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    flatMap: (item: T) => readonly V[],\n    debugName?: string\n): View<V, ArrayEvent<T>> {\n    const sourceTDHandle = getTrackedDataHandle<\n        readonly T[],\n        CollectionImpl<T> | ViewImpl<T>,\n        ArrayEvent<T>,\n        ArrayEvent<any>\n    >(sourceCollection);\n    log.assert(sourceTDHandle, 'missing tdHandle');\n    const slotSizes: number[] = [];\n    const initialTransform: V[] = [];\n\n    untrackReads(() => {\n        for (const item of sourceCollection) {\n            const slot = flatMap(item);\n            slotSizes.push(slot.length);\n            initialTransform.push(...slot);\n        }\n    });\n\n    const derivedCollection = new TrackedDataHandle<\n        readonly V[],\n        ViewImpl<V>,\n        ArrayEvent<V>,\n        ArrayEvent<T>\n    >(\n        initialTransform,\n        ViewHandler,\n        makeViewPrototype(sourceCollection),\n        sourceTDHandle.emitter,\n        function* (target, events: ArrayEvent<T>[]) {\n            for (const event of events) {\n                const lengthStart = initialTransform.length;\n                // Oops this is accidentally quadratic!\n                yield* arrayEventFlatMap(\n                    slotSizes,\n                    flatMap,\n                    initialTransform,\n                    event\n                );\n                // Invalidate affected ranges\n                switch (event.type) {\n                    case ArrayEventType.SPLICE: {\n                        const lengthEnd = initialTransform.length;\n                        if (lengthStart === lengthEnd) {\n                            for (\n                                let i = event.index;\n                                i < event.index + event.count;\n                                ++i\n                            ) {\n                                derivedCollection.fieldMap.set(\n                                    i.toString(),\n                                    initialTransform[i]\n                                );\n                            }\n                        } else {\n                            for (let i = event.index; i < lengthEnd; ++i) {\n                                derivedCollection.fieldMap.set(\n                                    i.toString(),\n                                    initialTransform[i]\n                                );\n                            }\n                            for (let i = lengthEnd; i < lengthStart; ++i) {\n                                derivedCollection.fieldMap.delete(i.toString());\n                            }\n                            derivedCollection.fieldMap.set('length', lengthEnd);\n                        }\n                        break;\n                    }\n                    case ArrayEventType.MOVE: {\n                        const lowerBound = Math.min(event.from, event.to);\n                        const upperBound = Math.max(\n                            event.from + event.count,\n                            event.to + event.count\n                        );\n                        for (let i = lowerBound; i < upperBound; ++i) {\n                            derivedCollection.fieldMap.set(\n                                i.toString(),\n                                initialTransform[i]\n                            );\n                        }\n                        break;\n                    }\n                    case ArrayEventType.SORT:\n                        for (\n                            let i = event.from;\n                            i < event.from + event.indexes.length;\n                            ++i\n                        ) {\n                            derivedCollection.fieldMap.set(\n                                i.toString(),\n                                initialTransform[i]\n                            );\n                        }\n                        break;\n                }\n            }\n        },\n        addArrayEvent,\n        addArrayEvent,\n        debugName ?? 'derived'\n    );\n\n    return derivedCollection.revocable.proxy;\n}\n", "import * as log from './log';\nimport {\n    Retainable,\n    retain,\n    release,\n    trackCreates,\n    untrackReads,\n    flush,\n    removeRenderNode,\n    dirtyRenderNode,\n} from './engine';\nimport { RefObjectOrCallback, Ref } from './ref';\nimport { JSXNode, setAttribute, assignProp } from './jsx';\nimport {\n    ArrayEvent,\n    ArrayEventType,\n    shiftEvent,\n    shiftEventBy,\n    applyArrayEvent,\n    addArrayEvent,\n} from './arrayevent';\nimport {\n    isCalculation,\n    isCalcUnsubscribe,\n    Calculation,\n    CalculationErrorType,\n} from './calc';\nimport { isCollection, isView, Collection, View } from './collection';\nimport { wrapError } from './util';\n\nexport interface ComponentLifecycle {\n    onMount: (callback: () => void) => (() => void) | void;\n    onUnmount: (callback: () => void) => void;\n    onDestroy: (callback: () => void) => void;\n    onError: (handler: (e: Error) => JSX.Element | null) => void;\n}\n\n// NOTE: UnusedSymbolForChildrenOmission is present solely for the typechecker to not allow assignment of { children?: JSXNode | JSXNode[] } to TProps if TProps is {}\n// Which allows components to flag type errors when they do not specify a `children` prop, but children are given\ndeclare const UnusedSymbolForChildrenOmission: unique symbol;\nexport type EmptyProps = { [UnusedSymbolForChildrenOmission]?: boolean };\nexport type Component<TProps = {}> =\n    | FunctionComponent<TProps>\n    | ClassComponentConstructor<TProps>;\n\nexport type FunctionComponent<TProps = {}> = (\n    props: TProps & EmptyProps,\n    lifecycle: ComponentLifecycle\n) => JSX.Element | null;\n\nexport interface ClassComponentInterface {\n    render?(): JSX.Element | null;\n    onMount?(): (() => void) | void;\n    onUnmount?(): void;\n    onDestroy?(): void;\n    onError?(e: Error): JSX.Element | null;\n}\n\nexport interface ClassComponentConstructor<TProps> {\n    new (props: TProps): ClassComponent<TProps>;\n}\n\nexport function isClassComponent(\n    val: any\n): val is ClassComponentConstructor<unknown> {\n    return val && val.prototype instanceof ClassComponent;\n}\n\nexport class ClassComponent<TProps = EmptyProps>\n    implements ClassComponentInterface\n{\n    declare props: TProps;\n    constructor(props: TProps) {\n        this.props = props;\n    }\n\n    render?(): JSX.Element | null;\n    onMount?(): (() => void) | void;\n    onUnmount?(): void;\n    onDestroy?(): void;\n    onError?(e: Error): JSX.Element | null;\n}\n\nexport type NodeEmitter = (event: ArrayEvent<Node> | Error) => void;\n\nexport const RenderNodeType = Symbol('rendernode');\n\nexport enum RenderNodeCommitPhase {\n    COMMIT_UNMOUNT,\n    COMMIT_DEL,\n    COMMIT_INS,\n    COMMIT_MOUNT,\n}\nfunction isNextRenderNodeCommitPhase(\n    commitPhase: RenderNodeCommitPhase,\n    nextPhase: RenderNodeCommitPhase\n) {\n    return (\n        (commitPhase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n            nextPhase === RenderNodeCommitPhase.COMMIT_UNMOUNT) ||\n        (commitPhase === RenderNodeCommitPhase.COMMIT_UNMOUNT &&\n            nextPhase === RenderNodeCommitPhase.COMMIT_DEL) ||\n        (commitPhase === RenderNodeCommitPhase.COMMIT_DEL &&\n            nextPhase === RenderNodeCommitPhase.COMMIT_INS) ||\n        (commitPhase === RenderNodeCommitPhase.COMMIT_INS &&\n            nextPhase === RenderNodeCommitPhase.COMMIT_MOUNT)\n    );\n}\n\nexport interface RenderNode extends Retainable {\n    _type: typeof RenderNodeType;\n    _commitPhase: RenderNodeCommitPhase;\n    detach(): void;\n    attach(emitter: NodeEmitter, parentXmlNamespace: string): void;\n    setMounted(isMounted: boolean): void;\n    commit(phase: RenderNodeCommitPhase): void;\n    retain(): void;\n    release(): void;\n}\n\nfunction own(parent: RenderNode, child: RenderNode) {\n    if (child === emptyRenderNode) return;\n    retain(child);\n}\n\nfunction disown(parent: RenderNode, child: RenderNode) {\n    if (child === emptyRenderNode) return;\n    release(child);\n}\n\n/**\n * Renders nothing\n */\nexport class EmptyRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    constructor() {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.__debugName = 'empty';\n        this.__refcount = 0;\n    }\n\n    detach() {}\n    attach() {}\n    setMounted() {}\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n    commit() {\n        // No children, no commit action\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {}\n    __dead() {\n        removeRenderNode(this);\n    }\n}\n\n/**\n * Only need one of nothing\n */\nexport const emptyRenderNode = new EmptyRenderNode();\n\n/**\n * Renders a Text DOM node\n */\nexport class TextRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare text: Text;\n    private declare emitter?: NodeEmitter | undefined;\n\n    constructor(string: string, debugName?: string) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.text = document.createTextNode(string);\n\n        this.__debugName = debugName ?? 'text';\n        this.__refcount = 0;\n    }\n\n    detach() {\n        this.emitter?.({ type: ArrayEventType.SPLICE, index: 0, count: 1 });\n        this.emitter = undefined;\n    }\n\n    attach(emitter: NodeEmitter) {\n        log.assert(!this.emitter, 'Invariant: Text node double attached');\n        this.emitter = emitter;\n        this.emitter?.({\n            type: ArrayEventType.SPLICE,\n            index: 0,\n            count: 0,\n            items: [this.text],\n        });\n    }\n\n    setMounted() {}\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n    commit() {\n        // No children, no commit action\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {}\n    __dead() {\n        this.emitter = undefined;\n        removeRenderNode(this);\n    }\n}\n\n/**\n * Renders a foreign managed DOM node\n */\nexport class ForeignRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare node: Node;\n    private declare emitter?: NodeEmitter | undefined;\n\n    constructor(node: Node, debugName?: string) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.node = node;\n\n        this.__debugName = debugName ?? 'foreign';\n        this.__refcount = 0;\n    }\n\n    detach() {\n        this.emitter?.({ type: ArrayEventType.SPLICE, index: 0, count: 1 });\n        this.emitter = undefined;\n    }\n\n    attach(emitter: NodeEmitter) {\n        log.assert(!this.emitter, 'Invariant: Foreign node double attached');\n        this.emitter = emitter;\n        this.emitter?.({\n            type: ArrayEventType.SPLICE,\n            index: 0,\n            count: 0,\n            items: [this.node],\n        });\n    }\n\n    setMounted() {}\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n    commit() {\n        // No children, no commit action\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {}\n    __dead() {\n        this.emitter = undefined;\n        removeRenderNode(this);\n    }\n}\n\n/**\n * Renders an array of render nodes\n */\nexport class ArrayRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare children: RenderNode[];\n    private declare slotSizes: number[];\n    private declare attached: boolean[];\n    private declare emitter?: NodeEmitter | undefined;\n\n    constructor(children: RenderNode[], debugName?: string) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.children = children;\n        this.slotSizes = children.map(() => 0);\n        this.attached = children.map(() => false);\n\n        this.__debugName = debugName ?? 'array';\n        this.__refcount = 0;\n    }\n\n    detach() {\n        for (const [index, child] of this.children.entries()) {\n            if (this.attached[index]) {\n                child.detach();\n                this.attached[index] = false;\n            }\n        }\n        this.emitter = undefined;\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        this.emitter = emitter;\n        for (const [index, child] of this.children.entries()) {\n            child.attach((event) => {\n                if (this.emitter) {\n                    if (event instanceof Error) {\n                        this.emitter(event);\n                    } else {\n                        shiftEvent(this.slotSizes, index, event);\n                        this.emitter(event);\n                    }\n                }\n            }, parentXmlNamespace);\n            this.attached[index] = true;\n        }\n    }\n\n    setMounted(isMounted: boolean) {\n        for (const child of this.children) {\n            child.setMounted(isMounted);\n        }\n    }\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n    commit(phase: RenderNodeCommitPhase) {\n        if (isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            for (const child of this.children) {\n                child.commit(phase);\n            }\n            this._commitPhase = phase;\n        }\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        for (const child of this.children) {\n            own(this, child);\n        }\n    }\n    __dead() {\n        for (const child of this.children) {\n            disown(this, child);\n        }\n        removeRenderNode(this);\n        this.emitter = undefined;\n    }\n}\n\nconst HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nconst MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nconst ELEMENT_NAMESPACE_GUESS: Record<string, string | undefined> = {\n    // HTML elements per https://html.spec.whatwg.org/multipage/indices.html#elements-3\n    a: HTML_NAMESPACE,\n    abbr: HTML_NAMESPACE,\n    address: HTML_NAMESPACE,\n    area: HTML_NAMESPACE,\n    article: HTML_NAMESPACE,\n    aside: HTML_NAMESPACE,\n    audio: HTML_NAMESPACE,\n    b: HTML_NAMESPACE,\n    base: HTML_NAMESPACE,\n    bdi: HTML_NAMESPACE,\n    bdo: HTML_NAMESPACE,\n    blockquote: HTML_NAMESPACE,\n    body: HTML_NAMESPACE,\n    br: HTML_NAMESPACE,\n    button: HTML_NAMESPACE,\n    canvas: HTML_NAMESPACE,\n    caption: HTML_NAMESPACE,\n    cite: HTML_NAMESPACE,\n    code: HTML_NAMESPACE,\n    col: HTML_NAMESPACE,\n    colgroup: HTML_NAMESPACE,\n    data: HTML_NAMESPACE,\n    datalist: HTML_NAMESPACE,\n    dd: HTML_NAMESPACE,\n    del: HTML_NAMESPACE,\n    details: HTML_NAMESPACE,\n    dfn: HTML_NAMESPACE,\n    dialog: HTML_NAMESPACE,\n    div: HTML_NAMESPACE,\n    dl: HTML_NAMESPACE,\n    dt: HTML_NAMESPACE,\n    em: HTML_NAMESPACE,\n    embed: HTML_NAMESPACE,\n    fieldset: HTML_NAMESPACE,\n    figcaption: HTML_NAMESPACE,\n    figure: HTML_NAMESPACE,\n    footer: HTML_NAMESPACE,\n    form: HTML_NAMESPACE,\n    h1: HTML_NAMESPACE,\n    h2: HTML_NAMESPACE,\n    h3: HTML_NAMESPACE,\n    h4: HTML_NAMESPACE,\n    h5: HTML_NAMESPACE,\n    h6: HTML_NAMESPACE,\n    head: HTML_NAMESPACE,\n    header: HTML_NAMESPACE,\n    hgroup: HTML_NAMESPACE,\n    hr: HTML_NAMESPACE,\n    html: HTML_NAMESPACE,\n    i: HTML_NAMESPACE,\n    iframe: HTML_NAMESPACE,\n    img: HTML_NAMESPACE,\n    input: HTML_NAMESPACE,\n    ins: HTML_NAMESPACE,\n    kbd: HTML_NAMESPACE,\n    label: HTML_NAMESPACE,\n    legend: HTML_NAMESPACE,\n    li: HTML_NAMESPACE,\n    link: HTML_NAMESPACE,\n    main: HTML_NAMESPACE,\n    map: HTML_NAMESPACE,\n    mark: HTML_NAMESPACE,\n    // 'math': HTML_NAMESPACE,\n    menu: HTML_NAMESPACE,\n    meta: HTML_NAMESPACE,\n    meter: HTML_NAMESPACE,\n    nav: HTML_NAMESPACE,\n    noscript: HTML_NAMESPACE,\n    object: HTML_NAMESPACE,\n    ol: HTML_NAMESPACE,\n    optgroup: HTML_NAMESPACE,\n    option: HTML_NAMESPACE,\n    output: HTML_NAMESPACE,\n    p: HTML_NAMESPACE,\n    picture: HTML_NAMESPACE,\n    pre: HTML_NAMESPACE,\n    progress: HTML_NAMESPACE,\n    q: HTML_NAMESPACE,\n    rp: HTML_NAMESPACE,\n    rt: HTML_NAMESPACE,\n    ruby: HTML_NAMESPACE,\n    s: HTML_NAMESPACE,\n    samp: HTML_NAMESPACE,\n    script: HTML_NAMESPACE,\n    section: HTML_NAMESPACE,\n    select: HTML_NAMESPACE,\n    slot: HTML_NAMESPACE,\n    small: HTML_NAMESPACE,\n    source: HTML_NAMESPACE,\n    span: HTML_NAMESPACE,\n    strong: HTML_NAMESPACE,\n    style: HTML_NAMESPACE,\n    sub: HTML_NAMESPACE,\n    summary: HTML_NAMESPACE,\n    sup: HTML_NAMESPACE,\n    // 'svg': HTML_NAMESPACE,\n    table: HTML_NAMESPACE,\n    tbody: HTML_NAMESPACE,\n    td: HTML_NAMESPACE,\n    template: HTML_NAMESPACE,\n    textarea: HTML_NAMESPACE,\n    tfoot: HTML_NAMESPACE,\n    th: HTML_NAMESPACE,\n    thead: HTML_NAMESPACE,\n    time: HTML_NAMESPACE,\n    title: HTML_NAMESPACE,\n    tr: HTML_NAMESPACE,\n    track: HTML_NAMESPACE,\n    u: HTML_NAMESPACE,\n    ul: HTML_NAMESPACE,\n    var: HTML_NAMESPACE,\n    video: HTML_NAMESPACE,\n    wbr: HTML_NAMESPACE,\n\n    // SVG Elements per https://developer.mozilla.org/en-US/docs/Web/SVG/Element\n    //'a': SVG_NAMESPACE,\n    animate: SVG_NAMESPACE,\n    animateMotion: SVG_NAMESPACE,\n    animateTransform: SVG_NAMESPACE,\n    circle: SVG_NAMESPACE,\n    clipPath: SVG_NAMESPACE,\n    defs: SVG_NAMESPACE,\n    desc: SVG_NAMESPACE,\n    discard: SVG_NAMESPACE,\n    ellipse: SVG_NAMESPACE,\n    feBlend: SVG_NAMESPACE,\n    feColorMatrix: SVG_NAMESPACE,\n    feComponentTransfer: SVG_NAMESPACE,\n    feComposite: SVG_NAMESPACE,\n    feConvolveMatrix: SVG_NAMESPACE,\n    feDiffuseLighting: SVG_NAMESPACE,\n    feDisplacementMap: SVG_NAMESPACE,\n    feDistantLight: SVG_NAMESPACE,\n    feDropShadow: SVG_NAMESPACE,\n    feFlood: SVG_NAMESPACE,\n    feFuncA: SVG_NAMESPACE,\n    feFuncB: SVG_NAMESPACE,\n    feFuncG: SVG_NAMESPACE,\n    feFuncR: SVG_NAMESPACE,\n    feGaussianBlur: SVG_NAMESPACE,\n    feImage: SVG_NAMESPACE,\n    feMerge: SVG_NAMESPACE,\n    feMergeNode: SVG_NAMESPACE,\n    feMorphology: SVG_NAMESPACE,\n    feOffset: SVG_NAMESPACE,\n    fePointLight: SVG_NAMESPACE,\n    feSpecularLighting: SVG_NAMESPACE,\n    feSpotLight: SVG_NAMESPACE,\n    feTile: SVG_NAMESPACE,\n    feTurbulence: SVG_NAMESPACE,\n    filter: SVG_NAMESPACE,\n    foreignObject: SVG_NAMESPACE,\n    g: SVG_NAMESPACE,\n    hatch: SVG_NAMESPACE,\n    hatchpath: SVG_NAMESPACE,\n    image: SVG_NAMESPACE,\n    line: SVG_NAMESPACE,\n    linearGradient: SVG_NAMESPACE,\n    marker: SVG_NAMESPACE,\n    mask: SVG_NAMESPACE,\n    metadata: SVG_NAMESPACE,\n    mpath: SVG_NAMESPACE,\n    path: SVG_NAMESPACE,\n    pattern: SVG_NAMESPACE,\n    polygon: SVG_NAMESPACE,\n    polyline: SVG_NAMESPACE,\n    radialGradient: SVG_NAMESPACE,\n    rect: SVG_NAMESPACE,\n    //'script': SVG_NAMESPACE,\n    set: SVG_NAMESPACE,\n    stop: SVG_NAMESPACE,\n    //'style': SVG_NAMESPACE,\n    svg: SVG_NAMESPACE,\n    switch: SVG_NAMESPACE,\n    symbol: SVG_NAMESPACE,\n    text: SVG_NAMESPACE,\n    textPath: SVG_NAMESPACE,\n    //'title': SVG_NAMESPACE,\n    tspan: SVG_NAMESPACE,\n    use: SVG_NAMESPACE,\n    view: SVG_NAMESPACE,\n\n    // MATHML Elements per https://developer.mozilla.org/en-US/docs/Web/MathML/Element\n    math: MATHML_NAMESPACE,\n    maction: MATHML_NAMESPACE,\n    annotation: MATHML_NAMESPACE,\n    'annotation-xml': MATHML_NAMESPACE,\n    menclose: MATHML_NAMESPACE,\n    merror: MATHML_NAMESPACE,\n    mfenced: MATHML_NAMESPACE,\n    mfrac: MATHML_NAMESPACE,\n    mi: MATHML_NAMESPACE,\n    mmultiscripts: MATHML_NAMESPACE,\n    mn: MATHML_NAMESPACE,\n    none: MATHML_NAMESPACE,\n    mo: MATHML_NAMESPACE,\n    mover: MATHML_NAMESPACE,\n    mpadded: MATHML_NAMESPACE,\n    mphantom: MATHML_NAMESPACE,\n    mprescripts: MATHML_NAMESPACE,\n    mroot: MATHML_NAMESPACE,\n    mrow: MATHML_NAMESPACE,\n    ms: MATHML_NAMESPACE,\n    semantics: MATHML_NAMESPACE,\n    mspace: MATHML_NAMESPACE,\n    msqrt: MATHML_NAMESPACE,\n    mstyle: MATHML_NAMESPACE,\n    msub: MATHML_NAMESPACE,\n    msup: MATHML_NAMESPACE,\n    msubsup: MATHML_NAMESPACE,\n    mtable: MATHML_NAMESPACE,\n    mtd: MATHML_NAMESPACE,\n    mtext: MATHML_NAMESPACE,\n    mtr: MATHML_NAMESPACE,\n    munder: MATHML_NAMESPACE,\n    munderover: MATHML_NAMESPACE,\n};\n\nconst elementNamespaceTransitionMap: Record<\n    string,\n    Record<string, { node: string; children: string } | undefined> | undefined\n> = {\n    [HTML_NAMESPACE]: {\n        svg: {\n            node: SVG_NAMESPACE,\n            children: SVG_NAMESPACE,\n        },\n        math: {\n            node: MATHML_NAMESPACE,\n            children: MATHML_NAMESPACE,\n        },\n    },\n    [SVG_NAMESPACE]: {\n        foreignObject: {\n            node: SVG_NAMESPACE,\n            children: HTML_NAMESPACE,\n        },\n    },\n} as const;\n\nconst EventProps = [\n    { prefix: 'on:', param: false },\n    { prefix: 'oncapture:', param: true },\n    { prefix: 'onpassive:', param: { passive: true } },\n] as const;\n\n/**\n * Renders an intrinsic DOM node\n */\nexport class IntrinsicRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare tagName: string;\n    private declare element?: Element | undefined;\n    private declare emitter?: NodeEmitter | undefined;\n    private declare detachedError?: Error | undefined;\n    private declare xmlNamespace?: string | undefined;\n    private declare childXmlNamespace?: string | undefined;\n    private declare props?: Record<string, any> | undefined;\n    private declare children: ArrayRenderNode;\n    private declare portalRenderNode?: PortalRenderNode | undefined;\n    private declare calculations?: Map<string, Calculation<any>>;\n    private declare calculationSubscriptions?: Set<() => void>;\n\n    constructor(\n        tagName: string,\n        props: Record<string, any> | undefined,\n        children: RenderNode[],\n        debugName?: string\n    ) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.props = props;\n        this.children = new ArrayRenderNode(children);\n        this.tagName = tagName;\n\n        this.__debugName = debugName ?? `intrinsic:${this.tagName}`;\n        this.__refcount = 0;\n    }\n\n    private createElement(xmlNamespace: string) {\n        const element = document.createElementNS(xmlNamespace, this.tagName);\n        if (this.props) {\n            for (const [prop, val] of Object.entries(this.props)) {\n                if (prop === 'ref') continue; // specially handled by PortalRenderNode\n                if (\n                    EventProps.some(({ prefix, param }) => {\n                        if (prop.startsWith(prefix)) {\n                            element.addEventListener(\n                                prop.slice(prefix.length),\n                                (e) => {\n                                    try {\n                                        val(e, element);\n                                    } finally {\n                                        flush();\n                                    }\n                                },\n                                param\n                            );\n                            return true;\n                        }\n                        return false;\n                    })\n                ) {\n                    continue;\n                }\n                if (isCalcUnsubscribe(val) || isCalculation(val)) {\n                    if (!this.calculations) {\n                        this.calculations = new Map();\n                    }\n                    this.calculations.set(\n                        prop,\n                        isCalculation(val) ? val : val.calculation\n                    );\n                } else {\n                    this.setProp(element, prop, val);\n                }\n            }\n            if (this.calculations) {\n                if (!this.calculationSubscriptions) {\n                    this.calculationSubscriptions = new Set();\n                }\n                for (const [prop, calculation] of this.calculations.entries()) {\n                    retain(calculation);\n                    const currentVal = calculation();\n                    this.setProp(element, prop, currentVal);\n                    this.calculationSubscriptions.add(\n                        calculation.subscribe((error, updatedVal) => {\n                            if (error) {\n                                log.error('Unhandled error in bound prop', {\n                                    prop,\n                                    element,\n                                    error: updatedVal,\n                                });\n                            } else {\n                                this.setProp(element, prop, updatedVal);\n                            }\n                        })\n                    );\n                }\n            }\n        }\n        return element;\n    }\n\n    private setProp(element: Element, prop: string, val: unknown) {\n        if (prop.startsWith('prop:')) {\n            const propName = prop.slice(5);\n            (element as any)[propName] = val;\n            return;\n        }\n\n        if (prop.startsWith('attr:')) {\n            const attrName = prop.slice(5);\n            setAttribute(element, attrName, val);\n            return;\n        }\n\n        assignProp(element, prop, val);\n    }\n\n    private handleEvent = (event: ArrayEvent<Node> | Error) => {\n        if (event instanceof Error) {\n            if (this.emitter) {\n                this.emitter(event);\n            } else {\n                log.warn(\n                    'Unhandled error on detached IntrinsicRenderNode',\n                    this.__debugName,\n                    event\n                );\n                this.detachedError = event;\n            }\n            return;\n        }\n        log.assert(false, 'unexpected event from IntrinsicRenderNode');\n    };\n\n    detach() {\n        this.emitter?.({\n            type: ArrayEventType.SPLICE,\n            index: 0,\n            count: 1,\n        });\n        this.emitter = undefined;\n    }\n\n    ensureElement(xmlNamespace: string, childXmlNamespace: string) {\n        if (!this.element || xmlNamespace !== this.xmlNamespace) {\n            this.xmlNamespace = xmlNamespace;\n            this.element = this.createElement(xmlNamespace);\n\n            if (this.portalRenderNode) {\n                this.portalRenderNode.detach();\n                disown(this, this.portalRenderNode);\n            }\n            this.portalRenderNode = new PortalRenderNode(\n                this.element,\n                this.children,\n                this.props?.ref\n            );\n            own(this, this.portalRenderNode);\n\n            this.portalRenderNode.attach(this.handleEvent, childXmlNamespace);\n        }\n        return this.element;\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        log.assert(!this.emitter, 'Invariant: Intrinsic node double attached');\n        this.emitter = emitter;\n        if (this.detachedError) {\n            this.emitter(this.detachedError);\n            return;\n        }\n\n        const namespaceTransition =\n            elementNamespaceTransitionMap[parentXmlNamespace]?.[this.tagName];\n        const xmlNamespace = namespaceTransition?.node ?? parentXmlNamespace;\n        const childXmlNamespace =\n            namespaceTransition?.children ?? parentXmlNamespace;\n\n        const element = this.ensureElement(xmlNamespace, childXmlNamespace);\n\n        this.emitter?.({\n            type: ArrayEventType.SPLICE,\n            index: 0,\n            count: 0,\n            items: [element],\n        });\n    }\n\n    setMounted(isMounted: boolean) {\n        this.portalRenderNode?.setMounted(isMounted);\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        if (isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            this.portalRenderNode?.commit(phase);\n            this._commitPhase = phase;\n        }\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        // At this point in time, we don't know for sure what the correct XML namespace is, as this could be an SVG\n        // looking element that eventually gets placed within an SVG tree, which ought to result in an\n        // SVGUnknownElement. So we take an educated guess;\n        const xmlNamespaceGuess =\n            ELEMENT_NAMESPACE_GUESS[this.tagName] || HTML_NAMESPACE;\n\n        if (this.portalRenderNode) {\n            own(this, this.portalRenderNode);\n        }\n\n        // foreignObject is special; it should be created with an SVG namespace but children should have a HTML\n        // namespace\n        this.ensureElement(\n            xmlNamespaceGuess,\n            this.tagName === 'foreignObject'\n                ? HTML_NAMESPACE\n                : xmlNamespaceGuess\n        );\n    }\n    __dead() {\n        if (this.calculations) {\n            for (const calculation of this.calculations.values()) {\n                release(calculation);\n            }\n        }\n        if (this.calculationSubscriptions) {\n            for (const unsubscribe of this.calculationSubscriptions) {\n                unsubscribe();\n            }\n            this.calculationSubscriptions.clear();\n        }\n\n        this.element = undefined;\n        if (this.portalRenderNode) {\n            disown(this, this.portalRenderNode);\n            this.portalRenderNode = undefined;\n        }\n        removeRenderNode(this);\n        this.emitter = undefined;\n    }\n}\n\n// A shared document fragment; NOTE: always clear after use\nconst fragment = document.createDocumentFragment();\n\n// TODO: fix this, this needs to be two flags: needs unmount notification; needs mount notification\nenum MountState {\n    MOUNTED,\n    NOTIFY_MOUNT,\n    NOTIFY_UNMOUNT,\n    UNMOUNTED,\n}\n\nexport class PortalRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare tagName: string;\n    private declare element: Element;\n    private declare childEvents: ArrayEvent<Node>[];\n    private declare committedNodes: Node[];\n    private declare liveNodes: Node[];\n    private declare liveNodeSet: Set<Node>;\n    private declare deadNodeSet: Set<Node>;\n    private declare refProp?: RefObjectOrCallback<Element> | undefined;\n    private declare mountState?: MountState | undefined;\n    private declare emitter?: NodeEmitter | undefined;\n    private declare existingOffset: number;\n    private declare arrayRenderNode: ArrayRenderNode;\n    private declare calculations?: Map<string, Calculation<any>>;\n    private declare calculationSubscriptions?: Set<() => void>;\n\n    constructor(\n        element: Element,\n        children: ArrayRenderNode,\n        refProp: RefObjectOrCallback<Element> | null | undefined,\n        debugName?: string\n    ) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.arrayRenderNode = children;\n        this.childEvents = [];\n        this.committedNodes = [];\n        this.liveNodes = [];\n        this.liveNodeSet = new Set();\n        this.deadNodeSet = new Set();\n        this.element = element;\n        if (refProp) {\n            this.refProp = refProp;\n            this.mountState = MountState.UNMOUNTED;\n        }\n        this.tagName = this.element.tagName;\n        this.existingOffset = element.childNodes.length;\n\n        this.__debugName = debugName ?? `mount:${this.tagName}`;\n        this.__refcount = 0;\n    }\n\n    private handleEvent = (event: ArrayEvent<Node> | Error) => {\n        if (event instanceof Error) {\n            if (this.emitter) {\n                this.emitter(event);\n            } else {\n                log.warn('Unhandled error on detached PortalRenderNode');\n            }\n            return;\n        }\n        addArrayEvent(this.childEvents, event);\n        dirtyRenderNode(this);\n    };\n\n    detach() {\n        this.emitter = undefined;\n        this.arrayRenderNode.detach();\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        log.assert(!this.emitter, 'Invariant: Intrinsic node double attached');\n        this.emitter = emitter;\n        this.arrayRenderNode.attach(\n            this.handleEvent,\n            // Note: portal elements & namespaces are weird! parentXmlNamespace is not quite the right word -- it's the \"child\" XML namespace.\n            parentXmlNamespace\n        );\n    }\n\n    setMounted(isMounted: boolean) {\n        if (isMounted) {\n            this.arrayRenderNode.setMounted(true);\n            if (this.refProp) {\n                dirtyRenderNode(this);\n                this.mountState = MountState.NOTIFY_MOUNT;\n            }\n        } else {\n            if (this.refProp) {\n                dirtyRenderNode(this);\n                this.mountState = MountState.NOTIFY_UNMOUNT;\n            }\n            this.arrayRenderNode.setMounted(false);\n        }\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        if (!isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            return;\n        }\n        this.arrayRenderNode.commit(phase);\n        this._commitPhase = phase;\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_UNMOUNT &&\n            this.childEvents.length > 0\n        ) {\n            // Prep received events\n            const childEvents = this.childEvents;\n            this.childEvents = [];\n            for (const childEvent of childEvents) {\n                const removed = applyArrayEvent(this.liveNodes, childEvent);\n                for (const toRemove of removed) {\n                    if (this.liveNodeSet.has(toRemove)) {\n                        this.deadNodeSet.add(toRemove);\n                    }\n                }\n            }\n        }\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_UNMOUNT &&\n            this.refProp &&\n            this.mountState === MountState.NOTIFY_UNMOUNT\n        ) {\n            if (this.refProp instanceof Ref) {\n                this.refProp.current = undefined;\n            } else if (typeof this.refProp === 'function') {\n                this.refProp(undefined);\n            }\n            this.mountState = MountState.UNMOUNTED;\n        }\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_DEL &&\n            this.deadNodeSet.size > 0\n        ) {\n            if (\n                this.deadNodeSet.size === this.liveNodeSet.size &&\n                this.existingOffset === 0\n            ) {\n                this.element.replaceChildren();\n                this.liveNodeSet.clear();\n                this.committedNodes = [];\n            } else {\n                for (const toRemove of this.deadNodeSet) {\n                    this.liveNodeSet.delete(toRemove);\n                    this.element.removeChild(toRemove);\n                }\n                this.committedNodes = this.committedNodes.filter(\n                    (node) => !this.deadNodeSet.has(node)\n                );\n            }\n            this.deadNodeSet.clear();\n        }\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_INS &&\n            this.liveNodes.length > 0\n        ) {\n            let toInsert: Node[] = [];\n            let liveIndex = 0;\n            let currIndex = 0;\n            while (liveIndex < this.liveNodes.length) {\n                if (\n                    this.committedNodes[currIndex] === this.liveNodes[liveIndex]\n                ) {\n                    this.insertBefore(toInsert, liveIndex);\n                    toInsert = [];\n                    liveIndex += 1;\n                    currIndex += 1;\n                } else {\n                    toInsert.push(this.liveNodes[liveIndex]);\n                    liveIndex += 1;\n                }\n            }\n            this.insertBefore(toInsert, this.liveNodes.length);\n        }\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n            this.refProp &&\n            this.mountState === MountState.NOTIFY_MOUNT\n        ) {\n            if (this.refProp instanceof Ref) {\n                this.refProp.current = this.element;\n            } else if (typeof this.refProp === 'function') {\n                this.refProp(this.element);\n            }\n            this.mountState = MountState.MOUNTED;\n        }\n    }\n\n    private insertBefore(nodes: Node[], targetIndex: number) {\n        let toInsert: Node | undefined;\n        if (nodes.length === 1) {\n            toInsert = nodes[0];\n            this.liveNodeSet.add(nodes[0]);\n            this.committedNodes.splice(targetIndex, 0, toInsert);\n        } else if (nodes.length > 1) {\n            for (const node of nodes) {\n                this.liveNodeSet.add(node);\n                fragment.appendChild(node);\n            }\n            this.committedNodes.splice(targetIndex, 0, ...nodes);\n            toInsert = fragment;\n        }\n        if (toInsert) {\n            this.element.insertBefore(\n                toInsert,\n                this.liveNodes[targetIndex] || null // TODO: should this be committedNodes[targetIndex] or liveNodes[targetIndex]?\n            );\n        }\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        own(this, this.arrayRenderNode);\n    }\n    __dead() {\n        if (this.calculations) {\n            for (const calculation of this.calculations.values()) {\n                release(calculation);\n            }\n        }\n        if (this.calculationSubscriptions) {\n            for (const unsubscribe of this.calculationSubscriptions) {\n                unsubscribe();\n            }\n            this.calculationSubscriptions.clear();\n        }\n\n        disown(this, this.arrayRenderNode);\n        removeRenderNode(this);\n        this.emitter = undefined;\n    }\n}\n\n/**\n * Renders the result of a calculation\n */\nexport class CalculationRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare error?: Error | undefined;\n    private declare renderNode?: RenderNode | undefined;\n    private declare calculation: Calculation<any>;\n    private declare calculationSubscription?: (() => void) | undefined;\n    private declare isMounted: boolean;\n    private declare emitter?: NodeEmitter | undefined;\n    private declare parentXmlNamespace?: string | undefined;\n\n    constructor(calculation: Calculation<any>, debugName?: string) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.calculation = calculation;\n        this.isMounted = false;\n\n        this.__debugName = debugName ?? `rendercalc:${calculation.__debugName}`;\n        this.__refcount = 0;\n\n        this.subscribe = this.subscribe.bind(this);\n    }\n\n    detach() {\n        this.renderNode?.detach();\n        this.emitter = undefined;\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        this.emitter = emitter;\n        this.parentXmlNamespace = parentXmlNamespace;\n        if (this.error) {\n            emitter(this.error);\n        } else {\n            this.renderNode?.attach(emitter, parentXmlNamespace);\n        }\n    }\n\n    setMounted(isMounted: boolean) {\n        this.isMounted = isMounted;\n        this.renderNode?.setMounted(isMounted);\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    cleanPrior() {\n        if (this.renderNode) {\n            if (this.emitter) {\n                if (this.isMounted) {\n                    this.renderNode.setMounted(false);\n                }\n                this.renderNode.detach();\n            }\n            disown(this, this.renderNode);\n            this.error = undefined;\n            this.renderNode = undefined;\n        }\n    }\n\n    subscribe(\n        errorType: undefined,\n        val: any,\n        addPostAction: (postAction: () => void) => void\n    ): void;\n    subscribe(\n        errorType: CalculationErrorType,\n        val: Error,\n        addPostAction: (postAction: () => void) => void\n    ): void;\n    subscribe(\n        errorType: undefined | CalculationErrorType,\n        val: Error,\n        addPostAction: (postAction: () => void) => void\n    ): void {\n        this.cleanPrior();\n        if (errorType) {\n            this.error = val;\n            if (this.emitter) {\n                this.emitter(val);\n            } else {\n                log.warn(\n                    'Unhandled error on detached CalculationRenderNode',\n                    val\n                );\n            }\n        } else {\n            addPostAction(() => {\n                const renderNode = renderJSXNode(val as any);\n                own(this, renderNode);\n                this.renderNode = renderNode;\n                if (this.emitter && this.parentXmlNamespace) {\n                    renderNode.attach(this.emitter, this.parentXmlNamespace);\n                }\n                if (this.isMounted) {\n                    renderNode.setMounted(true);\n                }\n            });\n        }\n    }\n    commit(phase: RenderNodeCommitPhase) {\n        if (isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            this.renderNode?.commit(phase);\n            this._commitPhase = phase;\n        }\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        try {\n            this.calculationSubscription = this.calculation.subscribe(\n                this.subscribe\n            );\n            this.subscribe(undefined, this.calculation(), (action) => {\n                action();\n            });\n        } catch (e) {\n            this.subscribe(\n                CalculationErrorType.EXCEPTION,\n                wrapError(e),\n                (action) => {\n                    action();\n                }\n            );\n        }\n    }\n    __dead() {\n        this.calculationSubscription?.();\n        this.calculationSubscription = undefined;\n        this.cleanPrior();\n        removeRenderNode(this);\n        this.emitter = undefined;\n    }\n}\n\nexport class CollectionRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    private declare children: RenderNode[];\n    private declare batchEvents?:\n        | [childIndex: number, childEvent: ArrayEvent<Node>][]\n        | undefined;\n    private declare childIndex: Map<RenderNode, number>;\n    private declare slotSizes: number[];\n    private declare collection: Collection<any> | View<any>;\n    private declare unsubscribe?: () => void;\n    private declare isMounted: boolean;\n    private declare emitter?: NodeEmitter | undefined;\n    private declare parentXmlNamespace?: string | undefined;\n\n    constructor(collection: Collection<any> | View<any>, debugName?: string) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.collection = collection;\n        this.children = [];\n        this.childIndex = new Map();\n        this.slotSizes = [];\n        this.isMounted = false;\n\n        this.__debugName = debugName ?? `rendercoll`;\n        this.__refcount = 0;\n    }\n\n    batchChildEvents(fn: () => void) {\n        this.batchEvents = [];\n        fn();\n        this.batchEvents.sort((a, b) => a[0] - b[0]);\n        let eventIndex = 0;\n        let shiftAmount = 0;\n        for (\n            let slotIndex = 0;\n            eventIndex < this.batchEvents.length &&\n            slotIndex < this.slotSizes.length;\n            ++slotIndex\n        ) {\n            while (\n                eventIndex < this.batchEvents.length &&\n                this.batchEvents[eventIndex][0] === slotIndex\n            ) {\n                const event = this.batchEvents[eventIndex][1];\n                if (event.type === ArrayEventType.SPLICE) {\n                    this.slotSizes[slotIndex] +=\n                        (event.items?.length ?? 0) - event.count;\n                }\n                if (this.emitter) {\n                    shiftEventBy(shiftAmount, event);\n                    this.emitter(event);\n                }\n                eventIndex++;\n            }\n            shiftAmount += this.slotSizes[slotIndex];\n        }\n        this.batchEvents = undefined;\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        this.emitter = emitter;\n        this.parentXmlNamespace = parentXmlNamespace;\n\n        this.batchChildEvents(() => {\n            for (const child of this.children) {\n                child.attach((event) => {\n                    this.handleChildEvent(event, child);\n                }, parentXmlNamespace);\n            }\n        });\n    }\n\n    detach() {\n        for (const child of this.children) {\n            child.detach();\n        }\n\n        this.emitter = undefined;\n    }\n\n    handleChildEvent(event: ArrayEvent<Node> | Error, child: RenderNode) {\n        if (this.emitter) {\n            if (!(event instanceof Error)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const index = this.childIndex.get(child)!;\n                if (this.batchEvents) {\n                    this.batchEvents.push([index, event]);\n                } else {\n                    shiftEvent(this.slotSizes, index, event);\n                    this.emitter(event);\n                }\n            } else {\n                this.emitter(event);\n            }\n        }\n    }\n\n    setMounted(isMounted: boolean) {\n        this.isMounted = isMounted;\n        for (const child of this.children) {\n            child.setMounted(isMounted);\n        }\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    private releaseChild(child: RenderNode) {\n        if (this.emitter) {\n            if (this.isMounted) {\n                child.setMounted(false);\n            }\n            child.detach();\n        }\n        disown(this, child);\n    }\n    private retainChild(child: RenderNode) {\n        own(this, child);\n        if (this.emitter && this.parentXmlNamespace) {\n            child.attach(\n                (event) => this.handleChildEvent(event, child),\n                this.parentXmlNamespace\n            );\n            if (this.isMounted) {\n                child.setMounted(true);\n            }\n        }\n    }\n\n    private handleCollectionEvent = (events: ArrayEvent<any>[]) => {\n        for (const event of events) {\n            switch (event.type) {\n                case ArrayEventType.SPLICE: {\n                    const newChildren: RenderNode[] = [];\n                    if (event.items) {\n                        for (const [index, item] of event.items.entries()) {\n                            const child = renderJSXNode(item);\n                            newChildren.push(child);\n                            this.childIndex.set(child, event.index + index);\n                        }\n                    }\n                    const removed = this.children.splice(\n                        event.index,\n                        event.count,\n                        ...newChildren\n                    );\n                    this.batchChildEvents(() => {\n                        for (const child of removed) {\n                            this.releaseChild(child);\n                            this.childIndex.delete(child);\n                        }\n                    });\n                    this.slotSizes.splice(\n                        event.index,\n                        event.count,\n                        ...newChildren.map(() => 0)\n                    );\n                    if (newChildren.length !== event.count) {\n                        for (\n                            let i = event.index + newChildren.length;\n                            i < this.children.length;\n                            ++i\n                        ) {\n                            this.childIndex.set(this.children[i], i);\n                        }\n                    }\n                    this.batchChildEvents(() => {\n                        for (const child of newChildren) {\n                            this.retainChild(child);\n                        }\n                    });\n                    break;\n                }\n                case ArrayEventType.MOVE: {\n                    // Get adjusted data for event\n                    const slotStartIndex: number[] = [];\n                    let realIndex = 0;\n                    for (const slotSize of this.slotSizes) {\n                        slotStartIndex.push(realIndex);\n                        realIndex += slotSize;\n                    }\n                    let realCount = 0;\n                    for (let i = 0; i < event.count; ++i) {\n                        realCount += this.slotSizes[event.from + i];\n                    }\n\n                    // Move slots\n                    applyArrayEvent(this.slotSizes, event);\n\n                    // Update and emit event\n                    event.from = slotStartIndex[event.from];\n                    event.count = realCount;\n                    event.to = slotStartIndex[event.to];\n                    this.emitter?.(event);\n                    break;\n                }\n                case ArrayEventType.SORT: {\n                    // Get adjusted data for event\n                    let realFrom = 0;\n                    for (let i = 0; i < event.from; ++i) {\n                        realFrom += this.slotSizes[i];\n                    }\n                    const nestedIndexes: number[][] = [];\n                    let index = 0;\n                    for (let i = 0; i < this.slotSizes.length; ++i) {\n                        const slotIndexes: number[] = [];\n                        for (let j = 0; j < this.slotSizes[i]; ++j) {\n                            slotIndexes.push(index);\n                            index += 1;\n                        }\n                        nestedIndexes.push(slotIndexes);\n                    }\n\n                    // Sort slots\n                    applyArrayEvent(this.slotSizes, event);\n                    // Sort nested indexes\n                    applyArrayEvent(nestedIndexes, event);\n\n                    // Update and emit event\n                    const sortedIndexes = nestedIndexes\n                        .slice(event.from)\n                        .flat();\n                    event.from = realFrom;\n                    event.indexes = sortedIndexes;\n                    this.emitter?.(event);\n                    break;\n                }\n            }\n        }\n    };\n\n    commit(phase: RenderNodeCommitPhase) {\n        if (isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            for (const child of this.children) {\n                child.commit(phase);\n            }\n            this._commitPhase = phase;\n        }\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        retain(this.collection);\n        this.unsubscribe = this.collection.subscribe(\n            this.handleCollectionEvent\n        );\n\n        untrackReads(() => {\n            this.batchChildEvents(() => {\n                for (const [index, item] of this.collection.entries()) {\n                    const child = renderJSXNode(item);\n                    this.children.push(child);\n                    this.slotSizes.push(0);\n                    this.childIndex.set(child, index);\n                    this.retainChild(child);\n                }\n            });\n        });\n    }\n    __dead() {\n        this.unsubscribe?.();\n        release(this.collection);\n        const removed = this.children.splice(0, this.children.length);\n        for (const child of removed) {\n            this.releaseChild(child);\n            this.childIndex.delete(child);\n        }\n        this.slotSizes.splice(0, this.slotSizes.length);\n        this.emitter = undefined;\n        removeRenderNode(this);\n    }\n}\n\nfunction isCalculationRenderNode(val: any): val is Calculation<JSXNode> {\n    return isCalculation(val);\n}\n\nfunction isCollectionOrViewRenderNode(\n    val: any\n): val is Collection<JSXNode> | View<JSXNode> {\n    return isCollection(val) || isView(val);\n}\n\nfunction isRenderNode(val: any): val is RenderNode {\n    return val && val._type === RenderNodeType;\n}\n\nexport function renderJSXNode(jsxNode: JSX.Node): RenderNode {\n    if (isRenderNode(jsxNode)) {\n        return jsxNode;\n    }\n    if (isCalculationRenderNode(jsxNode)) {\n        return new CalculationRenderNode(jsxNode);\n    }\n    if (isCollectionOrViewRenderNode(jsxNode)) {\n        return new CollectionRenderNode(jsxNode);\n    }\n    if (jsxNode instanceof Element) {\n        return new ForeignRenderNode(jsxNode);\n    }\n    if (Array.isArray(jsxNode)) {\n        return new ArrayRenderNode(jsxNode.map((item) => renderJSXNode(item)));\n    }\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        typeof jsxNode === 'boolean'\n    ) {\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'function') {\n        log.warn('Rendering a function as JSX renders to nothing');\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'symbol') {\n        log.warn('Rendering a symbol as JSX renders to nothing');\n        return emptyRenderNode;\n    }\n    if (typeof jsxNode === 'string') {\n        return new TextRenderNode(jsxNode);\n    }\n    if (typeof jsxNode === 'number' || typeof jsxNode === 'bigint') {\n        return new TextRenderNode(jsxNode.toString());\n    }\n    log.warn('Unexpected JSX node type, rendering nothing', jsxNode);\n    return emptyRenderNode;\n}\n\nexport function renderJSXChildren(\n    children?: JSX.Node | JSX.Node[]\n): RenderNode[] {\n    const childRenderNodes: RenderNode[] = [];\n    if (children) {\n        if (\n            Array.isArray(children) &&\n            !isCollection(children) &&\n            !isView(children)\n        ) {\n            for (const child of children) {\n                childRenderNodes.push(renderJSXNode(child));\n            }\n        } else {\n            childRenderNodes.push(renderJSXNode(children));\n        }\n    }\n    return childRenderNodes;\n}\n\nexport function mount(target: Element, node: RenderNode): () => void {\n    const root = new PortalRenderNode(\n        target,\n        new ArrayRenderNode([node]),\n        null,\n        'root'\n    );\n    retain(root);\n    let syncError: undefined | Error;\n    root.attach((event) => {\n        if (event instanceof Error) {\n            syncError = event;\n            log.error('Unhandled mount error', event);\n            return;\n        }\n    }, target.namespaceURI ?? HTML_NAMESPACE);\n    if (syncError) {\n        release(root);\n        throw syncError;\n    }\n    // WE HAVE A CONUNDRUM!\n    // - When setMounted(true) is called _before_ flushing, IntrinsicObserver callbacks work as expected; but component onMount notifications fail\n    // - When setMounted(true) is called _after_ flushing, IntrinsicObserver callbacks fail; but component onMount notifications work as expected\n    // This is probably because the interaction between mounting and commit is very awkward when dealing with DOM nodes\n    // - For onMount lifecycles to be able to observe nodes in the DOM, onMount needs to happen __after__ commit\n    // - ref={} callbacks should be equivalent to onMount\n    // - refRaw={} callbacks should be equivalent to retain() (NEEDS BETTER NAME)\n    root.setMounted(true);\n    flush();\n    return () => {\n        root.setMounted(false);\n        root.detach();\n        flush();\n        release(root);\n    };\n}\n\nexport enum IntrinsicObserverEventType {\n    MOUNT = 'mount',\n    UNMOUNT = 'unmount',\n}\n\nexport type IntrinsicObserverNodeCallback = (\n    node: Node,\n    event: IntrinsicObserverEventType\n) => void;\nexport type IntrinsicObserverElementCallback = (\n    element: Element,\n    event: IntrinsicObserverEventType\n) => void;\n\nexport class IntrinsicObserverRenderNode implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    declare nodeCallback?: IntrinsicObserverNodeCallback | undefined;\n    declare elementCallback?: IntrinsicObserverElementCallback | undefined;\n    declare child: ArrayRenderNode;\n    declare childNodes: Node[];\n    declare pendingMount: Node[];\n    declare pendingUnmount: Node[];\n    declare emitter?: NodeEmitter | undefined;\n    declare isMounted: boolean;\n\n    constructor(\n        nodeCallback: IntrinsicObserverNodeCallback | undefined,\n        elementCallback: IntrinsicObserverElementCallback | undefined,\n        children: RenderNode[],\n        debugName?: string\n    ) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.nodeCallback = nodeCallback;\n        this.elementCallback = elementCallback;\n        this.child = new ArrayRenderNode(children);\n        this.childNodes = [];\n        this.pendingMount = [];\n        this.pendingUnmount = [];\n        this.isMounted = false;\n\n        this.__debugName = debugName ?? `lifecycleobserver`;\n        this.__refcount = 0;\n    }\n\n    notify(node: Node, type: IntrinsicObserverEventType) {\n        switch (type) {\n            case IntrinsicObserverEventType.MOUNT:\n                this.pendingMount.push(node);\n                break;\n            case IntrinsicObserverEventType.UNMOUNT:\n                this.pendingUnmount.push(node);\n                break;\n            default:\n                log.assertExhausted(type);\n        }\n        dirtyRenderNode(this);\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        if (!isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            return;\n        }\n        this.child.commit(phase);\n        this._commitPhase = phase;\n\n        switch (phase) {\n            case RenderNodeCommitPhase.COMMIT_UNMOUNT:\n                if (this.pendingUnmount.length > 0) {\n                    for (const node of this.pendingUnmount) {\n                        this.nodeCallback?.(\n                            node,\n                            IntrinsicObserverEventType.UNMOUNT\n                        );\n                        if (node instanceof Element) {\n                            this.elementCallback?.(\n                                node,\n                                IntrinsicObserverEventType.UNMOUNT\n                            );\n                        }\n                    }\n                    this.pendingUnmount = [];\n                }\n                break;\n            case RenderNodeCommitPhase.COMMIT_MOUNT:\n                if (this.pendingMount.length > 0) {\n                    for (const node of this.pendingMount) {\n                        this.nodeCallback?.(\n                            node,\n                            IntrinsicObserverEventType.MOUNT\n                        );\n                        if (node instanceof Element) {\n                            this.elementCallback?.(\n                                node,\n                                IntrinsicObserverEventType.MOUNT\n                            );\n                        }\n                    }\n                    this.pendingMount = [];\n                }\n                break;\n        }\n    }\n\n    handleEvent(event: ArrayEvent<Node> | Error) {\n        if (event instanceof Error) {\n            if (this.emitter) {\n                this.emitter(event);\n            } else {\n                log.warn(\n                    'Unhandled error on detached IntrinsicObserverRenderNode',\n                    event\n                );\n            }\n            return;\n        }\n        if (event.type === ArrayEventType.SPLICE) {\n            for (let i = 0; i < event.count; ++i) {\n                const node = this.childNodes[event.index + i];\n                if (this.isMounted) {\n                    this.notify(node, IntrinsicObserverEventType.UNMOUNT);\n                }\n            }\n        }\n\n        applyArrayEvent(this.childNodes, event);\n        this.emitter?.(event);\n\n        if (event.type === ArrayEventType.SPLICE) {\n            if (event.items) {\n                for (const node of event.items) {\n                    if (this.isMounted) {\n                        this.notify(node, IntrinsicObserverEventType.MOUNT);\n                    }\n                }\n            }\n        }\n    }\n\n    detach() {\n        this.child.detach();\n        this.emitter = undefined;\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        this.emitter = emitter;\n        this.child.attach((event) => {\n            this.handleEvent(event);\n        }, parentXmlNamespace);\n    }\n\n    setMounted(isMounted: boolean) {\n        this.child.setMounted(isMounted);\n        this.isMounted = isMounted;\n        const event = isMounted\n            ? IntrinsicObserverEventType.MOUNT\n            : IntrinsicObserverEventType.UNMOUNT;\n        for (const node of this.childNodes) {\n            this.notify(node, event);\n        }\n    }\n\n    retain() {\n        retain(this);\n    }\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        own(this, this.child);\n    }\n    __dead() {\n        disown(this, this.child);\n        removeRenderNode(this);\n        this.emitter = undefined;\n    }\n}\n\nexport const IntrinsicObserver: Component<{\n    nodeCallback?: IntrinsicObserverNodeCallback;\n    elementCallback?: IntrinsicObserverElementCallback;\n    children?: JSX.Node | JSX.Node[];\n}> = ({ nodeCallback, elementCallback, children }) => {\n    return new IntrinsicObserverRenderNode(\n        nodeCallback,\n        elementCallback,\n        renderJSXChildren(children)\n    );\n};\n\nexport class ComponentRenderNode<TProps> implements RenderNode {\n    declare _type: typeof RenderNodeType;\n    declare _commitPhase: RenderNodeCommitPhase;\n    declare Component: FunctionComponent<TProps>;\n    declare props: TProps | null | undefined;\n    declare children: JSX.Node[];\n    declare result?: RenderNode | Error | undefined;\n    declare resultAttached: boolean;\n    declare onMountCallbacks?: (() => (() => void) | void)[];\n    declare onUnmountCallbacks?: (() => void)[];\n    declare onDestroyCallbacks?: (() => void)[];\n    declare owned: Set<Retainable>;\n    declare errorHandler?: ((e: Error) => RenderNode | null) | undefined;\n    declare emitter?: NodeEmitter | undefined;\n    declare parentXmlNamespace?: string | undefined;\n    declare isMounted: boolean;\n    private declare needsMount?: boolean | undefined;\n\n    constructor(\n        Component: FunctionComponent<TProps>,\n        props: TProps | null | undefined,\n        children: JSX.Node[],\n        debugName?: string\n    ) {\n        this._type = RenderNodeType;\n        this._commitPhase = RenderNodeCommitPhase.COMMIT_MOUNT;\n        this.Component = Component;\n        this.props = props;\n        this.children = children;\n        this.owned = new Set();\n        this.isMounted = false;\n\n        this.resultAttached = false;\n\n        this.__debugName = debugName ?? `component(${Component.name})`;\n        this.__refcount = 0;\n    }\n\n    detach() {\n        log.assert(this.result, 'Invariant: missing component result');\n        if (this.result instanceof Error) {\n            return;\n        }\n        log.assert(\n            this.resultAttached,\n            'Invariant: detached unattached component result'\n        );\n        this.result.detach();\n        this.resultAttached = false;\n        this.emitter = undefined;\n    }\n\n    private ensureResult() {\n        if (!this.result) {\n            let callbacksAllowed = true;\n            const lifecycle: ComponentLifecycle = {\n                onMount: (handler: () => (() => void) | void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onMount must be called in component body'\n                    );\n                    if (!this.onMountCallbacks) this.onMountCallbacks = [];\n                    this.onMountCallbacks.push(handler);\n                },\n                onUnmount: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onUnmount must be called in component body'\n                    );\n                    if (!this.onUnmountCallbacks) this.onUnmountCallbacks = [];\n                    this.onUnmountCallbacks.push(handler);\n                },\n                onDestroy: (handler: () => void) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onDestroy must be called in component body'\n                    );\n                    if (!this.onDestroyCallbacks) this.onDestroyCallbacks = [];\n                    this.onDestroyCallbacks.push(handler);\n                },\n                onError: (errorHandler: (e: Error) => RenderNode | null) => {\n                    log.assert(\n                        callbacksAllowed,\n                        'onError must be called in component body'\n                    );\n                    log.assert(\n                        !this.errorHandler,\n                        'onError called multiple times'\n                    );\n                    this.errorHandler = errorHandler;\n                },\n            };\n\n            let componentProps: any;\n            const Component = this.Component;\n            const children = this.children;\n            const props = this.props;\n            if (children.length === 0) {\n                componentProps = props || {};\n            } else if (children.length === 1) {\n                componentProps = props\n                    ? { ...props, children: children[0] }\n                    : { children: children[0] };\n            } else {\n                componentProps = props ? { ...props, children } : { children };\n            }\n            let jsxResult: RenderNode | Error;\n            try {\n                jsxResult = trackCreates(\n                    this.owned,\n                    () =>\n                        Component(componentProps, lifecycle) || emptyRenderNode\n                );\n            } catch (e) {\n                const error = wrapError(e, 'Unknown error rendering component');\n                if (this.errorHandler) {\n                    jsxResult = this.errorHandler(error) ?? emptyRenderNode;\n                } else {\n                    jsxResult = error;\n                }\n            }\n            callbacksAllowed = false;\n            for (const item of this.owned) {\n                retain(item);\n            }\n            if (!(jsxResult instanceof Error)) {\n                this.result = renderJSXNode(jsxResult);\n                own(this, this.result);\n            } else {\n                this.result = jsxResult;\n            }\n        }\n        return this.result;\n    }\n\n    attach(emitter: NodeEmitter, parentXmlNamespace: string) {\n        log.assert(\n            this.__refcount > 0,\n            'Invariant: dead ComponentRenderNode called attach'\n        );\n        this.emitter = emitter;\n        this.parentXmlNamespace = parentXmlNamespace;\n        const result = this.ensureResult();\n        if (result instanceof Error) {\n            emitter(result);\n        } else {\n            result.attach(this.handleEvent, parentXmlNamespace);\n            this.resultAttached = true;\n        }\n    }\n\n    handleEvent = (event: ArrayEvent<Node> | Error) => {\n        log.assert(\n            !(this.result instanceof Error),\n            'Invariant: received event on calculation error'\n        );\n        if (event instanceof Error && this.errorHandler) {\n            if (this.result) {\n                if (this.resultAttached) {\n                    if (this.isMounted) {\n                        this.result.setMounted(false);\n                    }\n                    this.result.detach();\n                    this.resultAttached = false;\n                }\n                disown(this, this.result);\n                this.result = undefined;\n            }\n            const handledResult = this.errorHandler(event);\n            this.result = handledResult\n                ? renderJSXNode(handledResult)\n                : emptyRenderNode;\n            own(this, this.result);\n\n            if (this.emitter && this.parentXmlNamespace) {\n                this.result.attach(this.handleEvent, this.parentXmlNamespace);\n                this.resultAttached = true;\n            }\n\n            if (this.isMounted) {\n                this.result.setMounted(true);\n            }\n        } else {\n            this.emitter?.(event);\n        }\n    };\n\n    setMounted(isMounted: boolean) {\n        log.assert(this.result, 'Invariant: missing result');\n        this.isMounted = isMounted;\n        if (this.result instanceof Error) {\n            return;\n        }\n        if (isMounted) {\n            this.needsMount = true;\n            dirtyRenderNode(this);\n            this.result.setMounted(isMounted);\n        } else {\n            this.result.setMounted(isMounted);\n            if (this.onUnmountCallbacks) {\n                for (const callback of this.onUnmountCallbacks) {\n                    callback();\n                }\n            }\n        }\n    }\n\n    commit(phase: RenderNodeCommitPhase) {\n        if (!isNextRenderNodeCommitPhase(this._commitPhase, phase)) {\n            return;\n        }\n        if (this.result && !(this.result instanceof Error)) {\n            this.result.commit(phase);\n        }\n        this._commitPhase = phase;\n        if (\n            phase === RenderNodeCommitPhase.COMMIT_MOUNT &&\n            this.needsMount &&\n            this.onMountCallbacks\n        ) {\n            for (const callback of this.onMountCallbacks) {\n                const maybeOnUnmount = callback();\n                if (typeof maybeOnUnmount === 'function') {\n                    if (!this.onUnmountCallbacks) {\n                        this.onUnmountCallbacks = [];\n                    }\n                    const onUnmount = () => {\n                        maybeOnUnmount();\n                        if (this.onUnmountCallbacks) {\n                            const index =\n                                this.onUnmountCallbacks.indexOf(onUnmount);\n                            if (index >= 0) {\n                                this.onUnmountCallbacks.splice(index, 1);\n                            }\n                        }\n                    };\n                    this.onUnmountCallbacks.push(onUnmount);\n                }\n            }\n            this.needsMount = false;\n        }\n    }\n\n    retain() {\n        retain(this);\n    }\n\n    release() {\n        release(this);\n    }\n\n    // Retainable\n    declare __debugName: string;\n    declare __refcount: number;\n    __alive() {\n        this.ensureResult();\n    }\n    __dead() {\n        if (this.onDestroyCallbacks) {\n            for (const callback of this.onDestroyCallbacks) {\n                callback();\n            }\n        }\n\n        if (this.result && !(this.result instanceof Error)) {\n            disown(this, this.result);\n        }\n        this.result = undefined;\n        for (const item of this.owned) {\n            release(item);\n        }\n        this.emitter = undefined;\n        removeRenderNode(this);\n    }\n}\n\nexport function classComponentToFunctionComponentRenderNode<TProps>(\n    Component: ClassComponentConstructor<TProps>,\n    props: TProps,\n    children: JSX.Node[]\n) {\n    return new ComponentRenderNode(\n        (props: TProps, lifecycle) => {\n            const instance = new Component(props);\n            if (!instance.render) return null;\n            if (instance.onDestroy)\n                lifecycle.onDestroy(instance.onDestroy.bind(instance));\n            if (instance.onMount)\n                lifecycle.onMount(instance.onMount.bind(instance));\n            if (instance.onError)\n                lifecycle.onError(instance.onError.bind(instance));\n            if (instance.onUnmount)\n                lifecycle.onUnmount(instance.onUnmount.bind(instance));\n            return instance.render();\n        },\n        props,\n        children,\n        Component.name\n    );\n}\n", "import {\n    RenderNode,\n    renderJSXNode,\n    renderJSXChildren,\n    ArrayRenderNode,\n    ComponentRenderNode,\n    ClassComponentConstructor,\n    classComponentToFunctionComponentRenderNode,\n    IntrinsicRenderNode,\n    Component,\n    FunctionComponent,\n    isClassComponent,\n} from './rendernode';\n\nexport { IntrinsicObserver } from './rendernode';\n\nexport { mount } from './rendernode';\n\nexport const Fragment: Component<{ children?: JSX.Node | JSX.Node[] }> = ({\n    children,\n}) => new ArrayRenderNode(renderJSXChildren(children));\n\nexport function createElement<TProps>(\n    type: string | Component<TProps>,\n    props: TProps,\n    ...children: JSX.Node[]\n): IntrinsicRenderNode | ComponentRenderNode<TProps> {\n    if (typeof type === 'string') {\n        const childNodes: RenderNode[] = [];\n        for (const jsxNode of children) {\n            childNodes.push(renderJSXNode(jsxNode));\n        }\n        return new IntrinsicRenderNode(type, props, childNodes);\n    }\n    if (isClassComponent(type)) {\n        return classComponentToFunctionComponentRenderNode<TProps>(\n            type as ClassComponentConstructor<TProps>,\n            props,\n            children\n        );\n    }\n    return new ComponentRenderNode<TProps>(\n        type as FunctionComponent<TProps>,\n        props,\n        children\n    );\n}\ncreateElement.Fragment = Fragment;\n", "import * as log from './log';\nimport {\n    getTrackedDataHandle,\n    TrackedData,\n    TrackedDataHandle,\n    ProxyHandler,\n} from './trackeddata';\nimport { retain, release } from './engine';\nimport { ViewHandler, ViewImpl, makeViewPrototype, View } from './collection';\nimport { noop } from './util';\nimport { ArrayEvent, ArrayEventType, addArrayEvent } from './arrayevent';\n\nconst ModelPrototype = {\n    __debugName: '',\n    __refcount: 0,\n    __alive: noop,\n    __dead: noop,\n};\n\nexport enum ModelEventType {\n    ADD = 'add',\n    SET = 'set',\n    DEL = 'del',\n}\n\nexport type ModelEvent =\n    | { type: ModelEventType.ADD; prop: string; value: any }\n    | { type: ModelEventType.SET; prop: string; value: any }\n    | { type: ModelEventType.DEL; prop: string; value?: undefined };\n\nexport type Model<T extends {}> = T;\n\n// Note: because model also has \"private\" fields (Retainable interface, __tdHandle), we lie\ntype InternalModel<T extends {}> = TrackedData<\n    T,\n    typeof ModelPrototype,\n    ModelEvent,\n    ModelEvent\n>;\n\nexport function model<T extends {}>(target: T, debugName?: string): Model<T> {\n    const proxyHandler: ProxyHandler<ModelEvent> = {\n        get: (dataAccessor, emitter, prop, receiver) =>\n            dataAccessor.get(prop, receiver),\n        has: (dataAccessor, emitter, prop) => dataAccessor.has(prop),\n        set: (dataAccessor, emitter, prop, value, receiver) => {\n            if (\n                typeof prop === 'string' &&\n                !Object.prototype.hasOwnProperty.call(ModelPrototype, prop)\n            ) {\n                if (dataAccessor.peekHas(prop)) {\n                    emitter({ type: ModelEventType.SET, prop, value });\n                } else {\n                    emitter({ type: ModelEventType.ADD, prop, value });\n                }\n            }\n            return dataAccessor.set(prop, value, receiver);\n        },\n        delete: (dataAccessor, emitter, prop) => {\n            if (\n                typeof prop === 'string' &&\n                !Object.prototype.hasOwnProperty.call(ModelPrototype, prop) &&\n                dataAccessor.peekHas(prop)\n            ) {\n                emitter({ type: ModelEventType.DEL, prop });\n            }\n            return dataAccessor.delete(prop);\n        },\n    };\n    const modelInterface = new TrackedDataHandle<\n        T,\n        typeof ModelPrototype,\n        ModelEvent,\n        ModelEvent\n    >(\n        target,\n        proxyHandler,\n        ModelPrototype,\n        null,\n        null,\n        addModelEvent,\n        addModelEvent,\n        debugName\n    );\n    return modelInterface.revocable.proxy;\n}\n\nmodel.subscribe = function modelSubscribe<T extends {}>(\n    sourceModel: Model<T>,\n    handler: (event: ModelEvent[]) => void,\n    debugName?: string\n): () => void {\n    const sourceTDHandle = getTrackedDataHandle(\n        sourceModel as InternalModel<T>\n    );\n    log.assert(sourceTDHandle, 'missing tdHandle');\n    retain(sourceTDHandle.emitter);\n    const unsubscribe = sourceTDHandle.emitter.subscribe((events) => {\n        handler(events);\n    });\n    return () => {\n        unsubscribe();\n        release(sourceTDHandle.emitter);\n    };\n};\n\nmodel.keys = function modelKeys<T extends {}>(\n    sourceModel: Model<T>,\n    debugName?: string\n): View<string, ModelEvent> {\n    const sourceTDHandle = getTrackedDataHandle(\n        sourceModel as InternalModel<T>\n    );\n    log.assert(sourceTDHandle, 'missing tdHandle');\n\n    const initialKeys = Object.keys(sourceModel);\n\n    const derivedCollection = new TrackedDataHandle<\n        string[],\n        ViewImpl<string>,\n        ArrayEvent<string>,\n        ModelEvent\n    >(\n        initialKeys,\n        ViewHandler,\n        makeViewPrototype(sourceModel),\n        sourceTDHandle.emitter,\n        function* keysHandler(\n            target: string[],\n            events: ModelEvent[]\n        ): IterableIterator<ArrayEvent<string>> {\n            for (const event of events) {\n                switch (event.type) {\n                    case ModelEventType.DEL: {\n                        const index = target.indexOf(event.prop);\n                        if (index !== -1) {\n                            const prevLength = target.length;\n                            target.splice(index, 1);\n                            const newLength = target.length;\n\n                            // Invalidate ranges\n                            for (let i = index; i < target.length; ++i) {\n                                derivedCollection.fieldMap.set(\n                                    i.toString(),\n                                    target[i]\n                                );\n                            }\n                            for (let i = newLength; i < prevLength; ++i) {\n                                derivedCollection.fieldMap.delete(i.toString());\n                            }\n                            derivedCollection.fieldMap.set(\n                                'length',\n                                target.length\n                            );\n\n                            yield {\n                                type: ArrayEventType.SPLICE,\n                                index,\n                                count: 1,\n                                items: [],\n                            };\n                        }\n                        break;\n                    }\n                    case ModelEventType.ADD: {\n                        const length = target.length;\n                        target.push(event.prop);\n\n                        // Invalidate ranges\n                        derivedCollection.fieldMap.set(\n                            length.toString(),\n                            event.prop\n                        );\n                        derivedCollection.fieldMap.set('length', target.length);\n\n                        yield {\n                            type: ArrayEventType.SPLICE,\n                            index: length,\n                            count: 0,\n                            items: [event.prop],\n                        };\n                        break;\n                    }\n                    case ModelEventType.SET:\n                        // Preexisting key\n                        break;\n                    default:\n                        log.assertExhausted(event);\n                }\n            }\n        },\n        addArrayEvent,\n        addModelEvent,\n        debugName\n    );\n\n    return derivedCollection.revocable.proxy;\n};\n\nfunction addModelEvent(events: ModelEvent[], event: ModelEvent) {\n    // TODO: make smarter\n    events.push(event);\n}\n", "export { getLogLevel, setLogLevel } from './log';\nexport type { LogLevel } from './log';\nimport { createElement } from './view';\nexport { createElement, IntrinsicObserver, Fragment, mount } from './view';\nexport type {\n    Component,\n    EmptyProps,\n    ComponentLifecycle,\n    IntrinsicObserverNodeCallback,\n    IntrinsicObserverElementCallback,\n} from './rendernode';\nexport { ClassComponent, IntrinsicObserverEventType } from './rendernode';\nexport type { Model, ModelEvent } from './model';\nexport { model, ModelEventType } from './model';\nexport { field } from './field';\nexport type { Field } from './field';\nexport type { Collection, View } from './collection';\nexport type { ArrayEvent } from './arrayevent';\nexport { ArrayEventType, applyArrayEvent } from './arrayevent';\nexport { collection } from './collection';\nexport { calc, CalculationErrorType } from './calc';\nexport type { Calculation } from './calc';\nexport { reset, subscribe, flush, debug, debugSubscribe } from './engine';\n\nexport { InvariantError } from './types';\nexport type { RefObjectOrCallback, Ref, RefCallback } from './ref';\nexport { ref } from './ref';\n\nexport default createElement;\n\nexport const VERSION =\n    typeof LIB_VERSION === 'string' ? LIB_VERSION : 'development';\n"],
  "mappings": ";AAAO,mCAA6B,MAAM;AAAA,EAEtC,YAAY,KAAa,QAAc;AACnC,UAAM;AACN,SAAK,SAAS;AAAA;AAAA;;;ACDtB,IAAM,SAAmC;AAAA,EACrC,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA;AAEX,IAAI,eAAuB,OAAO;AAE3B,uBAAiC;AACpC,MAAI,gBAAgB,OAAO;AAAM,WAAO;AACxC,MAAI,gBAAgB,OAAO;AAAM,WAAO;AACxC,MAAI,gBAAgB,OAAO;AAAO,WAAO;AACzC,SAAO;AAAA;AAEJ,qBAAqB,UAAoB;AAC5C,YAAU,MAAM,YAAY,QAAQ;AACpC,iBAAe,OAAO;AAAA;AAenB,iBAAiB,OAAc;AAClC,MAAI,gBAAgB,OAAO,MAAM;AAC7B,YAAQ,KAAK,GAAG;AAAA;AAAA;AAIjB,kBAAkB,OAAc;AACnC,MAAI,gBAAgB,OAAO,OAAO;AAC9B,YAAQ,MAAM,GAAG;AAAA;AAAA;AAyBlB,mBAAmB,UAAqB,OAAc;AACzD,MAAI,CAAC,SAAS;AACV,UAAM,mBAAmB,MAAM,YAAY,iBAAiB,GAAG;AAAA;AAAA;AAIhE,cAAc,QAAgB,OAAqB;AACtD,QAAM,mBAAmB,KAAK,GAAG;AACjC,QAAM,IAAI,eAAe,oBAAoB;AAAA;AAG1C,gBAAgB,OAAY,KAA4B;AAC3D,MAAI,CAAC,OAAO;AACR,UACI,qBACA,UAAU,SACJ,cACA,UAAU,OACV,SACA,MAAM,YACZ,iBACA;AAEJ,UAAM,IAAI,eAAe,sBAAsB;AAAA;AAAA;AAIhD,yBAAyB,YAAmB,OAAqB;AACpE,QAAM,qBAAqB,SAAS,oBAAoB,GAAG;AAC3D,QAAM,IAAI,eAAe,qBAAqB,EAAE,SAAS;AAAA;;;AC/FtD,IAAM,OAAO,MAAM;AAAA;AASnB,IAAM,WAAY,OAAM;AAC3B,MAAI,KAAK;AACT,SAAO,MAAM;AAAA;AAoFV,mBAAmB,GAAY,KAAqB;AACvD,MAAI,aAAa;AAAO,WAAO;AAE/B,QAAM,MAAM,IAAI,MAAM,OAAO,iBAAiB,EAAE,OAAO;AACvD,SAAO;AAAA;;;AC7FJ,iCACH,kBACA,sBACA,YACA,YACA,WACU;AACV,MAAI,QAAQ;AACZ,QAAM,aAAqC;AAC3C,QAAM,QAAkB;AACxB,QAAM,kBAA8B;AAEpC,2BAAyB,QAAgB;AACrC,eAAW,QAAQ,iBAAiB,SAAS;AACzC,YAAM,UAAU,qBAAqB;AACrC,UACI,YAAY,UACZ,cAAc,WACd,WAAW,YACb;AACE,cAAM;AAAA;AAAA;AAAA;AAKlB,QAAM,gBAAgB,CAAC,WAAmB;AACtC,WAAO,QAAQ;AACf,WAAO,UAAU;AACjB,YAAQ,QAAQ;AAChB,UAAM,KAAK;AACX,WAAO,UAAU;AAGjB,eAAW,QAAQ,eAAe,OAAO,SAAS;AAC9C,UAAI,CAAC,WAAW,OAAO;AACnB,mBAAW,QAAQ;AAAA,UACf,QAAQ;AAAA;AAAA;AAGhB,YAAM,WAAW,WAAW;AAC5B,UAAI,SAAS,UAAU,QAAW;AAE9B,sBAAc;AACd,eAAO,UAAU,KAAK,IAElB,OAAO,SAEP,SAAS;AAAA,iBAEN,SAAS,SAAS;AAKzB,eAAO,UAAU,KAAK,IAElB,OAAO,SACP,SAAS;AAAA;AAAA;AAMrB,QAAI,OAAO,YAAY,OAAO,OAAO;AAEjC,YAAM,YAAsB;AAC5B,iBAAS;AAEL,cAAM,WAAW,MAAM;AACvB,iBAAS,UAAU;AAEnB,kBAAU,KAAK,SAAS;AACxB,YAAI,aAAa,QAAQ;AACrB;AAAA;AAAA;AAIR,sBAAgB,KAAK;AAAA;AAAA;AAI7B,aAAW,UAAU,WAAW;AAC5B,QAAI,CAAC,WAAW,SAAS;AACrB,iBAAW,UAAU;AAAA,QACjB;AAAA;AAEJ,oBAAc,WAAW;AAAA;AAAA;AAIjC,SAAO;AAAA;;;ACwCX,IAAM,mBAAoC;AAC1C,IAAM,mBAAoC;AAC1C,IAAM,wBAAoC;AAC1C,IAAM,4BAAoC;AAUnC,kBAAqB;AAAA,EAqDxB,YACI,iBAKF;AAkYM,yBAAgB,CAAC,WAAuB;AAC5C,WAAK,YAAY,KAAK;AAAA;AAlYtB,SAAK,kBAAkB;AAEvB,SAAK,SAAS;AACd,SAAK,eAAe;AACpB,SAAK,mBAAmB;AAExB,SAAK,aAAa;AAClB,SAAK,aAAa,oBAAI;AAEtB,SAAK,iBAAiB;AACtB,SAAK,gBAAgB;AACrB,SAAK,uBAAuB;AAC5B,SAAK,sBAAsB;AAE3B,SAAK,uBAAuB;AAC5B,SAAK,yBAAyB;AAC9B,SAAK,yBAAyB;AAE9B,SAAK,cAAc;AAEnB,SAAK,mBAAmB;AACxB,SAAK,eAAe,oBAAI;AAExB,SAAK,qBAAqB,oBAAI;AAAA;AAAA,EAUlC,UAAU,QAAiB;AACvB,IAAI,OAAO,CAAC,KAAK,WAAW,IAAI,SAAS;AAEzC,QAAI;AACJ,QAAI,KAAK,aAAa,SAAS,GAAG;AAC9B,WAAK,KAAK,aAAa;AAAA,WACpB;AACH,WAAK,KAAK;AAAA;AAGd,SAAK,WAAW,IAAI,QAAQ;AAC5B,SAAK,WAAW,MAAM;AACtB,SAAK,eAAe,MAAM;AAE1B,QAAI;AACJ,QAAI,KAAK,iBAAiB,SAAS,GAAG;AAClC,cAAQ,KAAK,iBAAiB;AAAA,WAC3B;AACH,cAAQ,KAAK,oBAAoB;AACjC,WAAK,oBAAoB,UAAU;AAAA;AAGvC,SAAK,qBAAqB,MAAM;AAChC,SAAK,oBAAoB,SAAS;AAElC,SAAK,qBAAqB,MAAM;AAChC,SAAK,uBAAuB,MAAM;AAClC,SAAK,uBAAuB,MAAM;AAAA;AAAA,EAGtC,aAAa,QAAiB;AAC1B,UAAM,KAAK,KAAK,WAAW,IAAI;AAC/B,IAAI,OAAO,IAAI;AACf,UAAM,QAAQ,KAAK,qBAAqB;AACxC,IAAI,OAAO,UAAU,QAAW;AAGhC,IAAI,OACA,KAAK,uBAAuB,IAAI,WAAW,GAC3C;AAEJ,IAAI,OACA,KAAK,uBAAuB,IAAI,WAAW,GAC3C;AAGJ,SAAK,qBAAqB,MAAM;AAChC,SAAK,oBAAoB,SAAS;AAElC,SAAK,sBAAsB;AAC3B,SAAK,eAAe,MAAM;AAC1B,WAAO,KAAK,cAAc;AAC1B,SAAK,WAAW,OAAO;AACvB,SAAK,WAAW,MAAM;AACtB,SAAK,aAAa,OAAO;AAGzB,SAAK,aAAa,KAAK;AACvB,SAAK,iBAAiB,KAAK;AAAA;AAAA,EAG/B,UAAU,QAAiB;AACvB,WAAO,KAAK,WAAW,IAAI;AAAA;AAAA,EAG/B,gBAAgB,QAAiB;AAC7B,UAAM,WAAW,KAAK,WAAW,IAAI;AACrC,IAAI,OAAO,UAAU;AACrB,SAAK,qBAAqB;AAAA;AAAA,EAGtB,qBAAqB,UAAkB;AAC3C,UAAM,SAAS,KAAK,WAAW;AAC/B,QAAI,UAAU,CAAE,MAAK,eAAe,YAAY,mBAAmB;AAC/D,WAAK,eAAe,aAAa;AACjC,WAAK,eAAe,QAAQ;AAE5B,YAAM,QAAQ,KAAK,qBAAqB;AACxC,UAAI,UAAU,UAAa,QAAQ,KAAK,kBAAkB;AACtD,aAAK,mBAAmB;AAAA;AAAA;AAAA;AAAA,EAKpC,iBAAiB,QAAiB;AAC9B,UAAM,WAAW,KAAK,WAAW,IAAI;AACrC,IAAI,OAAO,UAAU;AACrB,SAAK,sBAAsB;AAAA;AAAA,EAGvB,sBAAsB,UAAkB;AAC5C,QAAI,KAAK,eAAe,YAAY,kBAAkB;AAClD,WAAK,eAAe,aAAa,CAAC;AAAA;AAAA;AAAA,EAI1C,wBAAwB,QAAiB;AACrC,UAAM,WAAW,KAAK,WAAW,IAAI;AACrC,IAAI,OAAO,UAAU;AACrB,SAAK,eAAe,aAAa;AAAA;AAAA,GAG5B,oBACL,UACA,WACA,eACF;AACE,QAAI,WAAW;AACX,YAAM,UAAU,oBAAI;AACpB,iBAAW,WAAW,UAAU,WAAW;AACvC,mBAAW,QAAQ,cAAc,UAAU;AACvC,cAAI,CAAC,UAAU,UAAU,IAAI,SAAS,CAAC,QAAQ,IAAI,OAAO;AACtD,oBAAQ,IAAI;AACZ,kBAAM;AAAA;AAAA;AAAA;AAIlB;AAAA;AAEJ,eAAW,QAAQ,cAAc,WAAW;AACxC,UAAI,SAAS;AAAU,cAAM;AAAA;AAAA;AAAA,EAIrC,QAAQ,YAAqB,UAAmB,MAAiB;AAC7D,UAAM,SAAS,KAAK,WAAW,IAAI;AACnC,UAAM,OAAO,KAAK,WAAW,IAAI;AACjC,IAAI,OAAO,QAAQ;AACnB,IAAI,OAAO,MAAM;AAEjB;AAKA,SAAK,uBAAuB,QAAQ,KAAK;AACzC,SAAK,uBAAuB,MAAM,KAAK;AACvC,QAAI,SAAS,mBAAqB;AAC9B,WAAK,qBAAqB,QAAQ,KAAK;AAAA;AAG3C,QACI,WAAW,QACV,MAAK,eAAe,UAAU,2BAA2B,GAC5D;AACE,YAAM,aACF,KAAK,eAAe,UAAU;AAClC,UAAI,CAAC,YAAY;AACb,cAAM,SAAS,KAAK,WAAW;AAC/B,QAAI,OAAO,QAAQ;AACnB,aAAK,eAAe,QAAQ;AAC5B,aAAK,eAAe,WAChB,4BAA4B;AAAA,aAC7B;AACH,aAAK,eAAe,WAAW;AAAA;AAAA;AAIvC,UAAM,YAAY,KAAK,qBAAqB;AAC5C,UAAM,UAAU,KAAK,qBAAqB;AAC1C,IAAI,OAAO,YAAY,QAAW;AAClC,IAAI,OAAO,cAAc,QAAW;AAGpC,UAAM,WAAW,YAAY;AAC7B,QAAI,UAAU;AACV,WAAK,aAAa,IAAI;AACtB,WAAK,aAAa,IAAI;AAAA;AAAA;AAAA,EAI9B,QAAQ,YAAqB,UAAmB,MAAiB;AAC7D,UAAM,SAAS,KAAK,WAAW,IAAI;AACnC,UAAM,OAAO,KAAK,WAAW,IAAI;AACjC,IAAI,OAAO,QAAQ;AACnB,IAAI,OAAO,MAAM;AAEjB,WAAO,KAAK,uBAAuB,QAAQ,SAAS;AAAA;AAAA,EAGxD,WAAW,YAAqB,UAAmB,MAAiB;AAChE,UAAM,SAAS,KAAK,WAAW,IAAI;AACnC,UAAM,OAAO,KAAK,WAAW,IAAI;AACjC,IAAI,OAAO,QAAQ;AACnB,IAAI,OAAO,MAAM;AAEjB;AAMA,oBAAgB,KAAK,uBAAuB,SAAS;AACrD,oBAAgB,KAAK,uBAAuB,OAAO;AACnD,QAAI,SAAS,mBAAqB;AAC9B,sBAAgB,KAAK,qBAAqB,SAAS;AAAA;AAIvD,QAAI,WAAW,MAAM;AACjB,WAAK,eAAe,UAChB,KAAK,eAAe,UAAU,CAAC;AAAA;AAIvC,UAAM,gBAAgB,KAAK,cAAc;AACzC,UAAM,cAAc,KAAK,cAAc;AACvC,QAAI,iBAAiB,eAAe,kBAAkB,aAAa;AAC/D,WAAK,aAAa,IAAI;AACtB,WAAK,aAAa,IAAI;AAAA;AAAA;AAAA,EAItB,uBACJ,UACA,YACA,YACA,SACF;AACE,QAAI,QAAQ,IAAI;AAAW;AAC3B,YAAQ,IAAI;AACZ,eAAW,QAAQ,KAAK,uBAAuB,WAAW;AACtD,YAAM,UAAU,KAAK,qBAAqB;AAC1C,MAAI,OAAO,YAAY,QAAW;AAClC,UAAI,cAAc,WAAW,WAAW,YAAY;AAChD,aAAK,uBACD,MACA,YACA,YACA;AAAA;AAAA;AAAA;AAAA,EAMR,gBACJ,eACA,YACA,YACF;AACE,UAAM,UAAU,oBAAI;AACpB,eAAW,YAAY,eAAe;AAClC,WAAK,uBACD,UACA,YACA,YACA;AAAA;AAGR,WAAO;AAAA;AAAA,EAGH,OAAO,WAAwB;AAEnC,QAAI,aAAa;AACjB,QAAI,aAAa;AACjB,eAAW,YAAY,WAAW;AAC9B,YAAM,YAAY,KAAK,cAAc;AACrC,UAAI,WAAW;AACX,YAAI,UAAU,aAAa;AACvB,uBAAa,UAAU;AAC3B,YAAI,UAAU,aAAa;AACvB,uBAAa,UAAU;AAAA,aACxB;AACH,cAAM,QAAQ,KAAK,qBAAqB;AACxC,QAAI,OAAO,UAAU,QAAW;AAChC,YAAI,QAAQ;AAAY,uBAAa;AACrC,YAAI,QAAQ;AAAY,uBAAa;AAAA;AAAA;AAK7C,UAAM,eAAe,KAAK,gBACtB,WACA,YACA;AAKJ,UAAM,aAAa,wBACf,KAAK,wBACL,KAAK,sBACL,YACA,YACA;AAIJ,UAAM,mBAA6B;AACnC,eAAW,aAAa,YAAY;AAChC,UAAI;AACJ,UAAI,UAAU,SAAS,GAAG;AACtB,gBAAQ;AAAA,UACJ,YAAY;AAAA,UACZ,YAAY;AAAA,UACZ,WAAW,IAAI,IAAI;AAAA;AAAA;AAI3B,iBAAW,YAAY,WAAW;AAC9B,cAAM,QAAQ,KAAK,qBAAqB;AACxC,QAAI,OAAO,UAAU,QAAW;AAChC,YAAI,OAAO;AACP,cAAI,QAAQ,MAAM;AAAY,kBAAM,aAAa;AACjD,cAAI,QAAQ,MAAM;AAAY,kBAAM,aAAa;AAEjD,cAAI,CAAE,MAAK,eAAe,YAAY,mBAAmB;AACrD,iBAAK,eAAe,aAAa;AAAA;AAErC,cACI,CACI,MAAK,eAAe,YACpB,4BAEN;AAEE,kBAAM,SAAS,KAAK,WAAW;AAC/B,YAAI,OAAO,QAAQ;AACnB,iBAAK,eAAe,QAAQ;AAC5B,iBAAK,eAAe,aAChB;AAAA;AAGR,eAAK,cAAc,YAAY;AAAA,mBACxB,KAAK,eAAe,YAAY,kBAAkB;AAEzD,eAAK,eAAe,YAChB,KAAK,eAAe,YACpB,CAAE,oBAAmB;AACzB,iBAAO,KAAK,cAAc;AAC1B,eAAK,qBAAqB;AAAA;AAE9B,yBAAiB,KAAK;AAAA;AAAA;AAK9B,qBAAiB,KAAK,CAAC,GAAG,MAAM,IAAI;AACpC,QAAI,IAAI;AACR,eAAW,aAAa,YAAY;AAChC,iBAAW,YAAY,WAAW;AAC9B,cAAM,QAAQ,iBAAiB;AAC/B,aAAK,oBAAoB,SAAS;AAClC,aAAK,qBAAqB,YAAY;AACtC,aAAK;AAAA;AAAA;AAIb,WAAO;AAAA;AAAA,EAOH,eAAe,QAAiB,QAAuB;AAC3D,QAAI,OAAO;AACP,WAAK,mBAAmB,QAAQ,CAAC,EAAE,cAAc,gBAAgB;AAC7D,cAAM,OAAO,UAAU,QAAQ;AAC/B,cAAM,QAAQ,GAAG,cAAc,YAAY;AAC3C,qBACI,KAAK,MACD,CAAC,MAAO;AAAA,aACD,UAAU;AAAA,UACb,UAAU,MAAM;AAAA,YAEpB,QAEJ;AAAA;AAAA;AAIZ,WAAO,KAAK,gBAAgB,QAAQ,QAAQ,KAAK;AAAA;AAAA,EAG7C,cAAc,UAAkB;AACpC,UAAM,SAAS,KAAK,WAAW;AAC/B,IAAI,OAAO,QAAQ;AACnB,WAAO,KAAK,eAAe,QAAQ;AAAA;AAAA,EAGvC,UAAU;AACN,QAAI,OAAO;AACP,WAAK,mBAAmB,QAAQ,CAAC,EAAE,cAAc,gBAAgB;AAC7D,cAAM,QAAQ;AACd,qBACI,KAAK,MACD,CAAC,MAAO;AAAA,aACD,UAAU;AAAA,YAEjB,QAEJ;AAAA;AAAA;AAIZ,QAAI,KAAK,aAAa,OAAO,GAAG;AAC5B,WAAK,OAAO,KAAK;AACjB,WAAK,aAAa;AAAA;AAGtB,eAAS;AACL,YAAM,cAAc,KAAK;AACzB,UAAI,eAAe,KAAK,WAAW,QAAQ;AACvC,cAAM,cAAc,KAAK;AACzB,aAAK,cAAc;AACnB,mBAAW,cAAc,aAAa;AAClC;AAAA;AAEJ,YAAI,gBAAgB,KAAK,kBAAkB;AAGvC;AAAA;AAGJ,aAAK,mBAAmB;AACxB;AAAA;AAEJ,WAAK;AAEL,YAAM,WAAW,KAAK,oBAAoB;AAC1C,UAAI,aAAa,QAAW;AACxB;AAAA;AAGJ,YAAM,UAAU,KAAK,eAAe,YAAY;AAChD,UAAI,CAAC,SAAS;AACV;AAAA;AAGJ,YAAM,SAAS,KAAK,WAAW;AAC/B,MAAI,OAAO,QAAQ;AAEnB,YAAM,YAAY,KAAK,cAAc;AAErC,UAAI,kBAAkB;AACtB,YAAM,aACF,aACA,KAAK,eAAe,YAAY,wBAC1B,KACA;AACV,UAAI,WAAW;AACX,mBAAW,WAAW,UAAU,WAAW;AACvC,cAAI,CAAC,KAAK,WAAW;AAAU;AAC/B,gBAAM,aACF,KAAK,eAAe,WACpB;AACJ,cAAI,YAAY;AAEZ,uBAAY,KAAK;AAAA;AAErB,4BACI,KAAK,cAAc,YAAY;AAAA;AAAA,aAEpC;AACH,cAAM,aACF,KAAK,eAAe,YAAY;AACpC,YAAI,cAAc,YAAY;AAC1B,qBAAW,KAAK;AAAA;AAEpB,0BACI,KAAK,cAAc,aAAa;AAAA;AAGxC,UAAI,KAAK,aAAa,OAAO,GAAG;AAC5B,cAAM,aAAa,KAAK,OAAO,KAAK;AACpC,YAAI,aAAa,KAAK,kBAAkB;AACpC,eAAK,mBAAmB;AAAA;AAE5B,aAAK,aAAa;AAAA;AAKtB,UAAI,YAAY;AACZ,mBAAW,WAAW,YAAY;AAC9B,gBAAM,eACF,KAAK,eAAe,WACnB,oBAAmB;AACxB,cAAI,cAAc;AACd,kBAAM,cAAc,KAAK,WAAW;AACpC,YAAI,OAAO,aAAa;AACxB,8BACI,KAAK,eACD,aACA,kBACC;AAAA;AAAA;AAAA;AAMrB,YAAM,eAAe,KAAK,cAAc;AACxC,UAAI,CAAC,aAAa,cAAc;AAC5B,0BAAkB;AAAA;AAEtB,UAAI,aAAa,CAAC,cAAc;AAC5B,0BAAkB;AAAA;AAEtB,UACI,aACA,gBACA,aAAa,cAAc,UAAU,WACvC;AACE,0BAAkB;AAAA;AAGtB,UAAI,iBAAiB;AAKjB,cAAM,cAA2B,oBAAI;AACrC,oBAAY,IAAI;AAChB,YAAI,WAAW;AACX,qBAAW,eAAe,UAAU,WAAW;AAC3C,wBAAY,IAAI;AAAA;AAAA;AAGxB,YAAI,cAAc;AACd,qBAAW,eAAe,aAAa,WAAW;AAC9C,wBAAY,IAAI;AAAA;AAAA;AAIxB,mBAAW,WAAW,aAAa;AAC/B,cAAI,CAAC,KAAK,WAAW;AAAU;AAC/B,eAAK,eAAe,SAAS;AAAA;AAAA,aAE9B;AACH,aAAK,sBAAsB;AAAA;AAAA;AAInC,QAAI,OAAO;AACP,WAAK,mBAAmB,QAAQ,CAAC,EAAE,cAAc,gBAAgB;AAC7D,cAAM,QAAQ;AACd,qBACI,KAAK,MACD,CAAC,MAAO;AAAA,aACD,UAAU;AAAA,YAEjB,QAEJ;AAAA;AAAA;AAAA;AAAA,EAMhB,kBAAkB;AACd,QAAI,KAAK,aAAa,OAAO,GAAG;AAC5B,WAAK,OAAO,KAAK;AACjB,WAAK,aAAa;AAAA;AAGtB,UAAM,WAAsB;AAC5B,aACQ,cAAc,GAClB,cAAc,KAAK,oBAAoB,QACvC,EAAE,aACJ;AACE,YAAM,WAAW,KAAK,oBAAoB;AAC1C,UAAI,aAAa,QAAW;AACxB;AAAA;AAGJ,YAAM,UAAU,KAAK,eAAe,YAAY;AAChD,UAAI,CAAC,SAAS;AACV;AAAA;AAGJ,YAAM,SAAS,KAAK,WAAW;AAC/B,MAAI,OAAO,QAAQ;AACnB,eAAS,KAAK;AAAA;AAElB,WAAO;AAAA;AAAA,EAGH,eACJ,UACA,gBACF;AACE,SAAK,sBAAsB;AAC3B,eAAW,QAAQ,KAAK,qBAAqB,WAAW;AACpD,YAAM,cAAc,KAAK,cAAc;AACvC,UAAI,aAAa;AACb,mBAAW,aAAa,YAAY,WAAW;AAC3C,cAAI,CAAC,kBAAkB,CAAC,eAAe,IAAI,YAAY;AACnD,iBAAK,qBAAqB;AAAA;AAAA;AAAA,aAG/B;AACH,YAAI,CAAC,kBAAkB,CAAC,eAAe,IAAI,OAAO;AAC9C,eAAK,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1C,MAAM,UAAmC,OAAgB;AACrD,UAAM,QAAQ;AACd,UAAM,KAAK;AACX,UAAM,KAAK;AACX,UAAM,KAAK;AACX,UAAM,KAAK;AACX,QAAI,OAAO;AACP,YAAM,KAAK,kBAAkB,KAAK,UAAU;AAAA;AAGhD,UAAM,aAAa,CAAC,OAAe;AAC/B,YAAM,SAAS,KAAK,WAAW;AAC/B,UAAI,CAAC;AAAQ;AACb,YAAM,cAAc,SAAS;AAC7B,YAAM,QAAyC;AAAA,QAC3C,OAAO;AAAA,QACP,OAAO,GAAG;AAAA,EAAO,YAAY;AAAA;AAIjC,YAAM,QAAQ;AAKd,UAAI,KAAK,eAAe,MAAM,kBAAkB;AAC5C,cAAM,QAAQ;AACd,cAAM,YAAY;AAClB,cAAM,YAAY;AAAA,aACf;AACH,cAAM,QAAQ;AACd,cAAM,YAAY;AAClB,cAAM,YAAY;AAAA;AAKtB,UAAI,YAAY,UAAU;AACtB,cAAM,WAAW;AACjB,cAAM,WAAW;AAAA;AAGrB,YAAM,aAAuB;AAC7B,iBAAW,CAAC,UAAU,YAAY,OAAO,QAAQ,QAAQ;AACrD,mBAAW,KAAK,GAAG,YAAY,KAAK,UAAU;AAAA;AAGlD,YAAM,KAAK,OAAO,OAAO,WAAW,KAAK;AAAA;AAG7C,UAAM,SAAS,oBAAI;AACnB,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,YAAM,YAAY,KAAK,cAAc;AACrC,UAAI,WAAW;AACX,eAAO,IAAI;AAAA;AAAA;AAGnB,eAAW,SAAS,QAAQ;AACxB,YAAM,KAAK;AACX,YAAM,KAAK;AACX,iBAAW,WAAW,MAAM,WAAW;AACnC,mBAAW;AAAA;AAEf,YAAM,KAAK;AAAA;AAGf,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,YAAM,YAAY,KAAK,cAAc;AACrC,UAAI;AAAW;AACf,iBAAW;AAAA;AAGf,aAAS,KAAK,GAAG,KAAK,KAAK,WAAW,QAAQ,EAAE,IAAI;AAChD,YAAM,OAAO,IAAI,IAAI,KAAK,qBAAqB,OAAO;AACtD,UAAI,KAAK,uBAAuB,KAAK;AACjC,mBAAW,QAAQ,KAAK,uBAAuB,KAAK;AAChD,cAAI,KAAK,IAAI,OAAO;AAChB,kBAAM,KAAK,OAAO,WAAW;AAAA,iBAC1B;AACH,kBAAM,KAAK,OAAO,WAAW;AAAA;AAAA;AAAA;AAAA;AAK7C,UAAM,KAAK;AACX,WAAO,MAAM,KAAK;AAAA;AAAA,EAGtB,eACI,WACA,cACF;AACE,UAAM,QAAQ;AAAA,MACV;AAAA,MACA;AAAA;AAEJ,SAAK,mBAAmB,IAAI;AAC5B,WAAO,MAAM;AACT,WAAK,mBAAmB,OAAO;AAAA;AAAA;AAAA;AAvxBhC,AADJ,MACI,YAAY;AACZ,AAFJ,MAEI,YAAY;AAyyBvB,IAAI,OAAM;AACN,QAAM,UAAU,oBAAoB,6BAElC;AACE,WAAO,KAAK,WAAW,OAAO,CAAC,WAAW,CAAC,CAAC;AAAA;AAEhD,QAAM,UAAU,wBAAwB,+BAEhB,QAAiB;AACrC,UAAM,KAAK,KAAK,WAAW,IAAI;AAC/B,IAAI,OAAO,IAAI;AACf,WAAO,KAAK,uBAAuB,IAAI,IACnC,CAAC,SAAS,KAAK,WAAW;AAAA;AAIlC,QAAM,UAAU,sBAAsB,6BAElC,QACF;AACE,UAAM,KAAK,KAAK,WAAW,IAAI;AAC/B,QAAI,OAAO;AAAW,aAAO;AAC7B,UAAM,QAAQ,KAAK,qBAAqB;AACxC,IAAI,OAAO,UAAU,QAAW;AAChC,UAAM,OAAO,KAAK,eAAe;AACjC,WAAO;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA;AAKZ,yBAAyB,OAAiB,OAAe;AACrD,MAAI,UAAU,MAAM,MAAM,SAAS,IAAI;AACnC,UAAM;AACN;AAAA;AAEJ,QAAM,QAAQ,MAAM,QAAQ;AAC5B,QAAM,SAAS,MAAM,MAAM,SAAS;AACpC,QAAM;AAAA;;;ACl9BH,uBAAuB,KAA8B;AACxD,SAAO,OAAO,IAAI,kBAAkB;AAAA;AAGxC,IAAI,wBAAwB,IAAI,MAAmB;AACnD,IAAI,sBAAsB,oBAAI;AAC9B,IAAI,gBAA4C;AAChD,IAAI,kBAA8C;AAClD,IAAI,aAAa;AACjB,IAAI,aAAa;AACjB,IAAI,cAAmC;AACvC,IAAI,iBAAiB;AAErB,uBAAuB,UAAsB;AACzC,SAAO;AAAA;AAGX,0BAA0B,UAAsB;AAC5C,MAAK,OAAe,gBAAgB;AAChC,QAAI,YAAY;AAChB,mBAAe,MAAM;AACjB,UAAI;AAAW;AACf;AAAA;AAEJ,WAAO,MAAM;AACT,kBAAY;AAAA;AAAA;AAGpB,QAAM,SAAS,WAAW,UAAU;AACpC,SAAO,MAAM,aAAa;AAAA;AAGvB,iBAAiB;AACpB,0BAAwB,IAAI,MAAmB;AAC/C,wBAAsB,oBAAI;AAC1B,kBAAgB;AAChB,oBAAkB;AAClB,eAAa;AACb,eAAa;AACb,MAAI;AAAa;AACjB,gBAAc;AACd,mBAAiB;AAAA;AAGrB,yBAAyB;AACrB,MAAI;AAAY;AAChB,eAAa;AACb,gBAAc,eAAe,MAAM;AAC/B,iBAAa;AACb,kBAAc;AACd;AAAA;AAAA;AAID,iBAAiB;AACpB,MAAI,CAAC,cAAc;AAAY;AAC/B,MAAI,aAAa;AACb;AACA,kBAAc;AAAA;AAElB,eAAa;AACb;AAAA;AAGG,mBAAmB,WAAkD;AACxE,mBAAiB,aAAa;AAAA;AAG3B,gBAAgB,YAAwB;AAC3C;AAOA,aAAW,cAAc;AACzB,MAAI,WAAW,eAAe,GAAG;AAC7B,eAAW;AAAA;AAAA;AAIZ,iBAAiB,YAAwB;AAC5C;AAOA,EAAI,OAAO,WAAW,aAAa,GAAG;AACtC,MAAI,WAAW,eAAe,GAAG;AAC7B,eAAW;AAAA;AAEf,aAAW,cAAc;AAAA;AAG7B,wBACI,QACA,QACA,eACF;AACE;AAEA,UAAQ;AAAA,SACC;AACD,aAAO,OAAO,oBAAoB;AAAA,SACjC;AACD,aAAO,OAAO,gBAAgB,kBAAkB;AAAA,SAC/C;AACD,aAAO,OAAO,UAAU,kBAAkB;AAAA;AAE1C,MAAI,gBAAgB,QAAQ;AAAA;AAAA;AAIxC,sBAAsB;AASlB,eAAa;AACb,wBAAsB;AACtB,aAAW,cAAc,qBAAqB;AAC1C,eAAW,SAAS;AAAA;AAExB,QAAM,YAAY,SAAS;AAC3B,aAAW,cAAc,qBAAqB;AAC1C,eAAW,SAAS;AAAA;AAExB,aAAW,cAAc,qBAAqB;AAC1C,eAAW,SAAS;AAAA;AAExB,MACI,aACC,sBAAqB,eAAe,qBAAqB,eAC1D,SAAS,gBAAgB,SAAS,YACpC;AACE,cAAU;AAAA;AAEd,aAAW,cAAc,qBAAqB;AAC1C,eAAW,SAAS;AAAA;AAExB,sBAAoB;AACpB,eAAa;AACb,MAAI,YAAY;AACZ;AAAA;AAAA;AAID,mBAAmB,QAAqB;AAC3C;AACA,wBAAsB,UAAU;AAAA;AAG7B,sBAAsB,QAAqB;AAC9C;AACA,wBAAsB,aAAa;AAAA;AAGhC,0BAA0B,QAAoB;AACjD,sBAAoB,OAAO;AAAA;AAGxB,yBAAyB,YAAwB;AACpD;AACA,sBAAoB,IAAI;AACxB;AAAA;AAGG,qBAAqB,YAAyB,UAAuB;AACxE;AAOA,wBAAsB,QAAQ,YAAY,UAAU,MAAM;AAAA;AAGvD,qBAAqB,YAAyB,UAAuB;AACxE;AAOA,wBAAsB,QAAQ,YAAY,UAAU,MAAM;AAAA;AAGvD,wBAAwB,YAAyB,UAAuB;AAC3E;AAOA,wBAAsB,WAAW,YAAY,UAAU,MAAM;AAAA;AAG1D,wBAAwB,YAAyB,UAAuB;AAC3E;AAOA,wBAAsB,WAAW,YAAY,UAAU,MAAM;AAAA;AAG1D,mBAAmB,QAAqB;AAC3C;AACA,wBAAsB,gBAAgB;AACtC;AAAA;AAGG,qBAAqB,QAAqB;AAC7C;AACA,wBAAsB,iBAAiB;AAAA;AAGpC,2BAA2B,QAAqB;AACnD;AACA,wBAAsB,wBAAwB;AAAA;AAG3C,oBACH,KACA,IACA,WACC;AACD;AACA,gBAAc,KAAK;AACnB,MAAI;AACA,WAAO;AAAA,YACT;AACE;AACA,IAAI,OACA,QAAQ,cAAc,OACtB;AAAA;AAAA;AAKL,sBAAyB,IAAa,WAAuB;AAChE;AACA,gBAAc,KAAK;AACnB,MAAI;AACA,WAAO;AAAA,YACT;AACE;AACA,IAAI,OACA,AAAS,cAAc,UAAvB,MACA;AAAA;AAAA;AAKL,sBACH,KACA,IACA,WACC;AACD;AACA,kBAAgB,KAAK;AACrB,MAAI;AACA,WAAO;AAAA,YACT;AACE;AACA,IAAI,OACA,QAAQ,gBAAgB,OACxB;AAAA;AAAA;AAmBL,sBAAsB,YAAwB;AACjD,MAAI,gBAAgB,WAAW;AAAG;AAClC,QAAM,YAAY,gBAAgB,gBAAgB,SAAS;AAC3D,MAAI,WAAW;AACX;AAMA,QAAI,CAAC,UAAU,IAAI,aAAa;AAC5B,gBAAU,IAAI;AAAA;AAAA;AAAA;AAKnB,oBAAoB,YAAwB;AAC/C,MAAI,cAAc,WAAW;AAAG;AAChC,QAAM,mBAAmB,cAAc,cAAc,SAAS;AAC9D,MAAI,kBAAkB;AAClB;AAMA,QAAI,CAAC,iBAAiB,IAAI,aAAa;AACnC,aAAO;AACP,uBAAiB,IAAI;AAAA;AAAA;AAAA;AAK1B,gBAAe,cAA4B,OAAgB;AAC9D,SAAO,sBAAsB,MAAM,CAAC,WAAW;AAC3C,WAAO;AAAA,MACH,UAAU,WAAW;AAAA,MACrB,MAAM,GAAG,OAAO,mBAAoB,OAAe;AAAA;AAAA,KAExD;AAAA;AAGA,wBAAwB,IAA+C;AAC1E,SAAO,sBAAsB,eAAe,CAAC,WAAW;AACpD,WAAO;AAAA,MACH,UAAU;AAAA,MACV,MAAM,OAAO;AAAA;AAAA,KAElB;AAAA;;;AC9WA,gBAAa;AAAA,EAEhB,YAAY,SAAyB;AACjC,SAAK,UAAU;AAAA;AAAA;AAOhB,aAAgB,KAAiB;AACpC,SAAO,IAAI,IAAI;AAAA;;;ACuEnB,kCACI,KACkB;AAClB,MAAI,CAAC;AAAK,WAAO;AACjB,SAAO;AAAA;AAGX,oCACI,KACkB;AAClB,MAAI,QAAQ;AAAW,WAAO;AAC9B,SAAO,OAAO,QAAQ,WAAW,MAAM,SAAS;AAAA;AAGpD,mBAAmB,KAAyD;AACxE,MAAI,QAAQ;AAAW,WAAO;AAC9B,SAAO,QAAQ,OAAO,QAAQ;AAAA;AAOlC,IAAM,eAUF;AAAA,EACA,kBAAkB,EAAE,KAAK;AAAA,EACzB,eAAe,EAAE,KAAK;AAAA,EACtB,qBAAqB,EAAE,KAAK;AAAA,EAC5B,aAAa,EAAE,KAAK;AAAA,EACpB,gBAAgB,EAAE,KAAK;AAAA,EACvB,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,qBAAqB,EAAE,KAAK;AAAA,EAC5B,gBAAgB,EAAE,KAAK;AAAA,EACvB,gBAAgB,EAAE,KAAK;AAAA,EACvB,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,eAAe,EAAE,KAAK;AAAA,EACtB,gBAAgB,EAAE,KAAK;AAAA,EACvB,qBAAqB,EAAE,KAAK;AAAA,EAC5B,cAAc,EAAE,KAAK;AAAA,EACrB,cAAc,EAAE,KAAK;AAAA,EACrB,aAAa,EAAE,KAAK;AAAA,EACpB,cAAc,EAAE,KAAK;AAAA,EACrB,kBAAkB,EAAE,KAAK;AAAA,EACzB,wBAAwB,EAAE,KAAK;AAAA,EAC/B,oBAAoB,EAAE,KAAK;AAAA,EAC3B,oBAAoB,EAAE,KAAK;AAAA,EAC3B,iBAAiB,EAAE,KAAK;AAAA,EACxB,gBAAgB,EAAE,KAAK;AAAA,EACvB,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,wBAAwB,EAAE,KAAK;AAAA,EAC/B,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,qBAAqB,EAAE,KAAK;AAAA,EAC5B,gBAAgB,EAAE,KAAK;AAAA,EACvB,iBAAiB,EAAE,KAAK;AAAA,EACxB,gBAAgB,EAAE,KAAK;AAAA,EACvB,aAAa,EAAE,KAAK;AAAA,EACpB,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,iBAAiB,EAAE,KAAK;AAAA,EACxB,kBAAkB,EAAE,KAAK;AAAA,EACzB,cAAc,EAAE,KAAK;AAAA,EACrB,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,WAAW,EAAE,KAAK;AAAA,EAClB,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,iBAAiB,EAAE,KAAK;AAAA,EACxB,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,WAAW;AAAA,EACX,UAAU;AAAA,EACV,SAAS,EAAE,KAAK;AAAA,EAChB,SAAS;AAAA,EACT,MAAM;AAAA,EACN,OAAO,EAAE,KAAK;AAAA,EACd,OAAO,EAAE,KAAK;AAAA,EACd,MAAM,EAAE,KAAK;AAAA,EACb,SAAS,EAAE,KAAK,WAAW,KAAK;AAAA,EAChC,SAAS;AAAA,EACT,iBAAiB,EAAE,KAAK;AAAA,EACxB,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,aAAa,EAAE,KAAK;AAAA,EACpB,MAAM;AAAA,EACN,UAAU,EAAE,KAAK;AAAA,EACjB,UAAU;AAAA,EACV,SAAS;AAAA,EACT,OAAO;AAAA,EACP,KAAK;AAAA,EACL,SAAS,EAAE,KAAK;AAAA,EAChB,UAAU;AAAA,EACV,UAAU;AAAA,EACV,WAAW;AAAA,EACX,SAAS;AAAA,EACT,cAAc,EAAE,KAAK;AAAA,EACrB,KAAK,EAAE,KAAK;AAAA,EACZ,MAAM,EAAE,KAAK;AAAA,EACb,YAAY,EAAE,KAAK;AAAA,EACnB,aAAa,EAAE,KAAK;AAAA,EACpB,YAAY,EAAE,KAAK;AAAA,EACnB,gBAAgB,EAAE,KAAK;AAAA,EACvB,YAAY,EAAE,KAAK;AAAA,EACnB,SAAS;AAAA,EACT,QAAQ,EAAE,KAAK;AAAA,EACf,QAAQ;AAAA,EACR,MAAM,EAAE,KAAK;AAAA,EACb,MAAM;AAAA,EACN,UAAU;AAAA,EACV,IAAI;AAAA,EACJ,YAAY,EAAE,KAAK;AAAA,EACnB,aAAa,EAAE,KAAK;AAAA,EACpB,eAAe,EAAE,KAAK;AAAA,EACtB,WAAW,EAAE,KAAK;AAAA,EAClB,WAAW;AAAA,EACX,IAAI,EAAE,KAAK;AAAA,EACX,OAAO,EAAE,KAAK;AAAA,EACd,QAAQ,EAAE,KAAK;AAAA,EACf,UAAU,EAAE,KAAK;AAAA,EACjB,SAAS,EAAE,KAAK;AAAA,EAChB,WAAW,EAAE,KAAK;AAAA,EAClB,UAAU,EAAE,KAAK;AAAA,EACjB,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM,EAAE,KAAK;AAAA,EACb,KAAK,EAAE,KAAK;AAAA,EACZ,KAAK,EAAE,KAAK;AAAA,EACZ,WAAW;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA;AAAA,EAET,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,KAAK,EAAE,KAAK;AAAA,EACZ,WAAW;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA;AAAA,EAET,UAAU;AAAA,EACV,OAAO;AAAA,EACP,MAAM;AAAA,EACN,UAAU,EAAE,KAAK;AAAA,EACjB,OAAO;AAAA,EACP,YAAY,EAAE,KAAK;AAAA,EACnB,MAAM;AAAA,EACN,SAAS,EAAE,KAAK;AAAA,EAChB,SAAS;AAAA,EACT,MAAM;AAAA,EACN,aAAa;AAAA,EACb,aAAa,EAAE,KAAK;AAAA,EACpB,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,UAAU,EAAE,KAAK;AAAA,EACjB,gBAAgB,EAAE,KAAK;AAAA,EACvB,KAAK;AAAA,EACL,UAAU;AAAA,EACV,UAAU;AAAA,EACV,MAAM;AAAA,EACN,MAAM,EAAE,KAAK;AAAA,EACb,SAAS,EAAE,KAAK,WAAW,KAAK;AAAA,EAChC,SAAS;AAAA,EACT,OAAO;AAAA,EACP,UAAU;AAAA,EACV,OAAO;AAAA,EACP,MAAM,EAAE,KAAK;AAAA,EACb,OAAO;AAAA,EACP,MAAM;AAAA,EACN,MAAM,EAAE,KAAK;AAAA,EACb,YAAY;AAAA,EACZ,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,OAAO,EAAE,KAAK;AAAA,EACd,MAAM,EAAE,KAAK;AAAA,EACb,OAAO;AAAA,EACP,UAAU,EAAE,KAAK,YAAY,KAAK;AAAA,EAClC,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,WAAW,EAAE,KAAK;AAAA,EAClB,MAAM;AAAA,EACN,QAAQ,EAAE,KAAK;AAAA,EAEf,OAAO,EAAE,KAAK;AAAA,EACd,MAAM;AAAA;AAGH,sBACH,SACA,eACA,KACF;AACE,MAAI,QAAQ,UAAa,QAAQ,QAAQ,QAAQ,OAAO;AACpD,YAAQ,gBAAgB;AAAA,aACjB,QAAQ,MAAM;AACrB,YAAQ,aAAa,eAAe;AAAA,aAC7B,OAAO,QAAQ,UAAU;AAChC,YAAQ,aAAa,eAAe;AAAA,aAC7B,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;AAC3D,YAAQ,aAAa,eAAe,IAAI;AAAA;AAAA;AAIzC,oBAAoB,SAAkB,WAAmB,OAAY;AAIxE,MAAI,CAAE,oBAAmB,cAAc;AACnC,iBAAa,SAAS,WAAW;AACjC;AAAA;AAEJ,MAAI,cAAc,SAAS;AAEvB,YAAQ,QAAQ;AAAA,WACP;AAAA,WACA;AAGD,qBAAa,SAAS,WAAW;AACjC,QAAC,QAAgB,QAAQ,2BAA2B;AACpD;AAAA,WAEC;AAGD,QAAC,QAAgB,QAAQ;AACzB;AAAA,WAEC;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAAA,WACA;AAGD,qBAAa,SAAS,WAAW;AACjC,QAAC,QAAgB,QAAQ;AACzB;AAAA;AAGA,qBAAa,SAAS,WAAW;AAAA;AAEzC;AAAA;AAEJ,QAAM,WAAW,aAAa;AAC9B,MAAI,UAAU;AACV,QAAI,CAAC,SAAS,KAAK;AACf,YAAM,iBAAiB;AACvB,mBAAa,SAAS,WAAW;AAAA;AAErC,QAAI,SAAS,QAAQ,MAAM;AACvB,YAAM,WAAW,SAAS,MAAM,SAAS,IAAI,SAAS;AACtD,MAAC,QAAgB,SAAS,OAAO,aAAa;AAAA;AAElD;AAAA;AAEJ,eAAa,SAAS,WAAW;AAAA;;;ACxW9B,IAAK,iBAAL,kBAAK,oBAAL;AACH,8BAAS;AACT,4BAAO;AACP,4BAAO;AAHC;AAAA;AA6BL,sBAAyB,aAAqB,OAAsB;AACvE,UAAQ,MAAM;AAAA,SACL,uBAAuB;AACxB,YAAM,SAAS;AACf;AAAA;AAAA,SAEC,mBAAqB;AACtB,YAAM,QAAQ;AACd,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,QAAQ,EAAE,GAAG;AAC3C,cAAM,QAAQ,MAAM;AAAA;AAExB;AAAA;AAAA,SAEC,mBAAqB;AACtB,YAAM,QAAQ;AACd,YAAM,MAAM;AACZ;AAAA;AAAA;AAGA,MAAI,gBAAgB;AAAA;AAAA;AAGzB,oBACH,WACA,WACA,OACF;AACE,MAAI,cAAc;AAClB,WAAS,IAAI,GAAG,IAAI,WAAW,EAAE,GAAG;AAChC,mBAAe,UAAU;AAAA;AAE7B,eAAa,aAAa;AAC1B,MAAI,MAAM,SAAS,uBAAuB;AACtC,cAAU,cAAe,OAAM,OAAO,UAAU,KAAK,MAAM;AAAA;AAAA;AAInE,IAAM,cAA2B;AAE1B,yBACH,QACA,OACY;AACZ,UAAQ,MAAM;AAAA,SACL,uBAAuB;AACxB,UAAI,MAAM,OAAO;AACb,eAAO,OAAO,OAAO,MAAM,OAAO,MAAM,OAAO,GAAG,MAAM;AAAA,aACrD;AACH,eAAO,OAAO,OAAO,MAAM,OAAO,MAAM;AAAA;AAAA;AAAA,SAG3C,mBAAqB;AACtB,YAAM,QAAQ,OAAO,MAAM,MAAM;AACjC,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,QAAQ,EAAE,GAAG;AAC3C,eAAO,KAAK,MAAM,MAAM,QAAQ,KAAK,MAAM;AAAA;AAE/C;AAAA;AAAA,SAEC,mBAAqB;AACtB,YAAM,QAAQ,OAAO,OAAO,MAAM,MAAM,MAAM;AAC9C,aAAO,OAAO,MAAM,IAAI,GAAG,GAAG;AAC9B;AAAA;AAAA;AAGA,MAAI,gBAAgB;AAAA;AAE5B,SAAO;AAAA;AAGJ,4BACH,WACA,SACA,QACA,OAC+B;AAC/B,UAAQ,MAAM;AAAA,SACL,uBAAuB;AACxB,UAAI,YAAY;AAChB,UAAI,QAAQ;AACZ,eAAS,IAAI,GAAG,IAAI,MAAM,OAAO,EAAE,GAAG;AAClC,qBAAa,IAAI,UAAU,SAAS,UAAU,KAAK;AAAA;AAEvD,eAAS,IAAI,GAAG,IAAI,MAAM,OAAO,EAAE,GAAG;AAClC,cAAM,YAAY,MAAM,QAAQ;AAChC,iBACI,YAAY,UAAU,SAAS,UAAU,aAAa;AAAA;AAE9D,YAAM,YAAsB;AAC5B,YAAM,QAAa;AACnB,UAAI,MAAM,OAAO;AACb,mBAAW,QAAQ,MAAM,OAAO;AAC5B,gBAAM,OAAO,QAAQ;AACrB,oBAAU,KAAK,KAAK;AACpB,gBAAM,KAAK,GAAG;AAAA;AAAA;AAGtB,aAAO,OAAO,WAAW,OAAO,GAAG;AACnC,gBAAU,OAAO,MAAM,OAAO,MAAM,OAAO,GAAG;AAC9C,YAAM;AAAA,QACF,MAAM;AAAA,QACN,OAAO;AAAA,QACP;AAAA,QACA;AAAA;AAEJ;AAAA;AAAA,SAEC,mBAAqB;AACtB,YAAM,iBAA2B;AACjC,UAAI,YAAY;AAChB,iBAAW,YAAY,WAAW;AAC9B,uBAAe,KAAK;AACpB,qBAAa;AAAA;AAEjB,YAAM,kBAAkB,UAAU;AAClC,YAAM,eAAe,OAAO;AAE5B,YAAM,aAAuB;AAC7B,UAAI,gBAAgB;AACpB,UAAI,YAAY;AAChB,iBAAW,eAAe,MAAM,SAAS;AACrC,cAAM,YAAY,gBAAgB;AAClC,cAAM,aAAY,eAAe;AACjC,iBAAS,IAAI,GAAG,IAAI,WAAW,EAAE,GAAG;AAChC,qBAAW,KAAK,aAAY;AAC5B,iBAAO,aAAa,aAAa,aAAY;AAC7C,uBAAa;AAAA;AAEjB,kBAAU,iBAAiB,gBAAgB;AAC3C,yBAAiB;AAAA;AAErB,YAAM;AAAA,QACF,MAAM;AAAA,QACN,MAAM,eAAe,MAAM;AAAA,QAC3B,SAAS;AAAA;AAEb;AAAA;AAAA,SAEC,mBAAqB;AACtB,UAAI,YAAY;AAChB,UAAI,UAAU;AACd,UAAI,QAAQ;AACZ,eAAS,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,GAAG;AACjC,qBAAa,UAAU;AAAA;AAE3B,eAAS,IAAI,GAAG,IAAI,MAAM,OAAO,EAAE,GAAG;AAClC,iBAAS,UAAU,MAAM,OAAO;AAAA;AAEpC,YAAM,aAAa,UAAU,OAAO,MAAM,MAAM,MAAM;AACtD,YAAM,aAAa,OAAO,OAAO,WAAW;AAC5C,eAAS,IAAI,GAAG,IAAI,MAAM,IAAI,EAAE,GAAG;AAC/B,mBAAW,UAAU;AAAA;AAEzB,gBAAU,OAAO,MAAM,IAAI,GAAG,GAAG;AACjC,aAAO,OAAO,SAAS,GAAG,GAAG;AAC7B,YAAM;AAAA,QACF,MAAM;AAAA,QACN,MAAM;AAAA,QACN;AAAA,QACA,IAAI;AAAA;AAER;AAAA;AAAA;AAGA,MAAI,gBAAgB;AAAA;AAAA;AAIzB,uBACH,QACA,OACF;AACE,QAAM,YAAY,OAAO,SAAS,IAAI,OAAO,OAAO,SAAS,KAAK;AAClE,MACI,aACA,MAAM,SAAS,yBACf,UAAU,SAAS,uBACrB;AAGE,UAAM,qBACF,UAAU,QAAS,WAAU,OAAO,UAAU;AAClD,QAAI,uBAAuB,MAAM,OAAO;AACpC,gBAAU,SAAS,MAAM;AACzB,UAAI,UAAU,SAAS,MAAM,OAAO;AAChC,kBAAU,MAAM,KAAK,GAAG,MAAM;AAAA,iBACvB,MAAM,OAAO;AACpB,kBAAU,QAAQ,MAAM;AAAA;AAE5B;AAAA;AAAA;AAIR,SAAO,KAAK;AAAA;;;AC5NT,IAAM,WAAW,OAAO;;;ACmKxB,IAAK,uBAAL,kBAAK,0BAAL;AACH;AACA;AAFQ;AAAA;AAKZ,IAAM,oBAAoB,OAAO;AACjC,IAAM,+BAA+B,OAAO;AA8CrC,uBAAuB,KAAuC;AACjE,SAAO,OAAO,IAAI,UAAU;AAAA;AAGzB,2BAA2B,KAA2C;AACzE,SAAO,OAAO,IAAI,UAAU;AAAA;AAGhC,qBAAwB,GAAM,GAAM;AAChC,SAAO,MAAM;AAAA;AAGjB,sBAA+C,SAA8B;AACzE,OAAK,gBAAgB;AACrB,SAAO;AAAA;AAGX,oBAA6C,IAA6B;AACtE,OAAK,MAAM;AACX,SAAO;AAAA;AAGX,uBAEI,SACkB;AAClB,SAAO;AACP,MAAI;AACA;AAAA,WACK,GAAP;AAAA;AAGF,MAAI,CAAC,KAAK,gBAAgB;AACtB,SAAK,iBAAiB,oBAAI;AAAA;AAE9B,OAAK,eAAe,IAAI;AACxB,QAAM,cAAc,MAAM;AACtB,SAAK,gBAAgB,OAAO;AAC5B,YAAQ;AAAA;AAEZ,QAAM,kBAAkB;AAAA,IACpB,OAAO;AAAA,IACP,aAAa;AAAA;AAEjB,SAAO,OAAO,OAAO,aAAa;AAAA;AAGtC,sBAA6C;AACzC,SAAO;AAAA;AAGX,uBAA8C;AAC1C,SAAO;AAAA;AAGX,+BAAyB,MAAM;AAAA,EAG3B,YAAY,KAAa,mBAAqC;AAC1D,UAAM;AACN,SAAK,oBAAoB;AAAA;AAAA;AAIjC,yBAA4B,aAAgC;AACxD,aAAW;AAEX,QAAM,QAAQ,YAAY;AAC1B,UAAQ;AAAA,SACC;AAED,aAAO,YAAY;AAAA,SAClB;AACD,aAAO,YAAY;AAAA,SAClB;AACD,kBAAY,SAAS;AACrB,kBAAY,SAAS,IAAI,WACrB,6CACA;AAEJ,YAAM,YAAY;AAAA,SACjB;AACD,UAAI,YAAY,WAAW,UAAU;AACjC,cAAM,IAAI,MAAM;AAAA,aACb;AACH,cAAM,IAAI,MACN,iCAAiC,YAAY,OAAO;AAAA;AAG5D;AAAA,SACC,eAAwB;AACzB,YAAM,mBAAoC,oBAAI;AAC9C,UAAI,SAAuB;AAC3B,UAAI;AACJ,kBAAY,SAAS;AACrB,UAAI;AACA,iBAAS,WACL,kBACA,MAAM,YAAY,OAClB,YAAY;AAAA,eAEX,GAAP;AACE,oBAAY;AAAA;AAGhB,UACK,YAAY,WACb,cACF;AAGE,mBAAW,YAAY,kBAAkB;AACrC,kBAAQ;AAAA;AAEZ,YAAI,WAAW;AAAU,gBAAM;AAC/B,eAAO;AAAA;AAMX,UAEK,YAAY,WACb,eACF;AACE,oBAAY,YAAY;AAAA;AAG5B,UAAI,gBAAgB;AACpB,UAAI,oBAAoB;AACxB,UAAI,WAAW;AACX,YAAI,qBAAqB,YAAY;AACjC,0BAAgB;AAChB,8BACI,UAAU,sBAAsB;AAAA;AAExC,cAAM,eAAe,YAAY;AACjC,YAAI,cAAc;AACd,mBAAS,aACL,MACI,gBACM,aACI,eACA,IAAI,MAAM,YAEd,aACI,mBACA,YAEd,YAAY;AAAA;AAIpB,YAAI,eAAe;AACf,4BAAkB;AAAA;AAAA;AAI1B,UAAI,WAAW,UAAU;AACrB,YAAI,UAAU,aAAa;AACvB,iBAAO,YAAY;AAAA;AAEvB,oBAAY,SAAS;AACrB,oBAAY,SAAS;AAAA,aAClB;AACH,oBAAY,OAAO;AACnB,YAAI,YAAY,aAAa;AACzB,iBAAO,YAAY;AAAA;AAEvB,oBAAY,SAAS;AACrB,oBAAY;AAAA;AAGhB,UAAI,YAAY,WAAW;AACvB,mBAAW,mBAAmB,YAAY,WAAW;AACjD,cACI,cAAc,oBACd,CAAC,iBAAiB,IAAI,kBACxB;AACE,2BAAe,iBAAiB;AAAA;AAMpC,kBAAQ;AAAA;AAAA;AAGhB,iBAAW,cAAc,kBAAkB;AACvC,YAAI,cAAc,aAAa;AAC3B,cACI,CAAC,YAAY,aACb,CAAC,YAAY,UAAU,IAAI,aAC7B;AACE,wBAAY,YAAY;AAAA;AAAA;AAAA;AAIpC,kBAAY,YAAY;AAExB,UAAI,WAAW,UAAU;AACrB,cAAM;AAAA,iBACC,iBAAiB,CAAC,mBAAmB;AAC5C,cAAM;AAAA,aACH;AACH,eAAO;AAAA;AAAA;AAAA;AAIX,MAAI,gBAAgB,OAAO;AAAA;AAAA;AAIvC,4BAAmD;AAC/C,YAAU;AACV,OAAK,SAAS;AAAA;AAGlB,2BAAkD;AAC9C,MAAI,KAAK,WAAW;AAChB,eAAW,YAAY,KAAK,WAAW;AACnC,UAAI,cAAc,WAAW;AACzB,uBAAe,UAAU;AAAA;AAE7B,cAAQ;AAAA;AAAA;AAGhB,SAAO,KAAK;AACZ,eAAa;AACb,OAAK,SAAS;AACd,SAAO,KAAK;AAAA;AAGhB,gCAEI,eACF;AACE,UAAQ,KAAK;AAAA,SACJ;AACD,MAAI,KAAK;AACT;AAAA,SACC;AACD,MAAI,KAAK;AACT;AAAA,SACC;AAAA,SACA;AAAA,SACA,gBAAyB;AAC1B,YAAM,cAAc,UAAU,OAAQ,KAAK,OAAa;AACxD,WAAK,SAAS;AACd,UAAI;AACJ,UAAI;AACA,oBAAY,gBAAgB;AAAA,eACvB,GAAP;AACE,aAAK,SAAS;AACd,aAAK,SAAS;AACd,YAAI,KAAK,gBAAgB;AACrB,gBAAM,SAAQ,UAAU,GAAG;AAC3B,qBAAW,gBAAgB,KAAK,gBAAgB;AAC5C,yBACI,mBACA,QACA;AAAA;AAAA;AAIZ,eAAO;AAAA;AAEX,UAAI,gBAAgB,YAAY,KAAK,IAAI,aAAa,YAAY;AAC9D,aAAK,OAAO;AACZ,eAAO;AAAA;AAEX,UAAI,KAAK,gBAAgB;AACrB,mBAAW,gBAAgB,KAAK,gBAAgB;AAC5C,uBAAa,QAAW,WAAW;AAAA;AAAA;AAG3C,aAAO;AAAA;AAAA;AAGP,MAAI,gBAAgB,KAAK,QAAQ;AAAA;AAAA;AAI7C,iCAAwD;AACpD,UAAQ,KAAK;AAAA,SACJ;AACD,MAAI,KAAK;AACT;AAAA,SACC;AACD,MAAI,KAAK;AACT;AAAA,SACC;AACD,aAAO;AAAA,SACN;AACD,WAAK,SAAS;AACd,aAAO;AAAA,SACN;AACD,WAAK,SAAS;AACd,aAAO;AAAA;AAEP,MAAI,gBAAgB,KAAK,QAAQ;AAAA;AAAA;AAI7C,0BAEI,eACF;AACE,UAAQ,KAAK;AAAA,SACJ;AACD,MAAI,KAAK;AACT;AAAA,SACC;AACD,MAAI,KAAK;AACT;AAAA,SACC;AAAA,SACA;AAAA,SACA,eAAwB;AACzB,YAAM,cAAc,UAAU,OAAQ,KAAK,OAAa;AACxD,WAAK,SAAS;AACd,YAAM,eAAe,KAAK;AAC1B,UAAI,cAAc;AACd,aAAK,OAAO,aACR,MACI,aACI,eACA,IAAI,MAAM,WAElB,KAAK;AAET,aAAK,SAAS;AACd,oBAAY;AAAA,aACT;AACH,aAAK,SAAS;AACd,aAAK,SAAS;AACd,YAAI,KAAK,gBAAgB;AACrB,qBAAW,gBAAgB,KAAK,gBAAgB;AAC5C,yBACI,eACA,IAAI,MAAM,UACV;AAAA;AAAA;AAIZ,eAAO;AAAA;AAEX,UAAI,gBAAgB,YAAY,KAAK,IAAI,aAAa,KAAK,OAAO;AAC9D,aAAK,OAAO;AACZ,eAAO;AAAA;AAEX,UAAI,KAAK,gBAAgB;AACrB,mBAAW,gBAAgB,KAAK,gBAAgB;AAC5C,uBAAa,QAAW,KAAK,MAAM;AAAA;AAAA;AAG3C,aAAO;AAAA;AAAA;AAGP,MAAI,gBAAgB,KAAK,QAAQ;AAAA;AAAA;AAItC,cAAiB,IAAa,WAAoB;AACrD,QAAM,kBAAkB;AAAA,IAEpB,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,KAAK;AAAA,IAGL,OAAO;AAAA,IACP,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,SAAS;AAAA,IAGT,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,YAAY;AAAA,IAGZ,eAAe;AAAA,IACf,aAAa,aAAa,GAAG;AAAA,IAC7B,eAAe;AAAA,IACf,SAAS;AAAA,IACT,cAAc;AAAA;AAElB,QAAM,cAA8B,OAAO,OACvC,MAAM,gBAAgB,cACtB;AAEJ,eAAa;AACb,SAAO;AAAA;;;AC1lBJ,kBAAkD;AAAA,EAWrD,YAAY,KAAQ,WAAoB;AACpC,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,eAAe;AAEpB,SAAK,gBAAgB;AACrB,SAAK,aAAa;AAElB,SAAK,cAAc,aAAa;AAAA;AAAA,EAGpC,MAAS;AACL,eAAW;AACX,WAAO,KAAK;AAAA;AAAA,EAGhB,IAAI,QAAW;AACX,QAAI,WAAW,KAAK,MAAM;AACtB,UAAI,KAAK,cAAc;AACnB,aAAK,gBAAgB;AAAA;AAEzB,WAAK,OAAO;AACZ,UAAI,KAAK,UAAU;AACf,kBAAU;AAAA;AAAA;AAAA;AAAA,EAKtB,UAAU,YAA4C;AAClD,QAAI,CAAC,KAAK;AAAc,WAAK,eAAe,oBAAI;AAChD,SAAK,aAAa,IAAI,YAAY,KAAK;AACvC,WAAO,MAAM,KAAK,cAAc,OAAO;AAAA;AAAA,EAG3C,UAAU;AACN,SAAK,WAAW;AAChB,cAAU;AAAA;AAAA,EAGd,SAAS;AACL,iBAAa;AACb,SAAK,WAAW;AAAA;AAAA,EAGpB,gBAAgB;AACZ,IAAI,OAAO,KAAK,UAAU;AAC1B,QAAI,KAAK,cAAc;AACnB,iBAAW,CAAC,YAAY,iBAAiB,KAAK,cAAc;AACxD,YAAI,eAAe,KAAK,cAAc;AAClC,qBAAW,KAAK;AAAA;AAEpB,aAAK,aAAa,IAAI,YAAY;AAAA;AAEtC,WAAK,eAAe;AAAA;AAExB,WAAO;AAAA;AAAA;AAIR,eAAkB,KAAQ,WAA8B;AAC3D,SAAO,IAAI,MAAM,KAAK;AAAA;;;ACzEnB,qBAAqC;AAAA,EASxC,YACI,WACA,UACA,SACA,WACF;AACE,SAAK,aAAa;AAClB,SAAK,cAAc,aAAa;AAChC,SAAK,YAAY;AACjB,SAAK,WAAW,oBAAI;AACpB,SAAK,WAAW;AAChB,SAAK,UAAU;AAAA;AAAA,EAGnB,UAAU,MAAc,KAAU;AAC9B,QAAI,SAAQ,KAAK,SAAS,IAAI;AAC9B,QAAI,CAAC,QAAO;AACR,eAAQ,IAAI,MAAM,KAAK,GAAG,KAAK,eAAe;AAC9C,WAAK,SAAS,IAAI,MAAM;AAExB,UAAI,KAAK,aAAa,GAAG;AACrB,eAAO;AACP,YAAI,KAAK;AAAU,sBAAY,KAAK,UAAU;AAC9C,YAAI,KAAK;AAAS,sBAAY,QAAO,KAAK;AAAA;AAAA;AAGlD,WAAO;AAAA;AAAA,EAGX,IAAI,MAAc,KAAU;AACxB,UAAM,SAAQ,KAAK,UAAU,MAAM;AACnC,WAAO,OAAM,IAAI;AAAA;AAAA,EAGrB,OAAO,MAAc;AACjB,UAAM,SAAQ,KAAK,SAAS,IAAI;AAChC,QAAI,QAAO;AACP,aAAM,IAAI;AACV,WAAK,SAAS,OAAO;AAErB,UAAI,KAAK,aAAa,GAAG;AACrB,YAAI,KAAK;AAAS,yBAAe,QAAO,KAAK;AAC7C,YAAI,KAAK;AAAU,yBAAe,KAAK,UAAU;AACjD,gBAAQ;AAAA;AAAA;AAAA;AAAA,EAKpB,SAAS;AACL,eAAW,UAAS,KAAK,SAAS,UAAU;AACxC,UAAI,KAAK;AAAS,uBAAe,QAAO,KAAK;AAC7C,UAAI,KAAK;AAAU,uBAAe,KAAK,UAAU;AACjD,cAAQ;AAAA;AAGZ,QAAI,KAAK;AAAS,qBAAe,KAAK,WAAW,KAAK;AACtD,QAAI,KAAK;AAAU,qBAAe,KAAK,UAAU,KAAK;AACtD,YAAQ,KAAK;AAEb,QAAI,KAAK;AAAS,cAAQ,KAAK;AAC/B,QAAI,KAAK;AAAU,cAAQ,KAAK;AAAA;AAAA,EAGpC,UAAU;AACN,QAAI,KAAK;AAAS,aAAO,KAAK;AAC9B,QAAI,KAAK;AAAU,aAAO,KAAK;AAE/B,WAAO,KAAK;AACZ,QAAI,KAAK;AAAS,kBAAY,KAAK,WAAW,KAAK;AACnD,QAAI,KAAK;AAAU,kBAAY,KAAK,UAAU,KAAK;AAEnD,eAAW,UAAS,KAAK,SAAS,UAAU;AACxC,aAAO;AACP,UAAI,KAAK;AAAS,oBAAY,QAAO,KAAK;AAC1C,UAAI,KAAK;AAAU,oBAAY,KAAK,UAAU;AAAA;AAAA;AAAA;;;AChFnD,gCAEP;AAAA,EAgBI,gBAAgB;AACZ,eAAW,cAAc,KAAK,aAAa;AACvC,iBAAW,QAAQ,WAAW;AAC9B,iBAAW,SAAS;AAAA;AAExB,WAAO;AAAA;AAAA,EAMX,UAAU;AACN,SAAK,WAAW;AAChB,cAAU;AAAA;AAAA,EAGd,SAAS;AACL,IAAI,OACA,KAAK,YAAY,WAAW,GAC5B;AAEJ,iBAAa;AACb,SAAK,WAAW;AAAA;AAAA,EAGpB,YACI,aACA,WACF;AACE,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,WAAW;AAChB,SAAK,aAAa;AAClB,SAAK,gBAAgB;AACrB,SAAK,cAAc,WAAW;AAAA;AAAA,EAGlC,SAAS,OAAmB;AACxB,QAAI,CAAC,KAAK;AAAU;AACpB,QAAI,aAAa;AACjB,eAAW,cAAc,KAAK,aAAa;AACvC,UAAI,WAAW,OAAO,WAAW;AAAG,qBAAa;AACjD,WAAK,YAAY,WAAW,QAAQ;AAAA;AAExC,QAAI,YAAY;AACZ,gBAAU;AAAA;AAAA;AAAA,EAIlB,UAAU,SAAiD;AACvD,SAAK,YAAY,KAAK,EAAE,SAAS,QAAQ;AACzC,WAAO,MAAM;AACT,YAAM,QAAQ,KAAK,YAAY,UAC3B,CAAC,eAAe,WAAW,YAAY;AAE3C,UAAI,UAAU;AAAI;AAClB,WAAK,YAAY,OAAO,OAAO;AAAA;AAAA;AAAA;;;AChEpC,iCAEP;AAAA,EAsBI,gBAAgB;AACZ,eAAW,aAAa,KAAK,QAAQ,KAAK,QAAQ,KAAK,SAAS;AAC5D,WAAK,iBAAiB,SAAS;AAAA;AAEnC,SAAK,OAAO,OAAO,GAAG,KAAK,OAAO;AAClC,WAAO;AAAA;AAAA,EAMX,UAAU;AACN,SAAK,WAAW;AAChB,cAAU;AACV,WAAO,KAAK;AACZ,gBAAY,KAAK,eAAe;AAChC,SAAK,cAAc,KAAK,cAAc,UAAU,CAAC,WAAW;AACxD,iBAAW,SAAS,QAAQ;AACxB,aAAK,SAAS;AAAA;AAAA;AAAA;AAAA,EAK1B,SAAS;AACL,QAAI,KAAK,aAAa;AAClB,WAAK;AACL,qBAAe,KAAK,eAAe;AACnC,cAAQ,KAAK;AAAA;AAEjB,SAAK,OAAO,OAAO,GAAG,KAAK,OAAO;AAClC,iBAAa;AACb,SAAK,WAAW;AAAA;AAAA,EAGpB,YACI,QACA,eACA,kBACA,SACA,aACA,WACF;AACE,SAAK,SAAS;AACd,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,WAAW;AAChB,SAAK,gBAAgB;AACrB,SAAK,mBAAmB;AACxB,SAAK,cAAc;AACnB,SAAK,aAAa;AAClB,SAAK,gBAAgB;AACrB,SAAK,cAAc,YAAY;AAAA;AAAA,EAGnC,SAAS,OAAsB;AAC3B,QAAI,CAAC,KAAK;AAAU;AACpB,UAAM,aAAa,KAAK,OAAO,WAAW;AAC1C,SAAK,YAAY,KAAK,QAAQ;AAC9B,QAAI,YAAY;AACZ,gBAAU;AAAA;AAAA;AAAA,EAIlB,SAAS,QAAmB;AACxB,QAAI,KAAK,UAAU;AACf,aAAO;AACP,kBAAY,MAAM;AAAA;AAAA;AAAA,EAI1B,YAAY,QAAmB;AAC3B,QAAI,KAAK,UAAU;AACf,qBAAe,MAAM;AACrB,cAAQ;AAAA;AAAA;AAAA;;;AClHb,8BAKL;AAAA,EAmBE,YACI,QACA,cACA,SACA,gBACA,cAMA,iBACA,oBAIA,YAAY,eACd;AACE,SAAK,SAAS;AACd,SAAK,UAAU;AAEf,SAAK,UAAU,IAAI,oBACf,iBACA;AAGJ,QAAI,kBAAkB,cAAc;AAChC,WAAK,WAAW,IAAI,qBAChB,QACA,gBACA,KAAK,SACL,cACA,oBACA;AAAA,WAED;AACH,WAAK,WAAW;AAAA;AAGpB,SAAK,OAAO,IAAI,IAAY,OAAO,KAAK;AACxC,SAAK,YAAY,IAAI,MAAM,KAAK,KAAK,MAAM,GAAG;AAC9C,SAAK,WAAW,IAAI,SAChB,KAAK,WACL,KAAK,UACL,KAAK,SACL;AAGJ,UAAM,YAAY,CAAC,UAAsB;AACrC,WAAK,QAAQ,SAAS;AAAA;AAG1B,SAAK,eAAe;AAAA,MAChB,KAAK,CAAC,MAAM,aAAa;AACrB,YAAI,SAAS,cAAc;AACvB,iBAAO;AAAA;AAEX,YAAI,SAAS,eAAe;AACxB,iBAAO;AAAA;AAEX,YAAI,SAAS,iBAAiB;AAC1B,iBAAO;AAAA;AAEX,YACI,SAAS,gBACT,SAAS,aACT,SAAS,UACX;AACE,iBAAO,QAAQ;AAAA;AAEnB,YAAI,OAAO,SAAS,UAAU;AAC1B,iBAAO,QAAQ,IAAI,KAAK,QAAQ,MAAM;AAAA;AAE1C,YAAI,QAAQ,SAAS;AACjB,iBAAQ,QAAgB;AAAA;AAE5B,cAAM,QAAQ,QAAQ,IAAI,KAAK,QAAQ,MAAM;AAC7C,cAAM,SAAQ,KAAK,SAAS,UAAU,MAAM;AAC5C,mBAAW,KAAK,UAAU;AAC1B,mBAAW;AACX,eAAO;AAAA;AAAA,MAEX,SAAS,CAAC,SAAS;AACf,eAAO,QAAQ,IAAI,QAAQ;AAAA;AAAA,MAE/B,KAAK,CAAC,SAAS;AACX,YACI,SAAS,gBACT,SAAS,aACT,SAAS,UACX;AACE,iBAAO,QAAQ;AAAA;AAEnB,YAAI,SAAS,iBAAiB;AAC1B,iBAAO;AAAA;AAEX,YAAI,QAAQ,SAAS;AACjB,iBAAO;AAAA;AAEX,YAAI,OAAO,SAAS,UAAU;AAC1B,iBAAO,QAAQ,IAAI,KAAK,QAAQ;AAAA;AAEpC,cAAM,QAAQ,QAAQ,IAAI,QAAQ;AAClC,cAAM,SAAQ,KAAK,SAAS,UAAU,MAAM;AAC5C,mBAAW,KAAK,UAAU;AAC1B,mBAAW;AACX,eAAO;AAAA;AAAA,MAEX,KAAK,CAAC,MAAM,OAAO,aAAa;AAC5B,YAAI,SAAS,cAAc;AACvB,kBAAQ,QAAQ;AAChB,iBAAO;AAAA;AAEX,YAAI,QAAQ,SAAS;AACjB,iBAAO;AAAA;AAEX,YAAI,OAAO,SAAS,UAAU;AAC1B,iBAAO,QAAQ,IAAI,KAAK,QAAQ,MAAM,OAAO;AAAA;AAEjD,cAAM,UAAU,QAAQ,IAAI,QAAQ;AACpC,cAAM,SAAQ,KAAK,SAAS,UAAU,MAAM;AAC5C,eAAM,IAAI;AACV,YAAI,CAAC,SAAS;AACV,eAAK,KAAK,IAAI;AACd,eAAK,UAAU,IAAI,KAAK,KAAK;AAAA;AAEjC,eAAO,QAAQ,IAAI,QAAQ,MAAM,OAAO,KAAK,UAAU;AAAA;AAAA,MAE3D,QAAQ,CAAC,SAAS;AACd,YACI,SAAS,gBACT,SAAS,aACT,SAAS,YACT,SAAS,iBACX;AACE,iBAAO;AAAA;AAEX,YAAI,QAAQ,SAAS;AACjB,iBAAO;AAAA;AAEX,YAAI,OAAO,SAAS,UAAU;AAC1B,iBAAO,QAAQ,eAAe,KAAK,QAAQ;AAAA;AAE/C,cAAM,UAAU,QAAQ,IAAI,QAAQ;AACpC,cAAM,SAAS,QAAQ,eAAe,QAAQ;AAC9C,YAAI,SAAS;AACT,eAAK,KAAK,OAAO;AACjB,eAAK,UAAU,IAAI,KAAK,KAAK;AAC7B,eAAK,SAAS,OAAO;AAAA;AAEzB,eAAO;AAAA;AAAA;AAIf,SAAK,YAAY,MAAM,UAErB,QAAmE;AAAA,MACjE,KAAK,CAAC,SAAQ,MAAM,aAChB,aAAa,IAAI,KAAK,cAAc,WAAW,MAAM;AAAA,MACzD,KAAK,CAAC,SAAQ,SACV,aAAa,IAAI,KAAK,cAAc,WAAW;AAAA,MACnD,KAAK,CAAC,SAAQ,MAAM,OAAO,aACvB,aAAa,IACT,KAAK,cACL,WACA,MACA,OACA;AAAA,MAER,gBAAgB,CAAC,SAAQ,SACrB,aAAa,OAAO,KAAK,cAAc,WAAW;AAAA,MACtD,SAAS,MAAM;AACX,cAAM,OAAO,KAAK;AAClB,aAAK,UAAU;AACf,eAAO,CAAC,GAAG;AAAA;AAAA;AAInB,iBAAa,KAAK,UAAU;AAAA;AAAA;AAmB7B,8BAMH,aACyE;AACzE,SAAO,YAAY;AAAA;;;AC9LhB,mCAAyD;AAC5D,SAAO;AAAA,IACH,OAAO;AAAA,IAGP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,KAAK;AAAA,IACL,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN,SAAS;AAAA,IAGT,QAAQ;AAAA,IACR,WAAW;AAAA,IAGX;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IAGX,YAAY;AAAA,IACZ,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,aAAa;AAAA;AAAA;AA+Bd,2BACH,kBACW;AACX,SAAO;AAAA,IACH,OAAO;AAAA,IAGP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,KAAK;AAAA,IACL,OAAO;AAAA,IACP,SAAS;AAAA,IACT,MAAM;AAAA,IACN,SAAS;AAAA,IAGT;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW;AAAA,IAGX,YAAY;AAAA,IACZ,UAAuB;AACnB,aAAO;AACP,YAAM,WAAW,qBAAqB;AACtC,MAAI,OAAO,UAAU;AACrB,aAAO,SAAS;AAAA;AAAA,IAEpB,SAAsB;AAClB,YAAM,WAAW,qBAAqB;AACtC,MAAI,OAAO,UAAU;AACrB,cAAQ,SAAS;AACjB,cAAQ;AAAA;AAAA,IAEZ,aAAa;AAAA;AAAA;AAiBd,sBAAsB,KAAkC;AAC3D,SAAO,OAAO,IAAI,UAAU;AAAA;AAGzB,gBAAgB,KAA4B;AAC/C,SAAO,OAAO,IAAI,UAAU;AAAA;AAGzB,IAAM,oBAAmD;AAAA,EAC5D,KAAK,CAAC,cAAc,SAAS,MAAM,aAAa;AAC5C,WAAO,aAAa,IAAI,MAAM;AAAA;AAAA,EAElC,KAAK,CAAC,cAAc,SAAS,SAAS;AAClC,WAAO,aAAa,IAAI;AAAA;AAAA,EAE5B,KAAK,CAAC,cAAc,SAAS,MAAM,OAAO,aAAa;AACnD,QAAI,OAAO,SAAS,UAAU;AAC1B,YAAM,cAAc,SAAS,MAAM;AACnC,UAAI,CAAC,MAAM,cAAc;AACrB,gBAAQ;AAAA,UACJ,MAAM;AAAA,UACN,OAAO;AAAA,UACP,OAAO;AAAA,UACP,OAAO,CAAC;AAAA;AAAA;AAAA;AAIpB,WAAO,aAAa,IAAI,MAAM,OAAO;AAAA;AAAA,EAEzC,QAAQ,CAAC,cAAc,SAAS,SAAS;AACrC,WAAO,aAAa,OAAO;AAAA;AAAA;AAI5B,IAAM,cAA6C;AAAA,EACtD,KAAK,CAAC,cAAc,SAAS,MAAM,aAAa;AAC5C,WAAO,aAAa,IAAI,MAAM;AAAA;AAAA,EAElC,KAAK,CAAC,cAAc,SAAS,SAAS;AAClC,WAAO,aAAa,IAAI;AAAA;AAAA,EAE5B,KAAK,CAAC,cAAc,SAAS,MAAM,OAAO,aAAa;AACnD,QAAI,SAAS,cAAc;AACvB,aAAO,aAAa,IAAI,MAAM,OAAO;AAAA;AAEzC,IAAI,KAAK;AAAA;AAAA,EAEb,QAAQ,CAAC,cAAc,SAAS,SAAS;AACrC,IAAI,KAAK;AAAA;AAAA;AAIV,oBAAuB,OAAY,WAAmC;AACzE,QAAM,SAAS,IAAI,kBAMf,OACA,mBACA,2BACA,MACA,MACA,eACA,eACA;AAEJ,SAAO,OAAO,UAAU;AAAA;AAG5B,oBAEI,OACA,UACG,OACE;AACL,EAAI,KAAK;AAAA;AAGb,qBACI,UAMA,OACA,UACG,OACL;AACE,QAAM,cAAc,SAAS,OAAO;AACpC,QAAM,UAAU,MAAM,UAAU,OAAO,KACnC,SAAS,QACT,OACA,OACA,GAAG;AAEP,QAAM,YAAY,SAAS,OAAO;AAClC,MAAI,gBAAgB,WAAW;AAE3B,aAAS,IAAI,OAAO,IAAI,QAAQ,MAAM,QAAQ,EAAE,GAAG;AAC/C,eAAS,SAAS,IAAI,EAAE,YAAY,SAAS,OAAO;AAAA;AAAA,SAErD;AAEH,aAAS,IAAI,OAAO,IAAI,WAAW,EAAE,GAAG;AACpC,eAAS,SAAS,IAAI,EAAE,YAAY,SAAS,OAAO;AAAA;AAGxD,aAAS,IAAI,WAAW,IAAI,aAAa,EAAE,GAAG;AAC1C,eAAS,SAAS,OAAO,EAAE;AAAA;AAE/B,aAAS,SAAS,IAAI,UAAU;AAAA;AAEpC,WAAS,QAAQ,SAAS;AAAA,IACtB,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA;AAEJ,SAAO;AAAA;AAGX,0BAEI,OACA,QAAQ,MACL,OACL;AACE,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,SAAO,YAAY,UAAU,OAAO,OAAO,GAAG;AAAA;AAGlD,qBAAuC,OAAmB;AACtD,EAAI,KAAK;AAAA;AAGb,2BAAmD,OAAY;AAC3D,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,cAAY,UAAU,SAAS,OAAO,QAAQ,GAAG,GAAG;AACpD,SAAO,SAAS,OAAO;AAAA;AAG3B,mBAA0C;AACtC,EAAI,KAAK;AAAA;AAGb,yBAA8D;AAC1D,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,SAAO,YAAY,UAAU,SAAS,OAAO,SAAS,GAAG,GAAG;AAAA;AAGhE,qBAA4C;AACxC,EAAI,KAAK;AAAA;AAGb,2BAAgE;AAC5D,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,SAAO,YAAY,UAAU,GAAG,GAAG;AAAA;AAGvC,wBAA0C,OAAmB;AACzD,EAAI,KAAK;AAAA;AAGb,8BAAsD,OAAY;AAC9D,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,cAAY,UAAU,GAAG,GAAG,GAAG;AAC/B,SAAO,SAAS,OAAO;AAAA;AAG3B,0BAEI,MACG;AACH,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AAErB,MAAI,QAAuB;AAC3B,MAAI,SAAS,SAAS,OAAO;AAC7B,MAAI,WAAW;AACf,QAAM,UAAe;AACrB,WAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC7B,eAAW,KAAK,SAAS,OAAO;AAChC,QAAI,YAAY,UAAU,MAAM;AAC5B,cAAQ;AAAA;AAEZ,QAAI,CAAC,YAAY,UAAU,MAAM;AAC7B,YAAM,QAAQ,IAAI;AAClB,cAAQ,KAAK,GAAG,YAAY,UAAU,OAAO;AAC7C,gBAAU;AACV,WAAK;AACL,cAAQ;AAAA;AAAA;AAGhB,MAAI,UAAU,MAAM;AAChB,UAAM,QAAQ,SAAS;AACvB,YAAQ,KAAK,GAAG,YAAY,UAAU,OAAO;AAAA;AAEjD,SAAO;AAAA;AAGX,6BAEI,WACA,OACA,SACF;AACE,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,QAAM,UAAU,SAAS,OAAO,OAAO,WAAW;AAClD,WAAS,OAAO,OAAO,SAAS,GAAG,GAAG;AACtC,WAAS,QAAQ,SAAS;AAAA,IACtB,MAAM;AAAA,IACN,MAAM;AAAA,IACN;AAAA,IACA,IAAI;AAAA;AAAA;AAIZ,6BAEI,SACF;AACE,QAAM,WAAW,qBAKf;AACF,EAAI,OAAO,UAAU;AACrB,SAAO,SAAS;AAChB,QAAM,cAAc,SAAS,QAAQ,UAAU,CAAC,WAAW;AACvD,YAAQ;AAAA;AAEZ,SAAO,MAAM;AACT;AACA,YAAQ,SAAS;AAAA;AAAA;AAIzB,2BAAiD;AAC7C,QAAM,WAAW,qBAKf;AACF,EAAI,OAAO,UAAU;AACrB,SAAO,SAAS;AAAA;AAGpB,0BAAgD;AAC5C,QAAM,WAAW,qBAKf;AACF,EAAI,OAAO,UAAU;AACrB,UAAQ,SAAS;AAAA;AAGrB,kBAEI,QACK;AACL,EAAI,KAAK;AAAA;AAGb,uBAAoD;AAChD,EAAI,KAAK;AAAA;AAIb,qBAAqB,GAAQ,GAAQ;AACjC,MAAI,MAAM,UAAa,MAAM;AAAW,WAAO;AAC/C,MAAI,MAAM;AAAW,WAAO;AAC5B,MAAI,MAAM;AAAW,WAAO;AAC5B,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,MAAI,OAAO;AAAM,WAAO;AACxB,MAAI,OAAO;AAAM,WAAO;AACxB,SAAO;AAAA;AAGX,wBAEI,SAAiC,aACnC;AACE,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,MAAI,UAA2B;AAC/B,MAAI,SAAS,SAAS;AAClB,cAAW,SAAS,OACf,IAAI,CAAC,SAAY,UAAkB,OACnC,KAAK,CAAC,GAAG,MAAM,OAAO,SAAS,OAAO,IAAI,SAAS,OAAO;AAAA;AAEnE,WAAS,OAAO,KAAK;AACrB,MAAI,SAAS;AACT,aAAS,QAAQ,SAAS;AAAA,MACtB,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA;AAAA;AAKR,WAAS,IAAI,GAAG,IAAI,SAAS,OAAO,QAAQ,EAAE,GAAG;AAC7C,aAAS,SAAS,IAAI,EAAE,YAAY,SAAS,OAAO;AAAA;AAExD,SAAO;AAAA;AAGX,6BAAmD;AAC/C,QAAM,WAAW,qBAAqB;AACtC,EAAI,OAAO,UAAU;AACrB,WAAS,OAAO;AAChB,MAAI,SAAS,SAAS;AAClB,UAAM,UAAoB;AAC1B,aAAS,IAAI,SAAS,OAAO,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAClD,cAAQ,KAAK;AAAA;AAEjB,aAAS,QAAQ,SAAS;AAAA,MACtB,MAAM;AAAA,MACN,MAAM;AAAA,MACN;AAAA;AAAA;AAKR,WAAS,IAAI,GAAG,IAAI,SAAS,OAAO,QAAQ,EAAE,GAAG;AAC7C,aAAS,SAAS,IAAI,EAAE,YAAY,SAAS,OAAO;AAAA;AAExD,SAAO;AAAA;AAGX,iBAEI,IACA,WACsB;AACtB,SAAO,gBAAgB,MAAM,CAAC,SAAY,CAAC,GAAG,QAAQ;AAAA;AAE1D,oBAEI,IACA,WACsB;AACtB,SAAO,gBACH,MACA,CAAC,SAAa,GAAG,QAAQ,CAAC,QAAQ,IAClC;AAAA;AAGR,qBAEI,IACA,WACsB;AACtB,SAAO,gBAAgB,MAAM,IAAI;AAAA;AAGrC,yBACI,kBACA,SACA,WACsB;AACtB,QAAM,iBAAiB,qBAKrB;AACF,EAAI,OAAO,gBAAgB;AAC3B,QAAM,YAAsB;AAC5B,QAAM,mBAAwB;AAE9B,eAAa,MAAM;AACf,eAAW,QAAQ,kBAAkB;AACjC,YAAM,OAAO,QAAQ;AACrB,gBAAU,KAAK,KAAK;AACpB,uBAAiB,KAAK,GAAG;AAAA;AAAA;AAIjC,QAAM,oBAAoB,IAAI,kBAM1B,kBACA,aACA,kBAAkB,mBAClB,eAAe,SACf,WAAW,QAAQ,QAAyB;AACxC,eAAW,SAAS,QAAQ;AACxB,YAAM,cAAc,iBAAiB;AAErC,aAAO,kBACH,WACA,SACA,kBACA;AAGJ,cAAQ,MAAM;AAAA,aACL,uBAAuB;AACxB,gBAAM,YAAY,iBAAiB;AACnC,cAAI,gBAAgB,WAAW;AAC3B,qBACQ,IAAI,MAAM,OACd,IAAI,MAAM,QAAQ,MAAM,OACxB,EAAE,GACJ;AACE,gCAAkB,SAAS,IACvB,EAAE,YACF,iBAAiB;AAAA;AAAA,iBAGtB;AACH,qBAAS,IAAI,MAAM,OAAO,IAAI,WAAW,EAAE,GAAG;AAC1C,gCAAkB,SAAS,IACvB,EAAE,YACF,iBAAiB;AAAA;AAGzB,qBAAS,IAAI,WAAW,IAAI,aAAa,EAAE,GAAG;AAC1C,gCAAkB,SAAS,OAAO,EAAE;AAAA;AAExC,8BAAkB,SAAS,IAAI,UAAU;AAAA;AAE7C;AAAA;AAAA,aAEC,mBAAqB;AACtB,gBAAM,aAAa,KAAK,IAAI,MAAM,MAAM,MAAM;AAC9C,gBAAM,aAAa,KAAK,IACpB,MAAM,OAAO,MAAM,OACnB,MAAM,KAAK,MAAM;AAErB,mBAAS,IAAI,YAAY,IAAI,YAAY,EAAE,GAAG;AAC1C,8BAAkB,SAAS,IACvB,EAAE,YACF,iBAAiB;AAAA;AAGzB;AAAA;AAAA,aAEC;AACD,mBACQ,IAAI,MAAM,MACd,IAAI,MAAM,OAAO,MAAM,QAAQ,QAC/B,EAAE,GACJ;AACE,8BAAkB,SAAS,IACvB,EAAE,YACF,iBAAiB;AAAA;AAGzB;AAAA;AAAA;AAAA,KAIhB,eACA,eACA,aAAa;AAGjB,SAAO,kBAAkB,UAAU;AAAA;;;ACxjBhC,0BACH,KACyC;AACzC,SAAO,OAAO,IAAI,qBAAqB;AAAA;AAGpC,2BAEP;AAAA,EAEI,YAAY,OAAe;AACvB,SAAK,QAAQ;AAAA;AAAA;AAYd,IAAM,iBAAiB,OAAO;AAQrC,qCACI,aACA,WACF;AACE,SACK,gBAAgB,wBACb,cAAc,0BACjB,gBAAgB,0BACb,cAAc,sBACjB,gBAAgB,sBACb,cAAc,sBACjB,gBAAgB,sBACb,cAAc;AAAA;AAe1B,aAAa,QAAoB,OAAmB;AAChD,MAAI,UAAU;AAAiB;AAC/B,SAAO;AAAA;AAGX,gBAAgB,QAAoB,OAAmB;AACnD,MAAI,UAAU;AAAiB;AAC/B,UAAQ;AAAA;AAML,4BAA4C;AAAA,EAG/C,cAAc;AACV,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,aAAa;AAAA;AAAA,EAGtB,SAAS;AAAA;AAAA,EACT,SAAS;AAAA;AAAA,EACT,aAAa;AAAA;AAAA,EACb,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAEZ,SAAS;AAAA;AAAA,EAOT,UAAU;AAAA;AAAA,EACV,SAAS;AACL,qBAAiB;AAAA;AAAA;AAOlB,IAAM,kBAAkB,IAAI;AAK5B,2BAA2C;AAAA,EAM9C,YAAY,QAAgB,WAAoB;AAC5C,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,OAAO,SAAS,eAAe;AAEpC,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA;AAAA,EAGtB,SAAS;AACL,SAAK,UAAU,EAAE,MAAM,uBAAuB,OAAO,GAAG,OAAO;AAC/D,SAAK,UAAU;AAAA;AAAA,EAGnB,OAAO,SAAsB;AACzB,IAAI,OAAO,CAAC,KAAK,SAAS;AAC1B,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,MACX,MAAM;AAAA,MACN,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO,CAAC,KAAK;AAAA;AAAA;AAAA,EAIrB,aAAa;AAAA;AAAA,EACb,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAEZ,SAAS;AAAA;AAAA,EAOT,UAAU;AAAA;AAAA,EACV,SAAS;AACL,SAAK,UAAU;AACf,qBAAiB;AAAA;AAAA;AAOlB,8BAA8C;AAAA,EAMjD,YAAY,MAAY,WAAoB;AACxC,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,OAAO;AAEZ,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA;AAAA,EAGtB,SAAS;AACL,SAAK,UAAU,EAAE,MAAM,uBAAuB,OAAO,GAAG,OAAO;AAC/D,SAAK,UAAU;AAAA;AAAA,EAGnB,OAAO,SAAsB;AACzB,IAAI,OAAO,CAAC,KAAK,SAAS;AAC1B,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,MACX,MAAM;AAAA,MACN,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO,CAAC,KAAK;AAAA;AAAA;AAAA,EAIrB,aAAa;AAAA;AAAA,EACb,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAEZ,SAAS;AAAA;AAAA,EAOT,UAAU;AAAA;AAAA,EACV,SAAS;AACL,SAAK,UAAU;AACf,qBAAiB;AAAA;AAAA;AAOlB,4BAA4C;AAAA,EAQ/C,YAAY,UAAwB,WAAoB;AACpD,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,WAAW;AAChB,SAAK,YAAY,SAAS,IAAI,MAAM;AACpC,SAAK,WAAW,SAAS,IAAI,MAAM;AAEnC,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA;AAAA,EAGtB,SAAS;AACL,eAAW,CAAC,OAAO,UAAU,KAAK,SAAS,WAAW;AAClD,UAAI,KAAK,SAAS,QAAQ;AACtB,cAAM;AACN,aAAK,SAAS,SAAS;AAAA;AAAA;AAG/B,SAAK,UAAU;AAAA;AAAA,EAGnB,OAAO,SAAsB,oBAA4B;AACrD,SAAK,UAAU;AACf,eAAW,CAAC,OAAO,UAAU,KAAK,SAAS,WAAW;AAClD,YAAM,OAAO,CAAC,UAAU;AACpB,YAAI,KAAK,SAAS;AACd,cAAI,iBAAiB,OAAO;AACxB,iBAAK,QAAQ;AAAA,iBACV;AACH,uBAAW,KAAK,WAAW,OAAO;AAClC,iBAAK,QAAQ;AAAA;AAAA;AAAA,SAGtB;AACH,WAAK,SAAS,SAAS;AAAA;AAAA;AAAA,EAI/B,WAAW,WAAoB;AAC3B,eAAW,SAAS,KAAK,UAAU;AAC/B,YAAM,WAAW;AAAA;AAAA;AAAA,EAGzB,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAEZ,OAAO,OAA8B;AACjC,QAAI,4BAA4B,KAAK,cAAc,QAAQ;AACvD,iBAAW,SAAS,KAAK,UAAU;AAC/B,cAAM,OAAO;AAAA;AAEjB,WAAK,eAAe;AAAA;AAAA;AAAA,EAO5B,UAAU;AACN,eAAW,SAAS,KAAK,UAAU;AAC/B,UAAI,MAAM;AAAA;AAAA;AAAA,EAGlB,SAAS;AACL,eAAW,SAAS,KAAK,UAAU;AAC/B,aAAO,MAAM;AAAA;AAEjB,qBAAiB;AACjB,SAAK,UAAU;AAAA;AAAA;AAIvB,IAAM,iBAAiB;AACvB,IAAM,gBAAgB;AACtB,IAAM,mBAAmB;AAEzB,IAAM,0BAA8D;AAAA,EAEhE,GAAG;AAAA,EACH,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM;AAAA,EACN,SAAS;AAAA,EACT,OAAO;AAAA,EACP,OAAO;AAAA,EACP,GAAG;AAAA,EACH,MAAM;AAAA,EACN,KAAK;AAAA,EACL,KAAK;AAAA,EACL,YAAY;AAAA,EACZ,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,UAAU;AAAA,EACV,MAAM;AAAA,EACN,UAAU;AAAA,EACV,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,GAAG;AAAA,EACH,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EAEN,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,KAAK;AAAA,EACL,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,IAAI;AAAA,EACJ,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,GAAG;AAAA,EACH,SAAS;AAAA,EACT,KAAK;AAAA,EACL,UAAU;AAAA,EACV,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,GAAG;AAAA,EACH,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,KAAK;AAAA,EACL,SAAS;AAAA,EACT,KAAK;AAAA,EAEL,OAAO;AAAA,EACP,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,UAAU;AAAA,EACV,UAAU;AAAA,EACV,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,MAAM;AAAA,EACN,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EAIL,SAAS;AAAA,EACT,eAAe;AAAA,EACf,kBAAkB;AAAA,EAClB,QAAQ;AAAA,EACR,UAAU;AAAA,EACV,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,eAAe;AAAA,EACf,qBAAqB;AAAA,EACrB,aAAa;AAAA,EACb,kBAAkB;AAAA,EAClB,mBAAmB;AAAA,EACnB,mBAAmB;AAAA,EACnB,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,gBAAgB;AAAA,EAChB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,aAAa;AAAA,EACb,cAAc;AAAA,EACd,UAAU;AAAA,EACV,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,aAAa;AAAA,EACb,QAAQ;AAAA,EACR,cAAc;AAAA,EACd,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,GAAG;AAAA,EACH,OAAO;AAAA,EACP,WAAW;AAAA,EACX,OAAO;AAAA,EACP,MAAM;AAAA,EACN,gBAAgB;AAAA,EAChB,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,UAAU;AAAA,EACV,OAAO;AAAA,EACP,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,EACV,gBAAgB;AAAA,EAChB,MAAM;AAAA,EAEN,KAAK;AAAA,EACL,MAAM;AAAA,EAEN,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,UAAU;AAAA,EAEV,OAAO;AAAA,EACP,KAAK;AAAA,EACL,MAAM;AAAA,EAGN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,OAAO;AAAA,EACP,IAAI;AAAA,EACJ,eAAe;AAAA,EACf,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb,OAAO;AAAA,EACP,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,OAAO;AAAA,EACP,KAAK;AAAA,EACL,QAAQ;AAAA,EACR,YAAY;AAAA;AAGhB,IAAM,gCAGF;AAAA,GACC,iBAAiB;AAAA,IACd,KAAK;AAAA,MACD,MAAM;AAAA,MACN,UAAU;AAAA;AAAA,IAEd,MAAM;AAAA,MACF,MAAM;AAAA,MACN,UAAU;AAAA;AAAA;AAAA,GAGjB,gBAAgB;AAAA,IACb,eAAe;AAAA,MACX,MAAM;AAAA,MACN,UAAU;AAAA;AAAA;AAAA;AAKtB,IAAM,aAAa;AAAA,EACf,EAAE,QAAQ,OAAO,OAAO;AAAA,EACxB,EAAE,QAAQ,cAAc,OAAO;AAAA,EAC/B,EAAE,QAAQ,cAAc,OAAO,EAAE,SAAS;AAAA;AAMvC,gCAAgD;AAAA,EAenD,YACI,SACA,OACA,UACA,WACF;AA4FM,uBAAc,CAAC,UAAoC;AACvD,UAAI,iBAAiB,OAAO;AACxB,YAAI,KAAK,SAAS;AACd,eAAK,QAAQ;AAAA,eACV;AACH,UAAI,KACA,mDACA,KAAK,aACL;AAEJ,eAAK,gBAAgB;AAAA;AAEzB;AAAA;AAEJ,MAAI,OAAO,OAAO;AAAA;AAzGlB,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,QAAQ;AACb,SAAK,WAAW,IAAI,gBAAgB;AACpC,SAAK,UAAU;AAEf,SAAK,cAAc,aAAa,aAAa,KAAK;AAClD,SAAK,aAAa;AAAA;AAAA,EAGd,cAAc,cAAsB;AACxC,UAAM,UAAU,SAAS,gBAAgB,cAAc,KAAK;AAC5D,QAAI,KAAK,OAAO;AACZ,iBAAW,CAAC,MAAM,QAAQ,OAAO,QAAQ,KAAK,QAAQ;AAClD,YAAI,SAAS;AAAO;AACpB,YACI,WAAW,KAAK,CAAC,EAAE,QAAQ,YAAY;AACnC,cAAI,KAAK,WAAW,SAAS;AACzB,oBAAQ,iBACJ,KAAK,MAAM,OAAO,SAClB,CAAC,MAAM;AACH,kBAAI;AACA,oBAAI,GAAG;AAAA,wBACT;AACE;AAAA;AAAA,eAGR;AAEJ,mBAAO;AAAA;AAEX,iBAAO;AAAA,YAEb;AACE;AAAA;AAEJ,YAAI,kBAAkB,QAAQ,cAAc,MAAM;AAC9C,cAAI,CAAC,KAAK,cAAc;AACpB,iBAAK,eAAe,oBAAI;AAAA;AAE5B,eAAK,aAAa,IACd,MACA,cAAc,OAAO,MAAM,IAAI;AAAA,eAEhC;AACH,eAAK,QAAQ,SAAS,MAAM;AAAA;AAAA;AAGpC,UAAI,KAAK,cAAc;AACnB,YAAI,CAAC,KAAK,0BAA0B;AAChC,eAAK,2BAA2B,oBAAI;AAAA;AAExC,mBAAW,CAAC,MAAM,gBAAgB,KAAK,aAAa,WAAW;AAC3D,iBAAO;AACP,gBAAM,aAAa;AACnB,eAAK,QAAQ,SAAS,MAAM;AAC5B,eAAK,yBAAyB,IAC1B,YAAY,UAAU,CAAC,QAAO,eAAe;AACzC,gBAAI,QAAO;AACP,cAAI,MAAM,iCAAiC;AAAA,gBACvC;AAAA,gBACA;AAAA,gBACA,OAAO;AAAA;AAAA,mBAER;AACH,mBAAK,QAAQ,SAAS,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAOpD,WAAO;AAAA;AAAA,EAGH,QAAQ,SAAkB,MAAc,KAAc;AAC1D,QAAI,KAAK,WAAW,UAAU;AAC1B,YAAM,WAAW,KAAK,MAAM;AAC5B,MAAC,QAAgB,YAAY;AAC7B;AAAA;AAGJ,QAAI,KAAK,WAAW,UAAU;AAC1B,YAAM,WAAW,KAAK,MAAM;AAC5B,mBAAa,SAAS,UAAU;AAChC;AAAA;AAGJ,eAAW,SAAS,MAAM;AAAA;AAAA,EAoB9B,SAAS;AACL,SAAK,UAAU;AAAA,MACX,MAAM;AAAA,MACN,OAAO;AAAA,MACP,OAAO;AAAA;AAEX,SAAK,UAAU;AAAA;AAAA,EAGnB,cAAc,cAAsB,mBAA2B;AAC3D,QAAI,CAAC,KAAK,WAAW,iBAAiB,KAAK,cAAc;AACrD,WAAK,eAAe;AACpB,WAAK,UAAU,KAAK,cAAc;AAElC,UAAI,KAAK,kBAAkB;AACvB,aAAK,iBAAiB;AACtB,eAAO,MAAM,KAAK;AAAA;AAEtB,WAAK,mBAAmB,IAAI,iBACxB,KAAK,SACL,KAAK,UACL,KAAK,OAAO;AAEhB,UAAI,MAAM,KAAK;AAEf,WAAK,iBAAiB,OAAO,KAAK,aAAa;AAAA;AAEnD,WAAO,KAAK;AAAA;AAAA,EAGhB,OAAO,SAAsB,oBAA4B;AACrD,IAAI,OAAO,CAAC,KAAK,SAAS;AAC1B,SAAK,UAAU;AACf,QAAI,KAAK,eAAe;AACpB,WAAK,QAAQ,KAAK;AAClB;AAAA;AAGJ,UAAM,sBACF,8BAA8B,sBAAsB,KAAK;AAC7D,UAAM,eAAe,qBAAqB,QAAQ;AAClD,UAAM,oBACF,qBAAqB,YAAY;AAErC,UAAM,UAAU,KAAK,cAAc,cAAc;AAEjD,SAAK,UAAU;AAAA,MACX,MAAM;AAAA,MACN,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO,CAAC;AAAA;AAAA;AAAA,EAIhB,WAAW,WAAoB;AAC3B,SAAK,kBAAkB,WAAW;AAAA;AAAA,EAGtC,SAAS;AACL,WAAO;AAAA;AAAA,EAGX,UAAU;AACN,YAAQ;AAAA;AAAA,EAGZ,OAAO,OAA8B;AACjC,QAAI,4BAA4B,KAAK,cAAc,QAAQ;AACvD,WAAK,kBAAkB,OAAO;AAC9B,WAAK,eAAe;AAAA;AAAA;AAAA,EAO5B,UAAU;AAIN,UAAM,oBACF,wBAAwB,KAAK,YAAY;AAE7C,QAAI,KAAK,kBAAkB;AACvB,UAAI,MAAM,KAAK;AAAA;AAKnB,SAAK,cACD,mBACA,KAAK,YAAY,kBACX,iBACA;AAAA;AAAA,EAGd,SAAS;AACL,QAAI,KAAK,cAAc;AACnB,iBAAW,eAAe,KAAK,aAAa,UAAU;AAClD,gBAAQ;AAAA;AAAA;AAGhB,QAAI,KAAK,0BAA0B;AAC/B,iBAAW,eAAe,KAAK,0BAA0B;AACrD;AAAA;AAEJ,WAAK,yBAAyB;AAAA;AAGlC,SAAK,UAAU;AACf,QAAI,KAAK,kBAAkB;AACvB,aAAO,MAAM,KAAK;AAClB,WAAK,mBAAmB;AAAA;AAE5B,qBAAiB;AACjB,SAAK,UAAU;AAAA;AAAA;AAKvB,IAAM,WAAW,SAAS;AAUnB,6BAA6C;AAAA,EAkBhD,YACI,SACA,UACA,SACA,WACF;AAqBM,uBAAc,CAAC,UAAoC;AACvD,UAAI,iBAAiB,OAAO;AACxB,YAAI,KAAK,SAAS;AACd,eAAK,QAAQ;AAAA,eACV;AACH,UAAI,KAAK;AAAA;AAEb;AAAA;AAEJ,oBAAc,KAAK,aAAa;AAChC,sBAAgB;AAAA;AA9BhB,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,kBAAkB;AACvB,SAAK,cAAc;AACnB,SAAK,iBAAiB;AACtB,SAAK,YAAY;AACjB,SAAK,cAAc,oBAAI;AACvB,SAAK,cAAc,oBAAI;AACvB,SAAK,UAAU;AACf,QAAI,SAAS;AACT,WAAK,UAAU;AACf,WAAK,aAAa;AAAA;AAEtB,SAAK,UAAU,KAAK,QAAQ;AAC5B,SAAK,iBAAiB,QAAQ,WAAW;AAEzC,SAAK,cAAc,aAAa,SAAS,KAAK;AAC9C,SAAK,aAAa;AAAA;AAAA,EAgBtB,SAAS;AACL,SAAK,UAAU;AACf,SAAK,gBAAgB;AAAA;AAAA,EAGzB,OAAO,SAAsB,oBAA4B;AACrD,IAAI,OAAO,CAAC,KAAK,SAAS;AAC1B,SAAK,UAAU;AACf,SAAK,gBAAgB,OACjB,KAAK,aAEL;AAAA;AAAA,EAIR,WAAW,WAAoB;AAC3B,QAAI,WAAW;AACX,WAAK,gBAAgB,WAAW;AAChC,UAAI,KAAK,SAAS;AACd,wBAAgB;AAChB,aAAK,aAAa;AAAA;AAAA,WAEnB;AACH,UAAI,KAAK,SAAS;AACd,wBAAgB;AAChB,aAAK,aAAa;AAAA;AAEtB,WAAK,gBAAgB,WAAW;AAAA;AAAA;AAAA,EAIxC,OAAO,OAA8B;AACjC,QAAI,CAAC,4BAA4B,KAAK,cAAc,QAAQ;AACxD;AAAA;AAEJ,SAAK,gBAAgB,OAAO;AAC5B,SAAK,eAAe;AACpB,QACI,UAAU,0BACV,KAAK,YAAY,SAAS,GAC5B;AAEE,YAAM,cAAc,KAAK;AACzB,WAAK,cAAc;AACnB,iBAAW,cAAc,aAAa;AAClC,cAAM,UAAU,gBAAgB,KAAK,WAAW;AAChD,mBAAW,YAAY,SAAS;AAC5B,cAAI,KAAK,YAAY,IAAI,WAAW;AAChC,iBAAK,YAAY,IAAI;AAAA;AAAA;AAAA;AAAA;AAKrC,QACI,UAAU,0BACV,KAAK,WACL,KAAK,eAAe,wBACtB;AACE,UAAI,KAAK,mBAAmB,KAAK;AAC7B,aAAK,QAAQ,UAAU;AAAA,iBAChB,OAAO,KAAK,YAAY,YAAY;AAC3C,aAAK,QAAQ;AAAA;AAEjB,WAAK,aAAa;AAAA;AAEtB,QACI,UAAU,sBACV,KAAK,YAAY,OAAO,GAC1B;AACE,UACI,KAAK,YAAY,SAAS,KAAK,YAAY,QAC3C,KAAK,mBAAmB,GAC1B;AACE,aAAK,QAAQ;AACb,aAAK,YAAY;AACjB,aAAK,iBAAiB;AAAA,aACnB;AACH,mBAAW,YAAY,KAAK,aAAa;AACrC,eAAK,YAAY,OAAO;AACxB,eAAK,QAAQ,YAAY;AAAA;AAE7B,aAAK,iBAAiB,KAAK,eAAe,OACtC,CAAC,SAAS,CAAC,KAAK,YAAY,IAAI;AAAA;AAGxC,WAAK,YAAY;AAAA;AAErB,QACI,UAAU,sBACV,KAAK,UAAU,SAAS,GAC1B;AACE,UAAI,WAAmB;AACvB,UAAI,YAAY;AAChB,UAAI,YAAY;AAChB,aAAO,YAAY,KAAK,UAAU,QAAQ;AACtC,YACI,KAAK,eAAe,eAAe,KAAK,UAAU,YACpD;AACE,eAAK,aAAa,UAAU;AAC5B,qBAAW;AACX,uBAAa;AACb,uBAAa;AAAA,eACV;AACH,mBAAS,KAAK,KAAK,UAAU;AAC7B,uBAAa;AAAA;AAAA;AAGrB,WAAK,aAAa,UAAU,KAAK,UAAU;AAAA;AAE/C,QACI,UAAU,wBACV,KAAK,WACL,KAAK,eAAe,sBACtB;AACE,UAAI,KAAK,mBAAmB,KAAK;AAC7B,aAAK,QAAQ,UAAU,KAAK;AAAA,iBACrB,OAAO,KAAK,YAAY,YAAY;AAC3C,aAAK,QAAQ,KAAK;AAAA;AAEtB,WAAK,aAAa;AAAA;AAAA;AAAA,EAIlB,aAAa,OAAe,aAAqB;AACrD,QAAI;AACJ,QAAI,MAAM,WAAW,GAAG;AACpB,iBAAW,MAAM;AACjB,WAAK,YAAY,IAAI,MAAM;AAC3B,WAAK,eAAe,OAAO,aAAa,GAAG;AAAA,eACpC,MAAM,SAAS,GAAG;AACzB,iBAAW,QAAQ,OAAO;AACtB,aAAK,YAAY,IAAI;AACrB,iBAAS,YAAY;AAAA;AAEzB,WAAK,eAAe,OAAO,aAAa,GAAG,GAAG;AAC9C,iBAAW;AAAA;AAEf,QAAI,UAAU;AACV,WAAK,QAAQ,aACT,UACA,KAAK,UAAU,gBAAgB;AAAA;AAAA;AAAA,EAK3C,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAMZ,UAAU;AACN,QAAI,MAAM,KAAK;AAAA;AAAA,EAEnB,SAAS;AACL,QAAI,KAAK,cAAc;AACnB,iBAAW,eAAe,KAAK,aAAa,UAAU;AAClD,gBAAQ;AAAA;AAAA;AAGhB,QAAI,KAAK,0BAA0B;AAC/B,iBAAW,eAAe,KAAK,0BAA0B;AACrD;AAAA;AAEJ,WAAK,yBAAyB;AAAA;AAGlC,WAAO,MAAM,KAAK;AAClB,qBAAiB;AACjB,SAAK,UAAU;AAAA;AAAA;AAOhB,kCAAkD;AAAA,EAWrD,YAAY,aAA+B,WAAoB;AAC3D,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,cAAc;AACnB,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa,cAAc,YAAY;AAC1D,SAAK,aAAa;AAElB,SAAK,YAAY,KAAK,UAAU,KAAK;AAAA;AAAA,EAGzC,SAAS;AACL,SAAK,YAAY;AACjB,SAAK,UAAU;AAAA;AAAA,EAGnB,OAAO,SAAsB,oBAA4B;AACrD,SAAK,UAAU;AACf,SAAK,qBAAqB;AAC1B,QAAI,KAAK,OAAO;AACZ,cAAQ,KAAK;AAAA,WACV;AACH,WAAK,YAAY,OAAO,SAAS;AAAA;AAAA;AAAA,EAIzC,WAAW,WAAoB;AAC3B,SAAK,YAAY;AACjB,SAAK,YAAY,WAAW;AAAA;AAAA,EAGhC,SAAS;AACL,WAAO;AAAA;AAAA,EAGX,UAAU;AACN,YAAQ;AAAA;AAAA,EAGZ,aAAa;AACT,QAAI,KAAK,YAAY;AACjB,UAAI,KAAK,SAAS;AACd,YAAI,KAAK,WAAW;AAChB,eAAK,WAAW,WAAW;AAAA;AAE/B,aAAK,WAAW;AAAA;AAEpB,aAAO,MAAM,KAAK;AAClB,WAAK,QAAQ;AACb,WAAK,aAAa;AAAA;AAAA;AAAA,EAc1B,UACI,WACA,KACA,eACI;AACJ,SAAK;AACL,QAAI,WAAW;AACX,WAAK,QAAQ;AACb,UAAI,KAAK,SAAS;AACd,aAAK,QAAQ;AAAA,aACV;AACH,QAAI,KACA,qDACA;AAAA;AAAA,WAGL;AACH,oBAAc,MAAM;AAChB,cAAM,aAAa,cAAc;AACjC,YAAI,MAAM;AACV,aAAK,aAAa;AAClB,YAAI,KAAK,WAAW,KAAK,oBAAoB;AACzC,qBAAW,OAAO,KAAK,SAAS,KAAK;AAAA;AAEzC,YAAI,KAAK,WAAW;AAChB,qBAAW,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAKtC,OAAO,OAA8B;AACjC,QAAI,4BAA4B,KAAK,cAAc,QAAQ;AACvD,WAAK,YAAY,OAAO;AACxB,WAAK,eAAe;AAAA;AAAA;AAAA,EAO5B,UAAU;AACN,QAAI;AACA,WAAK,0BAA0B,KAAK,YAAY,UAC5C,KAAK;AAET,WAAK,UAAU,QAAW,KAAK,eAAe,CAAC,WAAW;AACtD;AAAA;AAAA,aAEC,GAAP;AACE,WAAK,UACD,mBACA,UAAU,IACV,CAAC,WAAW;AACR;AAAA;AAAA;AAAA;AAAA,EAKhB,SAAS;AACL,SAAK;AACL,SAAK,0BAA0B;AAC/B,SAAK;AACL,qBAAiB;AACjB,SAAK,UAAU;AAAA;AAAA;AAIhB,iCAAiD;AAAA,EAepD,YAAY,aAAyC,WAAoB;AAuHjE,iCAAwB,CAAC,WAA8B;AAC3D,iBAAW,SAAS,QAAQ;AACxB,gBAAQ,MAAM;AAAA,eACL,uBAAuB;AACxB,kBAAM,cAA4B;AAClC,gBAAI,MAAM,OAAO;AACb,yBAAW,CAAC,OAAO,SAAS,MAAM,MAAM,WAAW;AAC/C,sBAAM,QAAQ,cAAc;AAC5B,4BAAY,KAAK;AACjB,qBAAK,WAAW,IAAI,OAAO,MAAM,QAAQ;AAAA;AAAA;AAGjD,kBAAM,UAAU,KAAK,SAAS,OAC1B,MAAM,OACN,MAAM,OACN,GAAG;AAEP,iBAAK,iBAAiB,MAAM;AACxB,yBAAW,SAAS,SAAS;AACzB,qBAAK,aAAa;AAClB,qBAAK,WAAW,OAAO;AAAA;AAAA;AAG/B,iBAAK,UAAU,OACX,MAAM,OACN,MAAM,OACN,GAAG,YAAY,IAAI,MAAM;AAE7B,gBAAI,YAAY,WAAW,MAAM,OAAO;AACpC,uBACQ,IAAI,MAAM,QAAQ,YAAY,QAClC,IAAI,KAAK,SAAS,QAClB,EAAE,GACJ;AACE,qBAAK,WAAW,IAAI,KAAK,SAAS,IAAI;AAAA;AAAA;AAG9C,iBAAK,iBAAiB,MAAM;AACxB,yBAAW,SAAS,aAAa;AAC7B,qBAAK,YAAY;AAAA;AAAA;AAGzB;AAAA;AAAA,eAEC,mBAAqB;AAEtB,kBAAM,iBAA2B;AACjC,gBAAI,YAAY;AAChB,uBAAW,YAAY,KAAK,WAAW;AACnC,6BAAe,KAAK;AACpB,2BAAa;AAAA;AAEjB,gBAAI,YAAY;AAChB,qBAAS,IAAI,GAAG,IAAI,MAAM,OAAO,EAAE,GAAG;AAClC,2BAAa,KAAK,UAAU,MAAM,OAAO;AAAA;AAI7C,4BAAgB,KAAK,WAAW;AAGhC,kBAAM,OAAO,eAAe,MAAM;AAClC,kBAAM,QAAQ;AACd,kBAAM,KAAK,eAAe,MAAM;AAChC,iBAAK,UAAU;AACf;AAAA;AAAA,eAEC,mBAAqB;AAEtB,gBAAI,WAAW;AACf,qBAAS,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,GAAG;AACjC,0BAAY,KAAK,UAAU;AAAA;AAE/B,kBAAM,gBAA4B;AAClC,gBAAI,QAAQ;AACZ,qBAAS,IAAI,GAAG,IAAI,KAAK,UAAU,QAAQ,EAAE,GAAG;AAC5C,oBAAM,cAAwB;AAC9B,uBAAS,IAAI,GAAG,IAAI,KAAK,UAAU,IAAI,EAAE,GAAG;AACxC,4BAAY,KAAK;AACjB,yBAAS;AAAA;AAEb,4BAAc,KAAK;AAAA;AAIvB,4BAAgB,KAAK,WAAW;AAEhC,4BAAgB,eAAe;AAG/B,kBAAM,gBAAgB,cACjB,MAAM,MAAM,MACZ;AACL,kBAAM,OAAO;AACb,kBAAM,UAAU;AAChB,iBAAK,UAAU;AACf;AAAA;AAAA;AAAA;AAAA;AAtNZ,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,aAAa;AAClB,SAAK,WAAW;AAChB,SAAK,aAAa,oBAAI;AACtB,SAAK,YAAY;AACjB,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA;AAAA,EAGtB,iBAAiB,IAAgB;AAC7B,SAAK,cAAc;AACnB;AACA,SAAK,YAAY,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE;AACzC,QAAI,aAAa;AACjB,QAAI,cAAc;AAClB,aACQ,YAAY,GAChB,aAAa,KAAK,YAAY,UAC9B,YAAY,KAAK,UAAU,QAC3B,EAAE,WACJ;AACE,aACI,aAAa,KAAK,YAAY,UAC9B,KAAK,YAAY,YAAY,OAAO,WACtC;AACE,cAAM,QAAQ,KAAK,YAAY,YAAY;AAC3C,YAAI,MAAM,SAAS,uBAAuB;AACtC,eAAK,UAAU,cACV,OAAM,OAAO,UAAU,KAAK,MAAM;AAAA;AAE3C,YAAI,KAAK,SAAS;AACd,uBAAa,aAAa;AAC1B,eAAK,QAAQ;AAAA;AAEjB;AAAA;AAEJ,qBAAe,KAAK,UAAU;AAAA;AAElC,SAAK,cAAc;AAAA;AAAA,EAGvB,OAAO,SAAsB,oBAA4B;AACrD,SAAK,UAAU;AACf,SAAK,qBAAqB;AAE1B,SAAK,iBAAiB,MAAM;AACxB,iBAAW,SAAS,KAAK,UAAU;AAC/B,cAAM,OAAO,CAAC,UAAU;AACpB,eAAK,iBAAiB,OAAO;AAAA,WAC9B;AAAA;AAAA;AAAA;AAAA,EAKf,SAAS;AACL,eAAW,SAAS,KAAK,UAAU;AAC/B,YAAM;AAAA;AAGV,SAAK,UAAU;AAAA;AAAA,EAGnB,iBAAiB,OAAiC,OAAmB;AACjE,QAAI,KAAK,SAAS;AACd,UAAI,CAAE,kBAAiB,QAAQ;AAE3B,cAAM,QAAQ,KAAK,WAAW,IAAI;AAClC,YAAI,KAAK,aAAa;AAClB,eAAK,YAAY,KAAK,CAAC,OAAO;AAAA,eAC3B;AACH,qBAAW,KAAK,WAAW,OAAO;AAClC,eAAK,QAAQ;AAAA;AAAA,aAEd;AACH,aAAK,QAAQ;AAAA;AAAA;AAAA;AAAA,EAKzB,WAAW,WAAoB;AAC3B,SAAK,YAAY;AACjB,eAAW,SAAS,KAAK,UAAU;AAC/B,YAAM,WAAW;AAAA;AAAA;AAAA,EAIzB,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAGJ,aAAa,OAAmB;AACpC,QAAI,KAAK,SAAS;AACd,UAAI,KAAK,WAAW;AAChB,cAAM,WAAW;AAAA;AAErB,YAAM;AAAA;AAEV,WAAO,MAAM;AAAA;AAAA,EAET,YAAY,OAAmB;AACnC,QAAI,MAAM;AACV,QAAI,KAAK,WAAW,KAAK,oBAAoB;AACzC,YAAM,OACF,CAAC,UAAU,KAAK,iBAAiB,OAAO,QACxC,KAAK;AAET,UAAI,KAAK,WAAW;AAChB,cAAM,WAAW;AAAA;AAAA;AAAA;AAAA,EA2G7B,OAAO,OAA8B;AACjC,QAAI,4BAA4B,KAAK,cAAc,QAAQ;AACvD,iBAAW,SAAS,KAAK,UAAU;AAC/B,cAAM,OAAO;AAAA;AAEjB,WAAK,eAAe;AAAA;AAAA;AAAA,EAO5B,UAAU;AACN,WAAO,KAAK;AACZ,SAAK,cAAc,KAAK,WAAW,UAC/B,KAAK;AAGT,iBAAa,MAAM;AACf,WAAK,iBAAiB,MAAM;AACxB,mBAAW,CAAC,OAAO,SAAS,KAAK,WAAW,WAAW;AACnD,gBAAM,QAAQ,cAAc;AAC5B,eAAK,SAAS,KAAK;AACnB,eAAK,UAAU,KAAK;AACpB,eAAK,WAAW,IAAI,OAAO;AAC3B,eAAK,YAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjC,SAAS;AACL,SAAK;AACL,YAAQ,KAAK;AACb,UAAM,UAAU,KAAK,SAAS,OAAO,GAAG,KAAK,SAAS;AACtD,eAAW,SAAS,SAAS;AACzB,WAAK,aAAa;AAClB,WAAK,WAAW,OAAO;AAAA;AAE3B,SAAK,UAAU,OAAO,GAAG,KAAK,UAAU;AACxC,SAAK,UAAU;AACf,qBAAiB;AAAA;AAAA;AAIzB,iCAAiC,KAAuC;AACpE,SAAO,cAAc;AAAA;AAGzB,sCACI,KAC0C;AAC1C,SAAO,aAAa,QAAQ,OAAO;AAAA;AAGvC,sBAAsB,KAA6B;AAC/C,SAAO,OAAO,IAAI,UAAU;AAAA;AAGzB,uBAAuB,SAA+B;AACzD,MAAI,aAAa,UAAU;AACvB,WAAO;AAAA;AAEX,MAAI,wBAAwB,UAAU;AAClC,WAAO,IAAI,sBAAsB;AAAA;AAErC,MAAI,6BAA6B,UAAU;AACvC,WAAO,IAAI,qBAAqB;AAAA;AAEpC,MAAI,mBAAmB,SAAS;AAC5B,WAAO,IAAI,kBAAkB;AAAA;AAEjC,MAAI,MAAM,QAAQ,UAAU;AACxB,WAAO,IAAI,gBAAgB,QAAQ,IAAI,CAAC,SAAS,cAAc;AAAA;AAEnE,MACI,YAAY,QACZ,YAAY,UACZ,OAAO,YAAY,WACrB;AACE,WAAO;AAAA;AAEX,MAAI,OAAO,YAAY,YAAY;AAC/B,IAAI,KAAK;AACT,WAAO;AAAA;AAEX,MAAI,OAAO,YAAY,UAAU;AAC7B,IAAI,KAAK;AACT,WAAO;AAAA;AAEX,MAAI,OAAO,YAAY,UAAU;AAC7B,WAAO,IAAI,eAAe;AAAA;AAE9B,MAAI,OAAO,YAAY,YAAY,OAAO,YAAY,UAAU;AAC5D,WAAO,IAAI,eAAe,QAAQ;AAAA;AAEtC,EAAI,KAAK,+CAA+C;AACxD,SAAO;AAAA;AAGJ,2BACH,UACY;AACZ,QAAM,mBAAiC;AACvC,MAAI,UAAU;AACV,QACI,MAAM,QAAQ,aACd,CAAC,aAAa,aACd,CAAC,OAAO,WACV;AACE,iBAAW,SAAS,UAAU;AAC1B,yBAAiB,KAAK,cAAc;AAAA;AAAA,WAErC;AACH,uBAAiB,KAAK,cAAc;AAAA;AAAA;AAG5C,SAAO;AAAA;AAGJ,eAAe,QAAiB,MAA8B;AACjE,QAAM,OAAO,IAAI,iBACb,QACA,IAAI,gBAAgB,CAAC,QACrB,MACA;AAEJ,SAAO;AACP,MAAI;AACJ,OAAK,OAAO,CAAC,UAAU;AACnB,QAAI,iBAAiB,OAAO;AACxB,kBAAY;AACZ,MAAI,MAAM,yBAAyB;AACnC;AAAA;AAAA,KAEL,OAAO,gBAAgB;AAC1B,MAAI,WAAW;AACX,YAAQ;AACR,UAAM;AAAA;AASV,OAAK,WAAW;AAChB;AACA,SAAO,MAAM;AACT,SAAK,WAAW;AAChB,SAAK;AACL;AACA,YAAQ;AAAA;AAAA;AAIT,IAAK,6BAAL,kBAAK,gCAAL;AACH,yCAAQ;AACR,2CAAU;AAFF;AAAA;AAcL,wCAAwD;AAAA,EAY3D,YACI,cACA,iBACA,UACA,WACF;AACE,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,eAAe;AACpB,SAAK,kBAAkB;AACvB,SAAK,QAAQ,IAAI,gBAAgB;AACjC,SAAK,aAAa;AAClB,SAAK,eAAe;AACpB,SAAK,iBAAiB;AACtB,SAAK,YAAY;AAEjB,SAAK,cAAc,aAAa;AAChC,SAAK,aAAa;AAAA;AAAA,EAGtB,OAAO,MAAY,MAAkC;AACjD,YAAQ;AAAA,WACC;AACD,aAAK,aAAa,KAAK;AACvB;AAAA,WACC;AACD,aAAK,eAAe,KAAK;AACzB;AAAA;AAEA,QAAI,gBAAgB;AAAA;AAE5B,oBAAgB;AAAA;AAAA,EAGpB,OAAO,OAA8B;AACjC,QAAI,CAAC,4BAA4B,KAAK,cAAc,QAAQ;AACxD;AAAA;AAEJ,SAAK,MAAM,OAAO;AAClB,SAAK,eAAe;AAEpB,YAAQ;AAAA,WACC;AACD,YAAI,KAAK,eAAe,SAAS,GAAG;AAChC,qBAAW,QAAQ,KAAK,gBAAgB;AACpC,iBAAK,eACD,MACA;AAEJ,gBAAI,gBAAgB,SAAS;AACzB,mBAAK,kBACD,MACA;AAAA;AAAA;AAIZ,eAAK,iBAAiB;AAAA;AAE1B;AAAA,WACC;AACD,YAAI,KAAK,aAAa,SAAS,GAAG;AAC9B,qBAAW,QAAQ,KAAK,cAAc;AAClC,iBAAK,eACD,MACA;AAEJ,gBAAI,gBAAgB,SAAS;AACzB,mBAAK,kBACD,MACA;AAAA;AAAA;AAIZ,eAAK,eAAe;AAAA;AAExB;AAAA;AAAA;AAAA,EAIZ,YAAY,OAAiC;AACzC,QAAI,iBAAiB,OAAO;AACxB,UAAI,KAAK,SAAS;AACd,aAAK,QAAQ;AAAA,aACV;AACH,QAAI,KACA,2DACA;AAAA;AAGR;AAAA;AAEJ,QAAI,MAAM,SAAS,uBAAuB;AACtC,eAAS,IAAI,GAAG,IAAI,MAAM,OAAO,EAAE,GAAG;AAClC,cAAM,OAAO,KAAK,WAAW,MAAM,QAAQ;AAC3C,YAAI,KAAK,WAAW;AAChB,eAAK,OAAO,MAAM;AAAA;AAAA;AAAA;AAK9B,oBAAgB,KAAK,YAAY;AACjC,SAAK,UAAU;AAEf,QAAI,MAAM,SAAS,uBAAuB;AACtC,UAAI,MAAM,OAAO;AACb,mBAAW,QAAQ,MAAM,OAAO;AAC5B,cAAI,KAAK,WAAW;AAChB,iBAAK,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOtC,SAAS;AACL,SAAK,MAAM;AACX,SAAK,UAAU;AAAA;AAAA,EAGnB,OAAO,SAAsB,oBAA4B;AACrD,SAAK,UAAU;AACf,SAAK,MAAM,OAAO,CAAC,UAAU;AACzB,WAAK,YAAY;AAAA,OAClB;AAAA;AAAA,EAGP,WAAW,WAAoB;AAC3B,SAAK,MAAM,WAAW;AACtB,SAAK,YAAY;AACjB,UAAM,QAAQ,YACR,sBACA;AACN,eAAW,QAAQ,KAAK,YAAY;AAChC,WAAK,OAAO,MAAM;AAAA;AAAA;AAAA,EAI1B,SAAS;AACL,WAAO;AAAA;AAAA,EAEX,UAAU;AACN,YAAQ;AAAA;AAAA,EAMZ,UAAU;AACN,QAAI,MAAM,KAAK;AAAA;AAAA,EAEnB,SAAS;AACL,WAAO,MAAM,KAAK;AAClB,qBAAiB;AACjB,SAAK,UAAU;AAAA;AAAA;AAIhB,IAAM,oBAIR,CAAC,EAAE,cAAc,iBAAiB,eAAe;AAClD,SAAO,IAAI,4BACP,cACA,iBACA,kBAAkB;AAAA;AAInB,gCAAwD;AAAA,EAkB3D,YACI,YACA,OACA,UACA,WACF;AAgIF,uBAAc,CAAC,UAAoC;AAC/C,MAAI,OACA,CAAE,MAAK,kBAAkB,QACzB;AAEJ,UAAI,iBAAiB,SAAS,KAAK,cAAc;AAC7C,YAAI,KAAK,QAAQ;AACb,cAAI,KAAK,gBAAgB;AACrB,gBAAI,KAAK,WAAW;AAChB,mBAAK,OAAO,WAAW;AAAA;AAE3B,iBAAK,OAAO;AACZ,iBAAK,iBAAiB;AAAA;AAE1B,iBAAO,MAAM,KAAK;AAClB,eAAK,SAAS;AAAA;AAElB,cAAM,gBAAgB,KAAK,aAAa;AACxC,aAAK,SAAS,gBACR,cAAc,iBACd;AACN,YAAI,MAAM,KAAK;AAEf,YAAI,KAAK,WAAW,KAAK,oBAAoB;AACzC,eAAK,OAAO,OAAO,KAAK,aAAa,KAAK;AAC1C,eAAK,iBAAiB;AAAA;AAG1B,YAAI,KAAK,WAAW;AAChB,eAAK,OAAO,WAAW;AAAA;AAAA,aAExB;AACH,aAAK,UAAU;AAAA;AAAA;AA/JnB,SAAK,QAAQ;AACb,SAAK,eAAe;AACpB,SAAK,YAAY;AACjB,SAAK,QAAQ;AACb,SAAK,WAAW;AAChB,SAAK,QAAQ,oBAAI;AACjB,SAAK,YAAY;AAEjB,SAAK,iBAAiB;AAEtB,SAAK,cAAc,aAAa,aAAa,WAAU;AACvD,SAAK,aAAa;AAAA;AAAA,EAGtB,SAAS;AACL,IAAI,OAAO,KAAK,QAAQ;AACxB,QAAI,KAAK,kBAAkB,OAAO;AAC9B;AAAA;AAEJ,IAAI,OACA,KAAK,gBACL;AAEJ,SAAK,OAAO;AACZ,SAAK,iBAAiB;AACtB,SAAK,UAAU;AAAA;AAAA,EAGX,eAAe;AACnB,QAAI,CAAC,KAAK,QAAQ;AACd,UAAI,mBAAmB;AACvB,YAAM,YAAgC;AAAA,QAClC,SAAS,CAAC,YAAuC;AAC7C,UAAI,OACA,kBACA;AAEJ,cAAI,CAAC,KAAK;AAAkB,iBAAK,mBAAmB;AACpD,eAAK,iBAAiB,KAAK;AAAA;AAAA,QAE/B,WAAW,CAAC,YAAwB;AAChC,UAAI,OACA,kBACA;AAEJ,cAAI,CAAC,KAAK;AAAoB,iBAAK,qBAAqB;AACxD,eAAK,mBAAmB,KAAK;AAAA;AAAA,QAEjC,WAAW,CAAC,YAAwB;AAChC,UAAI,OACA,kBACA;AAEJ,cAAI,CAAC,KAAK;AAAoB,iBAAK,qBAAqB;AACxD,eAAK,mBAAmB,KAAK;AAAA;AAAA,QAEjC,SAAS,CAAC,iBAAkD;AACxD,UAAI,OACA,kBACA;AAEJ,UAAI,OACA,CAAC,KAAK,cACN;AAEJ,eAAK,eAAe;AAAA;AAAA;AAI5B,UAAI;AACJ,YAAM,aAAY,KAAK;AACvB,YAAM,WAAW,KAAK;AACtB,YAAM,QAAQ,KAAK;AACnB,UAAI,SAAS,WAAW,GAAG;AACvB,yBAAiB,SAAS;AAAA,iBACnB,SAAS,WAAW,GAAG;AAC9B,yBAAiB,QACX,KAAK,OAAO,UAAU,SAAS,OAC/B,EAAE,UAAU,SAAS;AAAA,aACxB;AACH,yBAAiB,QAAQ,KAAK,OAAO,aAAa,EAAE;AAAA;AAExD,UAAI;AACJ,UAAI;AACA,oBAAY,aACR,KAAK,OACL,MACI,WAAU,gBAAgB,cAAc;AAAA,eAE3C,GAAP;AACE,cAAM,SAAQ,UAAU,GAAG;AAC3B,YAAI,KAAK,cAAc;AACnB,sBAAY,KAAK,aAAa,WAAU;AAAA,eACrC;AACH,sBAAY;AAAA;AAAA;AAGpB,yBAAmB;AACnB,iBAAW,QAAQ,KAAK,OAAO;AAC3B,eAAO;AAAA;AAEX,UAAI,CAAE,sBAAqB,QAAQ;AAC/B,aAAK,SAAS,cAAc;AAC5B,YAAI,MAAM,KAAK;AAAA,aACZ;AACH,aAAK,SAAS;AAAA;AAAA;AAGtB,WAAO,KAAK;AAAA;AAAA,EAGhB,OAAO,SAAsB,oBAA4B;AACrD,IAAI,OACA,KAAK,aAAa,GAClB;AAEJ,SAAK,UAAU;AACf,SAAK,qBAAqB;AAC1B,UAAM,SAAS,KAAK;AACpB,QAAI,kBAAkB,OAAO;AACzB,cAAQ;AAAA,WACL;AACH,aAAO,OAAO,KAAK,aAAa;AAChC,WAAK,iBAAiB;AAAA;AAAA;AAAA,EAwC9B,WAAW,WAAoB;AAC3B,IAAI,OAAO,KAAK,QAAQ;AACxB,SAAK,YAAY;AACjB,QAAI,KAAK,kBAAkB,OAAO;AAC9B;AAAA;AAEJ,QAAI,WAAW;AACX,WAAK,aAAa;AAClB,sBAAgB;AAChB,WAAK,OAAO,WAAW;AAAA,WACpB;AACH,WAAK,OAAO,WAAW;AACvB,UAAI,KAAK,oBAAoB;AACzB,mBAAW,YAAY,KAAK,oBAAoB;AAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhB,OAAO,OAA8B;AACjC,QAAI,CAAC,4BAA4B,KAAK,cAAc,QAAQ;AACxD;AAAA;AAEJ,QAAI,KAAK,UAAU,CAAE,MAAK,kBAAkB,QAAQ;AAChD,WAAK,OAAO,OAAO;AAAA;AAEvB,SAAK,eAAe;AACpB,QACI,UAAU,wBACV,KAAK,cACL,KAAK,kBACP;AACE,iBAAW,YAAY,KAAK,kBAAkB;AAC1C,cAAM,iBAAiB;AACvB,YAAI,OAAO,mBAAmB,YAAY;AACtC,cAAI,CAAC,KAAK,oBAAoB;AAC1B,iBAAK,qBAAqB;AAAA;AAE9B,gBAAM,YAAY,MAAM;AACpB;AACA,gBAAI,KAAK,oBAAoB;AACzB,oBAAM,QACF,KAAK,mBAAmB,QAAQ;AACpC,kBAAI,SAAS,GAAG;AACZ,qBAAK,mBAAmB,OAAO,OAAO;AAAA;AAAA;AAAA;AAIlD,eAAK,mBAAmB,KAAK;AAAA;AAAA;AAGrC,WAAK,aAAa;AAAA;AAAA;AAAA,EAI1B,SAAS;AACL,WAAO;AAAA;AAAA,EAGX,UAAU;AACN,YAAQ;AAAA;AAAA,EAMZ,UAAU;AACN,SAAK;AAAA;AAAA,EAET,SAAS;AACL,QAAI,KAAK,oBAAoB;AACzB,iBAAW,YAAY,KAAK,oBAAoB;AAC5C;AAAA;AAAA;AAIR,QAAI,KAAK,UAAU,CAAE,MAAK,kBAAkB,QAAQ;AAChD,aAAO,MAAM,KAAK;AAAA;AAEtB,SAAK,SAAS;AACd,eAAW,QAAQ,KAAK,OAAO;AAC3B,cAAQ;AAAA;AAEZ,SAAK,UAAU;AACf,qBAAiB;AAAA;AAAA;AAIlB,qDACH,YACA,OACA,UACF;AACE,SAAO,IAAI,oBACP,CAAC,QAAe,cAAc;AAC1B,UAAM,WAAW,IAAI,WAAU;AAC/B,QAAI,CAAC,SAAS;AAAQ,aAAO;AAC7B,QAAI,SAAS;AACT,gBAAU,UAAU,SAAS,UAAU,KAAK;AAChD,QAAI,SAAS;AACT,gBAAU,QAAQ,SAAS,QAAQ,KAAK;AAC5C,QAAI,SAAS;AACT,gBAAU,QAAQ,SAAS,QAAQ,KAAK;AAC5C,QAAI,SAAS;AACT,gBAAU,UAAU,SAAS,UAAU,KAAK;AAChD,WAAO,SAAS;AAAA,KAEpB,OACA,UACA,WAAU;AAAA;;;AC7kEX,IAAM,WAA4D,CAAC;AAAA,EACtE;AAAA,MACE,IAAI,gBAAgB,kBAAkB;AAErC,uBACH,MACA,UACG,UAC8C;AACjD,MAAI,OAAO,SAAS,UAAU;AAC1B,UAAM,aAA2B;AACjC,eAAW,WAAW,UAAU;AAC5B,iBAAW,KAAK,cAAc;AAAA;AAElC,WAAO,IAAI,oBAAoB,MAAM,OAAO;AAAA;AAEhD,MAAI,iBAAiB,OAAO;AACxB,WAAO,4CACH,MACA,OACA;AAAA;AAGR,SAAO,IAAI,oBACP,MACA,OACA;AAAA;AAGR,cAAc,WAAW;;;ACnCzB,IAAM,iBAAiB;AAAA,EACnB,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,QAAQ;AAAA;AAGL,IAAK,iBAAL,kBAAK,oBAAL;AACH,2BAAM;AACN,2BAAM;AACN,2BAAM;AAHE;AAAA;AAqBL,eAA6B,QAAW,WAA8B;AACzE,QAAM,eAAyC;AAAA,IAC3C,KAAK,CAAC,cAAc,SAAS,MAAM,aAC/B,aAAa,IAAI,MAAM;AAAA,IAC3B,KAAK,CAAC,cAAc,SAAS,SAAS,aAAa,IAAI;AAAA,IACvD,KAAK,CAAC,cAAc,SAAS,MAAM,OAAO,aAAa;AACnD,UACI,OAAO,SAAS,YAChB,CAAC,OAAO,UAAU,eAAe,KAAK,gBAAgB,OACxD;AACE,YAAI,aAAa,QAAQ,OAAO;AAC5B,kBAAQ,EAAE,MAAM,iBAAoB,MAAM;AAAA,eACvC;AACH,kBAAQ,EAAE,MAAM,iBAAoB,MAAM;AAAA;AAAA;AAGlD,aAAO,aAAa,IAAI,MAAM,OAAO;AAAA;AAAA,IAEzC,QAAQ,CAAC,cAAc,SAAS,SAAS;AACrC,UACI,OAAO,SAAS,YAChB,CAAC,OAAO,UAAU,eAAe,KAAK,gBAAgB,SACtD,aAAa,QAAQ,OACvB;AACE,gBAAQ,EAAE,MAAM,iBAAoB;AAAA;AAExC,aAAO,aAAa,OAAO;AAAA;AAAA;AAGnC,QAAM,iBAAiB,IAAI,kBAMvB,QACA,cACA,gBACA,MACA,MACA,eACA,eACA;AAEJ,SAAO,eAAe,UAAU;AAAA;AAGpC,MAAM,YAAY,wBACd,aACA,SACA,WACU;AACV,QAAM,iBAAiB,qBACnB;AAEJ,EAAI,OAAO,gBAAgB;AAC3B,SAAO,eAAe;AACtB,QAAM,cAAc,eAAe,QAAQ,UAAU,CAAC,WAAW;AAC7D,YAAQ;AAAA;AAEZ,SAAO,MAAM;AACT;AACA,YAAQ,eAAe;AAAA;AAAA;AAI/B,MAAM,OAAO,mBACT,aACA,WACwB;AACxB,QAAM,iBAAiB,qBACnB;AAEJ,EAAI,OAAO,gBAAgB;AAE3B,QAAM,cAAc,OAAO,KAAK;AAEhC,QAAM,oBAAoB,IAAI,kBAM1B,aACA,aACA,kBAAkB,cAClB,eAAe,SACf,sBACI,QACA,QACoC;AACpC,eAAW,SAAS,QAAQ;AACxB,cAAQ,MAAM;AAAA,aACL,iBAAoB;AACrB,gBAAM,QAAQ,OAAO,QAAQ,MAAM;AACnC,cAAI,UAAU,IAAI;AACd,kBAAM,aAAa,OAAO;AAC1B,mBAAO,OAAO,OAAO;AACrB,kBAAM,YAAY,OAAO;AAGzB,qBAAS,IAAI,OAAO,IAAI,OAAO,QAAQ,EAAE,GAAG;AACxC,gCAAkB,SAAS,IACvB,EAAE,YACF,OAAO;AAAA;AAGf,qBAAS,IAAI,WAAW,IAAI,YAAY,EAAE,GAAG;AACzC,gCAAkB,SAAS,OAAO,EAAE;AAAA;AAExC,8BAAkB,SAAS,IACvB,UACA,OAAO;AAGX,kBAAM;AAAA,cACF,MAAM;AAAA,cACN;AAAA,cACA,OAAO;AAAA,cACP,OAAO;AAAA;AAAA;AAGf;AAAA;AAAA,aAEC,iBAAoB;AACrB,gBAAM,SAAS,OAAO;AACtB,iBAAO,KAAK,MAAM;AAGlB,4BAAkB,SAAS,IACvB,OAAO,YACP,MAAM;AAEV,4BAAkB,SAAS,IAAI,UAAU,OAAO;AAEhD,gBAAM;AAAA,YACF,MAAM;AAAA,YACN,OAAO;AAAA,YACP,OAAO;AAAA,YACP,OAAO,CAAC,MAAM;AAAA;AAElB;AAAA;AAAA,aAEC;AAED;AAAA;AAEA,UAAI,gBAAgB;AAAA;AAAA;AAAA,KAIpC,eACA,eACA;AAGJ,SAAO,kBAAkB,UAAU;AAAA;AAGvC,uBAAuB,QAAsB,OAAmB;AAE5D,SAAO,KAAK;AAAA;;;AC7KhB,IAAO,cAAQ;AAER,IAAM,UACT,OAAkC,WAAc;",
  "names": []
}
