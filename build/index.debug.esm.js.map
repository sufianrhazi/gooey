{
  "version": 3,
  "sources": ["../src/types.ts", "../src/log.ts", "../src/util.ts", "../src/tarjan.ts", "../src/graph.ts", "../src/debug.ts", "../src/calc.ts", "../src/jsx.ts", "../src/vnode.ts", "../src/view.ts", "../src/collection.ts", "../src/trackeddata.ts", "../src/model.ts", "../src/index.ts"],
  "sourcesContent": ["export class InvariantError extends Error {\n    detail?: any;\n    constructor(msg: string, detail?: any) {\n        super(msg);\n        this.detail = detail;\n    }\n}\n\nexport const TypeTag = Symbol('typeTag');\nexport const ContextGetterTag = Symbol('contextGetter');\nexport const DataTypeTag = Symbol('dataTypeTag');\nexport const CalculationTypeTag = Symbol('calculationType');\nexport const CalculationRecalculateTag = Symbol('calculationRecalculate');\nexport const CalculationRecalculateCycleTag = Symbol(\n    'calculationRecalculateCycle'\n);\nexport const CalculationInvalidateTag = Symbol('calculationInvalidate');\nexport const CalculationSetCycleTag = Symbol('calculationSetCycle');\n\nexport const ObserveKey = Symbol('observe');\nexport const GetSubscriptionNodeKey = Symbol('getSubscriptionNode');\nexport const MakeModelViewKey = Symbol('makeModelView');\nexport const DisposeKey = Symbol('dispose');\nexport const FlushKey = Symbol('flush');\nexport const AddDeferredWorkKey = Symbol('addDeferredWork');\nexport const NotifyKey = Symbol('notify');\n\nexport type IntrinsicNodeObserverNodeCallback = (\n    node: Node,\n    event: 'add' | 'remove'\n) => void;\nexport type IntrinsicNodeObserverElementCallback = (\n    element: Element,\n    event: 'add' | 'remove'\n) => void;\n\nexport type ProcessAction =\n    | 'recalculate'\n    | 'recalculate-cycle'\n    | 'cycle'\n    | 'invalidate';\n\n/**\n * A ref object that can be passed to native elements.\n */\nexport type Ref<T> = {\n    [TypeTag]: 'ref';\n    current: T | undefined;\n};\nexport function isRef(ref: any): ref is Ref<unknown> {\n    return ref && ref[TypeTag] === 'ref';\n}\n\n/**\n * Make a ref object that can be passed to native elements.\n */\nexport function ref<T>(val?: T): Ref<T> {\n    return {\n        [TypeTag]: 'ref',\n        current: val,\n    };\n}\n\nexport type ModelEvent =\n    | {\n          type: 'add';\n          key: string | number | symbol;\n      }\n    | {\n          type: 'set';\n          key: string | number | symbol;\n          value: any;\n      }\n    | {\n          type: 'delete';\n          key: string | number | symbol;\n      };\nexport type ModelObserver = (event: ModelEvent) => void;\n\nexport type EqualityFunc<T> = (a: T, b: T) => boolean;\nexport type MappingFunction<T, V> = (item: T) => V;\nexport type FilterFunction<T> = (item: T) => boolean;\nexport type FlatMapFunction<T, V> = (item: T) => V[];\n\nexport interface ViewSpec<TInitialize, TItem, TEvent> {\n    /**\n     * Return initial items\n     */\n    initialize: (items: TInitialize) => TItem[];\n\n    /**\n     * Process subscription events\n     */\n    processEvent: (\n        view: Collection<TItem>,\n        event: TEvent,\n        initialValue: TItem[]\n    ) => void;\n}\n\nexport type CollectionEvent<T> =\n    | {\n          type: 'splice';\n          index: number;\n          count: number;\n          items: readonly T[];\n          removed: readonly T[];\n      }\n    | {\n          type: 'move';\n          fromIndex: number;\n          fromCount: number;\n          toIndex: number;\n          moved: readonly T[];\n      }\n    | {\n          type: 'sort';\n          indexes: readonly number[];\n      };\n\nexport type TrackedData<TTypeTag, TEvent> = {\n    $__id: number;\n    [TypeTag]: 'data';\n    [DataTypeTag]: TTypeTag;\n    [FlushKey]: () => boolean;\n    [AddDeferredWorkKey]: (task: () => void) => void;\n    [ObserveKey]: (\n        listener: (events: TEvent[], subscriptionNode: Subscription) => void\n    ) => () => void;\n    [GetSubscriptionNodeKey]: () => Subscription;\n    [NotifyKey](event: TEvent): void; // Note: bivariance needed here!\n    [DisposeKey]: () => void;\n};\n\n/**\n * A mutable object to hold state\n */\ninterface ModelMethods<T extends {}> {\n    [MakeModelViewKey]: <V>(\n        modelViewSpec: ViewSpec<Readonly<T>, V, ModelEvent>,\n        debugName?: string\n    ) => View<V>;\n}\nexport type Model<T> = TrackedData<'model', ModelEvent> &\n    ModelMethods<T> & {\n        [Key in keyof T]: T[Key];\n    };\n\n/**\n * A mutable array to hold state, with some additional convenience methods\n */\ninterface CollectionMethods<T> {\n    makeView<V>(\n        viewSpec: ViewSpec<readonly T[], V, CollectionEvent<T>>,\n        debugName?: string\n    ): View<V>;\n    mapView<V>(mapFn: MappingFunction<T, V>, debugName?: string): View<V>;\n    filterView(filterFn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(\n        flatMapFn: MappingFunction<T, V[]>,\n        debugName?: string\n    ): View<V>;\n    reject(shouldReject: (item: T, index: number) => boolean): T[];\n    moveSlice(fromIndex: number, fromCount: number, toIndex: number): void;\n}\nexport interface Collection<T>\n    extends TrackedData<'collection', CollectionEvent<T>>,\n        CollectionMethods<T>,\n        Array<T> {}\n\n/**\n * A readonly array to hold projected state\n */\ninterface ViewMethods<T> {\n    makeView<V>(\n        viewSpec: ViewSpec<readonly T[], V, CollectionEvent<T>>,\n        debugName?: string\n    ): View<V>;\n    mapView<V>(mapFn: MappingFunction<T, V>, debugName?: string): View<V>;\n    filterView(filterFn: FilterFunction<T>, debugName?: string): View<T>;\n    flatMapView<V>(\n        flatMapFn: MappingFunction<T, V[]>,\n        debugName?: string\n    ): View<V>;\n}\nexport interface View<T>\n    extends TrackedData<'collection', CollectionEvent<T>>,\n        ViewMethods<T>,\n        ReadonlyArray<T> {}\n\nexport interface Subscription {\n    $__id: number;\n    [TypeTag]: 'subscription';\n    item: any;\n    [FlushKey]: () => boolean;\n}\n\nexport interface NodeOrdering {\n    $__id: number;\n    [TypeTag]: 'nodeOrdering';\n}\n\n/**\n * A key-value pair that is active for a subtree\n */\nexport interface Context<TValue> {\n    (): never;\n    [ContextGetterTag]: () => TValue;\n    [TypeTag]: 'context';\n}\n\nexport function createContext<TValue>(val: TValue): Context<TValue> {\n    return Object.assign(\n        () => {\n            throw new Error('Do not call contexts as functions');\n        },\n        {\n            [ContextGetterTag]: () => val,\n            [TypeTag]: 'context' as const,\n        }\n    );\n}\n\nexport function getContext<TValue>(context: Context<TValue>): TValue {\n    return context[ContextGetterTag]();\n}\n\nexport function isContext(val: any): val is Context<any> {\n    return !!(val && val[TypeTag] === 'context');\n}\n\n/**\n * A calculation cell that recalculates when dependencies change\n */\nexport interface Calculation<Result> {\n    (): Result;\n    $__id: number;\n    [TypeTag]: 'calculation';\n    [CalculationTypeTag]: 'calculation' | 'effect';\n    dispose: () => void;\n    onError: (handler: (errorType: 'cycle' | 'error') => Result) => this;\n    [CalculationSetCycleTag]: () => boolean;\n    [CalculationRecalculateTag]: () => boolean;\n    [CalculationRecalculateCycleTag]: () => boolean;\n    [CalculationInvalidateTag]: () => void;\n}\n\nexport interface ModelField {\n    $__id: number;\n    model: {\n        [DataTypeTag]: any;\n    };\n    key: string | number | symbol;\n}\n\nexport function isModel(thing: any): thing is Model<unknown> {\n    return !!(\n        thing &&\n        thing[TypeTag] === 'data' &&\n        thing[DataTypeTag] === 'model'\n    );\n}\n\nexport function isModelField(thing: any): thing is ModelField {\n    return !!(\n        thing &&\n        !thing[TypeTag] &&\n        !!thing.model &&\n        !!thing.model[DataTypeTag]\n    );\n}\n\nexport function isCollection(thing: any): thing is Collection<any> | View<any> {\n    return !!(\n        thing &&\n        thing[TypeTag] === 'data' &&\n        thing[DataTypeTag] === 'collection'\n    );\n}\n\nexport function isCalculation(thing: any): thing is Calculation<any> {\n    return !!(thing && thing[TypeTag] === 'calculation');\n}\n\nexport function isEffect(thing: Calculation<unknown>): boolean {\n    return thing[CalculationTypeTag] === 'effect';\n}\n\nexport function isSubscription(thing: any): thing is Subscription {\n    return !!(thing && thing[TypeTag] === 'subscription');\n}\n\nexport function isNodeOrdering(thing: any): thing is NodeOrdering {\n    return !!(thing && thing[TypeTag] === 'nodeOrdering');\n}\n\nexport type GraphNode = { $__id: number };\n", "import { InvariantError } from './types';\n\nexport type LogLevel = 'error' | 'warn' | 'info' | 'debug';\nconst levels: Record<LogLevel, number> = {\n    error: 0,\n    warn: 1,\n    info: 2,\n    debug: 3,\n};\nlet currentLevel: number = levels.warn;\n\nexport function getLogLevel(): LogLevel {\n    if (currentLevel >= levels.info) return 'info';\n    if (currentLevel >= levels.warn) return 'warn';\n    if (currentLevel >= levels.debug) return 'debug';\n    return 'error';\n}\nexport function setLogLevel(logLevel: LogLevel) {\n    invariant(() => logLevel in levels, logLevel);\n    currentLevel = levels[logLevel];\n}\n\nexport function debug(...items: any[]) {\n    if (currentLevel >= levels.debug) {\n        console.log(...items);\n    }\n}\n\nexport function info(...items: any[]) {\n    if (currentLevel >= levels.info) {\n        console.log(...items);\n    }\n}\n\nexport function warn(...items: any[]) {\n    if (currentLevel >= levels.warn) {\n        console.warn(...items);\n    }\n}\n\nexport function error(...items: any[]) {\n    if (currentLevel >= levels.error) {\n        console.error(...items);\n    }\n}\n\nexport function exception(exception: any, ...items: any[]) {\n    if (exception instanceof Error) {\n        error(exception);\n        error(...items);\n    } else {\n        error(exception, ...items);\n    }\n}\n\nexport function invariant(check: () => any, ...items: any[]) {\n    if (!check()) {\n        error('Invariant error', check.toString(), 'is not truthy', ...items);\n    }\n}\n\nexport function assert(check: any, msg: string): asserts check {\n    if (!check) {\n        error(\n            'Assertion failure',\n            check === undefined\n                ? 'undefined'\n                : check === null\n                ? 'null'\n                : check.toString(),\n            'is not truthy',\n            msg\n        );\n        throw new InvariantError(`Assertion failure: ${msg}`);\n    }\n}\n\nexport function assertExhausted(context: never, ...items: any[]): never {\n    error('Assertion failure', context, 'is not exhausted', ...items);\n    throw new InvariantError('Assertion failure', { context, items });\n}\n", "// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\nexport const uniqueid = (() => {\n    let id = 1;\n    return () => id++;\n})();\n\nexport const sleep = (ms: number) =>\n    new Promise<void>((resolve) => setTimeout(() => resolve(), ms));\n\nexport function makePromise<T>(): {\n    promise: Promise<T>;\n    resolve: (val: T) => void;\n    reject: (val: T) => void;\n} {\n    let resolve: (val: T) => void = noop;\n    let reject: (val: T) => void = noop;\n    const promise = new Promise<T>((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nexport function groupBy<TItem, TKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TKey, TVal]\n): Map<TKey, TVal[]> {\n    const grouped: Map<TKey, TVal[]> = new Map();\n    items.forEach((item) => {\n        const [key, val] = grouper(item);\n        let inner = grouped.get(key);\n        if (!inner) {\n            inner = [];\n            grouped.set(key, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function groupBy2<TItem, TOuterKey, TInnerKey, TVal>(\n    items: TItem[],\n    grouper: (item: TItem) => [TOuterKey, TInnerKey, TVal]\n) {\n    const grouped: Map<TOuterKey, Map<TInnerKey, TVal[]>> = new Map();\n    items.forEach((item) => {\n        const [outerKey, innerKey, val] = grouper(item);\n        let outer = grouped.get(outerKey);\n        if (!outer) {\n            outer = new Map();\n            grouped.set(outerKey, outer);\n        }\n        let inner = outer.get(innerKey);\n        if (!inner) {\n            inner = [];\n            outer.set(innerKey, inner);\n        }\n        inner.push(val);\n    });\n    return grouped;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function strictEqual<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low)) + low;\n}\n\nexport function median(numbers: number[]): number {\n    const sorted = numbers.slice().sort((a, b) => a - b);\n    return (\n        (sorted[Math.floor((numbers.length - 1) / 2)] +\n            sorted[Math.ceil((numbers.length - 1) / 2)]) /\n        2\n    );\n}\n", "type Vertex = {\n    nodeId: string;\n    index?: number;\n    lowlink?: number;\n    onStack?: boolean;\n};\n\nexport function tarjanStronglyConnected(\n    graph: Record<string, Record<string, number>>,\n    fromNodes: string[]\n): Set<string>[] {\n    let index = 0;\n    const nodeVertex: Record<string, Vertex> = {};\n    const stack: Vertex[] = [];\n    const reverseTopoSort: Vertex[][] = [];\n\n    function getDepenencies(nodeId: string) {\n        const dependencies: string[] = [];\n        Object.keys(graph[nodeId] || {}).forEach((toId) => {\n            if (graph[nodeId][toId]) {\n                dependencies.push(toId);\n            }\n        });\n        return dependencies;\n    }\n\n    const strongconnect = (vertex: Vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index = index + 1;\n        stack.push(vertex);\n        vertex.onStack = true;\n\n        // Consider successors of v\n        getDepenencies(vertex.nodeId).forEach((toId) => {\n            if (!nodeVertex[toId]) {\n                nodeVertex[toId] = {\n                    nodeId: toId,\n                };\n            }\n            const toVertex = nodeVertex[toId];\n            if (toVertex.index === undefined) {\n                // Successor toVertex has not yet been visited; recurse on it\n                strongconnect(toVertex);\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    toVertex.lowlink!\n                );\n            } else if (toVertex.onStack) {\n                // Successor toVertex is in stack S and hence in the current SCC\n                // If toVertex is not on stack, then (vertex, toVertex) is an edge pointing to an SCC already found and must be ignored\n                // Note: The next line may look odd - but is correct.\n                // It says toVertex.index not toVertex.lowlink; that is deliberate and from the original paper\n                vertex.lowlink = Math.min(\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    vertex.lowlink!,\n                    toVertex.index\n                );\n            }\n        });\n\n        // If vertex is a root node, pop the stack and generate an SCC\n        if (vertex.lowlink === vertex.index) {\n            // start a new strongly connected component\n            const component: Vertex[] = [];\n            for (;;) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const toVertex = stack.pop()!;\n                toVertex.onStack = false;\n                // add toVertex to current strongly connected component\n                component.push(toVertex);\n                if (toVertex === vertex) {\n                    break;\n                }\n            }\n            // output the current strongly connected component\n            reverseTopoSort.push(component);\n        }\n    };\n\n    fromNodes.forEach((nodeId) => {\n        if (!nodeVertex[nodeId]) {\n            nodeVertex[nodeId] = {\n                nodeId,\n            };\n            strongconnect(nodeVertex[nodeId]);\n        }\n    });\n\n    reverseTopoSort.reverse();\n\n    return reverseTopoSort.map(\n        (component) => new Set(component.map((vertex) => vertex.nodeId))\n    );\n}\n", "import * as log from './log';\nimport type { ProcessAction } from './types';\nimport { groupBy } from './util';\nimport { tarjanStronglyConnected } from './tarjan';\n\nconst VISITED_NO_CYCLE = 1 as const;\nconst VISITED_CYCLE = 2 as const;\n\ntype EdgeList = [fromId: string, toId: string, edgeKind: number][];\ntype EdgeMap = Record<string, Record<string, number>>;\n\nfunction edgeMapToEdgeList(graph: EdgeMap): EdgeList {\n    const edgeList: EdgeList = [];\n    Object.entries(graph).forEach(([fromId, toIds]) => {\n        Object.entries(toIds).forEach(([toId, edgeKind]) => {\n            if (edgeKind > 0) {\n                edgeList.push([fromId, toId, edgeKind]);\n            }\n        });\n    });\n    return edgeList;\n}\n\nfunction edgeListToEdgeMap(edgeList: EdgeList): EdgeMap {\n    const graph: EdgeMap = {};\n    edgeList.forEach(([fromId, toId, edgeKind]) => {\n        if (edgeKind > 0) {\n            if (!graph[fromId]) graph[fromId] = {};\n            graph[fromId][toId] = edgeKind;\n        }\n    });\n    return graph;\n}\n\nenum PendingOperationType {\n    NODE_ADD,\n    NODE_DELETE,\n    EDGE_ADD,\n    EDGE_DELETE,\n}\ntype PendingOperation<Type extends object> =\n    | {\n          type: typeof PendingOperationType.NODE_ADD;\n          node: Type;\n      }\n    | {\n          type: typeof PendingOperationType.NODE_DELETE;\n          nodeId: string;\n      }\n    | {\n          type: typeof PendingOperationType.EDGE_ADD;\n          fromId: string;\n          toId: string;\n          kind: 0b01 | 0b10;\n      }\n    | {\n          type: typeof PendingOperationType.EDGE_DELETE;\n          fromId: string;\n          toId: string;\n          kind: 0b01 | 0b10 | 0b11;\n      };\n\n/**\n * A directed graph\n *\n * Edges may me marked as Graph.EDGE_SOFT (visualized as ->) or Graph.EDGE_HARD (visualized as =>):\n * - An EDGE_SOFT edge from A to B indicate an order dependency, but not a data dependency\n *   - If A and B are both dirty, A should be flushed **after** B is flushed\n *   - If A is not dirty and B is dirty and B is visited and B does not short-circuit, A does not get marked as dirty\n *   - Used to ensure that the DOM structure is updated in the correct order\n *     - onEffect() effects are executed after all of the calc() present in a component's DOM\n *     - \"parent\" calc() view nodes are executed after \"child\" calc() view nodes\n * - An EDGE_HARD edge from A to B indicates both order dependency and data dependency\n *   - If A and B are both dirty, A should be flushed **after** B is flushed\n *   - If A is not dirty and B is dirty and B is visited and B does not short-circuit, A gets marked as dirty and is visited\n */\nexport class Graph<Type extends object> {\n    private static EDGE_NONE = 0b00 as const;\n    static EDGE_SOFT = 0b01 as const;\n    static EDGE_HARD = 0b10 as const;\n    private static EDGE_ANY = 0b11 as const;\n\n    private retained: Record<string, true>;\n    private dirtyNodes: Record<string, true>;\n    private recentDirtyNodes: undefined | string[];\n    private informedCycles: Map<string, boolean>;\n    private knownCycles: Map<\n        string,\n        {\n            connectedComponentEdges: Record<string, Record<string, number>>;\n            connectedComponentNodes: Set<string>;\n            isInformed: boolean;\n            initiallyDirty: boolean;\n        }\n    >;\n    private minCycleBrokenIndex: null | number;\n\n    /**\n     * The subgraph that has been added but not yet ordered\n     */\n    private pendingOperations: PendingOperation<Type>[];\n    private pendingNodes: Record<string, boolean>;\n\n    /**\n     * A mapping of nodeId to index in topological order\n     */\n    private topologicalIndex: Record<string, number>;\n    /**\n     * The list of vertices maintained in topological order\n     */\n    private topologicallyOrderedNodes: (Type | undefined)[];\n    /**\n     * A mapping of nodeId to whether or not the node is visited while reordering\n     * Note: this is internal state to the process() function but global to reduce object memory thrash\n     */\n    private reorderingVisitedState: Map<string, boolean>;\n\n    private graph: EdgeMap;\n    private reverseGraph: EdgeMap;\n\n    constructor() {\n        this.topologicalIndex = {};\n        this.topologicallyOrderedNodes = [];\n\n        this.pendingOperations = [];\n        this.pendingNodes = {};\n\n        this.retained = {};\n        this.graph = {};\n        this.reverseGraph = {};\n\n        this.dirtyNodes = {};\n        this.recentDirtyNodes = undefined;\n\n        this.knownCycles = new Map();\n        this.informedCycles = new Map();\n        this.reorderingVisitedState = new Map();\n        this.minCycleBrokenIndex = null;\n    }\n\n    private getId(node: Type): string {\n        return (node as any).$__id.toString();\n    }\n\n    private hasNodeInner(nodeId: string) {\n        return (\n            this.topologicalIndex[nodeId] !== undefined ||\n            this.pendingNodes[nodeId]\n        );\n    }\n\n    addNode(node: Type): boolean {\n        const nodeId = this.getId(node);\n        if (this.hasNodeInner(nodeId)) return false;\n        this.pendingOperations.push({\n            type: PendingOperationType.NODE_ADD,\n            node,\n        });\n        this.pendingNodes[nodeId] = true;\n        return true;\n    }\n\n    private performAddNodeInner(node: Type, nodeId: string) {\n        this.graph[nodeId] = {};\n        this.reverseGraph[nodeId] = {};\n        this.topologicalIndex[nodeId] = this.topologicallyOrderedNodes.length;\n        this.topologicallyOrderedNodes.push(node);\n        return true;\n    }\n\n    markNodeCycle(node: Type): void {\n        const nodeId = this.getId(node);\n        const cycleInfo = this.knownCycles.get(nodeId);\n        if (cycleInfo) {\n            cycleInfo.isInformed = true;\n        } else {\n            this.informedCycles.set(this.getId(node), true);\n        }\n    }\n\n    markNodeDirty(node: Type): void {\n        const nodeId = this.getId(node);\n        const cycleInfo = this.knownCycles.get(nodeId);\n        if (cycleInfo) {\n            cycleInfo.connectedComponentNodes.forEach((cycleId) => {\n                this.markNodeDirtyInner(cycleId);\n            });\n        } else {\n            this.markNodeDirtyInner(this.getId(node));\n        }\n    }\n\n    private markNodeDirtyInner(nodeId: string): void {\n        this.dirtyNodes[nodeId] = true;\n        if (this.recentDirtyNodes) this.recentDirtyNodes.push(nodeId);\n    }\n\n    private markNodeCleanInner(nodeId: string): void {\n        delete this.dirtyNodes[nodeId];\n        this.informedCycles.set(nodeId, false);\n    }\n\n    private isNodeDirty(nodeId: string) {\n        return !!this.dirtyNodes[nodeId];\n    }\n\n    getUnorderedDirtyNodes() {\n        return Object.keys(this.dirtyNodes).filter(\n            (nodeId) => !!this.dirtyNodes[nodeId]\n        );\n    }\n\n    hasDirtyNodes(): boolean {\n        return Object.keys(this.dirtyNodes).length > 0;\n    }\n\n    /**\n     * Indicate that toNode needs to be updated if fromNode has changed\n     */\n    addEdge(fromNode: Type, toNode: Type, kind: 0b01 | 0b10): void {\n        const fromId = this.getId(fromNode);\n        const toId = this.getId(toNode);\n        this.addEdgeInner(fromId, toId, kind);\n    }\n\n    private addEdgeInner(\n        fromId: string,\n        toId: string,\n        kind: 0b01 | 0b10\n    ): void {\n        log.assert(\n            this.hasNodeInner(fromId),\n            'cannot add edge from node that does not exist'\n        );\n        log.assert(\n            this.hasNodeInner(toId),\n            'cannot add edge to node that does not exist'\n        );\n        this.pendingOperations.push({\n            type: PendingOperationType.EDGE_ADD,\n            fromId,\n            toId,\n            kind,\n        });\n    }\n\n    private performAddEdgeInner(\n        fromId: string,\n        toId: string,\n        kind: 0b01 | 0b10\n    ) {\n        this.graph[fromId][toId] = (this.graph[fromId][toId] || 0) | kind;\n        this.reverseGraph[toId][fromId] =\n            (this.reverseGraph[toId][fromId] || 0) | kind;\n    }\n\n    /**\n     * Returns true if edge is removed\n     */\n    removeEdge(fromNode: Type, toNode: Type, kind: 0b01 | 0b10 | 0b11) {\n        const fromId = this.getId(fromNode);\n        const toId = this.getId(toNode);\n        this.removeEdgeInner(fromId, toId, kind);\n    }\n\n    private removeEdgeInner(\n        fromId: string,\n        toId: string,\n        kind: 0b01 | 0b10 | 0b11\n    ) {\n        log.assert(\n            this.hasNodeInner(fromId),\n            'cannot remove edge from node that does not exist'\n        );\n        log.assert(\n            this.hasNodeInner(toId),\n            'cannot remove edge to node that does not exist'\n        );\n\n        this.pendingOperations.push({\n            type: PendingOperationType.EDGE_DELETE,\n            fromId,\n            toId,\n            kind,\n        });\n    }\n\n    private performRemoveEdgeInner(\n        fromId: string,\n        toId: string,\n        kind: 0b01 | 0b10 | 0b11\n    ) {\n        this.graph[fromId][toId] = (this.graph[fromId][toId] || 0) & ~kind;\n        this.reverseGraph[toId][fromId] =\n            (this.reverseGraph[toId][fromId] || 0) & ~kind;\n        const cycleInfo = this.knownCycles.get(fromId);\n        if (cycleInfo && cycleInfo.connectedComponentEdges[fromId]?.[toId]) {\n            cycleInfo.connectedComponentEdges[fromId][toId] =\n                cycleInfo.connectedComponentEdges[fromId][toId] & ~kind;\n\n            // Note: we are getting the topological ordering + components for **all** of the nodes reachable from these\n            // components. This is a conservative guess, which uses the assumption that the presence of cycles can cause\n            // incorrect orderings with the Pearce Kelly algorithm and we need to repair them.\n            //\n            // TODO: determine if we could only look at _just_ cycleInfo.connectedComponentEdges instead of this.graph\n            const newComponents = tarjanStronglyConnected(\n                this.graph,\n                Array.from(cycleInfo.connectedComponentNodes)\n            );\n\n            // The edge deletion broke the cycle into multiple components\n            const edgeList: EdgeList = edgeMapToEdgeList(\n                cycleInfo.connectedComponentEdges\n            );\n            const affectedIndexes: number[] = [];\n            const topologicallyCorrectNodes: {\n                nodeId: string;\n                node: Type | undefined;\n            }[] = [];\n            newComponents.forEach((component) => {\n                // Obtain the current indexes and topologically correct ordering of the entire component\n                component.forEach((nodeId) => {\n                    const nodeIndex = this.topologicalIndex[nodeId];\n                    affectedIndexes.push(nodeIndex);\n                    topologicallyCorrectNodes.push({\n                        nodeId,\n                        node: this.topologicallyOrderedNodes[nodeIndex],\n                    });\n                });\n\n                // Update all the knownCycles data structures to reflect the new reality, and collect the correct ordering\n                const componentIntersection = new Set(\n                    [...component].filter((nodeId) =>\n                        cycleInfo.connectedComponentNodes.has(nodeId)\n                    )\n                );\n                const isCycle = componentIntersection.size > 1;\n                if (isCycle) {\n                    const reducedConnectedComponentEdges = edgeListToEdgeMap(\n                        edgeList.filter(\n                            ([fromId, toId, _edgeKind]) =>\n                                componentIntersection.has(fromId) &&\n                                componentIntersection.has(toId)\n                        )\n                    );\n                    componentIntersection.forEach((nodeId) => {\n                        this.knownCycles.set(nodeId, {\n                            connectedComponentEdges:\n                                reducedConnectedComponentEdges,\n                            connectedComponentNodes: componentIntersection,\n                            isInformed:\n                                !!this.knownCycles.get(nodeId)?.isInformed,\n                            initiallyDirty:\n                                !!this.knownCycles.get(nodeId)?.initiallyDirty,\n                        });\n                    });\n                } else {\n                    componentIntersection.forEach((nodeId) => {\n                        this.knownCycles.delete(nodeId);\n                        this.markNodeDirtyInner(nodeId);\n                    });\n                }\n            });\n\n            // If the current indexes are already in topological order, no need to resort\n            let needsResort = false;\n            for (let i = 1; i < affectedIndexes.length; ++i) {\n                if (affectedIndexes[i - 1] >= affectedIndexes[i]) {\n                    needsResort = true;\n                    break;\n                }\n            }\n            if (needsResort) {\n                affectedIndexes.sort((a, b) => a - b);\n                for (let i = 0; i < affectedIndexes.length; ++i) {\n                    const entry = topologicallyCorrectNodes[i];\n                    this.topologicalIndex[entry.nodeId] = affectedIndexes[i];\n                    this.topologicallyOrderedNodes[affectedIndexes[i]] =\n                        entry.node;\n                }\n                this.minCycleBrokenIndex =\n                    this.minCycleBrokenIndex === null\n                        ? affectedIndexes[0]\n                        : Math.min(\n                              this.minCycleBrokenIndex,\n                              affectedIndexes[0]\n                          );\n            }\n        }\n    }\n\n    removeNode(node: Type) {\n        const nodeId = this.getId(node);\n        this.removeNodeInner(nodeId);\n    }\n\n    private removeNodeInner(nodeId: string) {\n        this.pendingOperations.push({\n            type: PendingOperationType.NODE_DELETE,\n            nodeId: nodeId,\n        });\n        this.pendingNodes[nodeId] = false;\n    }\n\n    private performRemoveNodeInner(nodeId: string) {\n        // Note: this can be performed without reordering topological ordering,\n        // since node and edge removal does not change the topological order.\n        log.assert(\n            !this.retained[nodeId],\n            'attempted to remove a retained node'\n        ); // Is this right?\n        const toIds = this.getDependenciesInner(nodeId, Graph.EDGE_ANY);\n        const fromIds = this.getReverseDependenciesInner(nodeId);\n\n        // delete fromId -> nodeId for fromId in fromIds\n        fromIds.forEach((fromId) => {\n            this.graph[fromId][nodeId] = 0;\n            this.reverseGraph[nodeId][fromId] = 0;\n        });\n\n        // delete nodeId -> toId for toId in toIds\n        toIds.forEach((toId) => {\n            this.reverseGraph[toId][nodeId] = 0;\n            this.graph[nodeId][toId] = 0;\n        });\n\n        this.topologicallyOrderedNodes[this.topologicalIndex[nodeId]] =\n            undefined;\n        delete this.topologicalIndex[nodeId];\n        this.markNodeCleanInner(nodeId);\n        delete this.retained[nodeId];\n        const cycleInfo = this.knownCycles.get(nodeId);\n        if (cycleInfo) {\n            // TODO: do we need to \"fix\" the existing cycles? Yes, yes we do\n            throw new Error('Not yet implemented');\n        }\n    }\n\n    retain(node: Type) {\n        const nodeId = this.getId(node);\n        log.assert(!this.retained[nodeId], 'double-retain');\n        this.retained[nodeId] = true;\n    }\n\n    release(node: Type) {\n        const nodeId = this.getId(node);\n        log.assert(this.retained[nodeId], 'double-release');\n        delete this.retained[nodeId];\n    }\n\n    replaceIncoming(node: Type, newIncomingNodes: Type[]) {\n        const toId = this.getId(node);\n\n        const beforeFromIds = this.getReverseDependenciesInner(\n            toId,\n            Graph.EDGE_HARD\n        );\n        const beforeFromSet = new Set(beforeFromIds);\n        const newFromIds = newIncomingNodes.map((fromNode) =>\n            this.getId(fromNode)\n        );\n        const newFromSet = new Set(newFromIds);\n        beforeFromIds.forEach((fromId) => {\n            if (!newFromSet.has(fromId)) {\n                this.removeEdgeInner(fromId, toId, Graph.EDGE_HARD);\n            }\n        });\n        newFromIds.forEach((fromId) => {\n            if (!beforeFromSet.has(fromId)) {\n                this.addEdgeInner(fromId, toId, Graph.EDGE_HARD);\n            }\n        });\n    }\n\n    removeIncoming(node: Type) {\n        const toId = this.getId(node);\n\n        const fromIds = this.getReverseDependenciesInner(toId);\n        fromIds.forEach((fromId) => {\n            this.removeEdgeInner(fromId, toId, Graph.EDGE_HARD);\n        });\n    }\n\n    /**\n     * Get dependencies (specify EDGE_SOFT, EDGE_HARD, or EDGE_ANY)\n     */\n    private getDependenciesInner(\n        nodeId: string,\n        edgeType: 0b01 | 0b10 | 0b11\n    ): string[] {\n        if (!this.graph[nodeId]) return [];\n        const dependencies: string[] = [];\n        Object.keys(this.graph[nodeId]).forEach((toId) => {\n            if ((this.graph[nodeId][toId] || 0) & edgeType) {\n                dependencies.push(toId);\n            }\n        });\n        return dependencies;\n    }\n\n    /**\n     * Get reverse dependencies (either EDGE_SOFT or EDGE_HARD)\n     */\n    private getReverseDependenciesInner(\n        nodeId: string,\n        edgeType: 0b01 | 0b10 | 0b11 = Graph.EDGE_ANY\n    ): string[] {\n        if (!this.reverseGraph[nodeId]) return [];\n        const dependencies: string[] = [];\n        Object.keys(this.reverseGraph[nodeId]).forEach((fromId) => {\n            if ((this.reverseGraph[nodeId][fromId] || 0) & edgeType) {\n                dependencies.push(fromId);\n            }\n        });\n        return dependencies;\n    }\n\n    /**\n     * Get list of things need to be updated, when fromNode has changed?\n     */\n    _test_getDependencies(\n        fromNode: Type,\n        edgeType: 0b01 | 0b10 | 0b11 = Graph.EDGE_ANY\n    ): Type[] {\n        const nodeId = this.getId(fromNode);\n        return this.getDependenciesInner(nodeId, edgeType).map(\n            (toId) =>\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this.topologicallyOrderedNodes[this.topologicalIndex[toId]]!\n        );\n    }\n\n    /*\n     * Core Processing Algorithm\n     * =========================\n     *\n     * In topological order, recalculate all of the dirty nodes that reach retained nodes; propagating dirtiness if\n     * propagation is requested.\n     *\n     * For all remaining dirty nodes (which do not reach retained nodes), flush them & all their reachable nodes.\n     *\n     * If a strongly connected component is identified, it should be treated as a single unit:\n     * - If any node is dirtied or flushed; all nodes are\n     *\n     * Topological order is maintained by the PK algorithm, outlined in:\n     * - David J. Pearce and Paul H. J. Kelly. 2007. A dynamic topological sort algorithm for directed acyclic graphs. ACM J. Exp. Algorithmics 11 (2006), 1.7\u2013es.\n     *   https://doi.org/10.1145/1187436.1210590\n     * - Available from https://whileydave.com/publications/pk07_jea/\n     *\n     * TODO: As a performance optimization, consider implementing \"A Batch Algorithm for Maintaining a Topological\n     * Order\"\n     */\n    process(callback: (node: Type, action: ProcessAction) => boolean): void {\n        const forwardSet = new Set<string>();\n        const reverseSet = new Set<string>();\n\n        // Affected region (lower bound, upper bound)\n        let lowerBound = 0;\n        let upperBound = 0;\n        let reordered = false;\n        const connectedComponentNodes = new Set<string>();\n        const connectedComponentEdges: Record<\n            string,\n            Record<string, number>\n        > = {};\n\n        const dfsF = (nodeId: string): boolean => {\n            this.reorderingVisitedState.set(nodeId, false);\n            forwardSet.add(nodeId);\n            return this.getDependenciesInner(nodeId, Graph.EDGE_ANY).some(\n                (toId) => {\n                    if (this.topologicalIndex[toId] === upperBound) {\n                        return true; // We have identified a new cycle!\n                    }\n                    // Only visit nodes that are in affected region\n                    //\n                    // **or** nodes that are part of a strongly connected component\n                    // Note: this consequent is a diversion from the Pearce-Kelly algorithm to account for cycles which we treat as a single strongly connected component,\n                    // in the presence of adding an edge to a cycle, the bounds must extend to the min/max bound of all nodes within the strongly connected component\n                    if (\n                        !this.reorderingVisitedState.has(toId) &&\n                        (this.topologicalIndex[toId] < upperBound ||\n                            this.knownCycles.has(toId))\n                    ) {\n                        if (dfsF(toId)) return true;\n                    }\n                    return false;\n                }\n            );\n        };\n\n        const dfsB = (nodeId: string) => {\n            this.reorderingVisitedState.set(nodeId, true);\n            reverseSet.add(nodeId);\n            this.getReverseDependenciesInner(nodeId, Graph.EDGE_ANY).forEach(\n                (fromId) => {\n                    // Only visit nodes that are in affected region\n                    //\n                    // **or** nodes that are part of a strongly connected component\n                    // Note: this consequent is a diversion from the Pearce-Kelly algorithm to account for cycles which we treat as a single strongly connected component,\n                    // in the presence of adding an edge to a cycle, the bounds must extend to the min/max bound of all nodes within the strongly connected component\n                    if (\n                        !this.reorderingVisitedState.has(fromId) &&\n                        (lowerBound < this.topologicalIndex[fromId] ||\n                            this.knownCycles.has(fromId))\n                    ) {\n                        dfsB(fromId);\n                    }\n                }\n            );\n        };\n\n        const stronglyConnectedVisited: Map<string, number> = new Map();\n        const dfsStronglyConnected = (nodeId: string): boolean => {\n            stronglyConnectedVisited.set(nodeId, VISITED_NO_CYCLE);\n            forwardSet.add(nodeId);\n            let reachesCycle = false;\n            this.getDependenciesInner(nodeId, Graph.EDGE_ANY).forEach(\n                (toId) => {\n                    if (this.topologicalIndex[toId] === upperBound) {\n                        // We identified the cycle\n                        // Add the current node to the connected component\n                        stronglyConnectedVisited.set(nodeId, VISITED_CYCLE);\n                        connectedComponentNodes.add(nodeId);\n                        stronglyConnectedVisited.set(toId, VISITED_CYCLE);\n                        connectedComponentNodes.add(toId);\n                        if (!connectedComponentEdges[nodeId]) {\n                            connectedComponentEdges[nodeId] = {};\n                        }\n                        connectedComponentEdges[nodeId][toId] =\n                            this.graph[nodeId][toId];\n                        reachesCycle = true;\n                        return;\n                    }\n                    let partOfComponent = false;\n\n                    if (!stronglyConnectedVisited.has(toId)) {\n                        partOfComponent = dfsStronglyConnected(toId);\n                    }\n                    if (stronglyConnectedVisited.get(toId) === VISITED_CYCLE) {\n                        partOfComponent = true;\n                    }\n                    if (partOfComponent) {\n                        reachesCycle = true;\n                        // We have identified a new cycle!\n                        // This node is part of a connected component\n                        stronglyConnectedVisited.set(nodeId, VISITED_CYCLE);\n                        connectedComponentNodes.add(nodeId);\n                        if (!connectedComponentEdges[nodeId]) {\n                            connectedComponentEdges[nodeId] = {};\n                        }\n                        connectedComponentEdges[nodeId][toId] =\n                            this.graph[nodeId][toId];\n                    }\n                }\n            );\n            return reachesCycle;\n        };\n\n        const reorder = () => {\n            const sortedReverseSet = Array.from(reverseSet);\n            sortedReverseSet.sort(\n                (a, b) => this.topologicalIndex[a] - this.topologicalIndex[b]\n            );\n            const sortedForwardSet = Array.from(forwardSet);\n            sortedForwardSet.sort(\n                (a, b) => this.topologicalIndex[a] - this.topologicalIndex[b]\n            );\n            const correctOrderNodeIds = [\n                ...sortedReverseSet,\n                ...sortedForwardSet,\n            ];\n            const affectedIndexes = correctOrderNodeIds\n                .map((nodeId) => this.topologicalIndex[nodeId])\n                .sort((a, b) => a - b);\n            const correctNodes = correctOrderNodeIds.map(\n                (nodeId) =>\n                    this.topologicallyOrderedNodes[\n                        this.topologicalIndex[nodeId]\n                    ]\n            );\n            affectedIndexes.forEach((affectedIndex, i) => {\n                this.topologicallyOrderedNodes[affectedIndex] = correctNodes[i];\n                this.topologicalIndex[correctOrderNodeIds[i]] = affectedIndex;\n            });\n        };\n\n        const addEdge = (fromId: string, toId: string) => {\n            // Note: this is a diversion from the Pearce-Kelly algorithm to account for cycles which we treat as a single strongly connected component,\n            // in the presence of adding an edge to a cycle, the bounds must extend to the min/max bound of all nodes within the strongly connected component\n            const toCycleInfo = this.knownCycles.get(toId);\n            if (toCycleInfo) {\n                lowerBound = this.topologicallyOrderedNodes.length;\n                toCycleInfo.connectedComponentNodes.forEach((toCycleId) => {\n                    lowerBound = Math.min(\n                        lowerBound,\n                        this.topologicalIndex[toCycleId]\n                    );\n                });\n            } else {\n                lowerBound = this.topologicalIndex[toId];\n            }\n\n            const fromCycleInfo = this.knownCycles.get(fromId);\n            if (fromCycleInfo) {\n                upperBound = 0;\n                fromCycleInfo.connectedComponentNodes.forEach((fromCycleId) => {\n                    upperBound = Math.max(\n                        upperBound,\n                        this.topologicalIndex[fromCycleId]\n                    );\n                });\n            } else {\n                upperBound = this.topologicalIndex[fromId];\n            }\n\n            if (lowerBound < upperBound) {\n                const isCycle = dfsF(toId);\n                if (isCycle) {\n                    stronglyConnectedVisited.clear();\n                    dfsStronglyConnected(toId);\n                    if (!connectedComponentEdges[fromId]) {\n                        connectedComponentEdges[fromId] = {};\n                    }\n                    connectedComponentEdges[fromId][toId] =\n                        this.graph[fromId][toId];\n                    connectedComponentNodes.forEach((nodeId) => {\n                        const cycleInfo = this.knownCycles.get(nodeId);\n\n                        const isInformed: boolean =\n                            !!cycleInfo?.isInformed ||\n                            !!this.informedCycles.get(nodeId);\n\n                        const initiallyDirty = !!this.dirtyNodes[nodeId];\n\n                        this.knownCycles.set(nodeId, {\n                            connectedComponentEdges,\n                            connectedComponentNodes,\n                            isInformed,\n                            initiallyDirty,\n                        });\n                    });\n                } else {\n                    dfsB(fromId);\n                    reorder();\n                    reordered = true;\n                }\n                forwardSet.clear();\n                reverseSet.clear();\n                this.reorderingVisitedState.clear();\n            }\n        };\n\n        const processPendingEdges = () => {\n            let minLowerBound: number | null = null;\n\n            //\n            // First construct a graph of *just* the edge additions to the graph and the final set of nodes being added\n            //\n            const nodesToAdd: Record<string, Type> = {};\n            const pendingGraph: EdgeMap = {};\n            const filteredPendingOperations = this.pendingOperations.filter(\n                (pendingOperation) => {\n                    switch (pendingOperation.type) {\n                        case PendingOperationType.NODE_ADD:\n                            nodesToAdd[this.getId(pendingOperation.node)] =\n                                pendingOperation.node;\n                            // We are handling node additions here in a specific order\n                            return false;\n                        case PendingOperationType.NODE_DELETE:\n                            if (nodesToAdd[pendingOperation.nodeId]) {\n                                delete nodesToAdd[pendingOperation.nodeId];\n                                return false;\n                            }\n                            // Deletions of nodes not added in this batch is handled below\n                            return true;\n                        case PendingOperationType.EDGE_ADD:\n                            if (!pendingGraph[pendingOperation.fromId]) {\n                                pendingGraph[pendingOperation.fromId] = {};\n                            }\n                            pendingGraph[pendingOperation.fromId][\n                                pendingOperation.toId\n                            ] =\n                                (pendingGraph[pendingOperation.fromId][\n                                    pendingOperation.toId\n                                ] || 0) | pendingOperation.kind;\n                            // All edge manipulations occur below\n                            return true;\n                        case PendingOperationType.EDGE_DELETE:\n                            if (!pendingGraph[pendingOperation.fromId]) {\n                                pendingGraph[pendingOperation.fromId] = {};\n                            }\n                            pendingGraph[pendingOperation.fromId][\n                                pendingOperation.toId\n                            ] =\n                                (pendingGraph[pendingOperation.fromId][\n                                    pendingOperation.toId\n                                ] || 0) & ~pendingOperation.kind;\n                            // All edge manipulations occur below\n                            return true;\n                        default:\n                            log.assertExhausted(\n                                pendingOperation,\n                                'unexpected pending operation'\n                            );\n                    }\n                }\n            );\n            this.pendingOperations = [];\n\n            //\n            // Pre-sort the final set of nodes to be added\n            //\n            const visited: Record<string, boolean> = {};\n            const pendingNodeIdIndex: Record<string, number> = {};\n            let assignedIndex = 0;\n\n            const assignIndex = (nodeId: string): void => {\n                if (visited[nodeId]) return;\n                visited[nodeId] = true;\n                const toEdges = pendingGraph[nodeId] || {};\n                Object.keys(toEdges).forEach((toId) => {\n                    if (toEdges[toId] > 0) {\n                        // If we have EDGE_*, the edge was not removed immediately after add\n                        assignIndex(toId);\n                    }\n                });\n                pendingNodeIdIndex[nodeId] = assignedIndex;\n                assignedIndex += 1;\n            };\n\n            // visit the pending graph, assigning indexes such that:\n            // for every (a -> b), index b < index a; unless there is a cycle (ignoring edges that close a cycle)\n            // This is a (partial) reverse topological sort\n            const pendingNodeIds: string[] = [];\n            Object.keys(nodesToAdd).forEach((nodeId) => {\n                assignIndex(nodeId);\n                pendingNodeIds.push(nodeId);\n            });\n\n            // Sort the pending nodes by the index (reversed) so they are in\n            // (partial) topological order\n            pendingNodeIds.sort(\n                (a, b) => pendingNodeIdIndex[b] - pendingNodeIdIndex[a]\n            );\n\n            //\n            // Add the final set of added nodes in this partial order.\n            // This ensures that as we add new edges for new nodes, we do not need to resort them.\n            pendingNodeIds.forEach((nodeId) => {\n                const node = nodesToAdd[nodeId];\n                if (node) {\n                    this.performAddNodeInner(node, nodeId);\n                }\n            });\n\n            //\n            // Process the remaining pending operations normally\n            //\n            filteredPendingOperations.forEach((pendingOperation) => {\n                switch (pendingOperation.type) {\n                    case PendingOperationType.NODE_ADD:\n                        log.assert(false, 'Incorrectly adding nodes twice');\n                        break;\n                    case PendingOperationType.NODE_DELETE:\n                        this.performRemoveNodeInner(pendingOperation.nodeId);\n                        break;\n                    case PendingOperationType.EDGE_ADD:\n                        this.performAddEdgeInner(\n                            pendingOperation.fromId,\n                            pendingOperation.toId,\n                            pendingOperation.kind\n                        );\n                        addEdge(pendingOperation.fromId, pendingOperation.toId);\n                        minLowerBound =\n                            minLowerBound === null\n                                ? lowerBound\n                                : Math.min(minLowerBound, lowerBound);\n                        break;\n                    case PendingOperationType.EDGE_DELETE:\n                        this.performRemoveEdgeInner(\n                            pendingOperation.fromId,\n                            pendingOperation.toId,\n                            pendingOperation.kind\n                        );\n                        break;\n                    default:\n                        log.assertExhausted(\n                            pendingOperation,\n                            'unexpected pending operation'\n                        );\n                }\n            });\n\n            return minLowerBound || 0;\n        };\n\n        let reachesRetainedCache: Record<string, boolean> = {};\n        const reachesRetained = (nodeId: string) => {\n            const visited: Record<string, boolean> = {};\n            const visit = (id: string): boolean => {\n                if (this.retained[id]) {\n                    reachesRetainedCache[id] = true;\n                }\n                if (reachesRetainedCache[id]) {\n                    return true;\n                }\n                if (visited[id]) return false;\n                visited[id] = true;\n                return this.getDependenciesInner(id, Graph.EDGE_ANY).some(\n                    (toId) => visit(toId)\n                );\n            };\n            return visit(nodeId);\n        };\n\n        // Step one: batch process pending edges\n        processPendingEdges();\n\n        // Step two: start processing dirty nodes in order\n        for (\n            let index = 0;\n            index < this.topologicallyOrderedNodes.length;\n            ++index\n        ) {\n            const node = this.topologicallyOrderedNodes[index];\n            if (!node) {\n                continue;\n            }\n            const nodeId = this.getId(node);\n            if (!this.dirtyNodes[nodeId]) {\n                continue;\n            }\n            if (!reachesRetained(nodeId)) {\n                continue;\n            }\n\n            let done = false;\n            const dirtyNodesUnknownPosition = new Set<string>();\n            this.minCycleBrokenIndex = null;\n\n            /** The set of node ids that have been processed and we will mark as clean after propagation */\n            const processedNodeIds = new Set<string>();\n\n            while (!done) {\n                const cycleUnconfirmedNodes = new Set<string>();\n                this.recentDirtyNodes = [];\n                const cycleInfo = this.knownCycles.get(nodeId);\n                if (cycleInfo) {\n                    // If the node is known to be a cycle, we must treat **all** of\n                    // the nodes in the strongly connected component as one.\n                    //\n                    // That is to say, we:\n                    // - invalidate all nodes first (even if they are not dirty)\n                    // - notify each they are a cycle (even if they are not dirty)\n                    // - if any should propagate, they all propagate -- and we mark dependencies of _all_ of the nodes as dirty -- is this correct?\n                    // - mark _all_ of the nodes in the strongly connected component as not dirty (since we just processed them)\n                    let anyPropagate = false;\n                    cycleInfo.connectedComponentNodes.forEach((cycleId) => {\n                        const cycleNode =\n                            this.topologicallyOrderedNodes[\n                                this.topologicalIndex[cycleId]\n                            ];\n                        if (cycleNode) {\n                            callback(cycleNode, 'invalidate');\n                        }\n                    });\n                    cycleInfo.connectedComponentNodes.forEach((cycleId) => {\n                        const cycleNode =\n                            this.topologicallyOrderedNodes[\n                                this.topologicalIndex[cycleId]\n                            ];\n                        const currentCycleInfo = this.knownCycles.get(cycleId);\n                        log.assert(\n                            currentCycleInfo,\n                            'missing cycleInfo for node in strongly connected component'\n                        );\n                        let action:\n                            | 'cycle'\n                            | 'recalculate-cycle'\n                            | 'recalculate';\n                        if (\n                            !currentCycleInfo.isInformed &&\n                            currentCycleInfo.initiallyDirty\n                        ) {\n                            action = 'recalculate';\n                            currentCycleInfo.initiallyDirty = false;\n                            cycleUnconfirmedNodes.add(cycleId);\n                        } else if (currentCycleInfo.isInformed) {\n                            action = 'recalculate-cycle';\n                        } else {\n                            action = 'cycle';\n                            currentCycleInfo.isInformed = true;\n                        }\n                        if (cycleNode && callback(cycleNode, action)) {\n                            anyPropagate = true;\n                        }\n                    });\n\n                    // Hold onto the dirty nodes we have obtained via side effect\n                    this.recentDirtyNodes.forEach((nodeId) =>\n                        dirtyNodesUnknownPosition.add(nodeId)\n                    );\n                    this.recentDirtyNodes = undefined;\n\n                    // If any of the nodes in the cycle propagated, then _all_ should propagate\n                    if (anyPropagate) {\n                        cycleInfo.connectedComponentNodes.forEach((cycleId) => {\n                            this.getDependenciesInner(\n                                cycleId,\n                                Graph.EDGE_HARD\n                            ).forEach((toId) => {\n                                if (\n                                    !cycleInfo.connectedComponentNodes.has(toId)\n                                ) {\n                                    const toCycleInfo =\n                                        this.knownCycles.get(toId);\n                                    if (toCycleInfo) {\n                                        toCycleInfo.connectedComponentNodes.forEach(\n                                            (toCycleId) => {\n                                                this.markNodeDirtyInner(\n                                                    toCycleId\n                                                );\n                                            }\n                                        );\n                                    } else {\n                                        this.markNodeDirtyInner(toId);\n                                    }\n                                }\n                            });\n                        });\n                    }\n\n                    cycleInfo.connectedComponentNodes.forEach((cycleId) => {\n                        processedNodeIds.add(cycleId);\n                    });\n                } else {\n                    const hasSelfEdge = (this.graph[nodeId]?.[nodeId] ?? 0) > 0;\n                    if (hasSelfEdge) {\n                        callback(node, 'invalidate');\n                    }\n                    const shouldPropagate = callback(\n                        node,\n                        hasSelfEdge ? 'cycle' : 'recalculate'\n                    );\n\n                    // Hold onto the dirty nodes we have obtained via side effect\n                    this.recentDirtyNodes.forEach((nodeId) =>\n                        dirtyNodesUnknownPosition.add(nodeId)\n                    );\n                    this.recentDirtyNodes = undefined;\n\n                    if (shouldPropagate) {\n                        // No need to hold onto these in dirtyNodesUnknownPosition as they are\n                        // guaranteed to be **after** the current index\n                        this.getDependenciesInner(\n                            nodeId,\n                            Graph.EDGE_HARD\n                        ).forEach((toId) => {\n                            const toCycleInfo = this.knownCycles.get(toId);\n                            if (toCycleInfo) {\n                                toCycleInfo.connectedComponentNodes.forEach(\n                                    (toCycleId) => {\n                                        this.markNodeDirtyInner(toCycleId);\n                                    }\n                                );\n                            } else {\n                                this.markNodeDirtyInner(toId);\n                            }\n                        });\n                    }\n                    processedNodeIds.add(nodeId);\n                }\n\n                // By virtue of recalculating the node, we may have grown/changed dependencies!\n                reordered = false;\n                processPendingEdges();\n\n                // If a node _believed_ to be a cycle was dirtied prior to becoming identified as part of the cycle, we\n                // proactively 'recalculated' it. At this point if these nodes are _still_ part of a cycle, we should\n                // call the 'cycle' event on it to allow it to correctly handle its error handling.\n                cycleUnconfirmedNodes.forEach((cycleId) => {\n                    const cycleNode =\n                        this.topologicallyOrderedNodes[\n                            this.topologicalIndex[cycleId]\n                        ];\n                    const newCycleInfo = this.knownCycles.get(cycleId);\n                    if (cycleNode && newCycleInfo) {\n                        const shouldPropagate = callback(cycleNode, 'cycle');\n                        newCycleInfo.isInformed = true;\n                        if (shouldPropagate) {\n                            // TODO: lift this into a shared ffs\n                            this.getDependenciesInner(\n                                cycleId,\n                                Graph.EDGE_HARD\n                            ).forEach((toId) => {\n                                const toCycleInfo = this.knownCycles.get(toId);\n                                if (toCycleInfo) {\n                                    toCycleInfo.connectedComponentNodes.forEach(\n                                        (toCycleId) => {\n                                            this.markNodeDirtyInner(toCycleId);\n                                        }\n                                    );\n                                } else {\n                                    this.markNodeDirtyInner(toId);\n                                }\n                            });\n                        }\n                    }\n                });\n\n                // At this time, we've dirtied all dependencies; and now can mark the processed nodes as clean.\n                // This must happen after dirtying all dependencies to prevent a feedback loop in case of a cycle.\n                processedNodeIds.forEach((nodeId) => {\n                    this.markNodeCleanInner(nodeId);\n                });\n\n                if (reordered || this.minCycleBrokenIndex !== null) {\n                    // If we've reordered, we need to flush the retained cache\n                    reachesRetainedCache = {};\n                    // If we've reordered, all bets are off with respect to which nodes are next\n                    this.getUnorderedDirtyNodes().forEach((nodeId) =>\n                        dirtyNodesUnknownPosition.add(nodeId)\n                    );\n                }\n\n                // By virtue of recalculating the node, the node may have become a cycle, or no longer become a cycle.\n                // In either case, we need to retry.\n                const newCycleInfo = this.knownCycles.get(nodeId);\n                if (newCycleInfo && !cycleInfo) {\n                    done = false;\n                } else if (!newCycleInfo && cycleInfo) {\n                    done = false;\n                } else {\n                    done = true;\n                }\n            }\n\n            if (\n                dirtyNodesUnknownPosition.size > 0 ||\n                this.minCycleBrokenIndex !== null\n            ) {\n                // If any dirty nodes have changed or we have broken a cycle, jump to the earliest of either the dirty\n                // node or the minimum broken cycle index\n                let minDirtyOrd = this.topologicallyOrderedNodes.length;\n                dirtyNodesUnknownPosition.forEach((dirtyNodeId) => {\n                    minDirtyOrd = Math.min(\n                        minDirtyOrd,\n                        this.topologicalIndex[dirtyNodeId]\n                    );\n                });\n\n                if (this.minCycleBrokenIndex !== null) {\n                    minDirtyOrd = Math.min(\n                        this.minCycleBrokenIndex,\n                        minDirtyOrd\n                    );\n                }\n\n                if (minDirtyOrd <= index) {\n                    index = minDirtyOrd - 1;\n                }\n            }\n        }\n\n        // Step three: flush all remaining dirty nodes and their reachable nodes\n        const flushed: Record<string, boolean> = {};\n        const transitiveFlush = (nodeId: string) => {\n            const node =\n                this.topologicallyOrderedNodes[this.topologicalIndex[nodeId]];\n            log.assert(node, 'transitiveFlush consistency error');\n            callback(node, 'invalidate');\n            flushed[nodeId] = true;\n            this.getDependenciesInner(nodeId, Graph.EDGE_HARD).forEach(\n                (toId) => {\n                    if (!flushed[toId]) {\n                        transitiveFlush(toId);\n                    }\n                }\n            );\n        };\n        this.getUnorderedDirtyNodes().forEach((nodeId) => {\n            if (!flushed[nodeId]) {\n                transitiveFlush(nodeId);\n            }\n            this.markNodeCleanInner(nodeId);\n        });\n\n        // And... we're done!\n    }\n\n    /**\n     * Generate a dot file structure of the graph\n     */\n    graphviz(\n        getAttributes: (\n            label: string,\n            item: Type\n        ) => { label: string; subgraph: object | undefined; penwidth: string }\n    ) {\n        const lines = [\n            'digraph debug {',\n            //'graph [rankdir=\"LR\"];',\n            'node [style=\"filled\", fillcolor=\"#DDDDDD\"];',\n        ];\n\n        const nodeIds = Object.keys(this.topologicalIndex).filter(\n            (nodeId) =>\n                !!this.topologicallyOrderedNodes[this.topologicalIndex[nodeId]]\n        );\n        const nodeAttributes: Record<\n            string,\n            { label: string; subgraph: object | undefined; penwidth: string }\n        > = {};\n        nodeIds.forEach((nodeId) => {\n            const node =\n                this.topologicallyOrderedNodes[this.topologicalIndex[nodeId]];\n            if (node) {\n                nodeAttributes[nodeId] = getAttributes(nodeId, node);\n            }\n        });\n        const groupedNodes = groupBy(nodeIds, (nodeId) => {\n            return [nodeAttributes[nodeId].subgraph, nodeId];\n        });\n\n        let clusterId = 0;\n        groupedNodes.forEach((nodeIds, group) => {\n            if (group)\n                lines.push(\n                    `subgraph cluster_${clusterId++} {`,\n                    'style=\"filled\";',\n                    'color=\"#AAAAAA\";'\n                );\n            nodeIds.forEach((nodeId) => {\n                const props: Record<string, string> = {\n                    shape: this.retained[nodeId] ? 'box' : 'ellipse',\n                    label: nodeAttributes[nodeId]?.label,\n                    penwidth: nodeAttributes[nodeId]?.penwidth,\n                    fillcolor: this.isNodeDirty(nodeId) ? '#FFDDDD' : '#DDDDDD',\n                };\n                lines.push(\n                    `  item_${nodeId} [${Object.entries(props)\n                        .map(\n                            ([key, value]) => `${key}=${JSON.stringify(value)}`\n                        )\n                        .join(',')}];`\n                );\n            });\n            if (group) lines.push('}');\n        });\n\n        nodeIds.forEach((fromId) => {\n            const allDestinations = Array.from(\n                new Set(Object.keys(this.graph[fromId]))\n            );\n            allDestinations.forEach((toId) => {\n                if (this.graph[fromId][toId] & Graph.EDGE_HARD) {\n                    lines.push(\n                        `  item_${fromId} -> item_${toId} [style=\"solid\"];`\n                    );\n                }\n                if (this.graph[fromId][toId] & Graph.EDGE_SOFT) {\n                    lines.push(\n                        `  item_${fromId} -> item_${toId} [style=\"dashed\"];`\n                    );\n                }\n            });\n        });\n\n        lines.push('}');\n\n        return lines.join('\\n');\n    }\n}\n", "import {\n    GraphNode,\n    isCalculation,\n    isCollection,\n    isEffect,\n    isModel,\n    isSubscription,\n    isNodeOrdering,\n    isModelField,\n} from './types';\n\nlet nameMap: WeakMap<any, string> = new WeakMap();\n\nexport function clearNames() {\n    nameMap = new WeakMap();\n}\n\nexport function debugNameFor(item: GraphNode): string {\n    if (!DEBUG) {\n        return '';\n    }\n    const id = (item as any).$__id;\n    if (isCollection(item)) {\n        return `${id}:collection:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isCalculation(item)) {\n        return `${id}:${isEffect(item) ? 'effect' : 'calc'}:${\n            nameMap.get(item) ?? '?'\n        }`;\n    }\n    if (isModel(item)) {\n        return `${id}:model:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isSubscription(item)) {\n        return `${id}:sub:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isNodeOrdering(item)) {\n        return `${id}:ord:${nameMap.get(item) ?? '?'}`;\n    }\n    if (isModelField(item)) {\n        return `${id}:field:${nameMap.get(item.model) ?? '?'}:${String(\n            item.key\n        )}`;\n    }\n    return `${id}:unknown`;\n}\n\nexport function name<T>(item: T, name: string): T {\n    if (!DEBUG) return item;\n    nameMap.set(item, name);\n    return item;\n}\n", "import {\n    Calculation,\n    CalculationRecalculateTag,\n    CalculationRecalculateCycleTag,\n    CalculationInvalidateTag,\n    CalculationSetCycleTag,\n    CalculationTypeTag,\n    GraphNode,\n    EqualityFunc,\n    FlushKey,\n    InvariantError,\n    TypeTag,\n    isCalculation,\n    isCollection,\n    isModel,\n    isModelField,\n    isSubscription,\n} from './types';\nimport * as log from './log';\nimport { Graph } from './graph';\nimport { alwaysTrue, noop, strictEqual, uniqueid } from './util';\nimport { clearNames, debugNameFor, name } from './debug';\n\nlet activeCalculations: { calc: null | Calculation<any>; deps: GraphNode[] }[] =\n    [];\n\nlet globalDependencyGraph = new Graph<GraphNode>();\n\nlet refcountMap: Record<string, number> = {};\n\n/**\n * Reset all data to a clean slate.\n */\nexport function reset() {\n    activeCalculations = [];\n\n    globalDependencyGraph = new Graph();\n    refcountMap = {};\n    clearNames();\n}\n\nlet createdCalculations: Calculation<any>[] | undefined;\n/**\n * Collect all synchronously created calc() and effect() calls\n */\nexport function trackCreatedCalculations(fn: () => void): Calculation<any>[] {\n    const before = createdCalculations;\n    createdCalculations = [];\n    try {\n        fn();\n        const toReturn = createdCalculations;\n        return toReturn;\n    } finally {\n        createdCalculations = before;\n    }\n}\n\n/**\n * Create a calculation cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be recalculated when any of those dependencies are changed. The result of this function is\n * treated as a dependency, so if recalculations change the result, any dependent calculations are recalculated.\n */\nexport function calc<Ret>(func: () => Ret): Calculation<Ret>;\nexport function calc<Ret>(func: () => Ret, debugName: string): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual: EqualityFunc<Ret>\n): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual: EqualityFunc<Ret>,\n    debugName: string\n): Calculation<Ret>;\nexport function calc<Ret>(\n    func: () => Ret,\n    isEqual?: string | EqualityFunc<Ret>,\n    debugName?: string\n): Calculation<Ret> {\n    if (typeof isEqual === 'string') debugName = isEqual;\n    if (typeof isEqual !== 'function') isEqual = strictEqual;\n    if (typeof debugName !== 'string') debugName = undefined;\n    const calculation = makeCalculation(func, isEqual, false);\n    if (debugName) name(calculation, debugName);\n    if (createdCalculations) createdCalculations.push(calculation);\n    return calculation;\n}\n\n/**\n * Create an effect cell: while the provided function is executed, all dependencies are tracked.\n *\n * The provided function will be re-executed when any of those dependencies are changed.\n *\n * Effect cells are not be added as dependencies to the current computation.\n *\n * Note: Since nothing depends on created effects, they must be be manually retained and released if you want the effect\n * to re-run when its dependencies change. Failure to do so will not automatically re-run the effect (which may be\n * desired if you want to trigger behavior only once within a computation)\n */\nexport function effect(\n    func: () => void,\n    debugName?: string\n): Calculation<void> {\n    const calculation = makeCalculation(\n        func,\n        alwaysTrue /* effects always return true for equality */,\n        true\n    );\n    if (debugName) name(calculation, debugName);\n    if (createdCalculations) createdCalculations.push(calculation);\n    return calculation;\n}\n\nexport function untracked<TRet>(func: () => TRet): TRet {\n    activeCalculations.push({ calc: null, deps: [] });\n    try {\n        return func();\n    } finally {\n        activeCalculations.pop();\n    }\n}\n\nenum CalculationState {\n    STATE_FLUSHED,\n    STATE_TRACKING,\n    STATE_CACHED,\n    STATE_CYCLE,\n    STATE_ERROR,\n}\n\nclass CalculationError extends Error {\n    public originalError: unknown;\n    constructor(msg: string, originalError: unknown) {\n        super(msg);\n        this.originalError = originalError;\n    }\n}\n\nclass CycleAbortError extends Error {}\n\nfunction makeCalculation<Ret>(\n    calculationFunc: () => Ret,\n    isEqual: (a: Ret, b: Ret) => boolean,\n    isEffect: boolean\n): Calculation<Ret> {\n    if (typeof calculationFunc !== 'function') {\n        throw new InvariantError('calculation must be provided a function');\n    }\n\n    let result: { result: Ret } | undefined = undefined;\n    let state: CalculationState = CalculationState.STATE_FLUSHED;\n    let errorHandler: ((errorType: 'cycle' | 'error') => Ret) | undefined =\n        undefined;\n    let isDisposed = false;\n\n    const calculation: Calculation<Ret> = Object.assign(calculationBody, {\n        $__id: uniqueid(),\n        [TypeTag]: 'calculation' as const,\n        [CalculationTypeTag]: isEffect\n            ? ('effect' as const)\n            : ('calculation' as const),\n        [CalculationSetCycleTag]: calculationSetCycle,\n        [CalculationRecalculateTag]: calculationRecalculate,\n        [CalculationRecalculateCycleTag]: calculationRecalculateCycle,\n        [CalculationInvalidateTag]: calculationInvalidate,\n        onError: calculationOnError,\n        dispose: calculationDispose,\n    });\n\n    globalDependencyGraph.addNode(calculation);\n\n    function calculationBody() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        if (!isEffect) {\n            // effects return void, so they **cannot** have an effect on the current calculation\n            addDepToCurrentCalculation(calculation);\n        }\n\n        switch (state) {\n            case CalculationState.STATE_FLUSHED: {\n                state = CalculationState.STATE_TRACKING;\n                activeCalculations.push({ calc: calculation, deps: [] });\n                const prevResult = result;\n                try {\n                    result = { result: calculationFunc() };\n                } catch (e) {\n                    const calcRecord = activeCalculations.pop();\n                    log.assert(\n                        calcRecord?.calc === calculation,\n                        'calculation stack inconsistency'\n                    );\n                    globalDependencyGraph.replaceIncoming(\n                        calculation,\n                        calcRecord.deps\n                    );\n                    const isCycle = e instanceof CycleAbortError;\n                    if (isCycle) {\n                        // Let the graph know that we are part of a cycle\n                        globalDependencyGraph.markNodeCycle(calculation);\n                    }\n                    state = isCycle\n                        ? CalculationState.STATE_CYCLE\n                        : CalculationState.STATE_ERROR;\n                    if (errorHandler) {\n                        result = {\n                            result: errorHandler(isCycle ? 'cycle' : 'error'),\n                        };\n                    } else {\n                        // If we don't have an error handler, but we hit an\n                        // error, we need to clear out the preexisting result\n                        // so we throw when called in an error state.\n                        result = undefined;\n                    }\n                    // Only return a value if we're the _outermost_ tracked call.\n                    // Otherwise, we need to propagate the error to catch the remaining ones.\n                    if (result && activeCalculations.length === 0) {\n                        return prevResult &&\n                            isEqual(prevResult.result, result.result)\n                            ? prevResult.result\n                            : result.result;\n                    }\n                    if (isCycle) {\n                        throw e;\n                    }\n                    throw new CalculationError(\n                        'Calculation error: calculation threw error while being called',\n                        e\n                    );\n                }\n                state = CalculationState.STATE_CACHED;\n                const calcRecord = activeCalculations.pop();\n                log.assert(\n                    calcRecord?.calc === calculation,\n                    'calculation stack inconsistency'\n                );\n                globalDependencyGraph.replaceIncoming(\n                    calculation,\n                    calcRecord.deps\n                );\n                return prevResult && isEqual(prevResult.result, result.result)\n                    ? prevResult.result\n                    : result.result;\n            }\n            case CalculationState.STATE_TRACKING:\n                state = CalculationState.STATE_ERROR;\n                if (errorHandler) {\n                    result = {\n                        result: errorHandler('cycle'),\n                    };\n\n                    // Let the graph know that we are part of a cycle\n                    globalDependencyGraph.markNodeCycle(calculation);\n\n                    // If we have an error handler and we call ourselves,\n                    // only return a value if we are the outermost tracked\n                    // call. Otherwise, we need to propagate the error to the\n                    // callers\n                    if (activeCalculations.length === 0) {\n                        return result.result;\n                    }\n                }\n                throw new CycleAbortError(\n                    'Cycle reached: calculation is part of a cycle'\n                );\n                break;\n            case CalculationState.STATE_CACHED:\n                if (result) {\n                    return result.result;\n                }\n                throw new InvariantError(\n                    'Calculation in cached state missing result value'\n                );\n            case CalculationState.STATE_CYCLE:\n                if (result) {\n                    return result.result;\n                }\n                throw new Error(\n                    'Cycle reached: calculation is part of a cycle'\n                );\n            case CalculationState.STATE_ERROR:\n                if (result) {\n                    return result.result;\n                }\n                throw new Error('Calculation in error state');\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationInvalidate() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot invalidate a calculation while being tracked'\n                );\n            case CalculationState.STATE_FLUSHED:\n                return;\n            case CalculationState.STATE_CYCLE:\n                state = CalculationState.STATE_FLUSHED;\n                break;\n            case CalculationState.STATE_CACHED:\n            case CalculationState.STATE_ERROR: {\n                DEBUG &&\n                    log.debug('Invalidating node', debugNameFor(calculation));\n                state = CalculationState.STATE_FLUSHED;\n                break;\n            }\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationSetCycle() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot mark calculation as being a cycle while it is being calculated'\n                );\n                break;\n            case CalculationState.STATE_FLUSHED:\n            case CalculationState.STATE_CACHED:\n            case CalculationState.STATE_CYCLE:\n            case CalculationState.STATE_ERROR: {\n                state = CalculationState.STATE_CYCLE;\n                if (errorHandler) {\n                    let isResultEqual = false;\n                    const newResult = errorHandler('cycle');\n                    if (result) {\n                        isResultEqual = isEqual(result.result, newResult);\n                    }\n                    if (!isResultEqual) {\n                        result = { result: newResult };\n                    }\n                    return !isResultEqual;\n                } else {\n                    if (result) {\n                        result = undefined;\n                        return true;\n                    }\n                    return false;\n                }\n            }\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationRecalculate() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot recalculate calculation while it is being calculated'\n                );\n                break;\n            case CalculationState.STATE_FLUSHED:\n            case CalculationState.STATE_ERROR:\n            case CalculationState.STATE_CACHED: {\n                const priorResult = result;\n                try {\n                    calculationBody();\n                } catch (e) {\n                    // Completely ignore, at this point `result` should hold the correct value\n                }\n                if (\n                    priorResult &&\n                    result &&\n                    isEqual(priorResult.result, result.result)\n                ) {\n                    result = priorResult;\n                    return false;\n                }\n                return true;\n            }\n            case CalculationState.STATE_CYCLE:\n                throw new InvariantError(\n                    'Cannot recalculate calculation in cycle state without flushing'\n                );\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationRecalculateCycle() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        switch (state) {\n            case CalculationState.STATE_TRACKING:\n                throw new InvariantError(\n                    'Cannot recalculate calculation while it is being calculated'\n                );\n                break;\n            case CalculationState.STATE_FLUSHED:\n            case CalculationState.STATE_ERROR:\n            case CalculationState.STATE_CACHED: {\n                const priorResult = result;\n                try {\n                    calculationBody();\n                } catch (e) {\n                    // Completely ignore, at this point `result` should hold the correct value\n                }\n                if (\n                    priorResult &&\n                    result &&\n                    isEqual(priorResult.result, result.result)\n                ) {\n                    result = priorResult;\n                    return false;\n                }\n                return true;\n            }\n            case CalculationState.STATE_CYCLE:\n                return calculationSetCycle();\n            default:\n                log.assertExhausted(state, 'Unexpected calculation state');\n        }\n    }\n\n    function calculationOnError(\n        handler: (errorType: 'cycle' | 'error') => Ret\n    ) {\n        log.assert(!isDisposed, 'calculation already disposed');\n        errorHandler = handler;\n        return calculation;\n    }\n\n    function calculationDispose() {\n        log.assert(!isDisposed, 'calculation already disposed');\n        globalDependencyGraph.removeNode(calculation);\n\n        // Delete local state\n        result = undefined;\n        errorHandler = undefined;\n\n        isDisposed = true;\n    }\n\n    return calculation;\n}\n\nexport function addDepToCurrentCalculation(item: GraphNode) {\n    if (activeCalculations.length === 0) return;\n    const dependentCalculation =\n        activeCalculations[activeCalculations.length - 1];\n    dependentCalculation.deps.push(item);\n    DEBUG &&\n        log.debug(\n            'New global dependency',\n            debugNameFor(item),\n            '->',\n            dependentCalculation.calc\n                ? debugNameFor(dependentCalculation.calc)\n                : '<untracked>' // We probably could avoid adding to .deps if we were untracked, but it may be helpful to log these\n        );\n}\n\nexport function addManualDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.addNode(fromNode);\n    globalDependencyGraph.addNode(toNode);\n    globalDependencyGraph.addEdge(fromNode, toNode, Graph.EDGE_HARD);\n    scheduleFlush();\n    DEBUG &&\n        log.debug(\n            'New manual dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function registerNode(node: GraphNode) {\n    globalDependencyGraph.addNode(node);\n}\n\nexport function disposeNode(node: GraphNode) {\n    globalDependencyGraph.removeNode(node);\n}\n\nexport function addOrderingDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.addEdge(fromNode, toNode, Graph.EDGE_SOFT);\n    scheduleFlush();\n    DEBUG &&\n        log.debug(\n            'New manual ordering dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function removeManualDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.removeEdge(fromNode, toNode, Graph.EDGE_HARD);\n    DEBUG &&\n        log.debug(\n            'Removed manual dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function removeOrderingDep(fromNode: GraphNode, toNode: GraphNode) {\n    globalDependencyGraph.removeEdge(fromNode, toNode, Graph.EDGE_SOFT);\n    DEBUG &&\n        log.debug(\n            'Removed manual ordering dependency',\n            debugNameFor(fromNode),\n            '->',\n            debugNameFor(toNode)\n        );\n}\n\nexport function markDirty(item: GraphNode) {\n    DEBUG && log.debug('Dirtying', debugNameFor(item));\n    globalDependencyGraph.addNode(item);\n    globalDependencyGraph.markNodeDirty(item);\n    scheduleFlush();\n}\n\ntype Listener = () => void;\nlet needsFlush = false;\nlet flushPromise: Promise<void> = Promise.resolve();\nlet resolveFlushPromise: () => void = noop;\nlet subscribeListener: Listener = () => setTimeout(() => flush(), 0);\n\nexport function nextFlush() {\n    if (!needsFlush) return Promise.resolve();\n    return flushPromise;\n}\n\n/**\n * Call provided callback when any pending calculations are created. Use to configure how/when the application flushes calculations.\n *\n * If any pending calculations are needed when this function is called, the provided callback is called synchronously.\n *\n * By default, the subscribe mechanism is to call flush() on setTimeout. Calling subscribe removes this default and\n * replaces it with whatever mechanism you'd like.\n *\n * Example: subscribe(() => requestAnimationFrame(() => flush()));\n */\nexport function subscribe(listener: Listener = noop): void {\n    subscribeListener = listener;\n    if (needsFlush) {\n        subscribeListener();\n    }\n}\n\nfunction scheduleFlush() {\n    if (!needsFlush) {\n        needsFlush = true;\n        notify();\n    }\n}\n\nfunction notify() {\n    try {\n        flushPromise = new Promise((resolve) => {\n            resolveFlushPromise = resolve;\n        });\n        subscribeListener();\n    } catch (e) {\n        log.exception(e, 'uncaught exception in notify');\n    }\n}\n\n/**\n * Hoo boy this is probably a mistake. Stream the graph while we flush\n */\nlet debugSubscription: ((graphViz: string, detail: string) => void) | null =\n    null;\n\n/**\n * Recalculate all pending calculations.\n */\nexport function flush() {\n    if (!needsFlush) {\n        return;\n    }\n    needsFlush = false;\n\n    DEBUG && debugSubscription && debugSubscription(debug(), '0: flush start');\n\n    // Then flush dependencies in topological order\n    globalDependencyGraph.process((item, action) => {\n        let shouldPropagate = true;\n\n        switch (action) {\n            case 'cycle':\n                if (isCalculation(item)) {\n                    shouldPropagate = item[CalculationSetCycleTag]();\n                } else {\n                    throw new Error('Unexpected dependency on cycle');\n                }\n                break;\n            case 'invalidate':\n                if (isCalculation(item)) {\n                    item[CalculationInvalidateTag]();\n                }\n                break;\n            case 'recalculate-cycle':\n                if (isCalculation(item)) {\n                    shouldPropagate = item[CalculationRecalculateCycleTag]();\n                } else if (\n                    isCollection(item) ||\n                    isModel(item) ||\n                    isSubscription(item)\n                ) {\n                    shouldPropagate = item[FlushKey]();\n                }\n                break;\n            case 'recalculate':\n                if (isCalculation(item)) {\n                    item[CalculationInvalidateTag]();\n                    shouldPropagate = item[CalculationRecalculateTag]();\n                } else if (\n                    isCollection(item) ||\n                    isModel(item) ||\n                    isSubscription(item)\n                ) {\n                    shouldPropagate = item[FlushKey]();\n                }\n                break;\n            default:\n                log.assertExhausted(action);\n        }\n        if (DEBUG) {\n            log.debug(\n                `process:${action}`,\n                debugNameFor(item),\n                `shouldPropagate=${shouldPropagate}`\n            );\n            debugSubscription &&\n                debugSubscription(\n                    debug(item),\n                    `process:${action}:shouldPropagate=${shouldPropagate}`\n                );\n        }\n        return shouldPropagate;\n    });\n\n    log.assert(\n        !globalDependencyGraph.hasDirtyNodes(),\n        'Graph contained dirty nodes post-flush'\n    );\n\n    DEBUG && debugSubscription && debugSubscription(debug(), `2: after visit`);\n\n    resolveFlushPromise();\n}\n\n/**\n * Retain a calculation (increase the refcount)\n */\nexport function retain(item: GraphNode) {\n    const refcount = refcountMap[item.$__id] ?? 0;\n    const newRefcount = refcount + 1;\n    if (refcount === 0) {\n        DEBUG &&\n            log.debug(\n                `retain ${debugNameFor(\n                    item\n                )} retained; refcount ${refcount} -> ${newRefcount}`\n            );\n        globalDependencyGraph.addNode(item);\n        globalDependencyGraph.retain(item);\n    } else {\n        DEBUG &&\n            log.debug(\n                `retain ${debugNameFor(\n                    item\n                )} incremented; refcount ${refcount} -> ${newRefcount}`\n            );\n    }\n    refcountMap[item.$__id] = newRefcount;\n}\n\n/**\n * Release a calculation (decrease the refcount). If the refcount reaches zero, the calculation will be garbage\n * collected.\n */\nexport function release(item: GraphNode) {\n    const refcount = refcountMap[item.$__id] ?? 0;\n    const newRefcount = Math.min(refcount - 1, 0);\n    if (refcount < 1) {\n        log.error(\n            `release called on unretained item ${debugNameFor(item)}`,\n            item\n        );\n    }\n    if (newRefcount < 1) {\n        DEBUG &&\n            log.debug(\n                `release ${debugNameFor(\n                    item\n                )} released; refcount ${refcount} -> ${newRefcount}`\n            );\n        globalDependencyGraph.release(item);\n    } else {\n        DEBUG &&\n            log.debug(\n                `release ${debugNameFor(\n                    item\n                )} decremented; refcount ${refcount} -> ${newRefcount}`\n            );\n    }\n    refcountMap[item.$__id] = newRefcount;\n}\n\n/**\n * Return a graphviz formatted directed graph\n */\nexport function debug(activeItem?: any): string {\n    return globalDependencyGraph.graphviz((id, item) => {\n        let subgraph: object | undefined = undefined;\n        if (isModel(item)) {\n            subgraph = item;\n        }\n        if (isCollection(item)) {\n            subgraph = item;\n        }\n        if (isModelField(item)) {\n            subgraph = item.model;\n        }\n        if (isSubscription(item)) {\n            subgraph = item.item;\n        }\n        return {\n            label: `${id}\\n${debugNameFor(item)}`,\n            subgraph,\n            penwidth: activeItem === item ? '5.0' : '1.0',\n        };\n    });\n}\n\nexport function debugState() {\n    return {\n        globalDependencyGraph,\n        activeCalculations,\n        refcountMap,\n        needsFlush,\n        flushPromise,\n        resolveFlushPromise,\n        subscribeListener,\n    };\n}\n\nexport function debugSubscribe(\n    callback: ((graphviz: string, detail: string) => void) | null\n) {\n    debugSubscription = callback;\n}\n", "import {\n    Ref,\n    Calculation,\n    Collection,\n    View,\n    Context,\n    IntrinsicNodeObserverNodeCallback,\n    IntrinsicNodeObserverElementCallback,\n} from './types';\n\n/**\n * The core type that can be used as a child or root of a JSX expression\n */\nexport type JSXNode =\n    | string\n    | number\n    | boolean\n    | null\n    | undefined\n    | symbol\n    | Function\n    | Element\n    | RenderedElement<any, any, any>\n    | Calculation<JSXNode>\n    | Collection<JSXNode>\n    | View<JSXNode>\n    | JSXNode[];\n\ndeclare global {\n    // eslint-disable-next-line @typescript-eslint/no-namespace\n    namespace JSX {\n        /**\n         * The core type that can be used as a child or root of a JSX expression\n         */\n        type Element = JSXNode;\n\n        interface IntrinsicElements extends KnownElements {\n            [unknownElement: string]: any;\n        }\n\n        interface ElementChildrenAttribute {\n            children: {}; // specify children name to use\n        }\n    }\n}\n\ntype OnUnmountCallback = () => void;\ntype OnMountCallback = () => void;\ntype EffectCallback = () => void;\n\ntype ComponentListeners = {\n    onUnmount: (callback: OnUnmountCallback) => void;\n    onMount: (callback: OnMountCallback) => void;\n    onEffect: (callback: EffectCallback) => void;\n    getContext: <TVal>(context: Context<TVal>) => TVal;\n};\n/**\n * This is a big ol hack that allows components which don't declare any props (const MyComponent: Component<{}> = ...) to enforce that no children can be passed.\n * Why does this work? {} types as function properties accept _any_ props\n *\n * See:\n * - https://www.typescriptlang.org/play?jsx=1#code/C4TwDgpgBAShB2ATCAnCiDCB7AtmL8CwUAvFAN5QDGWWANgFxQBGtdEAhvFAL4DcAKGRU6HNNQIBnYgFd4MyegDKIHK0ZQ5ASwCOM6JNXrBoSFGx4CRADwAVAAoosYSQD5SUABRgnLpg99JKAAyCigAbTkFZSN6AF0AfiZWek5uHgBKUnc4JFR0C3xCeGBBIQgRMWh4DhwISTAOKmgAKSUADQoBKB6oU2gASRKULXhJLSoAUXY6kqCycm7e5Yg8UCZF5eWeJa2oAC9ULA3dvd6AfXOoxUQkvpR9ABpT7ZfeqxOzraoACy06RBoeBMNrtAB001WREEXx4zy+VgA8mBgJ8vr1fv9AQg7qCITNoW8ejsvjgZHRgFo0ejqH8AUCQR18VCSuE4jCznCiVAyRStMjUV0aT1MfScYzwZDZsA2Ry9lyEYRESgALLkynU9Gi7HAqB4qVEKAAHz1TINrPZ3IVZyRqvV-JRmq+2qBuLNBJKxtNko9MstsPhZ3CVAUwFw5sF0hG8AA5nEnUGQ9Jw76AILAYAjZgyYAQJhR0ZxphcEByrb8U47U6jXMoABmTWgEYwdJ16czWmzuaFZxdCA2Fdep36UAjHgLsa98jUqC9KXYXC9cmQddG6Cn5LoXtyyDQmFwRUJVYA9MeBKeoEMO2MJlAIL7JOez0-R2sQFAfM4gp49PVKQQmAAdx+d9ECweo+j+IJmAgH4OAAN2gYAoKgQCOBABIMgEaxVhRd9j1cQQcLfVxrAADygAjrGPXDQEI7DaJAUiKKoljSJokiygvAAtI5aSxIFsMOJxKPo6xhKwZjROoiSxNk8jpLYmSjnol9EUIO8yKaYhtWwqxRKI-SpKo48rDEsyFNY6TTMIVSL3U6BnH-Got106wkRRAy9KVTzjPYjzgHMnzAssvzqICuzjygNU+TAdhNO0-ixXgbDeUpLzrDSrQoDC48srE-LQqKvL7Ui6LyS0OLHJRLQCA4VzW0EzL7QFDKsta3L2pRAqWu6oqlJKvkBTKyYtKoYA6HffSsBQHkZugPsUvcpU7T5DLbRi9Lco20rDJWzatDCgadr5MqBVqlzJqgabZpweakp1LwSygacYJQLDlogZUDtagi9q+1bKQ64qTqB7r-u+3qQqU479qhyKX0KKxPXvFlgEfC8BAEGgxmISY3yYJHimAaxyB4dwyE8LISHcTxKBoegmEzfReAyQQcekKBeKcQmD2RkmyYprxqdp+m2CZh5oEydmpGIBzecsYnSYehlvWZaVeCFqnsi8MXGfuFnpex2WoAcgUFcPEplcWt0fTRzWPG1mndYkfXmaltnjdx8q+Qt-nrca-s1YjNkHcpkWXYZjR3dZmXvZ+x1zD5pX6cD+BbfVohQ-Jx2I7p13o8l2Ovc5s3AapJPFZsVOBKD-VfS9eu0ezrW871wvDc9jm5bhobE6J6uVfFYOG5NJvpRb3OdfzqOJc7riovxvCP0CLxf2kC6gJAqAwIg5CtGg2CEKQlC0Iwj6l9ADLL6Y4qb7E+-+us++F65vjFuw7msAyr-ct-ojf5PxMv-LG9kNIQDGjpVs2EHIZVgblByYlEFAPYog1+sCnIXXqg9GBwU4F4IQcFJBRCUHUTNuDUBUUDpVQSuNIeS0DoZUYblA6YlWGkOPKw1+MVKrxUwXVBqtcGFQyYSIlh8MiIJ2hopayUiRqQKujdOa4gP7WDLowv6uCAbMOKuo3aWjIanQ4Xo066CaoCMURpGayiFppyevAd8r1UAfRMWDYgmi1G9zcTlXRXiHSBSIq4-xR1rJBOGgvRGydDSo2lEEUYdZUB7hfFjbul4b6O3OJ+PwFBMjT3bnPD2cdOYDC-o7LJkgNhQEuNcdAdx5xpFZnkguBTi6pIGLAym5TKmLQlJnT0uTnYz3FgbQpJdiDtLwZTTJgRulpwzmOAZotmkjNaSbAYjCpldLCD0kezc4iNMGfklZRs2lSIyVsmuyV5m+mzm3ZZMcTlrKCecmZ2y069LHGPd0eyDlLNnscruTy-GtU2a8y5Oprn2y+XbCe+zFmR2GQ8z2L50nlLXvoDeAFULb13kEfeh84KIUggfVC6FMLYQGOkjxlKSLFRpXhMS9K6IcKZUxV+pTVElL4tSwBA0uVOEZbymRJl+WSXQeAyBODrATOgNS+BdK0EUuQTDayMqzpWPMS5KVMrfqMvIcQXKOqKHSv1SEkVpruH2hoRAxKnKNGMp0XyrhFL2EqpFc6l8PCaH8K1XakR1KzmGrkURdZ8MWXBsoaOBRU0rG3Xupy55cq-E+L5UEvVfizXsR1eXM6mr6qWMcnGlRdjPDPSce9JVwLPJJu0WIhVVaAmVtrX3aRVlzUNsIkAA\n */\nconst UnusedSymbol = Symbol('unused');\nexport type Component<TProps extends {}> = (\n    props: TProps & { [UnusedSymbol]?: boolean },\n    listeners: ComponentListeners\n) => JSXNode;\n\n/**\n * The type returned by createElement\n */\nexport type RenderedElement<TProps, TContext, TChildren extends JSXNode> =\n    | {\n          type: 'intrinsic';\n          element: string;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'context';\n          context: Context<TContext>;\n          props: { value: TContext };\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children: TChildren }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children?: TChildren }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children: TChildren[] }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps & { children?: TChildren[] }>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'component';\n          component: Component<TProps>;\n          props: TProps;\n          children: TChildren[];\n      }\n    | {\n          type: 'observer';\n          nodeCallback: IntrinsicNodeObserverNodeCallback | undefined;\n          elementCallback: IntrinsicNodeObserverElementCallback | undefined;\n          children: TChildren[];\n      };\n\n/*\n * Interfaces adopted from HTML Living Standard Last Updated 30 November 2021: https://html.spec.whatwg.org/\n */\nfunction attrBooleanToEmptyString(\n    val: boolean | undefined\n): string | undefined {\n    if (!val) return undefined;\n    return '';\n}\nfunction attrStringOrNumberToNumber(\n    val: string | number | undefined\n): number | undefined {\n    if (val === undefined) return undefined;\n    return typeof val === 'number' ? val : parseInt(val);\n}\nfunction attrYesNo(val: '' | 'yes' | 'no' | undefined): boolean | undefined {\n    if (val === undefined) return undefined;\n    return val === 'no' ? false : true;\n}\n\n// Note: TypeScript has some notably missing IDL properties from its HTMLElement interface, this adds them in lieu of those properties:\ninterface MissingFromTypescriptHTMLElementProperties {\n    // https://w3c.github.io/aria/#idl-reflection-attribute-values\n    ariaColIndexText?: string | undefined;\n    ariaInvalid?: string | undefined;\n    ariaRowIndexText?: string | undefined;\n    role?: string | undefined;\n\n    // https://html.spec.whatwg.org/multipage/dom.html#htmlorsvgelement\n    autofocus?: boolean | undefined;\n\n    itemscope?: string | undefined;\n}\n\n// Note: TypeScript has some notably missing IDL properties from its HTMLDialog interface, this adds them in lieu of those properties:\ninterface MissingFromTypescriptHTMLDialogElementProperties {\n    // https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element\n    open?: boolean | undefined;\n}\n\ninterface MissingFromTypescriptHTMLIframeElementProperties {\n    // https://html.spec.whatwg.org/multipage/interactive-elements.html#the-dialog-element\n    loading?: LazyLoadingValue | undefined;\n}\n\ninterface MissingFromTypescriptHTMLMetaElementProperties {\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-meta-media\n    media?: string | undefined;\n}\n\ninterface MissingFromTypescriptHTMLSourceElementProperties {\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#the-source-element\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\ntype PropertyMapField<TJSXField, TElement, TIDLName extends keyof TElement> =\n    | {\n          makeAttrValue?:\n              | ((jsxAttr: Exclude<TJSXField, undefined>) => string | undefined)\n              | null;\n      }\n    | {\n          makeAttrValue?:\n              | ((jsxAttr: Exclude<TJSXField, undefined>) => string | undefined)\n              | null;\n          idlName?: TIDLName | null;\n          makeIdlValue?: (\n              jsxAttr: Exclude<TJSXField, undefined>\n          ) => TElement[TIDLName];\n      };\n\ntype PropertyMap<TJSXElementInterface, TElement> = {\n    [TJSXKey in keyof Required<TJSXElementInterface>]: PropertyMapField<\n        TJSXElementInterface[TJSXKey],\n        TElement,\n        keyof TElement\n    >;\n};\n\n// Note: abstract roles are **not** in this list, as \"Authors MUST NOT use abstract roles in content\"\ntype AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'associationlist'\n    | 'associationlistitemkey'\n    | 'associationlistitemvalue'\n    | 'banner'\n    | 'blockquote'\n    | 'button'\n    | 'caption'\n    | 'cell'\n    | 'checkbox'\n    | 'code'\n    | 'columnheader'\n    | 'combobox'\n    | 'comment'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'deletion'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'emphasis'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'generic'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'insertion'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'mark'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'meter'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'paragraph'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'strong'\n    | 'subscript'\n    | 'suggestion'\n    | 'superscript'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'time'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | string;\n\ntype DirValue = 'ltr' | 'rtl' | 'auto' | string;\n\ntype BrowsingContextValue = '_blank' | '_self' | '_parent' | '_top' | string;\n\ntype ReferrerPolicyValue =\n    | ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'same-origin'\n    | 'origin'\n    | 'strict-origin'\n    | 'origin-when-cross-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url'\n    | string;\n\ntype CrossOriginValue = 'anonymous' | '' | 'use-credentials';\n\ntype LazyLoadingValue = 'lazy' | 'eager' | string;\n\ntype ImageDecodingHintValue = 'sync' | 'async' | 'auto' | string;\n\ntype SandboxValue =\n    | 'allow-forms'\n    | 'allow-modals'\n    | 'allow-orientation-lock'\n    | 'allow-pointer-lock'\n    | 'allow-popups'\n    | 'allow-popups-to-escape-sandbox'\n    | 'allow-presentation'\n    | 'allow-same-origin'\n    | 'allow-scripts'\n    | 'allow-top-navigation'\n    | 'allow-top-navigation-by-user-activation'\n    | 'allow-downloads'\n    | string;\n\ntype EncTypeValue =\n    | 'application/x-www-form-urlencoded'\n    | 'multipart/form-data'\n    | 'text/plain'\n    | string;\n\ntype FormMethodValue = 'get' | 'post' | 'dialog' | string;\n\ntype AutocompleteValue = 'on' | 'off' | string;\n\ninterface JSXElementInterface {\n    /** a guide for creating a keyboard shortcut that activates or focuses the element */\n    accesskey?: string | undefined;\n    'aria-atomic'?: string | undefined; //  ariaAtomic\n    'aria-autocomplete'?: string | undefined; //  ariaAutoComplete\n    'aria-busy'?: string | undefined; //  ariaBusy\n    'aria-checked'?: string | undefined; //  ariaChecked\n    'aria-colcount'?: string | undefined; //  ariaColCount\n    'aria-colindex'?: string | undefined; //  ariaColIndex\n    'aria-colindextext'?: string | undefined; //  ariaColIndexText\n    'aria-colspan'?: string | undefined; //  ariaColSpan\n    'aria-current'?: string | undefined; //  ariaCurrent\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description'?: string | undefined; //  ariaDescription\n    */\n    'aria-disabled'?: string | undefined; //  ariaDisabled\n    'aria-expanded'?: string | undefined; //  ariaExpanded\n    'aria-haspopup'?: string | undefined; //  ariaHasPopup\n    'aria-hidden'?: string | undefined; //  ariaHidden\n    'aria-invalid'?: string | undefined; //  ariaInvalid\n    'aria-keyshortcuts'?: string | undefined; //  ariaKeyShortcuts\n    'aria-label'?: string | undefined; //  ariaLabel\n    'aria-level'?: string | undefined; //  ariaLevel\n    'aria-live'?: string | undefined; //  ariaLive\n    'aria-modal'?: string | undefined; //  ariaModal\n    'aria-multiline'?: string | undefined; //  ariaMultiLine\n    'aria-multiselectable'?: string | undefined; //  ariaMultiSelectable\n    'aria-orientation'?: string | undefined; //  ariaOrientation\n    'aria-placeholder'?: string | undefined; //  ariaPlaceholder\n    'aria-posinset'?: string | undefined; //  ariaPosInSet\n    'aria-pressed'?: string | undefined; //  ariaPressed\n    'aria-readonly'?: string | undefined; //  ariaReadOnly\n    'aria-required'?: string | undefined; //  ariaRequired\n    'aria-roledescription'?: string | undefined; //  ariaRoleDescription\n    'aria-rowcount'?: string | undefined; //  ariaRowCount\n    'aria-rowindex'?: string | undefined; //  ariaRowIndex\n    'aria-rowindextext'?: string | undefined; //  ariaRowIndexText\n    'aria-rowspan'?: string | undefined; //  ariaRowSpan\n    'aria-selected'?: string | undefined; //  ariaSelected\n    'aria-setsize'?: string | undefined; //  ariaSetSize\n    'aria-sort'?: string | undefined; //  ariaSort\n    'aria-valuemax'?: string | undefined; //  ariaValueMax\n    'aria-valuemin'?: string | undefined; //  ariaValueMin\n    'aria-valuenow'?: string | undefined; //  ariaValueNow\n    'aria-valuetext'?: string | undefined; //  ariaValueText\n    /** autocapitalization hint */\n    autocapitalize?:\n        | 'off'\n        | 'none'\n        | 'on'\n        | 'sentences'\n        | 'words'\n        | 'characters'\n        | string\n        | undefined;\n    /** focus as soon as the page is loaded or as soon as the dialog within which it finds itself is shown */\n    autofocus?: boolean | undefined;\n    /** the various classes that the element belongs to */\n    class?: string | undefined;\n    /** indicates if the element is editable */\n    contenteditable?: '' | 'true' | 'false' | string | undefined;\n    /** specifies the element's text directionality */\n    dir?: DirValue | undefined;\n    /** specifies the element's drag behavior */\n    draggable?: boolean | undefined;\n    /** specifies what action label (or icon) to present for the enter key on virtual keyboards */\n    enterkeyhint?:\n        | 'enter'\n        | 'done'\n        | 'go'\n        | 'next'\n        | 'previous'\n        | 'search'\n        | 'send'\n        | string\n        | undefined;\n    /** indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user */\n    hidden?: boolean | undefined;\n    /** the unique id of the element */\n    id?: string | undefined;\n    inputmode?:\n        | 'none'\n        | 'text'\n        | 'tel'\n        | 'url'\n        | 'email'\n        | 'numeric'\n        | 'decimal'\n        | 'search'\n        | string\n        | undefined;\n    is?: string | undefined;\n    itemid?: string | undefined;\n    itemprop?: string | undefined;\n    itemref?: string | undefined;\n    itemscope?: boolean | undefined;\n    itemtype?: string | undefined;\n    lang?: string | undefined;\n    nonce?: string | undefined;\n    role?: AriaRole | undefined;\n    slot?: string | undefined;\n    spellcheck?: boolean | undefined;\n    style?: string | undefined;\n    tabindex?: -1 | 0 | number | undefined; // \"-1\" and \"0\" used as convenience\n    title?: string | undefined;\n    translate?: '' | 'yes' | 'no' | undefined;\n}\n\nexport const HTMLElementMap: PropertyMap<\n    JSXElementInterface,\n    HTMLElement & MissingFromTypescriptHTMLElementProperties\n> = {\n    accesskey: {\n        idlName: 'accessKey',\n    },\n    'aria-atomic': {\n        idlName: 'ariaAtomic',\n    },\n    'aria-autocomplete': {\n        idlName: 'ariaAutoComplete',\n    },\n    'aria-busy': {\n        idlName: 'ariaBusy',\n    },\n    'aria-checked': {\n        idlName: 'ariaChecked',\n    },\n    'aria-colcount': {\n        idlName: 'ariaColCount',\n    },\n    'aria-colindex': {\n        idlName: 'ariaColIndex',\n    },\n    'aria-colindextext': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaColIndexText\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaColIndexText',\n    },\n    'aria-colspan': {\n        idlName: 'ariaColSpan',\n    },\n    'aria-current': {\n        idlName: 'ariaCurrent',\n    },\n    /*\n     * Note: omitting aria-description, as it is still in consideration for ARIA 2.0: https://www.w3.org/WAI/ARIA/track/issues/411\n    'aria-description': {\n        idlName: 'ariaDescription',\n    },\n    */\n    'aria-disabled': {\n        idlName: 'ariaDisabled',\n    },\n    'aria-expanded': {\n        idlName: 'ariaExpanded',\n    },\n    'aria-haspopup': {\n        idlName: 'ariaHasPopup',\n    },\n    'aria-hidden': {\n        idlName: 'ariaHidden',\n    },\n    'aria-invalid': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaInvalid\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaInvalid',\n    },\n    'aria-keyshortcuts': {\n        idlName: 'ariaKeyShortcuts',\n    },\n    'aria-label': {\n        idlName: 'ariaLabel',\n    },\n    'aria-level': {\n        idlName: 'ariaLevel',\n    },\n    'aria-live': {\n        idlName: 'ariaLive',\n    },\n    'aria-modal': {\n        idlName: 'ariaModal',\n    },\n    'aria-multiline': {\n        idlName: 'ariaMultiLine',\n    },\n    'aria-multiselectable': {\n        idlName: 'ariaMultiSelectable',\n    },\n    'aria-orientation': {\n        idlName: 'ariaOrientation',\n    },\n    'aria-placeholder': {\n        idlName: 'ariaPlaceholder',\n    },\n    'aria-posinset': {\n        idlName: 'ariaPosInSet',\n    },\n    'aria-pressed': {\n        idlName: 'ariaPressed',\n    },\n    'aria-readonly': {\n        idlName: 'ariaReadOnly',\n    },\n    'aria-required': {\n        idlName: 'ariaRequired',\n    },\n    'aria-roledescription': {\n        idlName: 'ariaRoleDescription',\n    },\n    'aria-rowcount': {\n        idlName: 'ariaRowCount',\n    },\n    'aria-rowindex': {\n        idlName: 'ariaRowIndex',\n    },\n    'aria-rowindextext': {\n        // Note: ariaColIndexText is not present on TypeScript's Element AriaMixin IDL, despite being present in https://www.w3.org/TR/wai-aria-1.2/\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: Type '\"ariaColIndexText\"' is not assignable to type 'keyof HTMLElement'.\n        idlName: 'ariaRowIndexText',\n    },\n    'aria-rowspan': {\n        idlName: 'ariaRowSpan',\n    },\n    'aria-selected': {\n        idlName: 'ariaSelected',\n    },\n    'aria-setsize': {\n        idlName: 'ariaSetSize',\n    },\n    'aria-sort': {\n        idlName: 'ariaSort',\n    },\n    'aria-valuemax': {\n        idlName: 'ariaValueMax',\n    },\n    'aria-valuemin': {\n        idlName: 'ariaValueMin',\n    },\n    'aria-valuenow': {\n        idlName: 'ariaValueNow',\n    },\n    'aria-valuetext': {\n        idlName: 'ariaValueText',\n    },\n    autocapitalize: {},\n    autofocus: {\n        // Note: The \"autofocus\" property exists in HTMLElement interface: https://html.spec.whatwg.org/multipage/dom.html#htmlorsvgelement\n    },\n    class: {\n        idlName: 'className',\n    },\n    contenteditable: {\n        idlName: 'contentEditable',\n    },\n    dir: {},\n    draggable: {},\n    enterkeyhint: {\n        idlName: 'enterKeyHint',\n    },\n    hidden: {},\n    id: {},\n    inputmode: {\n        idlName: 'inputMode',\n    },\n    is: { idlName: null },\n    itemid: { idlName: null },\n    itemprop: { idlName: null },\n    itemref: { idlName: null },\n    itemscope: { idlName: null },\n    itemtype: { idlName: null },\n    lang: {},\n    nonce: {},\n    role: {},\n    slot: {},\n    spellcheck: {},\n    style: {},\n    tabindex: {\n        idlName: 'tabIndex',\n        makeIdlValue: attrStringOrNumberToNumber,\n    },\n    title: {},\n    translate: {\n        makeIdlValue: attrYesNo,\n    },\n};\n\ninterface JSXAnchorElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** Browsing context for hyperlink navigation */\n    target?: BrowsingContextValue | undefined;\n    /** Whether to download the resource instead of navigating to it, and its filename if so */\n    download?: string | undefined;\n    /** URLs to ping */\n    ping?: string | undefined;\n    /** Relationship between the location in the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLAnchorElementMap: PropertyMap<\n    JSXAnchorElementInterface,\n    HTMLAnchorElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    target: {},\n    download: {},\n    ping: {},\n    rel: {},\n    hreflang: {},\n    type: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXAreaElementInterface extends JSXElementInterface {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    shape?:\n        | 'circle'\n        | 'circ'\n        | 'default'\n        | 'poly'\n        | 'polygon'\n        | 'rect'\n        | 'rectangle'\n        | string\n        | undefined;\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n    download?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLAreaElementMap: PropertyMap<\n    JSXAreaElementInterface,\n    HTMLAreaElement\n> = {\n    ...HTMLElementMap,\n    alt: {},\n    coords: {},\n    shape: {},\n    href: {},\n    target: {},\n    download: {},\n    ping: {},\n    rel: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXMediaElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Hints how much buffering the media resource will likely need */\n    preload?: 'none' | 'metadata' | 'auto' | undefined;\n    /** Hint that the media resource can be started automatically when the page is loaded */\n    autoplay?: boolean | undefined;\n    /** Whether to loop the media resource */\n    loop?: boolean | undefined;\n    /** Whether to mute the media resource by default */\n    muted?: boolean | undefined;\n    /** Show user agent controls */\n    controls?: boolean | undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXAudioElementInterface extends JSXMediaElementInterface {}\n\nconst HTMLAudioElementMap: PropertyMap<\n    JSXAudioElementInterface,\n    HTMLAudioElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    preload: {},\n    autoplay: {},\n    loop: {\n        makeIdlValue: attrBooleanToEmptyString,\n    },\n    muted: {},\n    controls: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBRElementInterface extends JSXElementInterface {}\n\nconst HTMLBRElementMap: PropertyMap<JSXBRElementInterface, HTMLBRElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXBaseElementInterface extends JSXElementInterface {\n    href?: string | undefined;\n    target?: BrowsingContextValue | undefined;\n}\n\nconst HTMLBaseElementMap: PropertyMap<\n    JSXBaseElementInterface,\n    HTMLBaseElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    target: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXBodyElementInterface extends JSXElementInterface {}\n\nconst HTMLBodyElementMap: PropertyMap<\n    JSXBodyElementInterface,\n    HTMLBodyElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXButtonElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formaction?: string | undefined;\n    formenctype?: EncTypeValue | undefined;\n    formmethod?: FormMethodValue | undefined;\n    formnovalidate?: boolean | undefined;\n    formtarget?: BrowsingContextValue | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | string | undefined;\n    value?: string | undefined;\n}\n\nconst HTMLButtonElementMap: PropertyMap<\n    JSXButtonElementInterface,\n    HTMLButtonElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    form: { idlName: null }, // Note: form IDL not ever written\n    formaction: {\n        idlName: 'formAction',\n    },\n    formenctype: {\n        idlName: 'formEnctype',\n    },\n    formmethod: {\n        idlName: 'formMethod',\n    },\n    formnovalidate: {\n        idlName: 'formNoValidate',\n    },\n    formtarget: {\n        idlName: 'formTarget',\n    },\n    name: {},\n    type: {},\n    value: {},\n};\n\ninterface JSXCanvasElementInterface extends JSXElementInterface {\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\nconst HTMLCanvasElementMap: PropertyMap<\n    JSXCanvasElementInterface,\n    HTMLCanvasElement\n> = {\n    ...HTMLElementMap,\n    width: {},\n    height: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDListElementInterface extends JSXElementInterface {}\n\nconst HTMLDListElementMap: PropertyMap<\n    JSXDListElementInterface,\n    HTMLDListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXDataElementInterface extends JSXElementInterface {\n    value?: string | undefined;\n}\n\nconst HTMLDataElementMap: PropertyMap<\n    JSXDataElementInterface,\n    HTMLDataElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDataListElementInterface extends JSXElementInterface {}\n\nconst HTMLDataListElementMap: PropertyMap<\n    JSXDataListElementInterface,\n    HTMLDataListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXDetailsElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\nconst HTMLDetailsElementMap: PropertyMap<\n    JSXDetailsElementInterface,\n    HTMLDetailsElement\n> = {\n    ...HTMLElementMap,\n    open: {},\n};\n\ninterface JSXDialogElementInterface extends JSXElementInterface {\n    open?: boolean | undefined;\n}\n\nconst HTMLDialogElementMap: PropertyMap<\n    JSXDialogElementInterface,\n    HTMLDialogElement & MissingFromTypescriptHTMLDialogElementProperties\n> = {\n    ...HTMLElementMap,\n    open: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXDivElementInterface extends JSXElementInterface {}\n\nconst HTMLDivElementMap: PropertyMap<JSXDivElementInterface, HTMLDivElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXEmbedElementInterface extends JSXElementInterface {\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: number | undefined;\n    height?: number | undefined;\n}\n\nconst HTMLEmbedElementMap: PropertyMap<\n    JSXEmbedElementInterface,\n    HTMLEmbedElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    type: {},\n    width: {},\n    height: {},\n};\n\ninterface JSXFieldSetElementInterface extends JSXElementInterface {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\nconst HTMLFieldSetElementMap: PropertyMap<\n    JSXFieldSetElementInterface,\n    HTMLFieldSetElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    form: { idlName: null }, // form IDL not ever written\n    name: {},\n};\n\ninterface JSXFormElementInterface extends JSXElementInterface {\n    'accept-charset'?: 'UTF-8' | string | undefined;\n    action?: string | undefined;\n    autocomplete?: AutocompleteValue | undefined;\n    enctype?: EncTypeValue | undefined;\n    method?: FormMethodValue | undefined;\n    name?: string | undefined;\n    novalidate?: boolean | undefined;\n    target?: BrowsingContextValue | undefined;\n    rel?: string | undefined;\n}\n\nconst HTMLFormElementMap: PropertyMap<\n    JSXFormElementInterface,\n    HTMLFormElement\n> = {\n    ...HTMLElementMap,\n    'accept-charset': {\n        idlName: 'acceptCharset',\n    },\n    action: {},\n    autocomplete: {},\n    enctype: {},\n    method: {},\n    name: {},\n    novalidate: {\n        idlName: 'noValidate',\n    },\n    target: {},\n    rel: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadingElementInterface extends JSXElementInterface {}\n\nconst HTMLHeadingElementMap: PropertyMap<\n    JSXHeadingElementInterface,\n    HTMLHeadingElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHeadElementInterface extends JSXElementInterface {}\n\nconst HTMLHeadElementMap: PropertyMap<\n    JSXHeadElementInterface,\n    HTMLHeadElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHRElementInterface extends JSXElementInterface {}\n\nconst HTMLHRElementMap: PropertyMap<JSXHRElementInterface, HTMLHRElement> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXHtmlElementInterface extends JSXElementInterface {}\n\nconst HTMLHtmlElementMap: PropertyMap<\n    JSXHtmlElementInterface,\n    HTMLHtmlElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXIFrameElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** A document to render in the iframe */\n    srcdoc?: string | undefined;\n    /** Name of nested browsing context */\n    name?: string | undefined;\n    /** Security rules for nested content */\n    sandbox?: SandboxValue | undefined; // TODO: This _could_ be a SandboxValue[], but feels awkward\n    /** Permissions policy to be applied to the iframe's contents */\n    allow?: string | undefined;\n    /** Whether to allow the iframe's contents to use requestFullscreen() */\n    allowfullscreen?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\nconst HTMLIFrameElementMap: PropertyMap<\n    JSXIFrameElementInterface,\n    HTMLIFrameElement & MissingFromTypescriptHTMLIframeElementProperties\n> = {\n    ...HTMLElementMap,\n    src: {},\n    srcdoc: {},\n    name: {},\n    sandbox: {},\n    allow: {},\n    allowfullscreen: {\n        idlName: 'allowFullscreen',\n    },\n    width: {},\n    height: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    loading: {},\n};\n\ninterface JSXImageElementInterface extends JSXElementInterface {\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Name of image map to use */\n    usemap?: string | undefined;\n    /** Whether the image is a server-side image map */\n    ismap?: boolean | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Decoding hint to use when processing this image for presentation */\n    decoding?: ImageDecodingHintValue | undefined;\n    /** Used when determining loading deferral */\n    loading?: LazyLoadingValue | undefined;\n}\n\nconst HTMLImageElementMap: PropertyMap<\n    JSXImageElementInterface,\n    HTMLImageElement\n> = {\n    ...HTMLElementMap,\n    alt: {},\n    src: {},\n    srcset: {},\n    sizes: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    usemap: {\n        idlName: 'useMap',\n    },\n    ismap: {\n        idlName: 'isMap',\n    },\n    width: {},\n    height: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    decoding: {},\n    loading: {},\n};\n\ntype FormInputTypeValues =\n    | 'button'\n    | 'checkbox'\n    | 'color'\n    | 'date'\n    | 'datetime-local'\n    | 'email'\n    | 'file'\n    | 'hidden'\n    | 'image'\n    | 'month'\n    | 'number'\n    | 'password'\n    | 'radio'\n    | 'range'\n    | 'reset'\n    | 'search'\n    | 'submit'\n    | 'tel'\n    | 'text'\n    | 'time'\n    | 'url'\n    | 'week'\n    | string;\n\ninterface JSXInputElementInterface extends JSXElementInterface {\n    /** Hint for expected file type in file upload controls */\n    accept?: string | undefined;\n    /** Replacement text for use when images are not available */\n    alt?: string | undefined;\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the control is checked */\n    checked?: boolean | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: string | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** URL to use for form submission */\n    formaction?: string | undefined;\n    /** Entry list encoding type to use for form submission */\n    formenctype?: EncTypeValue | undefined;\n    /** Variant to use for form submission */\n    formmethod?: FormMethodValue | undefined;\n    /** Bypass form control validation for form submission */\n    formnovalidate?: boolean | undefined;\n    /** Browsing context for form submission */\n    formtarget?: BrowsingContextValue | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n    /** Third, indeterminate state for checkboxes */\n    indeterminate?: boolean | undefined;\n    /** List of autocomplete options */\n    list?: string | undefined;\n    /** Maximum value */\n    max?: number | undefined;\n    /** Maximum length of value */\n    maxlength?: number | undefined;\n    /** Minimum value */\n    min?: number | undefined;\n    /** Minimum length of value */\n    minlength?: number | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Pattern to be matched by the form control's value */\n    pattern?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: number | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Granularity to be matched by the form control's value */\n    step?: number | undefined;\n    /** Type of form control */\n    type?: FormInputTypeValues | undefined;\n    /** Value of the form control */\n    value?: string | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n}\nconst HTMLInputElementMap: PropertyMap<\n    JSXInputElementInterface,\n    HTMLInputElement\n> = {\n    ...HTMLElementMap,\n    accept: {},\n    alt: {},\n    autocomplete: {},\n    checked: {},\n    dirname: {\n        idlName: 'dirName',\n    },\n    disabled: {},\n    form: {},\n    formaction: {\n        idlName: 'formAction',\n    },\n    formenctype: {\n        idlName: 'formEnctype',\n    },\n    formmethod: {\n        idlName: 'formMethod',\n    },\n    formnovalidate: {\n        idlName: 'formNoValidate',\n    },\n    formtarget: {\n        idlName: 'formTarget',\n    },\n    height: {},\n    indeterminate: {\n        makeAttrValue: null, // TODO: what other IDL attributes don't set html attributes?\n    },\n    list: {},\n    max: {},\n    maxlength: {},\n    min: {},\n    minlength: {\n        idlName: 'minLength',\n    },\n    multiple: {},\n    name: {},\n    pattern: {},\n    placeholder: {},\n    readonly: {\n        idlName: 'readOnly',\n    },\n    required: {},\n    size: {},\n    src: {},\n    step: {},\n    type: {},\n    value: {},\n    width: {},\n};\n\ninterface JSXModElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n    /** Date and (optionally) time of the change */\n    datetime?: string | undefined;\n}\n\nconst HTMLModElementMap: PropertyMap<JSXModElementInterface, HTMLModElement> = {\n    ...HTMLElementMap,\n    cite: {},\n    datetime: {\n        idlName: 'dateTime',\n    },\n};\n\ninterface JSXLabelElementInterface extends JSXElementInterface {\n    /** Associate the label with form control */\n    for?: string | undefined;\n}\n\nconst HTMLLabelElementMap: PropertyMap<\n    JSXLabelElementInterface,\n    HTMLLabelElement\n> = {\n    ...HTMLElementMap,\n    for: {\n        idlName: 'htmlFor',\n    },\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLegendElementInterface extends JSXElementInterface {}\n\nconst HTMLLegendElementMap: PropertyMap<\n    JSXLegendElementInterface,\n    HTMLLegendElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXLIElementInterface extends JSXElementInterface {\n    /** Ordinal value of the list item */\n    value?: string | undefined;\n}\n\nconst HTMLLIElementMap: PropertyMap<JSXLIElementInterface, HTMLLIElement> = {\n    ...HTMLElementMap,\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXLinkElementInterface extends JSXElementInterface {\n    /** Address of the hyperlink */\n    href?: string | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Relationship between the document containing the hyperlink and the destination resource */\n    rel?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Language of the linked resource */\n    hreflang?: string | undefined;\n    /** Hint for the type of the referenced resource */\n    type?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n    /** Sizes of the icons (for rel=\"icon\") */\n    sizes?: string | undefined;\n    /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. (for rel=\"preload\") */\n    imagesrcset?: string | undefined;\n    /** Image sizes for different page layouts (for rel=\"preload\") */\n    imagesizes?: string | undefined;\n    /** Potential destination for a preload request (for rel=\"preload\" and rel=\"modulepreload\") */\n    as?: string | undefined;\n    /** Color to use when customizing a site's icon (for rel=\"mask-icon\") */\n    color?: string | undefined;\n    /** Whether the link is disabled */\n    disabled?: boolean | undefined;\n}\n\nconst HTMLLinkElementMap: PropertyMap<\n    JSXLinkElementInterface,\n    HTMLLinkElement\n> = {\n    ...HTMLElementMap,\n    href: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    rel: {},\n    media: {},\n    integrity: {},\n    hreflang: {},\n    type: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n    sizes: {},\n    imagesrcset: {\n        idlName: 'imageSrcset',\n    },\n    imagesizes: {\n        idlName: 'imageSizes',\n    },\n    as: {},\n    color: {\n        idlName: null, // TODO: confirm\n    },\n    disabled: {},\n};\n\ninterface JSXMapElementInterface extends JSXElementInterface {\n    /** Name of image map to reference from the usemap attribute */\n    name?: string | undefined;\n}\n\nconst HTMLMapElementMap: PropertyMap<JSXMapElementInterface, HTMLMapElement> = {\n    ...HTMLElementMap,\n    name: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXMenuElementInterface extends JSXElementInterface {}\n\nconst HTMLMenuElementMap: PropertyMap<\n    JSXMenuElementInterface,\n    HTMLMenuElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXMetaElementInterface extends JSXElementInterface {\n    /** Metadata name */\n    name?:\n        | 'application-name'\n        | 'author'\n        | 'description'\n        | 'generator'\n        | 'keywords'\n        | 'referrer'\n        | 'theme-color'\n        | 'color-scheme'\n        | string\n        | undefined;\n    /** Pragma directive */\n    'http-equiv'?: string | undefined;\n    /** Value of the element */\n    content?: string | undefined;\n    /** Character encoding declaration */\n    charset?: string | undefined;\n    /** Applicable media */\n    media?: string | undefined;\n}\n\nconst HTMLMetaElementMap: PropertyMap<\n    JSXMetaElementInterface,\n    HTMLMetaElement & MissingFromTypescriptHTMLMetaElementProperties\n> = {\n    ...HTMLElementMap,\n    name: {},\n    'http-equiv': {\n        idlName: 'httpEquiv',\n    },\n    content: {},\n    charset: {\n        idlName: null, // TODO: confirm\n    },\n    media: {},\n};\n\ninterface JSXMeterElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: number | undefined;\n    /** Lower bound of range */\n    min?: number | undefined;\n    /** Upper bound of range */\n    max?: number | undefined;\n    /** High limit of low range */\n    low?: number | undefined;\n    /** Low limit of high range */\n    high?: number | undefined;\n    /** Optimum value in gauge */\n    optimum?: number | undefined;\n}\n\nconst HTMLMeterElementMap: PropertyMap<\n    JSXMeterElementInterface,\n    HTMLMeterElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n    min: {},\n    max: {},\n    low: {},\n    high: {},\n    optimum: {},\n};\n\ninterface JSXObjectElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    data?: string | undefined;\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** Name of nested browsing context */\n    name?: BrowsingContextValue | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Horizontal dimension */\n    width?: string | undefined;\n    /** Vertical dimension */\n    height?: string | undefined;\n}\n\nconst HTMLObjectElementMap: PropertyMap<\n    JSXObjectElementInterface,\n    HTMLObjectElement\n> = {\n    ...HTMLElementMap,\n    data: {},\n    type: {},\n    name: {},\n    form: {\n        idlName: null,\n    },\n    width: {},\n    height: {},\n};\n\ninterface JSXOListElementInterface extends JSXElementInterface {\n    /** Number the list backwards */\n    reversed?: boolean | undefined;\n    /** Starting value of the list */\n    start?: number | undefined;\n    /** Kind of list marker */\n    type?:\n        | 'decimal'\n        | 'lower-alpha'\n        | 'upper-alpha'\n        | 'lower-roman'\n        | 'upper-roman'\n        | string\n        | undefined;\n}\n\nconst HTMLOListElementMap: PropertyMap<\n    JSXOListElementInterface,\n    HTMLOListElement\n> = {\n    ...HTMLElementMap,\n    reversed: {},\n    start: {},\n    type: {},\n};\n\ninterface JSXOptGroupElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n}\n\nconst HTMLOptGroupElementMap: PropertyMap<\n    JSXOptGroupElementInterface,\n    HTMLOptGroupElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    label: {},\n};\n\ninterface JSXOptionElementInterface extends JSXElementInterface {\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Whether the option is selected by default */\n    selected?: boolean | undefined;\n    /** Value to be used for form submission */\n    value?: string | undefined;\n}\n\nconst HTMLOptionElementMap: PropertyMap<\n    JSXOptionElementInterface,\n    HTMLOptionElement\n> = {\n    ...HTMLElementMap,\n    disabled: {},\n    label: {},\n    selected: {},\n    value: {},\n};\n\ninterface JSXOutputElementInterface extends JSXElementInterface {\n    /** Specifies controls from which the output was calculated */\n    for?: string | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Name of the element to use in the form.elements API. */\n    name?: string | undefined;\n}\n\nconst HTMLOutputElementMap: PropertyMap<\n    JSXOutputElementInterface,\n    HTMLOutputElement\n> = {\n    ...HTMLElementMap,\n    for: {\n        idlName: 'htmlFor',\n    },\n    form: { idlName: null },\n    name: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXParagraphElementInterface extends JSXElementInterface {}\n\nconst HTMLParagraphElementMap: PropertyMap<\n    JSXParagraphElementInterface,\n    HTMLParagraphElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXParamElementInterface extends JSXElementInterface {\n    /** Name of parameter */\n    name?: string | undefined;\n    /** Value of parameter */\n    value?: string | undefined;\n}\n\nconst HTMLParamElementMap: PropertyMap<\n    JSXParamElementInterface,\n    HTMLParamElement\n> = {\n    ...HTMLElementMap,\n    name: {},\n    value: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPictureElementInterface extends JSXElementInterface {}\n\nconst HTMLPictureElementMap: PropertyMap<\n    JSXPictureElementInterface,\n    HTMLPictureElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXPreElementInterface extends JSXElementInterface {}\n\nconst HTMLPreElementMap: PropertyMap<JSXPreElementInterface, HTMLPreElement> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXProgressElementInterface extends JSXElementInterface {\n    /** Current value of the element */\n    value?: number | undefined;\n    /** Upper bound of range */\n    max?: number | undefined;\n}\n\nconst HTMLProgressElementMap: PropertyMap<\n    JSXProgressElementInterface,\n    HTMLProgressElement\n> = {\n    ...HTMLElementMap,\n    value: {},\n    max: {},\n};\n\ninterface JSXQuoteElementInterface extends JSXElementInterface {\n    /** Link to the source of the quotation or more information about the edit */\n    cite?: string | undefined;\n}\n\nconst HTMLQuoteElementMap: PropertyMap<\n    JSXQuoteElementInterface,\n    HTMLQuoteElement\n> = {\n    ...HTMLElementMap,\n    cite: {},\n};\n\ninterface JSXScriptElementInterface extends JSXElementInterface {\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Type of script */\n    type?: 'application/json' | 'text/json' | 'module' | string | undefined;\n    /** Prevents execution in user agents that support module scripts */\n    nomodule?: boolean | undefined;\n    /** Execute script when available, without blocking while fetching */\n    async?: boolean | undefined;\n    /** Defer script execution */\n    defer?: boolean | undefined;\n    /** How the element handles crossorigin requests */\n    crossorigin?: CrossOriginValue | undefined;\n    /** Integrity metadata used in Subresource Integrity checks [SRI] */\n    integrity?: string | undefined;\n    /** Referrer policy for fetches initiated by the element */\n    referrerpolicy?: ReferrerPolicyValue | undefined;\n}\n\nconst HTMLScriptElementMap: PropertyMap<\n    JSXScriptElementInterface,\n    HTMLScriptElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    type: {},\n    nomodule: {\n        idlName: 'noModule',\n    },\n    async: {},\n    defer: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    integrity: {},\n    referrerpolicy: {\n        idlName: 'referrerPolicy',\n    },\n};\n\ninterface JSXSelectElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Whether to allow multiple values */\n    multiple?: boolean | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Size of the control */\n    size?: number | undefined;\n    /** Value of the element */\n    value?: string | undefined;\n}\n\nconst HTMLSelectElementMap: PropertyMap<\n    JSXSelectElementInterface,\n    HTMLSelectElement\n> = {\n    ...HTMLElementMap,\n    autocomplete: {},\n    disabled: {},\n    form: { idlName: null },\n    multiple: {},\n    name: {},\n    required: {},\n    size: {},\n    value: { makeAttrValue: null },\n};\n\ninterface JSXSlotElementInterface extends JSXElementInterface {\n    /** Name of shadow tree slot */\n    name?: string | undefined;\n}\n\nconst HTMLSlotElementMap: PropertyMap<\n    JSXSlotElementInterface,\n    HTMLSlotElement\n> = {\n    ...HTMLElementMap,\n    name: {},\n};\n\ninterface JSXSourceElementInterface extends JSXElementInterface {\n    /** Type of embedded resource */\n    type?: string | undefined;\n    /** (in video or audio) \u2014 Address of the resource */\n    src?: string | undefined;\n    /** (in picture) \u2014 Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\n    srcset?: string | undefined;\n    /** (in picture) \u2014 Image sizes for different page layouts */\n    sizes?: string | undefined;\n    /** (in picture) \u2014 Applicable media */\n    media?: string | undefined;\n    /** (in picture) \u2014 Horizontal dimension */\n    width?: number | undefined;\n    /** (in picture) \u2014 Vertical dimension */\n    height?: number | undefined;\n}\n\nconst HTMLSourceElementMap: PropertyMap<\n    JSXSourceElementInterface,\n    HTMLSourceElement & MissingFromTypescriptHTMLSourceElementProperties\n> = {\n    ...HTMLElementMap,\n    type: {},\n    src: {},\n    srcset: {},\n    sizes: {},\n    media: {},\n    width: {},\n    height: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXSpanElementInterface extends JSXElementInterface {}\n\nconst HTMLSpanElementMap: PropertyMap<\n    JSXSpanElementInterface,\n    HTMLSpanElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXStyleElementInterface extends JSXElementInterface {\n    /** Applicable media */\n    media?: string | undefined;\n}\n\nconst HTMLStyleElementMap: PropertyMap<\n    JSXStyleElementInterface,\n    HTMLStyleElement\n> = {\n    ...HTMLElementMap,\n    media: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableElementInterface extends JSXElementInterface {}\n\nconst HTMLTableElementMap: PropertyMap<\n    JSXTableElementInterface,\n    HTMLTableElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableCaptionElementInterface extends JSXElementInterface {}\n\nconst HTMLTableCaptionElementMap: PropertyMap<\n    JSXTableCaptionElementInterface,\n    HTMLTableCaptionElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableSectionElementInterface extends JSXElementInterface {}\n\nconst HTMLTableSectionElementMap: PropertyMap<\n    JSXTableSectionElementInterface,\n    HTMLTableSectionElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTableCellElementInterface extends JSXElementInterface {\n    /** Number of columns that the cell is to span */\n    colspan?: number | undefined;\n    /** Number of rows that the cell is to span */\n    rowspan?: number | undefined;\n    /** The header cells for this cell */\n    headers?: string | undefined;\n}\n\nconst HTMLTableCellElementMap: PropertyMap<\n    JSXTableCellElementInterface,\n    HTMLTableCellElement\n> = {\n    ...HTMLElementMap,\n    colspan: {\n        idlName: 'colSpan',\n    },\n    rowspan: {\n        idlName: 'rowSpan',\n    },\n    headers: {},\n};\n\ninterface JSXTableColElementInterface extends JSXElementInterface {\n    /** Number of columns spanned by the element */\n    span?: number | undefined;\n}\n\nconst HTMLTableColElementMap: PropertyMap<\n    JSXTableColElementInterface,\n    HTMLTableColElement\n> = {\n    ...HTMLElementMap,\n    span: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTemplateElementInterface extends JSXElementInterface {}\n\nconst HTMLTemplateElementMap: PropertyMap<\n    JSXTemplateElementInterface,\n    HTMLTemplateElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTextAreaElementInterface extends JSXElementInterface {\n    /** Hint for form autofill feature */\n    autocomplete?: AutocompleteValue | undefined;\n    /** Maximum number of characters per line */\n    cols?: number | undefined;\n    /** Name of form control to use for sending the element's directionality in form submission */\n    dirname?: DirValue | undefined;\n    /** Whether the form control is disabled */\n    disabled?: boolean | undefined;\n    /** Associates the element with a form element */\n    form?: string | undefined;\n    /** Maximum length of value */\n    maxlength?: number | undefined;\n    /** Minimum length of value */\n    minlength?: number | undefined;\n    /** Name of the element to use for form submission and in the form.elements API */\n    name?: string | undefined;\n    /** User-visible label to be placed within the form control */\n    placeholder?: string | undefined;\n    /** Whether to allow the value to be edited by the user */\n    readonly?: boolean | undefined;\n    /** Whether the control is required for form submission */\n    required?: boolean | undefined;\n    /** Number of lines to show */\n    rows?: number | undefined;\n    /** How the value of the form control is to be wrapped for form submission */\n    wrap?: 'soft' | 'hard' | string | undefined;\n}\n\nconst HTMLTextAreaElementMap: PropertyMap<\n    JSXTextAreaElementInterface,\n    HTMLTextAreaElement\n> = {\n    ...HTMLElementMap,\n    autocomplete: {},\n    cols: {},\n    dirname: {\n        idlName: 'dirName',\n    },\n    disabled: {},\n    form: { idlName: null },\n    maxlength: {\n        idlName: 'maxLength',\n    },\n    minlength: {\n        idlName: 'minLength',\n    },\n    name: {},\n    placeholder: {},\n    readonly: {\n        idlName: 'readOnly',\n    },\n    required: {},\n    rows: {},\n    wrap: {},\n};\n\ninterface JSXTimeElementInterface extends JSXElementInterface {\n    /** Machine-readable value */\n    datetime?: string | undefined;\n}\n\nconst HTMLTimeElementMap: PropertyMap<\n    JSXTimeElementInterface,\n    HTMLTimeElement\n> = {\n    ...HTMLElementMap,\n    datetime: {\n        idlName: 'dateTime',\n    },\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTitleElementInterface extends JSXElementInterface {}\n\nconst HTMLTitleElementMap: PropertyMap<\n    JSXTitleElementInterface,\n    HTMLTitleElement\n> = {\n    ...HTMLElementMap,\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXTableRowElementInterface extends JSXElementInterface {}\n\nconst HTMLTableRowElementMap: PropertyMap<\n    JSXTableRowElementInterface,\n    HTMLTableRowElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXTrackElementInterface extends JSXElementInterface {\n    /** The type of text track */\n    kind?:\n        | 'subtitles'\n        | 'captions'\n        | 'descriptions'\n        | 'chapters'\n        | 'metadata'\n        | string\n        | undefined;\n    /** Address of the resource */\n    src?: string | undefined;\n    /** Language of the text track */\n    srclang?: string | undefined;\n    /** User-visible label */\n    label?: string | undefined;\n    /** Enable the track if no other text track is more suitable */\n    default?: boolean | undefined;\n}\n\nconst HTMLTrackElementMap: PropertyMap<\n    JSXTrackElementInterface,\n    HTMLTrackElement\n> = {\n    ...HTMLElementMap,\n    kind: {},\n    src: {},\n    srclang: {},\n    label: {},\n    default: {},\n};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface JSXUListElementInterface extends JSXElementInterface {}\n\nconst HTMLUListElementMap: PropertyMap<\n    JSXUListElementInterface,\n    HTMLUListElement\n> = {\n    ...HTMLElementMap,\n};\n\ninterface JSXVideoElementInterface extends JSXMediaElementInterface {\n    /** Poster frame to show prior to video playback */\n    poster?: string | undefined;\n    /** Encourage the user agent to display video content within the element's playback area */\n    playsinline?: string | undefined;\n    /** Horizontal dimension */\n    width?: number | undefined;\n    /** Vertical dimension */\n    height?: number | undefined;\n}\n\nconst HTMLVideoElementMap: PropertyMap<\n    JSXVideoElementInterface,\n    HTMLVideoElement\n> = {\n    ...HTMLElementMap,\n    src: {},\n    crossorigin: {\n        idlName: 'crossOrigin',\n    },\n    preload: {},\n    autoplay: {},\n    loop: {\n        makeIdlValue: attrBooleanToEmptyString,\n    },\n    muted: {},\n    controls: {},\n    poster: {},\n    playsinline: {\n        idlName: 'playsInline',\n    },\n    width: {},\n    height: {},\n};\n\nexport const ElementTypeMapping = {\n    a: HTMLAnchorElementMap,\n    abbr: HTMLElementMap,\n    address: HTMLElementMap,\n    area: HTMLAreaElementMap,\n    article: HTMLElementMap,\n    aside: HTMLElementMap,\n    audio: HTMLAudioElementMap,\n    b: HTMLElementMap,\n    base: HTMLBaseElementMap,\n    bdi: HTMLElementMap,\n    bdo: HTMLElementMap,\n    blockquote: HTMLElementMap,\n    body: HTMLBodyElementMap,\n    br: HTMLBRElementMap,\n    button: HTMLButtonElementMap,\n    canvas: HTMLCanvasElementMap,\n    caption: HTMLTableCaptionElementMap,\n    cite: HTMLElementMap,\n    code: HTMLElementMap,\n    col: HTMLTableColElementMap,\n    colgroup: HTMLTableColElementMap,\n    data: HTMLDataElementMap,\n    datalist: HTMLDataListElementMap,\n    dd: HTMLElementMap,\n    del: HTMLModElementMap,\n    details: HTMLDetailsElementMap,\n    dfn: HTMLElementMap,\n    dialog: HTMLDialogElementMap,\n    div: HTMLDivElementMap,\n    dl: HTMLDListElementMap,\n    dt: HTMLElementMap,\n    em: HTMLElementMap,\n    embed: HTMLEmbedElementMap,\n    fieldset: HTMLFieldSetElementMap,\n    figcaption: HTMLElementMap,\n    figure: HTMLElementMap,\n    footer: HTMLElementMap,\n    form: HTMLFormElementMap,\n    h1: HTMLElementMap,\n    h2: HTMLElementMap,\n    h3: HTMLElementMap,\n    h4: HTMLElementMap,\n    h5: HTMLElementMap,\n    h6: HTMLElementMap,\n    head: HTMLHeadElementMap,\n    header: HTMLElementMap,\n    heading: HTMLHeadingElementMap,\n    hgroup: HTMLElementMap,\n    hr: HTMLHRElementMap,\n    html: HTMLHtmlElementMap,\n    i: HTMLElementMap,\n    iframe: HTMLIFrameElementMap,\n    image: HTMLImageElementMap,\n    img: HTMLElementMap,\n    input: HTMLInputElementMap,\n    ins: HTMLModElementMap,\n    kbd: HTMLElementMap,\n    label: HTMLLabelElementMap,\n    legend: HTMLLegendElementMap,\n    li: HTMLLIElementMap,\n    link: HTMLLinkElementMap,\n    main: HTMLElementMap,\n    map: HTMLMapElementMap,\n    mark: HTMLElementMap,\n    menu: HTMLMenuElementMap,\n    meta: HTMLMetaElementMap,\n    meter: HTMLMeterElementMap,\n    nav: HTMLElementMap,\n    noscript: HTMLElementMap,\n    object: HTMLObjectElementMap,\n    ol: HTMLOListElementMap,\n    optgroup: HTMLOptGroupElementMap,\n    option: HTMLOptionElementMap,\n    output: HTMLOutputElementMap,\n    p: HTMLParagraphElementMap,\n    param: HTMLParamElementMap,\n    picture: HTMLPictureElementMap,\n    pre: HTMLPreElementMap,\n    progress: HTMLProgressElementMap,\n    quote: HTMLQuoteElementMap,\n    rp: HTMLElementMap,\n    rt: HTMLElementMap,\n    ruby: HTMLElementMap,\n    s: HTMLElementMap,\n    samp: HTMLElementMap,\n    script: HTMLScriptElementMap,\n    section: HTMLElementMap,\n    select: HTMLSelectElementMap,\n    slot: HTMLSlotElementMap,\n    small: HTMLElementMap,\n    source: HTMLSourceElementMap,\n    span: HTMLSpanElementMap,\n    strong: HTMLElementMap,\n    style: HTMLStyleElementMap,\n    sub: HTMLElementMap,\n    summary: HTMLElementMap,\n    sup: HTMLElementMap,\n    table: HTMLTableElementMap,\n    tbody: HTMLTableSectionElementMap,\n    td: HTMLTableCellElementMap,\n    template: HTMLTemplateElementMap,\n    textarea: HTMLTextAreaElementMap,\n    tfoot: HTMLTableSectionElementMap,\n    th: HTMLElementMap,\n    thead: HTMLTableSectionElementMap,\n    time: HTMLTimeElementMap,\n    title: HTMLTitleElementMap,\n    tr: HTMLTableRowElementMap,\n    track: HTMLTrackElementMap,\n    u: HTMLElementMap,\n    ul: HTMLUListElementMap,\n    var: HTMLElementMap,\n    video: HTMLVideoElementMap,\n    wbr: HTMLElementMap,\n} as const;\n\n// TODO: maybe typecheck this?\ninterface ElementTypeMappingField {\n    makeAttrValue?: (jsxAttr: any) => string | undefined;\n    idlName?: any;\n    makeIdlValue?: (jsxAttr: any) => any;\n}\n\n// TODO: maybe typecheck this?\nexport function getElementTypeMapping(\n    elementName: string,\n    property: string\n): ElementTypeMappingField {\n    return (ElementTypeMapping as any)[elementName]?.[property];\n}\n\n/**\n * Good old bivarianceHack to allow assignability of specific event handlers to more generic event handlers :facepalm:\n */\ntype EventHandler<TEvent extends Event> =\n    | undefined\n    | {\n          bivarianceHack(event: TEvent): void;\n      }['bivarianceHack'];\n\ninterface JSXRefProps<TElement extends HTMLElement> {\n    ref?: undefined | Ref<TElement> | ((current: TElement | undefined) => void);\n}\n\ninterface JSXEventProps {\n    'on:abort'?: EventHandler<Event>;\n    'on:auxclick'?: EventHandler<PointerEvent>;\n    'on:beforeinput'?: EventHandler<InputEvent>;\n    'on:blur'?: EventHandler<FocusEvent>;\n    'on:cancel'?: EventHandler<Event>;\n    'on:change'?: EventHandler<Event>;\n    'on:click'?: EventHandler<PointerEvent>;\n    'on:close'?: EventHandler<Event>;\n    'on:compositionend'?: EventHandler<CompositionEvent>;\n    'on:compositionstart'?: EventHandler<CompositionEvent>;\n    'on:compositionupdate'?: EventHandler<CompositionEvent>;\n    'on:connect'?: EventHandler<MessageEvent>;\n    'on:contextlost'?: EventHandler<Event>;\n    'on:contextmenu'?: EventHandler<PointerEvent>;\n    'on:contextrestored'?: EventHandler<Event>;\n    'on:copy'?: EventHandler<Event>;\n    'on:cut'?: EventHandler<Event>;\n    'on:dblclick'?: EventHandler<MouseEvent>;\n    'on:drag'?: EventHandler<DragEvent>;\n    'on:dragend'?: EventHandler<DragEvent>;\n    'on:dragenter'?: EventHandler<DragEvent>;\n    'on:dragleave'?: EventHandler<DragEvent>;\n    'on:dragover'?: EventHandler<DragEvent>;\n    'on:dragstart'?: EventHandler<DragEvent>;\n    'on:drop'?: EventHandler<DragEvent>;\n    'on:emptied'?: EventHandler<Event>;\n    'on:error'?: EventHandler<Event>;\n    'on:focus'?: EventHandler<FocusEvent>;\n    'on:focusin'?: EventHandler<FocusEvent>;\n    'on:focusout'?: EventHandler<FocusEvent>;\n    'on:formdata'?: EventHandler<FormDataEvent>;\n    'on:hashchange'?: EventHandler<HashChangeEvent>;\n    'on:input'?: EventHandler<InputEvent>;\n    'on:invalid'?: EventHandler<Event>;\n    'on:keydown'?: EventHandler<KeyboardEvent>;\n    'on:keyup'?: EventHandler<KeyboardEvent>;\n    'on:languagechange'?: EventHandler<Event>;\n    'on:load'?: EventHandler<Event>;\n    'on:loadstart'?: EventHandler<Event>;\n    'on:message'?: EventHandler<MessageEvent>;\n    'on:messageerror'?: EventHandler<MessageEvent>;\n    'on:mousedown'?: EventHandler<MouseEvent>;\n    'on:mouseenter'?: EventHandler<MouseEvent>;\n    'on:mouseleave'?: EventHandler<MouseEvent>;\n    'on:mousemove'?: EventHandler<MouseEvent>;\n    'on:mouseout'?: EventHandler<MouseEvent>;\n    'on:mouseover'?: EventHandler<MouseEvent>;\n    'on:mouseup'?: EventHandler<MouseEvent>;\n    'on:offline'?: EventHandler<Event>;\n    'on:online'?: EventHandler<Event>;\n    'on:open'?: EventHandler<Event>;\n    'on:pagehide'?: EventHandler<PageTransitionEvent>;\n    'on:pageshow'?: EventHandler<PageTransitionEvent>;\n    'on:paste'?: EventHandler<Event>;\n    'on:popstate'?: EventHandler<PopStateEvent>;\n    'on:progress'?: EventHandler<Event>;\n    'on:readystatechange'?: EventHandler<Event>;\n    'on:rejectionhandled'?: EventHandler<PromiseRejectionEvent>;\n    'on:reset'?: EventHandler<Event>;\n    'on:securitypolicyviolation'?: EventHandler<Event>;\n    'on:select'?: EventHandler<Event>;\n    'on:slotchange'?: EventHandler<Event>;\n    'on:stalled'?: EventHandler<Event>;\n    'on:storage'?: EventHandler<StorageEvent>;\n    'on:submit'?: EventHandler<SubmitEvent>;\n    'on:suspend'?: EventHandler<Event>;\n    'on:toggle'?: EventHandler<Event>;\n    'on:unhandledrejection'?: EventHandler<PromiseRejectionEvent>;\n    'on:unload'?: EventHandler<Event>;\n    'on:visibilitychange'?: EventHandler<Event>;\n    'on:wheel'?: EventHandler<WheelEvent>;\n    [key: `on:${string}`]: EventHandler<Event>;\n}\n\ninterface JSXDataProps {\n    [key: `data-${string}`]:\n        | Calculation<string | undefined>\n        | string\n        | undefined;\n}\n\ntype JSXElementInterfaceProps<TJSXType extends JSXElementInterface> = {\n    [Key in keyof TJSXType]:\n        | (Calculation<any> & (() => TJSXType[Key]))\n        | TJSXType[Key];\n};\n\ntype JSXChildrenProps<HasChildren extends boolean> = HasChildren extends true\n    ? { children?: JSX.Element | JSX.Element[] }\n    : { children?: never }; // TODO: this is not correct, leads to confusing errors; figure out why the types are not working as expected here...\n\ntype WithCalculationsAndRef<\n    TJSXType extends JSXElementInterface,\n    TElement extends HTMLElement,\n    HasChildren extends boolean\n> = JSXRefProps<TElement> &\n    JSXEventProps &\n    JSXDataProps &\n    JSXElementInterfaceProps<TJSXType> &\n    JSXChildrenProps<HasChildren>;\n\nexport interface KnownElements {\n    a: WithCalculationsAndRef<\n        JSXAnchorElementInterface,\n        HTMLAnchorElement,\n        true\n    >;\n    abbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    address: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    area: WithCalculationsAndRef<\n        JSXAreaElementInterface,\n        HTMLAreaElement,\n        false\n    >;\n    article: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    aside: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    audio: WithCalculationsAndRef<\n        JSXAudioElementInterface,\n        HTMLAudioElement,\n        true\n    >;\n    b: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    base: WithCalculationsAndRef<\n        JSXBaseElementInterface,\n        HTMLBaseElement,\n        false\n    >;\n    bdi: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    bdo: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    blockquote: WithCalculationsAndRef<\n        JSXQuoteElementInterface,\n        HTMLQuoteElement,\n        true\n    >;\n    body: WithCalculationsAndRef<\n        JSXBodyElementInterface,\n        HTMLBodyElement,\n        true\n    >;\n    br: WithCalculationsAndRef<JSXBRElementInterface, HTMLBRElement, false>;\n    button: WithCalculationsAndRef<\n        JSXButtonElementInterface,\n        HTMLButtonElement,\n        true\n    >;\n    canvas: WithCalculationsAndRef<\n        JSXCanvasElementInterface,\n        HTMLCanvasElement,\n        true\n    >;\n    caption: WithCalculationsAndRef<\n        JSXTableCaptionElementInterface,\n        HTMLTableCaptionElement,\n        true\n    >;\n    cite: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    code: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    col: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        false\n    >;\n    colgroup: WithCalculationsAndRef<\n        JSXTableColElementInterface,\n        HTMLTableColElement,\n        true\n    >;\n    data: WithCalculationsAndRef<\n        JSXDataElementInterface,\n        HTMLDataElement,\n        true\n    >;\n    datalist: WithCalculationsAndRef<\n        JSXDataListElementInterface,\n        HTMLDataListElement,\n        true\n    >;\n    dd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    del: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    details: WithCalculationsAndRef<\n        JSXDetailsElementInterface,\n        HTMLDetailsElement,\n        true\n    >;\n    dfn: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    dialog: WithCalculationsAndRef<\n        JSXDialogElementInterface,\n        HTMLDialogElement,\n        true\n    >;\n    div: WithCalculationsAndRef<JSXDivElementInterface, HTMLDivElement, true>;\n    dl: WithCalculationsAndRef<\n        JSXDListElementInterface,\n        HTMLDListElement,\n        true\n    >;\n    dt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    em: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    embed: WithCalculationsAndRef<\n        JSXEmbedElementInterface,\n        HTMLEmbedElement,\n        false\n    >;\n    fieldset: WithCalculationsAndRef<\n        JSXFieldSetElementInterface,\n        HTMLFieldSetElement,\n        true\n    >;\n    figcaption: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    figure: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    footer: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    form: WithCalculationsAndRef<\n        JSXFormElementInterface,\n        HTMLFormElement,\n        true\n    >;\n    h1: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h2: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h3: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h4: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h5: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    h6: WithCalculationsAndRef<\n        JSXHeadingElementInterface,\n        HTMLHeadingElement,\n        true\n    >;\n    head: WithCalculationsAndRef<\n        JSXHeadElementInterface,\n        HTMLHeadElement,\n        true\n    >;\n    header: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hgroup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    hr: WithCalculationsAndRef<JSXHRElementInterface, HTMLHRElement, false>;\n    html: WithCalculationsAndRef<\n        JSXHtmlElementInterface,\n        HTMLHtmlElement,\n        true\n    >;\n    i: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    iframe: WithCalculationsAndRef<\n        JSXIFrameElementInterface,\n        HTMLIFrameElement,\n        true\n    >;\n    img: WithCalculationsAndRef<\n        JSXImageElementInterface,\n        HTMLImageElement,\n        false\n    >;\n    input: WithCalculationsAndRef<\n        JSXInputElementInterface,\n        HTMLInputElement,\n        false\n    >;\n    ins: WithCalculationsAndRef<JSXModElementInterface, HTMLModElement, true>;\n    kbd: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    label: WithCalculationsAndRef<\n        JSXLabelElementInterface,\n        HTMLLabelElement,\n        true\n    >;\n    legend: WithCalculationsAndRef<\n        JSXLegendElementInterface,\n        HTMLLegendElement,\n        true\n    >;\n    li: WithCalculationsAndRef<JSXLIElementInterface, HTMLLIElement, true>;\n    link: WithCalculationsAndRef<\n        JSXLinkElementInterface,\n        HTMLLinkElement,\n        false\n    >;\n    main: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    map: WithCalculationsAndRef<JSXMapElementInterface, HTMLMapElement, true>;\n    mark: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    menu: WithCalculationsAndRef<\n        JSXMenuElementInterface,\n        HTMLMenuElement,\n        true\n    >;\n    meta: WithCalculationsAndRef<\n        JSXMetaElementInterface,\n        HTMLMetaElement,\n        false\n    >;\n    meter: WithCalculationsAndRef<\n        JSXMeterElementInterface,\n        HTMLMeterElement,\n        true\n    >;\n    nav: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    noscript: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    object: WithCalculationsAndRef<\n        JSXObjectElementInterface,\n        HTMLObjectElement,\n        true\n    >;\n    ol: WithCalculationsAndRef<\n        JSXOListElementInterface,\n        HTMLOListElement,\n        true\n    >;\n    optgroup: WithCalculationsAndRef<\n        JSXOptGroupElementInterface,\n        HTMLOptGroupElement,\n        true\n    >;\n    option: WithCalculationsAndRef<\n        JSXOptionElementInterface,\n        HTMLOptionElement,\n        true\n    >;\n    output: WithCalculationsAndRef<\n        JSXOutputElementInterface,\n        HTMLOutputElement,\n        true\n    >;\n    p: WithCalculationsAndRef<\n        JSXParagraphElementInterface,\n        HTMLParagraphElement,\n        true\n    >;\n    param: WithCalculationsAndRef<\n        JSXParamElementInterface,\n        HTMLParamElement,\n        false\n    >;\n    picture: WithCalculationsAndRef<\n        JSXPictureElementInterface,\n        HTMLPictureElement,\n        true\n    >;\n    pre: WithCalculationsAndRef<JSXPreElementInterface, HTMLPreElement, true>;\n    progress: WithCalculationsAndRef<\n        JSXProgressElementInterface,\n        HTMLProgressElement,\n        true\n    >;\n    q: WithCalculationsAndRef<JSXQuoteElementInterface, HTMLQuoteElement, true>;\n    rp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    rt: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ruby: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    s: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    samp: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    script: WithCalculationsAndRef<\n        JSXScriptElementInterface,\n        HTMLScriptElement,\n        true\n    >;\n    section: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    select: WithCalculationsAndRef<\n        JSXSelectElementInterface,\n        HTMLSelectElement,\n        true\n    >;\n    slot: WithCalculationsAndRef<\n        JSXSlotElementInterface,\n        HTMLSlotElement,\n        true\n    >;\n    small: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    source: WithCalculationsAndRef<\n        JSXSourceElementInterface,\n        HTMLSourceElement,\n        false\n    >;\n    span: WithCalculationsAndRef<\n        JSXSpanElementInterface,\n        HTMLSpanElement,\n        true\n    >;\n    strong: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    style: WithCalculationsAndRef<\n        JSXStyleElementInterface,\n        HTMLStyleElement,\n        true\n    >;\n    sub: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    summary: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    sup: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    table: WithCalculationsAndRef<\n        JSXTableElementInterface,\n        HTMLTableElement,\n        true\n    >;\n    tbody: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    td: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    template: WithCalculationsAndRef<\n        JSXTemplateElementInterface,\n        HTMLTemplateElement,\n        true\n    >;\n    textarea: WithCalculationsAndRef<\n        JSXTextAreaElementInterface,\n        HTMLTextAreaElement,\n        true\n    >;\n    tfoot: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    th: WithCalculationsAndRef<\n        JSXTableCellElementInterface,\n        HTMLTableCellElement,\n        true\n    >;\n    thead: WithCalculationsAndRef<\n        JSXTableSectionElementInterface,\n        HTMLTableSectionElement,\n        true\n    >;\n    time: WithCalculationsAndRef<\n        JSXTimeElementInterface,\n        HTMLTimeElement,\n        true\n    >;\n    title: WithCalculationsAndRef<\n        JSXTitleElementInterface,\n        HTMLTitleElement,\n        true\n    >;\n    tr: WithCalculationsAndRef<\n        JSXTableRowElementInterface,\n        HTMLTableRowElement,\n        true\n    >;\n    track: WithCalculationsAndRef<\n        JSXTrackElementInterface,\n        HTMLTrackElement,\n        false\n    >;\n    u: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    ul: WithCalculationsAndRef<\n        JSXUListElementInterface,\n        HTMLUListElement,\n        true\n    >;\n    var: WithCalculationsAndRef<JSXElementInterface, HTMLElement, true>;\n    video: WithCalculationsAndRef<\n        JSXVideoElementInterface,\n        HTMLVideoElement,\n        true\n    >;\n    wbr: WithCalculationsAndRef<JSXElementInterface, HTMLElement, false>;\n}\n", "import * as log from './log';\n\n/**\n * A VNode represents a node in the JSX tree structure\n *\n * Since a JSXNode may render to 0, 1, or many DOM nodes, we need to keep track\n * of the virtual tree structure to understand which index to update within the\n * DOM tree.\n */\nexport type VNode = {\n    domNode?: Node;\n    children?: VNode[];\n    domParent?: VNode;\n    onMount?: Function[];\n    onUnmount?: Function[];\n};\n\n/**\n * Get shallow DOM nodes from the virtual tree.\n *\n * For example, with this virtual tree:\n *\n * <root>\n *   <A>...</A>\n *   <B>\n *     <B1>\n *      <div id=\"b_1_1\">...</div>\n *      {false}\n *      {[\n *        <div id=\"b_1_arr_1\">...</div>\n *        <div id=\"b_1_arr_2\">...</div>\n *      ]}\n *      <SubComponent>\n *        <div id=\"b_1_sub_1\">...</div>\n *        <div id=\"b_1_sub_2\">...</div>\n *      </SubComponent>\n *      <div id=\"b_1_3\">...</div>\n *     </B1>\n *   </B>\n *   <C>\n *     ...\n *   </C>\n * </root>\n *\n * If getShallowNodes is called with <B> as the target, this would retrieve:\n * [b_1_1, b_1_arr_1, b_1_arr_2, b_1_sub_1, b_1_sub_2, b_1_3]\n */\nfunction getShallowNodes(vNode: VNode): Node[] {\n    const nodes: Node[] = [];\n    function visit(node: VNode) {\n        if (node.domNode) {\n            nodes.push(node.domNode);\n        } else {\n            node.children?.forEach((child) => visit(child));\n        }\n    }\n    visit(vNode);\n    return nodes;\n}\n\nfunction getDomParentChildIndex(\n    domParent: VNode,\n    immediateParent: VNode,\n    childIndex: number\n): number {\n    let realIndex = 0;\n\n    function visit(node: VNode): boolean {\n        if (node.domNode) {\n            realIndex += 1;\n            return false;\n        } else {\n            return visitChildren(node);\n        }\n    }\n    function visitChildren(node: VNode): boolean {\n        if (node.children) {\n            const visitIndex =\n                node === immediateParent ? childIndex : node.children.length;\n            for (let i = 0; i < visitIndex; ++i) {\n                if (visit(node.children[i])) {\n                    return true;\n                }\n            }\n        }\n        return node === immediateParent;\n    }\n    visitChildren(domParent);\n    return realIndex;\n}\n\nexport function callOnMount(node: VNode) {\n    // Note: we are doing a post-order traversal, so all children onMount are called before parents are called\n    node.children?.forEach((child) => callOnMount(child));\n\n    // Call any onMount listeners\n    if (node.onMount) {\n        node.onMount.forEach((onMount) => {\n            try {\n                onMount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onMount',\n                    node\n                );\n            }\n        });\n    }\n}\n\n/**\n * Collect shallow DOM nodes and conditionally call onUnmount if specified\n */\nfunction performUnmount(\n    node: VNode,\n    shallowDomNodes: Node[] | undefined,\n    runOnUnmount: boolean\n) {\n    if (shallowDomNodes && node.domNode) {\n        shallowDomNodes.push(node.domNode);\n    }\n    // Note: we are doing a post-order traversal, so all children are released/unmounted before parents are released/unmounted\n    node.children?.forEach((child) => {\n        performUnmount(\n            child,\n            node.domNode ? undefined : shallowDomNodes,\n            runOnUnmount\n        );\n    });\n\n    // Call any onUnmount listeners\n    if (runOnUnmount && node.onUnmount) {\n        node.onUnmount.forEach((onUnmount) => {\n            try {\n                onUnmount();\n            } catch (e) {\n                log.exception(\n                    e,\n                    'VNode node raised exception in onUnmount',\n                    node\n                );\n            }\n        });\n    }\n}\n\nexport function spliceVNode(\n    immediateParent: VNode,\n    childIndex: number,\n    removeCount: number,\n    newNodes: VNode[],\n    { runOnMount = true, runOnUnmount = true } = {}\n) {\n    log.assert(\n        immediateParent.children,\n        'attempted to splice a parent node with no children'\n    );\n    const domParent = immediateParent.domNode\n        ? immediateParent\n        : immediateParent.domParent;\n    if (childIndex > immediateParent.children.length) {\n        childIndex = immediateParent.children.length;\n    }\n    log.assert(\n        domParent && domParent.domNode,\n        'tried to replace a root tree slot with missing domParent'\n    );\n\n    const domParentNode = domParent.domNode;\n\n    const detachedVNodes = immediateParent.children.splice(\n        childIndex,\n        removeCount,\n        ...newNodes\n    );\n\n    // Remove nodes, optimizing for array replacement, where all nodes are completely removed via .replaceChildren()\n    const toRemove: Node[] = [];\n    detachedVNodes.forEach((detachedVNode) => {\n        performUnmount(detachedVNode, toRemove, runOnUnmount);\n    });\n\n    if (domParentNode.childNodes.length === toRemove.length) {\n        // By virtue of having children, this Node must be an Element\n        (domParentNode as Element).replaceChildren();\n    } else {\n        toRemove.forEach((child) => domParentNode.removeChild(child));\n    }\n\n    // Insert nodes via fragment with a single DOM operation\n    if (newNodes.length > 0) {\n        const domIndex = getDomParentChildIndex(\n            domParent,\n            immediateParent,\n            childIndex\n        );\n        const referenceNode: Node | undefined =\n            domParentNode.childNodes[domIndex];\n\n        const fragment = document.createDocumentFragment();\n\n        for (let i = 0; i < newNodes.length; ++i) {\n            const newNode = newNodes[i];\n            newNode.domParent = domParent;\n            const nodesToAdd = getShallowNodes(newNode);\n            nodesToAdd.forEach((addNode) => {\n                fragment.appendChild(addNode);\n            });\n        }\n\n        domParentNode.insertBefore(fragment, referenceNode || null);\n        if (runOnMount) {\n            newNodes.forEach((newNode) => {\n                if (newNode) {\n                    callOnMount(newNode);\n                }\n            });\n        }\n    }\n    return detachedVNodes;\n}\n", "import {\n    effect,\n    retain,\n    release,\n    untracked,\n    addOrderingDep,\n    removeOrderingDep,\n    registerNode,\n    disposeNode,\n    trackCreatedCalculations,\n} from './calc';\nimport { name, debugNameFor } from './debug';\nimport {\n    Collection,\n    Calculation,\n    View,\n    Context,\n    NodeOrdering,\n    isContext,\n    isCalculation,\n    isCollection,\n    isRef,\n    ObserveKey,\n    GetSubscriptionNodeKey,\n    TypeTag,\n    createContext,\n    getContext,\n    IntrinsicNodeObserverNodeCallback,\n    IntrinsicNodeObserverElementCallback,\n} from './types';\nimport * as log from './log';\nimport { uniqueid } from './util';\nimport {\n    Component,\n    JSXNode,\n    RenderedElement,\n    getElementTypeMapping,\n} from './jsx';\nimport { VNode, spliceVNode, callOnMount } from './vnode';\n\nexport const Fragment = ({ children }: { children: JSXNode[] }) => children;\n\nconst emptyIntrinsicNodeObserverContext = {\n    nodeCallbacks: [],\n    elementCallbacks: [],\n} as const;\nconst IntrinsicNodeObserverContext = createContext<{\n    nodeCallbacks: readonly IntrinsicNodeObserverNodeCallback[];\n    elementCallbacks: readonly IntrinsicNodeObserverElementCallback[];\n}>(emptyIntrinsicNodeObserverContext);\n\nexport const LifecycleObserver = (_props: {\n    nodeCallback?: IntrinsicNodeObserverNodeCallback | undefined;\n    elementCallback?: IntrinsicNodeObserverElementCallback | undefined;\n    children?: JSXNode | JSXNode[];\n}): JSX.Element => {\n    // Note: this function is never actually called; see createElement\n    return null;\n};\n\n// Intrinsic element\nexport function createElement<TProps, TChildren extends JSXNode>(\n    Constructor: string,\n    props: TProps,\n    ...children: TChildren[]\n): RenderedElement<TProps, unknown, TChildren>;\n// Context component\nexport function createElement<\n    TContext,\n    TProps extends { value: TContext },\n    TChildren extends JSXNode\n>(\n    Constructor: Context<TContext>,\n    props: TProps,\n    ...children: TChildren[]\n): RenderedElement<unknown, TContext, TChildren>;\n// Component with one required child\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children: TChildren }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    children: TChildren\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with multiple required children\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children: TChildren[] }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    ...children: TChildren[]\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with one optional child\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children?: TChildren | undefined }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    children?: TChildren | undefined\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with multiple required children\nexport function createElement<\n    TChildren extends JSXNode,\n    TProps extends { children?: TChildren[] | undefined }\n>(\n    Constructor: Component<TProps>,\n    props: Omit<TProps, 'children'>,\n    ...children: TChildren[]\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\n// Component with no children\nexport function createElement<TChildren extends JSXNode, TProps extends {}>(\n    Constructor: Component<TProps>,\n    props: TProps\n): RenderedElement<Omit<TProps, 'children'>, any, TChildren>;\nexport function createElement<TProps, TContext, TChildren extends JSXNode>(\n    Constructor:\n        | string\n        | Component<TProps>\n        | Component<TProps & { children?: TChildren }>\n        | Component<TProps & { children: TChildren }>,\n    props: TProps,\n    ...children: TChildren[]\n): RenderedElement<TProps, TContext, TChildren> {\n    if (typeof Constructor === 'string') {\n        return {\n            type: 'intrinsic',\n            element: Constructor,\n            props,\n            children,\n        };\n    }\n    if (isContext(Constructor)) {\n        return {\n            type: 'context',\n            context: Constructor,\n            props: props as unknown as { value: TContext },\n            children,\n        };\n    }\n    if (Constructor === LifecycleObserver) {\n        return {\n            type: 'observer',\n            nodeCallback: (props as any).nodeCallback || undefined,\n            elementCallback: (props as any).elementCallback || undefined,\n            children,\n        };\n    }\n    return {\n        type: 'component',\n        component: Constructor,\n        props,\n        children,\n    };\n}\n\ncreateElement.Fragment = Fragment;\n\nfunction setAttributeValue(\n    elementType: string,\n    element: Element,\n    key: string,\n    value: unknown,\n    boundEvents: Record<string, (ev: Event) => void>\n) {\n    if (key.startsWith('on:') && typeof value === 'function') {\n        const eventName = key.slice(3);\n        if (boundEvents[key]) {\n            element.removeEventListener(eventName, boundEvents[key]);\n        }\n        element.addEventListener(eventName, value as any);\n        boundEvents[key] = value as any;\n    } else {\n        const attributeNamespace = attributeNamespaceMap[key] || null;\n        const mapping = getElementTypeMapping(elementType, key);\n        if (mapping) {\n            if (mapping.makeAttrValue !== null) {\n                const attributeValue = mapping.makeAttrValue\n                    ? mapping.makeAttrValue(value)\n                    : (value as any);\n                if (\n                    attributeValue === undefined ||\n                    attributeValue === null ||\n                    attributeValue === false\n                ) {\n                    element.removeAttribute(key);\n                } else if (attributeValue === true) {\n                    element.setAttributeNS(attributeNamespace, key, '');\n                } else {\n                    element.setAttributeNS(\n                        attributeNamespace,\n                        key,\n                        attributeValue\n                    );\n                }\n            }\n            if (mapping.idlName !== null) {\n                (element as any)[mapping.idlName ?? key] = mapping.makeIdlValue\n                    ? mapping.makeIdlValue(value)\n                    : value;\n            }\n        } else if (value === false || value === undefined || value === null) {\n            element.removeAttributeNS(attributeNamespace, key);\n        } else if (value === true) {\n            element.setAttributeNS(attributeNamespace, key, '');\n        } else if (typeof value === 'string' || typeof value === 'number') {\n            element.setAttributeNS(attributeNamespace, key, value.toString());\n        }\n    }\n}\n\nfunction isCollectionView(\n    thing: JSXNode\n): thing is Collection<JSXNode> | View<JSXNode> {\n    return isCollection(thing);\n}\n\nfunction jsxNodeToVNode(\n    jsxNode: JSXNode,\n    domParent: VNode,\n    parentOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    if (\n        jsxNode === null ||\n        jsxNode === undefined ||\n        jsxNode === false ||\n        jsxNode === true\n    ) {\n        return { domParent };\n    }\n    if (typeof jsxNode === 'string') {\n        const domNode = document.createTextNode(jsxNode);\n        documentFragment.appendChild(domNode);\n        const observerCallback = makeObserverCallback(contextMap);\n        return {\n            domNode,\n            domParent,\n            onMount: [\n                () => {\n                    observerCallback?.(domNode, 'add');\n                },\n            ],\n            onUnmount: [\n                () => {\n                    observerCallback?.(domNode, 'remove');\n                },\n            ],\n        };\n    }\n    if (typeof jsxNode === 'number') {\n        const domNode = document.createTextNode(jsxNode.toString());\n        documentFragment.appendChild(domNode);\n        const observerCallback = makeObserverCallback(contextMap);\n        return {\n            domNode,\n            domParent,\n            onMount: [\n                () => {\n                    observerCallback?.(domNode, 'add');\n                },\n            ],\n            onUnmount: [\n                () => {\n                    observerCallback?.(domNode, 'remove');\n                },\n            ],\n        };\n    }\n    if (jsxNode instanceof Element) {\n        documentFragment.appendChild(jsxNode);\n        return {\n            domNode: jsxNode,\n            domParent,\n        };\n    }\n    if (isCalculation(jsxNode)) {\n        return makeCalculationVNode(\n            jsxNode,\n            domParent,\n            parentOrdering,\n            contextMap,\n            documentFragment\n        );\n    }\n    if (isCollectionView(jsxNode)) {\n        return makeCollectionVNode(\n            jsxNode,\n            domParent,\n            parentOrdering,\n            contextMap,\n            documentFragment\n        );\n    }\n    if (Array.isArray(jsxNode)) {\n        return {\n            domParent,\n            children: jsxNode.map((child) =>\n                jsxNodeToVNode(\n                    child,\n                    domParent,\n                    parentOrdering,\n                    contextMap,\n                    documentFragment\n                )\n            ),\n        };\n    }\n    if (typeof jsxNode === 'function') {\n        log.warn(\n            'Attempted to render JSX node that was a function, not rendering anything'\n        );\n        return { domParent };\n    }\n    if (typeof jsxNode === 'symbol') {\n        log.warn(\n            'Attempted to render JSX node that was a symbol, not rendering anything'\n        );\n        return { domParent };\n    }\n    return renderElementToVNode(\n        jsxNode,\n        domParent,\n        parentOrdering,\n        contextMap,\n        documentFragment\n    );\n}\n\nfunction renderElementToVNode(\n    renderElement: RenderedElement<any, any, any>,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n) {\n    switch (renderElement.type) {\n        case 'intrinsic':\n            return makeElementVNode(\n                renderElement.element,\n                renderElement.props,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        case 'context':\n            return makeContextVNode(\n                renderElement.context,\n                renderElement.props.value,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        case 'component':\n            return makeComponentVNode(\n                renderElement.component,\n                renderElement.props,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        case 'observer':\n            return makeObserverVNode(\n                renderElement.nodeCallback,\n                renderElement.elementCallback,\n                renderElement.children,\n                domParent,\n                nodeOrdering,\n                contextMap,\n                documentFragment\n            );\n        default:\n            log.assertExhausted(renderElement, 'Unexpected renderElement type');\n    }\n}\n\nconst HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nconst MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nconst XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\nconst XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nconst XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\n\nconst attributeNamespaceMap: Record<string, string> = {\n    'xlink:actuate': XLINK_NAMESPACE,\n    'xlink:arcrole': XLINK_NAMESPACE,\n    'xlink:href': XLINK_NAMESPACE,\n    'xlink:role': XLINK_NAMESPACE,\n    'xlink:show': XLINK_NAMESPACE,\n    'xlink:title': XLINK_NAMESPACE,\n    'xlink:type': XLINK_NAMESPACE,\n    'xml:lang': XML_NAMESPACE,\n    'xml:space': XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE,\n    'xmlns:xlink': XMLNS_NAMESPACE,\n};\nconst elementNamespaceTransitionMap: Record<\n    string,\n    Record<string, { node: string; children: string } | undefined> | undefined\n> = {\n    [HTML_NAMESPACE]: {\n        svg: {\n            node: SVG_NAMESPACE,\n            children: SVG_NAMESPACE,\n        },\n        math: {\n            node: MATHML_NAMESPACE,\n            children: MATHML_NAMESPACE,\n        },\n    },\n    [SVG_NAMESPACE]: {\n        foreignObject: {\n            node: SVG_NAMESPACE,\n            children: HTML_NAMESPACE,\n        },\n    },\n} as const;\n\nconst XmlNamespaceContext = createContext(HTML_NAMESPACE);\n\nfunction makeElementVNode(\n    elementType: string,\n    props: {} | undefined,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n) {\n    let subContextMap = contextMap;\n    let elementXMLNamespace: string = contextMap.has(XmlNamespaceContext)\n        ? contextMap.get(XmlNamespaceContext)\n        : getContext(XmlNamespaceContext);\n    let childElementXMLNamespace: null | string = null;\n    const xmlNamespaceTransition =\n        elementNamespaceTransitionMap[elementXMLNamespace]?.[elementType];\n    if (xmlNamespaceTransition) {\n        elementXMLNamespace = xmlNamespaceTransition.node;\n        childElementXMLNamespace = xmlNamespaceTransition.children;\n    }\n    if (childElementXMLNamespace != null) {\n        subContextMap = new Map(contextMap);\n        subContextMap.set(XmlNamespaceContext, childElementXMLNamespace);\n    }\n\n    const hostObserverContext = readContext(\n        subContextMap,\n        IntrinsicNodeObserverContext\n    );\n    if (hostObserverContext !== emptyIntrinsicNodeObserverContext) {\n        subContextMap = new Map(contextMap);\n        subContextMap.set(\n            IntrinsicNodeObserverContext,\n            emptyIntrinsicNodeObserverContext\n        );\n    }\n\n    const element = document.createElementNS(elementXMLNamespace, elementType);\n    const elementBoundEvents: Record<string, (ev: Event) => void> = {};\n\n    const onReleaseActions: (() => void)[] = [];\n    let refCallback: any = undefined;\n\n    // Bind props\n    if (props) {\n        Object.entries(props).forEach(([key, value]) => {\n            if (key === 'ref') {\n                if (isRef(value)) {\n                    value.current = element;\n                    return;\n                }\n                if (typeof value === 'function' && !isCalculation(value)) {\n                    refCallback = value;\n                    return;\n                }\n            }\n            if (isCalculation(value)) {\n                const boundEffect = effect(() => {\n                    const computedValue = value();\n                    setAttributeValue(\n                        elementType,\n                        element,\n                        key,\n                        computedValue,\n                        elementBoundEvents\n                    );\n                }, `viewattr:${key}`);\n                onReleaseActions.push(() => {\n                    removeOrderingDep(boundEffect, nodeOrdering);\n                    boundEffect.dispose();\n                });\n                addOrderingDep(boundEffect, nodeOrdering);\n\n                boundEffect();\n            } else {\n                setAttributeValue(\n                    elementType,\n                    element,\n                    key,\n                    value,\n                    elementBoundEvents\n                );\n            }\n        });\n    }\n\n    const observerCallback = makeObserverCallback(contextMap);\n\n    const elementNode: VNode = {\n        domParent,\n        domNode: element,\n        onMount: [\n            () => {\n                if (refCallback) {\n                    refCallback(element);\n                }\n                observerCallback?.(element, 'add');\n            },\n        ],\n        onUnmount: [\n            () => {\n                onReleaseActions.forEach((action) => action());\n                observerCallback?.(element, 'remove');\n                if (refCallback) {\n                    refCallback(undefined);\n                }\n            },\n        ],\n    };\n\n    if (children && children.length > 0) {\n        const childDocumentFragment = document.createDocumentFragment();\n        const childVNodes = children.map((child) =>\n            jsxNodeToVNode(\n                child,\n                elementNode,\n                nodeOrdering,\n                subContextMap,\n                childDocumentFragment\n            )\n        );\n        elementNode.children = childVNodes;\n        element.appendChild(childDocumentFragment);\n    }\n    documentFragment.appendChild(element);\n\n    return elementNode;\n}\n\nfunction readContext<TContext>(\n    contextMap: Map<Context<any>, any>,\n    context: Context<TContext>\n): TContext {\n    if (contextMap.has(context)) {\n        return contextMap.get(context);\n    }\n    return getContext(context);\n}\n\nfunction makeContextVNode<TContext>(\n    context: Context<TContext>,\n    value: TContext,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const subContextMap = new Map(contextMap);\n    subContextMap.set(context, value);\n\n    const providerNode: VNode = {\n        domParent,\n    };\n\n    if (children) {\n        providerNode.children = children.map((jsxChild) =>\n            jsxNodeToVNode(\n                jsxChild,\n                domParent,\n                nodeOrdering,\n                subContextMap,\n                documentFragment\n            )\n        );\n    }\n\n    return providerNode;\n}\n\nfunction makeObserverVNode(\n    nodeCallback: IntrinsicNodeObserverNodeCallback | undefined,\n    elementCallback: IntrinsicNodeObserverElementCallback | undefined,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const intrinsicNodeContextValue = readContext(\n        contextMap,\n        IntrinsicNodeObserverContext\n    );\n    let subContextMap = contextMap;\n    if (nodeCallback || elementCallback) {\n        const newContextValue = {\n            nodeCallbacks: intrinsicNodeContextValue.nodeCallbacks.slice(),\n            elementCallbacks:\n                intrinsicNodeContextValue.elementCallbacks.slice(),\n        };\n        if (nodeCallback) {\n            newContextValue.nodeCallbacks.push(nodeCallback);\n        }\n        if (elementCallback) {\n            newContextValue.elementCallbacks.push(elementCallback);\n        }\n        subContextMap = new Map(contextMap);\n        subContextMap.set(IntrinsicNodeObserverContext, newContextValue);\n    }\n\n    const providerNode: VNode = {\n        domParent,\n    };\n\n    if (children) {\n        providerNode.children = children.map((jsxChild) =>\n            jsxNodeToVNode(\n                jsxChild,\n                domParent,\n                nodeOrdering,\n                subContextMap,\n                documentFragment\n            )\n        );\n    }\n\n    return providerNode;\n}\n\nfunction makeComponentVNode<TProps>(\n    Component: Component<TProps>,\n    props: TProps,\n    children: JSXNode[] | undefined,\n    domParent: VNode,\n    nodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const onUnmount: Function[] = [];\n    const onMount: Function[] = [];\n\n    let jsxNode: JSXNode;\n    const createdCalculations = trackCreatedCalculations(() => {\n        jsxNode = Component(\n            // The children prop is weird, mostly due to TypeScript\n            // - if there aren't any children, it is `undefined`\n            !children || children.length === 0\n                ? { ...props }\n                : // - if there is one child, it is the value of that sole child\n                children.length === 1\n                ? { ...props, children: children[0] }\n                : // - if there are two or more children, it is an array of children\n                  {\n                      ...props,\n                      children: children,\n                  },\n            {\n                onUnmount: (unmountCallback) => {\n                    onUnmount.push(unmountCallback);\n                },\n                onMount: (mountCallback) => {\n                    onMount.push(mountCallback);\n                },\n                onEffect: (effectCallback: () => void, debugName?: string) => {\n                    const effectCalc = effect(\n                        effectCallback,\n                        `componenteffect:${Component.name}:${debugName ?? '?'}`\n                    );\n                    onMount.push(() => {\n                        retain(effectCalc);\n                        addOrderingDep(nodeOrdering, effectCalc);\n                        effectCalc();\n                    });\n                    onUnmount.push(() => {\n                        removeOrderingDep(nodeOrdering, effectCalc);\n                        release(effectCalc);\n                        effectCalc.dispose();\n                    });\n                },\n                getContext: <TVal>(context: Context<TVal>): TVal => {\n                    return readContext(contextMap, context);\n                },\n            }\n        );\n    });\n    onUnmount.push(() => {\n        createdCalculations.forEach((calculation) => {\n            calculation.dispose();\n        });\n    });\n\n    const childVNode = jsxNodeToVNode(\n        jsxNode,\n        domParent,\n        nodeOrdering,\n        contextMap,\n        documentFragment\n    );\n\n    const componentNode = {\n        domParent,\n        children: [childVNode],\n        onMount,\n        onUnmount,\n    };\n\n    return componentNode;\n}\n\nfunction makeObserverCallback(contextMap: Map<Context<any>, any>) {\n    const intrinsicNodeObserverContext = readContext(\n        contextMap,\n        IntrinsicNodeObserverContext\n    );\n    if (intrinsicNodeObserverContext === emptyIntrinsicNodeObserverContext) {\n        return null;\n    }\n    return (node: Node, event: 'add' | 'remove') => {\n        intrinsicNodeObserverContext.nodeCallbacks.forEach((nodeCallback) =>\n            nodeCallback(node, event)\n        );\n        intrinsicNodeObserverContext.elementCallbacks.forEach(\n            (elementCallback) => {\n                if (node instanceof Element) {\n                    elementCallback(node, event);\n                }\n            }\n        );\n    };\n}\n\nfunction makeCalculationVNode(\n    calculation: Calculation<JSXNode>,\n    domParent: VNode,\n    parentNodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const onUnmount: (() => void)[] = [];\n    const calculationNodeChildren: VNode[] = [];\n    const calculationNode: VNode = {\n        domParent,\n        children: calculationNodeChildren,\n        onUnmount,\n    };\n\n    const calculationNodeOrdering = makeNodeOrdering(\n        DEBUG\n            ? `viewcalc:${debugNameFor(calculation) ?? 'node'}:order`\n            : 'viewcalc:order'\n    );\n    registerNode(calculationNodeOrdering);\n\n    let firstRun = true;\n    const resultEffect = effect(() => {\n        const renderElement = calculation();\n        const calculationChild = jsxNodeToVNode(\n            renderElement,\n            domParent,\n            calculationNodeOrdering,\n            contextMap,\n            documentFragment\n        );\n        if (firstRun) {\n            // TODO: can we just call spliceVNode here?\n            firstRun = false;\n            calculationNodeChildren.push(calculationChild);\n        } else {\n            // Untracked here since spliceVNode calls onMount / onUnmount handlers and we don't want to recalculate if those read values\n            untracked(() => {\n                spliceVNode(\n                    calculationNode,\n                    0,\n                    calculationNodeChildren.length,\n                    [calculationChild]\n                );\n            });\n        }\n    }, `viewcalc:${debugNameFor(calculation) ?? 'node'}`);\n\n    addOrderingDep(calculationNodeOrdering, parentNodeOrdering);\n    addOrderingDep(resultEffect, calculationNodeOrdering);\n\n    onUnmount.push(() => {\n        removeOrderingDep(calculationNodeOrdering, parentNodeOrdering);\n        removeOrderingDep(resultEffect, calculationNodeOrdering);\n        resultEffect.dispose();\n        disposeNode(calculationNodeOrdering);\n    });\n\n    resultEffect();\n\n    return calculationNode;\n}\n\nfunction makeCollectionVNode(\n    collection: Collection<JSXNode> | View<JSXNode>,\n    domParent: VNode,\n    parentNodeOrdering: NodeOrdering,\n    contextMap: Map<Context<any>, any>,\n    documentFragment: DocumentFragment\n): VNode {\n    const onUnmount: (() => void)[] = [];\n\n    const collectionNodeChildren: VNode[] = [];\n    const collectionNode = {\n        domParent,\n        children: collectionNodeChildren,\n        onUnmount,\n    };\n\n    const collectionNodeOrdering = makeNodeOrdering(\n        DEBUG\n            ? `viewcoll:${debugNameFor(collection) ?? 'node'}:order`\n            : 'viewcoll:order'\n    );\n    registerNode(collectionNodeOrdering);\n    addOrderingDep(collectionNodeOrdering, parentNodeOrdering);\n    onUnmount.push(() => {\n        removeOrderingDep(collectionNodeOrdering, parentNodeOrdering);\n    });\n\n    untracked(() => {\n        collectionNode.children.push(\n            ...collection.map((jsxChild) =>\n                jsxNodeToVNode(\n                    jsxChild,\n                    domParent,\n                    collectionNodeOrdering,\n                    contextMap,\n                    documentFragment\n                )\n            )\n        );\n    });\n\n    const unobserve = collection[ObserveKey]((events) => {\n        events.forEach((event) => {\n            if (event.type === 'splice') {\n                untracked(() => {\n                    const { count, index, items } = event;\n                    const childNodes = items.map((jsxChild) =>\n                        jsxNodeToVNode(\n                            jsxChild,\n                            domParent,\n                            collectionNodeOrdering,\n                            contextMap,\n                            documentFragment\n                        )\n                    );\n                    spliceVNode(collectionNode, index, count, childNodes);\n                });\n            } else if (event.type === 'move') {\n                const { fromIndex, fromCount, toIndex } = event;\n                const moved = spliceVNode(\n                    collectionNode,\n                    fromIndex,\n                    fromCount,\n                    [],\n                    { runOnUnmount: false }\n                );\n                spliceVNode(\n                    collectionNode,\n                    fromIndex < toIndex ? toIndex - fromCount : toIndex,\n                    0,\n                    moved,\n                    { runOnMount: false }\n                );\n            } else if (event.type === 'sort') {\n                const { indexes } = event;\n                const removedVNodes = spliceVNode(\n                    collectionNode,\n                    0,\n                    indexes.length,\n                    [],\n                    { runOnUnmount: false }\n                );\n                const sortedVNodes = indexes.map(\n                    (newIndex) => removedVNodes[newIndex]\n                );\n                spliceVNode(collectionNode, 0, 0, sortedVNodes, {\n                    runOnMount: false,\n                });\n            } else {\n                log.assertExhausted(event, 'unhandled collection event');\n            }\n        });\n    });\n\n    const subscriptionNode = collection[GetSubscriptionNodeKey]();\n    registerNode(subscriptionNode);\n    addOrderingDep(subscriptionNode, collectionNodeOrdering);\n    onUnmount.push(unobserve);\n    onUnmount.push(() => {\n        removeOrderingDep(subscriptionNode, collectionNodeOrdering);\n    });\n\n    return collectionNode;\n}\n\nfunction makeNodeOrdering(debugName?: string): NodeOrdering {\n    const nodeOrdering: NodeOrdering = {\n        $__id: uniqueid(),\n        [TypeTag]: 'nodeOrdering',\n    };\n    if (debugName) name(nodeOrdering, debugName);\n    return nodeOrdering;\n}\n\n/**\n * Mount the provided JSX to an element\n */\nexport function mount(parentElement: Element, jsxNode: JSXNode) {\n    const contextMap: Map<Context<any>, any> = new Map();\n    if (\n        parentElement.namespaceURI === SVG_NAMESPACE ||\n        parentElement.namespaceURI === MATHML_NAMESPACE\n    ) {\n        contextMap.set(XmlNamespaceContext, parentElement.namespaceURI);\n    }\n    const nodeOrdering = makeNodeOrdering('mount');\n    retain(nodeOrdering);\n    const anchorNode: VNode = { domNode: parentElement };\n    const documentFragment = document.createDocumentFragment();\n    const rootNode = jsxNodeToVNode(\n        jsxNode,\n        anchorNode,\n        nodeOrdering,\n        contextMap,\n        documentFragment\n    );\n    anchorNode.children = [rootNode];\n\n    parentElement.appendChild(documentFragment);\n\n    // Call onMount callbacks\n    callOnMount(anchorNode);\n\n    return () => {\n        spliceVNode(anchorNode, 0, anchorNode.children?.length ?? 0, []);\n        release(nodeOrdering);\n    };\n}\n", "import {\n    Collection,\n    FilterFunction,\n    FlatMapFunction,\n    InvariantError,\n    MappingFunction,\n    View,\n    NotifyKey,\n    DisposeKey,\n} from './types';\nimport * as log from './log';\nimport { trackedData } from './trackeddata';\n\n// https://tc39.es/ecma262/multipage/indexed-collections.html#sec-sortcompare\nfunction defaultSort(x: any, y: any) {\n    if (x === undefined && y === undefined) return 0;\n    if (x === undefined) return 1;\n    if (y === undefined) return -1;\n    const xStr = '' + x;\n    const yStr = '' + y;\n    if (xStr < yStr) return -1;\n    if (xStr > yStr) return 1;\n    return 0;\n}\n\n/**\n * Make a mutable array to hold state, with some additional convenience methods\n */\nexport function collection<T>(array: T[], debugName?: string): Collection<T> {\n    if (!Array.isArray(array)) {\n        throw new InvariantError('collection must be provided an array');\n    }\n\n    return trackedData(\n        array,\n        'collection' as const,\n        {\n            get(notify, target, key) {\n                return target[key];\n            },\n\n            has(notify, target, key) {\n                return key in target;\n            },\n\n            set(this: Collection<T>, notify, target, key, value) {\n                if (\n                    key === 'length' &&\n                    typeof value === 'number' &&\n                    value < target.length\n                ) {\n                    // Special handling of resizing length smaller than normal length to handle removing of items\n                    this.splice(value, target.length - value);\n                    return true;\n                }\n                const numericKey = Number(key);\n                if (!isNaN(numericKey) && numericKey <= array.length) {\n                    this.splice(numericKey, 1, value);\n                } else {\n                    target[key] = value;\n                }\n                return true;\n            },\n\n            deleteProperty(notify, target, key) {\n                delete target[key];\n                return true;\n            },\n        },\n        ({\n            notify,\n            subscriptionNode,\n            makeView,\n            processFieldChange,\n            processFieldDelete,\n        }) => ({\n            splice: function splice(\n                index: number,\n                count: number,\n                ...items: T[]\n            ): T[] {\n                if (count < 1 && items.length === 0) return []; // noop\n                const origLength = array.length;\n                const removed = array.splice(index, count, ...items);\n                const newLength = array.length;\n                notify({\n                    type: 'splice',\n                    index,\n                    count,\n                    items,\n                    removed,\n                });\n\n                // Cases to consider:\n                // 1. count === items.length: we are replacing count items\n                // 2. count > items.length: we are adding (count - items.length items), notify index to new end\n                // 3. count < items.length: we are removing (items.length - count items), notify index to old end\n\n                // Process changes in *added* items\n                if (origLength === newLength) {\n                    for (let i = index; i < index + count; ++i) {\n                        processFieldChange(i.toString());\n                    }\n                } else {\n                    for (\n                        let i = index;\n                        i < Math.max(newLength, origLength);\n                        ++i\n                    ) {\n                        const key = i.toString();\n                        if (i >= newLength) {\n                            // Field deletion\n                            processFieldDelete(key);\n                        } else {\n                            // Field change\n                            processFieldChange(key);\n                        }\n                    }\n                    processFieldChange('length');\n                }\n                return removed;\n            },\n            pop: function pop(this: Collection<T>): T | undefined {\n                const removed = this.splice(array.length - 1, 1);\n                return removed[0];\n            },\n            shift: function shift(this: Collection<T>): T | undefined {\n                const removed = this.splice(0, 1);\n                return removed[0];\n            },\n            push: function push(this: Collection<T>, ...items: T[]): number {\n                this.splice(array.length, 0, ...items);\n                return array.length;\n            },\n            unshift: function unshift(\n                this: Collection<T>,\n                ...items: T[]\n            ): number {\n                this.splice(0, 0, ...items);\n                return array.length;\n            },\n            reject: function reject(\n                this: Collection<T>,\n                func: (item: T, index: number) => boolean\n            ) {\n                const removed: T[] = [];\n                for (let i = array.length - 1; i >= 0; --i) {\n                    if (func(this[i], i)) {\n                        removed.push(...this.splice(i, 1));\n                    }\n                }\n                return removed;\n            },\n            moveSlice: function moveSlice(\n                this: Collection<T>,\n                fromIndex: number,\n                fromCount: number,\n                toIndex: number\n            ) {\n                if (fromCount <= 0) return; // nothing to slice\n                if (toIndex >= fromIndex && toIndex < fromIndex + fromCount)\n                    return; // destination is inside moved slice, so noop\n                const moved = array.splice(fromIndex, fromCount);\n                if (toIndex < fromIndex) {\n                    array.splice(toIndex, 0, ...moved);\n                } else {\n                    array.splice(toIndex - fromCount, 0, ...moved);\n                }\n                notify({\n                    type: 'move',\n                    fromIndex,\n                    fromCount,\n                    toIndex,\n                    moved,\n                });\n            },\n            sort: function sort(\n                this: Collection<T>,\n                sorter: (a: T, b: T) => number = defaultSort\n            ): T[] {\n                const arrayWithIndexes: [T, number][] = array.map(\n                    (item, index) => [item, index]\n                );\n                array.sort(sorter);\n                arrayWithIndexes.sort((ai, bi) => sorter(ai[0], bi[0]));\n                notify({\n                    type: 'sort',\n                    indexes: arrayWithIndexes.map((pair) => pair[1]),\n                });\n                return this;\n            },\n            reverse: function reverse(\n                this: Collection<T>,\n                sorter: (a: T, b: T) => number = defaultSort\n            ): T[] {\n                if (array.length === 0) return this;\n                array.reverse();\n                // Simulate a resort\n                const indexes: number[] = [];\n                for (let i = array.length - 1; i >= 0; --i) {\n                    indexes.push(i);\n                }\n                notify({\n                    type: 'sort',\n                    indexes,\n                });\n                return this;\n            },\n            makeView,\n            mapView: function mapView<V>(\n                this: Collection<T>,\n                mapper: MappingFunction<T, V>,\n                debugName?: string | undefined\n            ) {\n                return mapViewImplementation(this, mapper, debugName);\n            },\n            filterView: function filterView(\n                this: Collection<T>,\n                filterFn: FilterFunction<T>,\n                debugName?: string\n            ) {\n                return filterViewImplementation(this, filterFn, debugName);\n            },\n            flatMapView: function flatMapView<V>(\n                this: Collection<T>,\n                fn: FlatMapFunction<T, V>,\n                debugName?: string | undefined\n            ) {\n                return flatMapViewImplementation(this, fn, debugName);\n            },\n        }),\n        debugName\n    );\n}\ncollection.dispose = function dispose(c: Collection<any>) {\n    c[DisposeKey]();\n};\n\nfunction mapViewImplementation<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    mapper: MappingFunction<T, V>,\n    debugName?: string | undefined\n): View<V> {\n    // map is a specialization of flatMap\n    return flatMapViewImplementation(\n        sourceCollection,\n        (item) => [mapper(item)],\n        debugName\n    );\n}\n\nfunction filterViewImplementation<T>(\n    sourceCollection: Collection<T> | View<T>,\n    filterFn: FilterFunction<T>,\n    debugName?: string\n): View<T> {\n    // filter is a specialization of flatMap\n    return flatMapViewImplementation(\n        sourceCollection,\n        (item) => (filterFn(item) ? [item] : []),\n        debugName\n    );\n}\n\nfunction flatMapViewImplementation<T, V>(\n    sourceCollection: Collection<T> | View<T>,\n    fn: FlatMapFunction<T, V>,\n    debugName?: string | undefined\n): View<V> {\n    const flatMapCount: number[] = [];\n\n    return sourceCollection.makeView(\n        {\n            initialize: (items) => {\n                const flatMapItems: V[] = [];\n                items.forEach((value) => {\n                    const chunk = fn(value);\n                    flatMapItems.push(...chunk);\n                    flatMapCount.push(chunk.length);\n                });\n                return flatMapItems;\n            },\n            processEvent: (view, event, rawArray) => {\n                if (event.type === 'splice') {\n                    const { index, count, items } = event;\n                    let realIndex = 0;\n                    for (let i = 0; i < index; ++i) {\n                        realIndex += flatMapCount[i];\n                    }\n                    let realCount = 0;\n                    for (let i = index; i < index + count; ++i) {\n                        realCount += flatMapCount[i];\n                    }\n                    // Well that's deceptively easy\n                    const realItems: V[] = [];\n                    const realItemCount: number[] = [];\n                    items.forEach((itemValue) => {\n                        const chunk = fn(itemValue);\n                        realItems.push(...chunk);\n                        realItemCount.push(chunk.length);\n                    });\n                    view.splice(realIndex, realCount, ...realItems);\n                    flatMapCount.splice(index, count, ...realItemCount);\n                } else if (event.type === 'move') {\n                    const { fromIndex, fromCount, toIndex } = event;\n                    let realFromCount = 0;\n                    for (let i = fromIndex; i < fromIndex + fromCount; ++i) {\n                        realFromCount += flatMapCount[i];\n                    }\n\n                    if (realFromCount > 0) {\n                        let realFromIndex = 0;\n                        let realToIndex = 0;\n\n                        const lastIndex = Math.max(fromIndex, toIndex);\n                        let count = 0;\n                        for (let i = 0; i <= lastIndex; ++i) {\n                            if (i === fromIndex) realFromIndex = count;\n                            if (i === toIndex) realToIndex = count;\n                            count += flatMapCount[i];\n                        }\n                        view.moveSlice(\n                            realFromIndex,\n                            realFromCount,\n                            realToIndex\n                        );\n                    }\n                    flatMapCount.splice(\n                        toIndex,\n                        0,\n                        ...flatMapCount.splice(fromIndex, fromCount)\n                    );\n                } else if (event.type === 'sort') {\n                    const { indexes } = event;\n\n                    const flatMapIndexes: number[] = [];\n                    let accumulatorIndex = 0;\n                    for (let i = 0; i < flatMapCount.length; ++i) {\n                        flatMapIndexes.push(accumulatorIndex);\n                        accumulatorIndex += flatMapCount[i];\n                    }\n\n                    const copiedSource = rawArray.slice();\n                    const newIndexes: number[] = [];\n                    let destIndex = 0;\n                    indexes.forEach((sourceIndex) => {\n                        const realCount = flatMapCount[sourceIndex];\n                        if (realCount === 0) return;\n                        const realIndex = flatMapIndexes[sourceIndex];\n                        for (let i = 0; i < realCount; ++i) {\n                            newIndexes.push(realIndex + i);\n                            rawArray[destIndex] = copiedSource[realIndex + i];\n                            destIndex += 1;\n                        }\n                    });\n\n                    view[NotifyKey]({\n                        type: 'sort',\n                        indexes: newIndexes,\n                    });\n                } else {\n                    log.assertExhausted(\n                        event,\n                        'unhandled collection event type'\n                    );\n                }\n            },\n        },\n        debugName\n    );\n}\n", "import {\n    Collection,\n    Subscription,\n    ViewSpec,\n    FlushKey,\n    AddDeferredWorkKey,\n    ObserveKey,\n    NotifyKey,\n    GetSubscriptionNodeKey,\n    TypeTag,\n    DataTypeTag,\n    ModelField,\n    TrackedData,\n    DisposeKey,\n} from './types';\nimport { collection } from './collection';\nimport {\n    untracked,\n    addManualDep,\n    removeManualDep,\n    addOrderingDep,\n    removeOrderingDep,\n    addDepToCurrentCalculation,\n    markDirty,\n    registerNode,\n    disposeNode,\n    nextFlush,\n} from './calc';\nimport { uniqueid } from './util';\nimport { name } from './debug';\nimport * as log from './log';\n\ninterface DataImplementation<TEvent> {\n    get(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): any;\n\n    has(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): boolean;\n\n    set(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol,\n        value: any\n    ): boolean;\n\n    deleteProperty(\n        notify: (event: TEvent) => void,\n        target: any,\n        key: string | symbol\n    ): boolean;\n}\n\nexport function trackedData<\n    TDataTypeTag,\n    TData extends object,\n    TEvent,\n    TMethods extends object\n>(\n    initialValue: TData,\n    typeTag: TDataTypeTag,\n    implSpec: DataImplementation<TEvent>,\n    bindMethods: (bindSpec: {\n        notify: (event: TEvent) => void;\n        observe: (observer: (events: TEvent[]) => void) => () => void;\n        makeView: <V>(\n            spec: ViewSpec<TData, V, TEvent>,\n            viewDebugName?: string | undefined\n        ) => Collection<V>;\n        subscriptionNode: Subscription;\n        processFieldChange: (field: string | symbol) => void;\n        processFieldDelete: (field: string | symbol) => void;\n    }) => TMethods,\n    debugName?: string\n): TrackedData<TDataTypeTag, TEvent> & TData & TMethods {\n    type Observer = (events: TEvent[]) => void;\n\n    const fieldRecords: Map<string | number | symbol, ModelField> = new Map();\n\n    let subscriptionEvents: Map<Observer, TEvent[]> = new Map();\n    let observers: Observer[] = [];\n    let isDisposed = false;\n\n    let deferredTasks: (() => void)[] = [];\n\n    const subscriptionNode: Subscription = {\n        $__id: uniqueid(),\n        [TypeTag]: 'subscription',\n        [FlushKey]: flushSubscription,\n        item: null, // assigned later\n    };\n    name(subscriptionNode, `${debugName || '?'}:sub`);\n\n    function flushSubscription() {\n        log.assert(!isDisposed, 'data already disposed');\n        let processed = false;\n        const toProcess = subscriptionEvents;\n        subscriptionEvents = new Map();\n        toProcess.forEach((events, observer) => {\n            processed = true;\n            observer(events);\n        });\n        return processed;\n    }\n\n    function flush() {\n        log.assert(!isDisposed, 'data already disposed');\n        const toProcess = deferredTasks;\n        let processed = false;\n        deferredTasks = [];\n        toProcess.forEach((task) => {\n            processed = true;\n            task();\n        });\n        return processed;\n    }\n\n    function addDeferredTask(task: () => void) {\n        log.assert(!isDisposed, 'data already disposed');\n        deferredTasks.push(task);\n        markDirty(proxy);\n    }\n\n    function notify(event: TEvent) {\n        log.assert(!isDisposed, 'data already disposed');\n        if (observers.length > 0) {\n            observers.forEach((observer) => {\n                let observerEvents = subscriptionEvents.get(observer);\n                if (!observerEvents) {\n                    observerEvents = [];\n                    subscriptionEvents.set(observer, observerEvents);\n                }\n                observerEvents.push(event);\n            });\n            markDirty(subscriptionNode);\n        }\n    }\n\n    function getSubscriptionNode() {\n        log.assert(!isDisposed, 'data already disposed');\n        return subscriptionNode;\n    }\n\n    function observe(observer: (events: TEvent[]) => void) {\n        log.assert(!isDisposed, 'data already disposed');\n        if (observers.length === 0) {\n            registerNode(proxy);\n            registerNode(subscriptionNode);\n            addManualDep(proxy, subscriptionNode);\n            fieldRecords.forEach((field) => {\n                addOrderingDep(field, subscriptionNode);\n            });\n        }\n        observers.push(observer);\n        return () => {\n            observers = observers.filter((obs) => obs !== observer);\n            if (observers.length === 0) {\n                removeManualDep(proxy, subscriptionNode);\n                fieldRecords.forEach((field) => {\n                    removeOrderingDep(field, subscriptionNode);\n                });\n            }\n        };\n    }\n\n    function makeView<V>(\n        spec: ViewSpec<TData, V, TEvent>,\n        viewDebugName?: string | undefined\n    ) {\n        log.assert(!isDisposed, 'data already disposed');\n        const viewArray: V[] = untracked(() => spec.initialize(initialValue));\n        const view = collection(viewArray, viewDebugName);\n        observe((events: TEvent[]) => {\n            view[AddDeferredWorkKey](() => {\n                events.forEach((event) => {\n                    spec.processEvent(view, event, viewArray);\n                });\n            });\n        });\n        addManualDep(subscriptionNode, view);\n        return view;\n    }\n\n    function processFieldChange(key: string | symbol) {\n        log.assert(!isDisposed, 'data already disposed');\n        const field = getField(key);\n        markDirty(field);\n    }\n\n    function processFieldDelete(key: string | symbol) {\n        log.assert(!isDisposed, 'data already disposed');\n        const field = getField(key);\n        markDirty(field);\n    }\n\n    function dispose() {\n        log.assert(!isDisposed, 'data already disposed');\n        // Delete and clean everything up\n        fieldRecords.forEach((field) => {\n            removeOrderingDep(proxy, field);\n            if (observers.length > 0) {\n                removeOrderingDep(field, subscriptionNode);\n            }\n            disposeNode(field);\n        });\n        fieldRecords.clear();\n        disposeNode(proxy);\n        disposeNode(subscriptionNode);\n\n        observers.splice(0, observers.length);\n        subscriptionEvents.clear();\n        deferredTasks.splice(0, deferredTasks.length);\n        // TODO: this is very gross!\n        nextFlush().then(() => {\n            revokableProxy.revoke();\n        });\n        isDisposed = true;\n    }\n\n    const pseudoPrototype = {\n        $__id: uniqueid(),\n        [TypeTag]: 'data',\n        [DataTypeTag]: typeTag,\n        [FlushKey]: flush,\n        [AddDeferredWorkKey]: addDeferredTask,\n        [ObserveKey]: observe,\n        [NotifyKey]: notify,\n        [GetSubscriptionNodeKey]: getSubscriptionNode,\n        [DisposeKey]: dispose,\n        ...bindMethods({\n            observe,\n            notify,\n            makeView,\n            subscriptionNode,\n            processFieldChange,\n            processFieldDelete,\n        }),\n    };\n\n    function getField(key: string | number | symbol): ModelField {\n        let field = fieldRecords.get(key);\n        if (!field) {\n            field = {\n                model: proxy as any,\n                key,\n                $__id: uniqueid(),\n            };\n            if (debugName) name(field, debugName);\n            fieldRecords.set(key, field);\n            registerNode(field);\n            addOrderingDep(proxy, field);\n            if (observers.length > 0) {\n                addOrderingDep(field, subscriptionNode);\n            }\n        }\n        return field;\n    }\n\n    const revokableProxy = Proxy.revocable(initialValue, {\n        get(target: any, key: string | symbol) {\n            if (key in pseudoPrototype) {\n                return (pseudoPrototype as any)[key];\n            }\n            const field = getField(key);\n            addDepToCurrentCalculation(field);\n            return implSpec.get.call(proxy, notify, target, key);\n        },\n\n        has(target: any, key: string | symbol) {\n            if (key in pseudoPrototype) {\n                return true;\n            }\n            const field = getField(key);\n            addDepToCurrentCalculation(field);\n            return implSpec.has.call(proxy, notify, target, key);\n        },\n\n        set(target: any, key: string | symbol, value: any) {\n            if (key in pseudoPrototype) {\n                log.error(`Overriding ${String(key)} not supported`, key);\n                return false;\n            }\n            const changed = implSpec.set.call(\n                proxy,\n                notify,\n                target,\n                key,\n                value\n            );\n            if (changed) {\n                const field = getField(key);\n                markDirty(field);\n            }\n            return changed;\n        },\n\n        deleteProperty(target: any, key: string | symbol) {\n            if (key in pseudoPrototype) {\n                log.error(`Deleting ${String(key)} not supported`, key);\n                return false;\n            }\n            const changed = implSpec.deleteProperty.call(\n                proxy,\n                notify,\n                target,\n                key\n            );\n            if (changed) {\n                const field = getField(key);\n                markDirty(field); // Anything depending on this value will need to be recalculated\n            }\n            return changed;\n        },\n    });\n    const proxy: TrackedData<TDataTypeTag, TEvent> & TData & TMethods =\n        revokableProxy.proxy;\n\n    subscriptionNode.item = proxy;\n\n    if (debugName) name(proxy, debugName);\n    registerNode(proxy);\n\n    return proxy;\n}\n", "import {\n    InvariantError,\n    MakeModelViewKey,\n    DisposeKey,\n    Model,\n    View,\n} from './types';\nimport { trackedData } from './trackeddata';\n\nexport function model<T extends {}>(obj: T, debugName?: string): Model<T> {\n    if (typeof obj !== 'object' || !obj) {\n        throw new InvariantError('model must be provided an object');\n    }\n\n    const knownFields: Set<string | number | symbol> = new Set(\n        Object.keys(obj)\n    );\n\n    return trackedData(\n        obj,\n        'model' as const,\n        {\n            get: (_notify, target, key) => {\n                return target[key];\n            },\n            has: (notify, target, key) => {\n                return knownFields.has(key);\n            },\n            set: (notify, target, key, value) => {\n                const changed = !knownFields.has(key) || target[key] !== value;\n                target[key] = value;\n                if (changed) {\n                    if (!knownFields.has(key)) {\n                        knownFields.add(key);\n                        notify({ type: 'add', key });\n                    }\n                    notify({ type: 'set', key, value });\n                }\n                return true;\n            },\n            deleteProperty: (notify, target, key) => {\n                const changed = knownFields.has(key);\n                delete target[key];\n                if (changed) {\n                    knownFields.delete(key);\n                    notify({ type: 'delete', key });\n                }\n                return true;\n            },\n        },\n        ({ makeView, notify, observe, subscriptionNode }) => {\n            return {\n                [MakeModelViewKey]: makeView,\n            };\n        },\n        debugName\n    );\n}\nmodel.keys = function keys<T>(\n    target: Model<T>,\n    debugName?: string\n): View<string> {\n    const keysSet = new Set<string>();\n\n    const view = target[MakeModelViewKey]<string>(\n        {\n            initialize: (obj) => {\n                const keys = Object.keys(obj);\n                keys.forEach((key) => keysSet.add(key));\n                return keys;\n            },\n            processEvent: (modelView, event) => {\n                if (event.type === 'add') {\n                    const { key } = event;\n                    if (typeof key === 'number' || typeof key === 'string') {\n                        const stringKey = key.toString();\n                        if (!keysSet.has(stringKey)) {\n                            keysSet.add(stringKey);\n                            modelView.push(stringKey);\n                        }\n                    }\n                } else if (event.type === 'delete') {\n                    const { key } = event;\n                    if (typeof key === 'number' || typeof key === 'string') {\n                        const stringKey = key.toString();\n                        if (keysSet.has(stringKey)) {\n                            keysSet.delete(stringKey);\n                            modelView.reject((k) => k === stringKey);\n                        }\n                    }\n                }\n            },\n        },\n        debugName\n    );\n\n    return view;\n};\nmodel.dispose = function dispose(m: Model<any>) {\n    m[DisposeKey]();\n};\n", "export { getLogLevel, setLogLevel } from './log';\nexport type { LogLevel } from './log';\nimport { createElement } from './view';\nexport { LifecycleObserver, Fragment, mount } from './view';\nexport type { Component } from './jsx';\nexport { model } from './model';\nexport { collection } from './collection';\nexport {\n    calc,\n    effect,\n    reset,\n    subscribe,\n    flush,\n    nextFlush,\n    retain,\n    release,\n    debug,\n    debugState,\n    debugSubscribe,\n} from './calc';\n\nexport type {\n    Ref,\n    Calculation,\n    Collection,\n    View,\n    Model,\n    Context,\n} from './types';\nexport { ref, createContext, InvariantError } from './types';\n\nexport default createElement;\n\nexport const VERSION =\n    typeof LIB_VERSION === 'string' ? LIB_VERSION : 'development';\n"],
  "mappings": "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",
  "names": []
}
