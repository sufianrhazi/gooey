Model internals:
[ ] We have model.keys, do we need model.values and model.entries?
[ ] Ergonomics/efficiency around derived models? Or is calc(() => model({ val: derived.val })) good enough?

Collection internals:
[x] Make .sort work + add new 'sort' event
[ ] Make .flatMapView recalculate automatically if feasible (will also apply to .filterView and .mapView)
[ ] Consider adding .sortedView()

DAG internals:
[ ] get the right balance of fast + not too much GC so we add and free the same items constantly + not recalculating things that aren't needed
[ ] group topographic sorting by disconnected components; opportunity to defer processing of disconnected components to later

View internals:
[x] Add a Context.Provider equivalent
[ ] Have an opinion on controlled vs uncontrolled components
[ ] Better error handling... somehow
[ ] Portals; do they make sense? Do they hijack event bubbling somehow?
[ ] Maybe allow for reparenting of a DOM subtree? Use case: moving an item between two lists without unmounting/remounting the item. The API would feel weird, but this could totally be done if source parent and destination parent were known. Biggest challenge will be getting this to work with Contexts
[ ] Could this play well with web components?
[ ] Consider the pros/cons of the style prop as a string / object
